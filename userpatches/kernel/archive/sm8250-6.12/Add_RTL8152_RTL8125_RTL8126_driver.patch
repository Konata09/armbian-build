Subject: [PATCH] Add RTL8152 RTL8125 RTL8126 driver
---
Index: drivers/net/ethernet/r8126-10.016.00/r8126_firmware.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/r8126_firmware.h b/drivers/net/ethernet/r8126-10.016.00/r8126_firmware.h
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/r8126_firmware.h	(date 1763109333415)
@@ -0,0 +1,68 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_R8126_FIRMWARE_H
+#define _LINUX_R8126_FIRMWARE_H
+
+#include <linux/device.h>
+#include <linux/firmware.h>
+
+struct rtl8126_private;
+typedef void (*rtl8126_fw_write_t)(struct rtl8126_private *tp, u16 reg, u16 val);
+typedef u32 (*rtl8126_fw_read_t)(struct rtl8126_private *tp, u16 reg);
+
+#define RTL8126_VER_SIZE		32
+
+struct rtl8126_fw {
+        rtl8126_fw_write_t phy_write;
+        rtl8126_fw_read_t phy_read;
+        rtl8126_fw_write_t mac_mcu_write;
+        rtl8126_fw_read_t mac_mcu_read;
+        const struct firmware *fw;
+        const char *fw_name;
+        struct device *dev;
+
+        char version[RTL8126_VER_SIZE];
+
+        struct rtl8126_fw_phy_action {
+                __le32 *code;
+                size_t size;
+        } phy_action;
+};
+
+int rtl8126_fw_request_firmware(struct rtl8126_fw *rtl_fw);
+void rtl8126_fw_release_firmware(struct rtl8126_fw *rtl_fw);
+void rtl8126_fw_write_firmware(struct rtl8126_private *tp, struct rtl8126_fw *rtl_fw);
+
+#endif /* _LINUX_R8126_FIRMWARE_H */
Index: drivers/net/ethernet/r8125-9.016.01/r8125_rss.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/r8125_rss.c b/drivers/net/ethernet/r8125-9.016.01/r8125_rss.c
new file mode 100755
--- /dev/null	(date 1763113879456)
+++ b/drivers/net/ethernet/r8125-9.016.01/r8125_rss.c	(date 1763113879456)
@@ -0,0 +1,583 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/version.h>
+#include "r8125.h"
+
+enum rtl8125_rss_register_content {
+        /* RSS */
+        RSS_CTRL_TCP_IPV4_SUPP = (1 << 0),
+        RSS_CTRL_IPV4_SUPP  = (1 << 1),
+        RSS_CTRL_TCP_IPV6_SUPP  = (1 << 2),
+        RSS_CTRL_IPV6_SUPP  = (1 << 3),
+        RSS_CTRL_IPV6_EXT_SUPP  = (1 << 4),
+        RSS_CTRL_TCP_IPV6_EXT_SUPP  = (1 << 5),
+        RSS_HALF_SUPP  = (1 << 7),
+        RSS_CTRL_UDP_IPV4_SUPP  = (1 << 11),
+        RSS_CTRL_UDP_IPV6_SUPP  = (1 << 12),
+        RSS_CTRL_UDP_IPV6_EXT_SUPP  = (1 << 13),
+        RSS_QUAD_CPU_EN  = (1 << 16),
+        RSS_HQ_Q_SUP_R  = (1 << 31),
+};
+
+static int rtl8125_get_rss_hash_opts(struct rtl8125_private *tp,
+                                     struct ethtool_rxnfc *cmd)
+{
+        cmd->data = 0;
+
+        /* Report default options for RSS */
+        switch (cmd->flow_type) {
+        case TCP_V4_FLOW:
+                cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+                fallthrough;
+        case UDP_V4_FLOW:
+                if (tp->rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV4)
+                        cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+                fallthrough;
+        case IPV4_FLOW:
+                cmd->data |= RXH_IP_SRC | RXH_IP_DST;
+                break;
+        case TCP_V6_FLOW:
+                cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+                fallthrough;
+        case UDP_V6_FLOW:
+                if (tp->rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV6)
+                        cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+                fallthrough;
+        case IPV6_FLOW:
+                cmd->data |= RXH_IP_SRC | RXH_IP_DST;
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        return 0;
+}
+
+int rtl8125_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
+                      u32 *rule_locs)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ret = -EOPNOTSUPP;
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return ret;
+
+        switch (cmd->cmd) {
+        case ETHTOOL_GRXRINGS:
+                cmd->data = rtl8125_tot_rx_rings(tp);
+                ret = 0;
+                break;
+        case ETHTOOL_GRXFH:
+                ret = rtl8125_get_rss_hash_opts(tp, cmd);
+                break;
+        default:
+                break;
+        }
+
+        return ret;
+}
+
+u32 rtl8125_rss_indir_tbl_entries(struct rtl8125_private *tp)
+{
+        return tp->HwSuppIndirTblEntries;
+}
+
+#define RSS_MASK_BITS_OFFSET (8)
+#define RSS_CPU_NUM_OFFSET (16)
+#define RTL8125_UDP_RSS_FLAGS (RTL_8125_RSS_FLAG_HASH_UDP_IPV4 | \
+		       RTL_8125_RSS_FLAG_HASH_UDP_IPV6)
+static int _rtl8125_set_rss_hash_opt(struct rtl8125_private *tp)
+{
+        u32 rss_flags = tp->rss_flags;
+        u32 hash_mask_len;
+        u32 rss_ctrl;
+
+        rss_ctrl = ilog2(rtl8125_tot_rx_rings(tp));
+        rss_ctrl &= (BIT_0 | BIT_1 | BIT_2);
+        rss_ctrl <<= RSS_CPU_NUM_OFFSET;
+
+        /* Perform hash on these packet types */
+        rss_ctrl |= RSS_CTRL_TCP_IPV4_SUPP
+                    | RSS_CTRL_IPV4_SUPP
+                    | RSS_CTRL_IPV6_SUPP
+                    | RSS_CTRL_IPV6_EXT_SUPP
+                    | RSS_CTRL_TCP_IPV6_SUPP
+                    | RSS_CTRL_TCP_IPV6_EXT_SUPP;
+
+        if (rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV4)
+                rss_ctrl |= RSS_CTRL_UDP_IPV4_SUPP;
+
+        if (rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV6)
+                rss_ctrl |= RSS_CTRL_UDP_IPV6_SUPP |
+                            RSS_CTRL_UDP_IPV6_EXT_SUPP;
+
+        hash_mask_len = ilog2(rtl8125_rss_indir_tbl_entries(tp));
+        hash_mask_len &= (BIT_0 | BIT_1 | BIT_2);
+        rss_ctrl |= hash_mask_len << RSS_MASK_BITS_OFFSET;
+
+        RTL_W32(tp, RSS_CTRL_8125, rss_ctrl);
+
+        return 0;
+}
+
+static int rtl8125_set_rss_hash_opt(struct rtl8125_private *tp,
+                                    struct ethtool_rxnfc *nfc)
+{
+        u32 rss_flags = tp->rss_flags;
+
+        /*
+         * RSS does not support anything other than hashing
+         * to queues on src and dst IPs and ports
+         */
+        if (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |
+                          RXH_L4_B_0_1 | RXH_L4_B_2_3))
+                return -EINVAL;
+
+        switch (nfc->flow_type) {
+        case TCP_V4_FLOW:
+        case TCP_V6_FLOW:
+                if (!(nfc->data & RXH_IP_SRC) ||
+                    !(nfc->data & RXH_IP_DST) ||
+                    !(nfc->data & RXH_L4_B_0_1) ||
+                    !(nfc->data & RXH_L4_B_2_3))
+                        return -EINVAL;
+                break;
+        case UDP_V4_FLOW:
+                if (!(nfc->data & RXH_IP_SRC) ||
+                    !(nfc->data & RXH_IP_DST))
+                        return -EINVAL;
+                switch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {
+                case 0:
+                        rss_flags &= ~RTL_8125_RSS_FLAG_HASH_UDP_IPV4;
+                        break;
+                case (RXH_L4_B_0_1 | RXH_L4_B_2_3):
+                        rss_flags |= RTL_8125_RSS_FLAG_HASH_UDP_IPV4;
+                        break;
+                default:
+                        return -EINVAL;
+                }
+                break;
+        case UDP_V6_FLOW:
+                if (!(nfc->data & RXH_IP_SRC) ||
+                    !(nfc->data & RXH_IP_DST))
+                        return -EINVAL;
+                switch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {
+                case 0:
+                        rss_flags &= ~RTL_8125_RSS_FLAG_HASH_UDP_IPV6;
+                        break;
+                case (RXH_L4_B_0_1 | RXH_L4_B_2_3):
+                        rss_flags |= RTL_8125_RSS_FLAG_HASH_UDP_IPV6;
+                        break;
+                default:
+                        return -EINVAL;
+                }
+                break;
+        case SCTP_V4_FLOW:
+        case AH_ESP_V4_FLOW:
+        case AH_V4_FLOW:
+        case ESP_V4_FLOW:
+        case SCTP_V6_FLOW:
+        case AH_ESP_V6_FLOW:
+        case AH_V6_FLOW:
+        case ESP_V6_FLOW:
+        case IP_USER_FLOW:
+        case ETHER_FLOW:
+                /* RSS is not supported for these protocols */
+                if (nfc->data) {
+                        netif_err(tp, drv, tp->dev, "Command parameters not supported\n");
+                        return -EINVAL;
+                }
+                return 0;
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        /* if we changed something we need to update flags */
+        if (rss_flags != tp->rss_flags) {
+                u32 rss_ctrl = RTL_R32(tp, RSS_CTRL_8125);
+
+                if ((rss_flags & RTL8125_UDP_RSS_FLAGS) &&
+                    !(tp->rss_flags & RTL8125_UDP_RSS_FLAGS))
+                        netdev_warn(tp->dev,
+                                    "enabling UDP RSS: fragmented packets may "
+                                    "arrive out of order to the stack above\n");
+
+                tp->rss_flags = rss_flags;
+
+                /* Perform hash on these packet types */
+                rss_ctrl |= RSS_CTRL_TCP_IPV4_SUPP
+                            | RSS_CTRL_IPV4_SUPP
+                            | RSS_CTRL_IPV6_SUPP
+                            | RSS_CTRL_IPV6_EXT_SUPP
+                            | RSS_CTRL_TCP_IPV6_SUPP
+                            | RSS_CTRL_TCP_IPV6_EXT_SUPP;
+
+                rss_ctrl &= ~(RSS_CTRL_UDP_IPV4_SUPP |
+                              RSS_CTRL_UDP_IPV6_SUPP |
+                              RSS_CTRL_UDP_IPV6_EXT_SUPP);
+
+                if (rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV4)
+                        rss_ctrl |= RSS_CTRL_UDP_IPV4_SUPP;
+
+                if (rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV6)
+                        rss_ctrl |= RSS_CTRL_UDP_IPV6_SUPP |
+                                    RSS_CTRL_UDP_IPV6_EXT_SUPP;
+
+                RTL_W32(tp, RSS_CTRL_8125, rss_ctrl);
+        }
+
+        return 0;
+}
+
+int rtl8125_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ret = -EOPNOTSUPP;
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return ret;
+
+        switch (cmd->cmd) {
+        case ETHTOOL_SRXFH:
+                ret = rtl8125_set_rss_hash_opt(tp, cmd);
+                break;
+        default:
+                break;
+        }
+
+        return ret;
+}
+
+static u32 _rtl8125_get_rxfh_key_size(struct rtl8125_private *tp)
+{
+        return sizeof(tp->rss_key);
+}
+
+u32 rtl8125_get_rxfh_key_size(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return 0;
+
+        return _rtl8125_get_rxfh_key_size(tp);
+}
+
+u32 rtl8125_rss_indir_size(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return 0;
+
+        return rtl8125_rss_indir_tbl_entries(tp);
+}
+
+static void rtl8125_get_reta(struct rtl8125_private *tp, u32 *indir)
+{
+        int i, reta_size = rtl8125_rss_indir_tbl_entries(tp);
+
+        for (i = 0; i < reta_size; i++)
+                indir[i] = tp->rss_indir_tbl[i];
+}
+
+static u32 rtl8125_rss_key_reg(struct rtl8125_private *tp)
+{
+        return RSS_KEY_8125;
+}
+
+static u32 rtl8125_rss_indir_tbl_reg(struct rtl8125_private *tp)
+{
+        return RSS_INDIRECTION_TBL_8125_V2;
+}
+
+static void rtl8125_store_reta(struct rtl8125_private *tp)
+{
+        u16 indir_tbl_reg = rtl8125_rss_indir_tbl_reg(tp);
+        u32 i, reta_entries = rtl8125_rss_indir_tbl_entries(tp);
+        u32 reta = 0;
+        u8 *indir_tbl = tp->rss_indir_tbl;
+
+        /* Write redirection table to HW */
+        for (i = 0; i < reta_entries; i++) {
+                reta |= indir_tbl[i] << (i & 0x3) * 8;
+                if ((i & 3) == 3) {
+                        RTL_W32(tp, indir_tbl_reg, reta);
+
+                        indir_tbl_reg += 4;
+                        reta = 0;
+                }
+        }
+}
+
+static void rtl8125_store_rss_key(struct rtl8125_private *tp)
+{
+        const u16 rss_key_reg = rtl8125_rss_key_reg(tp);
+        u32 i, rss_key_size = _rtl8125_get_rxfh_key_size(tp);
+        u32 *rss_key = (u32*)tp->rss_key;
+
+        /* Write redirection table to HW */
+        for (i = 0; i < rss_key_size; i+=4)
+                RTL_W32(tp, rss_key_reg + i, *rss_key++);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,8,0)
+int rtl8125_get_rxfh(struct net_device *dev, struct ethtool_rxfh_param *rxfh)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return -EOPNOTSUPP;
+
+        rxfh->hfunc = ETH_RSS_HASH_TOP;
+
+        if (rxfh->indir)
+                rtl8125_get_reta(tp, rxfh->indir);
+
+        if (rxfh->key)
+                memcpy(rxfh->key, tp->rss_key, RTL8125_RSS_KEY_SIZE);
+
+        return 0;
+}
+
+int rtl8125_set_rxfh(struct net_device *dev, struct ethtool_rxfh_param *rxfh,
+                     struct netlink_ext_ack *extack)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+        u32 reta_entries = rtl8125_rss_indir_tbl_entries(tp);
+
+        /* We require at least one supported parameter to be changed and no
+         * change in any of the unsupported parameters
+         */
+        if (rxfh->hfunc != ETH_RSS_HASH_NO_CHANGE && rxfh->hfunc != ETH_RSS_HASH_TOP)
+                return -EOPNOTSUPP;
+
+        /* Fill out the redirection table */
+        if (rxfh->indir) {
+                int max_queues = tp->num_rx_rings;
+
+                /* Verify user input. */
+                for (i = 0; i < reta_entries; i++)
+                        if (rxfh->indir[i] >= max_queues)
+                                return -EINVAL;
+
+                for (i = 0; i < reta_entries; i++)
+                        tp->rss_indir_tbl[i] = rxfh->indir[i];
+        }
+
+        /* Fill out the rss hash key */
+        if (rxfh->key)
+                memcpy(tp->rss_key, rxfh->key, RTL8125_RSS_KEY_SIZE);
+
+        rtl8125_store_reta(tp);
+
+        rtl8125_store_rss_key(tp);
+
+        return 0;
+}
+#else
+int rtl8125_get_rxfh(struct net_device *dev, u32 *indir, u8 *key,
+                     u8 *hfunc)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return -EOPNOTSUPP;
+
+        if (hfunc)
+                *hfunc = ETH_RSS_HASH_TOP;
+
+        if (indir)
+                rtl8125_get_reta(tp, indir);
+
+        if (key)
+                memcpy(key, tp->rss_key, RTL8125_RSS_KEY_SIZE);
+
+        return 0;
+}
+
+int rtl8125_set_rxfh(struct net_device *dev, const u32 *indir,
+                     const u8 *key, const u8 hfunc)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+        u32 reta_entries = rtl8125_rss_indir_tbl_entries(tp);
+
+        /* We require at least one supported parameter to be changed and no
+         * change in any of the unsupported parameters
+         */
+        if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)
+                return -EOPNOTSUPP;
+
+        /* Fill out the redirection table */
+        if (indir) {
+                int max_queues = tp->num_rx_rings;
+
+                /* Verify user input. */
+                for (i = 0; i < reta_entries; i++)
+                        if (indir[i] >= max_queues)
+                                return -EINVAL;
+
+                for (i = 0; i < reta_entries; i++)
+                        tp->rss_indir_tbl[i] = indir[i];
+        }
+
+        /* Fill out the rss hash key */
+        if (key)
+                memcpy(tp->rss_key, key, RTL8125_RSS_KEY_SIZE);
+
+        rtl8125_store_reta(tp);
+
+        rtl8125_store_rss_key(tp);
+
+        return 0;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,8,0) */
+
+static u32 rtl8125_get_rx_desc_hash(struct rtl8125_private *tp,
+                                    struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                return le32_to_cpu(((struct RxDescV3 *)desc)->RxDescNormalDDWord2.RSSResult);
+        case RX_DESC_RING_TYPE_4:
+                return le32_to_cpu(((struct RxDescV4 *)desc)->RxDescNormalDDWord1.RSSResult);
+        default:
+                return 0;
+        }
+}
+
+#define RXS_8125B_RSS_UDP BIT(9)
+#define RXS_8125_RSS_IPV4 BIT(10)
+#define RXS_8125_RSS_IPV6 BIT(12)
+#define RXS_8125_RSS_TCP BIT(13)
+#define RTL8125_RXS_RSS_L3_TYPE_MASK (RXS_8125_RSS_IPV4 | RXS_8125_RSS_IPV6)
+#define RTL8125_RXS_RSS_L4_TYPE_MASK (RXS_8125_RSS_TCP | RXS_8125B_RSS_UDP)
+
+#define RXS_8125B_RSS_UDP_V4 BIT(27)
+#define RXS_8125_RSS_IPV4_V4 BIT(28)
+#define RXS_8125_RSS_IPV6_V4 BIT(29)
+#define RXS_8125_RSS_TCP_V4 BIT(30)
+#define RTL8125_RXS_RSS_L3_TYPE_MASK_V4 (RXS_8125_RSS_IPV4_V4 | RXS_8125_RSS_IPV6_V4)
+#define RTL8125_RXS_RSS_L4_TYPE_MASK_V4 (RXS_8125_RSS_TCP_V4 | RXS_8125B_RSS_UDP_V4)
+static void rtl8125_rx_hash_v3(struct rtl8125_private *tp,
+                               struct RxDescV3 *descv3,
+                               struct sk_buff *skb)
+{
+        u16 rss_header_info;
+
+        if (!(tp->dev->features & NETIF_F_RXHASH))
+                return;
+
+        rss_header_info = le16_to_cpu(descv3->RxDescNormalDDWord2.HeaderInfo);
+
+        if (!(rss_header_info & RTL8125_RXS_RSS_L3_TYPE_MASK))
+                return;
+
+        skb_set_hash(skb, rtl8125_get_rx_desc_hash(tp, (struct RxDesc *)descv3),
+                     (RTL8125_RXS_RSS_L4_TYPE_MASK & rss_header_info) ?
+                     PKT_HASH_TYPE_L4 : PKT_HASH_TYPE_L3);
+}
+
+static void rtl8125_rx_hash_v4(struct rtl8125_private *tp,
+                               struct RxDescV4 *descv4,
+                               struct sk_buff *skb)
+{
+        u32 rss_header_info;
+
+        if (!(tp->dev->features & NETIF_F_RXHASH))
+                return;
+
+        rss_header_info = le32_to_cpu(descv4->RxDescNormalDDWord1.RSSInfo);
+
+        if (!(rss_header_info & RTL8125_RXS_RSS_L3_TYPE_MASK_V4))
+                return;
+
+        skb_set_hash(skb, rtl8125_get_rx_desc_hash(tp, (struct RxDesc *)descv4),
+                     (RTL8125_RXS_RSS_L4_TYPE_MASK_V4 & rss_header_info) ?
+                     PKT_HASH_TYPE_L4 : PKT_HASH_TYPE_L3);
+}
+
+void rtl8125_rx_hash(struct rtl8125_private *tp,
+                     struct RxDesc *desc,
+                     struct sk_buff *skb)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                rtl8125_rx_hash_v3(tp, (struct RxDescV3 *)desc, skb);
+                break;
+        case RX_DESC_RING_TYPE_4:
+                rtl8125_rx_hash_v4(tp, (struct RxDescV4 *)desc, skb);
+                break;
+        default:
+                return;
+        }
+}
+
+void rtl8125_disable_rss(struct rtl8125_private *tp)
+{
+        RTL_W32(tp, RSS_CTRL_8125, 0x00);
+}
+
+void _rtl8125_config_rss(struct rtl8125_private *tp)
+{
+        _rtl8125_set_rss_hash_opt(tp);
+
+        rtl8125_store_reta(tp);
+
+        rtl8125_store_rss_key(tp);
+}
+
+void rtl8125_config_rss(struct rtl8125_private *tp)
+{
+        if (!tp->EnableRss) {
+                rtl8125_disable_rss(tp);
+                return;
+        }
+
+        _rtl8125_config_rss(tp);
+}
+
+void rtl8125_init_rss(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < rtl8125_rss_indir_tbl_entries(tp); i++)
+                tp->rss_indir_tbl[i] = ethtool_rxfh_indir_default(i, tp->num_rx_rings);
+
+        netdev_rss_key_fill(tp->rss_key, RTL8125_RSS_KEY_SIZE);
+}
Index: drivers/net/ethernet/r8126-10.016.00/r8126_ptp.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/r8126_ptp.c b/drivers/net/ethernet/r8126-10.016.00/r8126_ptp.c
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/r8126_ptp.c	(date 1763109333415)
@@ -0,0 +1,954 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/mii.h>
+#include <linux/in.h>
+#include <linux/ethtool.h>
+#include <linux/rtnetlink.h>
+
+#include "r8126.h"
+#include "r8126_ptp.h"
+
+static void rtl8126_wait_clkadj_ready(struct rtl8126_private *tp)
+{
+        int i;
+
+        for (i = 0; i < R8126_CHANNEL_WAIT_COUNT; i++)
+                if (!(rtl8126_mdio_direct_read_phy_ocp(tp, PTP_CLK_CFG_8126) & CLKADJ_MODE_SET))
+                        break;
+}
+
+static void rtl8126_set_clkadj_mode(struct rtl8126_private *tp, u16 cmd)
+{
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              PTP_CLK_CFG_8126,
+                                              BIT_3 | BIT_2 | BIT_1,
+                                              CLKADJ_MODE_SET | cmd);
+
+        rtl8126_wait_clkadj_ready(tp);
+}
+
+static int _rtl8126_phc_gettime(struct rtl8126_private *tp, struct timespec64 *ts64)
+{
+        unsigned long flags;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        //Direct Read
+        rtl8126_set_clkadj_mode(tp, DIRECT_READ);
+
+        /* nanoseconds */
+        //Ns[29:16] E414[13:0]
+        ts64->tv_nsec = rtl8126_mdio_direct_read_phy_ocp(tp, PTP_CFG_NS_HI_8126) & 0x3fff;
+        ts64->tv_nsec <<= 16;
+        //Ns[15:0]  E412[15:0]
+        ts64->tv_nsec |= rtl8126_mdio_direct_read_phy_ocp(tp, PTP_CFG_NS_LO_8126);
+
+
+        /* seconds */
+        //S[47:32] E41A[15:0]
+        ts64->tv_sec = rtl8126_mdio_direct_read_phy_ocp(tp, PTP_CFG_S_HI_8126);
+        ts64->tv_sec <<= 16;
+        //S[31:16] E418[15:0]
+        ts64->tv_sec |= rtl8126_mdio_direct_read_phy_ocp(tp, PTP_CFG_S_MI_8126);
+        ts64->tv_sec <<= 16;
+        //S[15:0]  E416[15:0]
+        ts64->tv_sec |= rtl8126_mdio_direct_read_phy_ocp(tp, PTP_CFG_S_LO_8126);
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        return 0;
+}
+
+static int _rtl8126_phc_settime(struct rtl8126_private *tp, const struct timespec64 *ts64)
+{
+        unsigned long flags;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        /* nanoseconds */
+        //Ns[15:0]  E412[15:0]
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_CFG_NS_LO_8126, ts64->tv_nsec);
+        //Ns[29:16] E414[13:0]
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_CFG_NS_HI_8126, (ts64->tv_nsec & 0x3fff0000) >> 16);
+
+        /* seconds */
+        //S[15:0]  E416[15:0]
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_CFG_S_LO_8126, ts64->tv_sec);
+        //S[31:16] E418[15:0]
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_CFG_S_MI_8126, (ts64->tv_sec >> 16));
+        //S[47:32] E41A[15:0]
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_CFG_S_HI_8126, (ts64->tv_sec >> 32));
+
+        //Direct Write
+        rtl8126_set_clkadj_mode(tp, DIRECT_WRITE);
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        return 0;
+}
+
+static int _rtl8126_phc_adjtime(struct rtl8126_private *tp, s64 delta)
+{
+        unsigned long flags;
+        struct timespec64 d;
+        bool negative;
+        u64 tohw;
+        u32 nsec;
+        u64 sec;
+
+        if (delta < 0) {
+                negative = true;
+                tohw = -delta;
+        } else {
+                negative = false;
+                tohw = delta;
+        }
+
+        d = ns_to_timespec64(tohw);
+
+        nsec = d.tv_nsec;
+        sec = d.tv_sec;
+
+        nsec &= 0x3fffffff;
+        sec &= 0x0000ffffffffffff;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        /* nanoseconds */
+        //Ns[15:0]  E412[15:0]
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_CFG_NS_LO_8126, nsec);
+        //Ns[29:16] E414[13:0]
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_CFG_NS_HI_8126, (nsec >> 16));
+
+        /* seconds */
+        //S[15:0]  E416[15:0]
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_CFG_S_LO_8126, sec);
+        //S[31:16] E418[15:0]
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_CFG_S_MI_8126, (sec >> 16));
+        //S[47:32] E41A[15:0]
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_CFG_S_HI_8126, (sec >> 32));
+
+        if (negative)
+                rtl8126_set_clkadj_mode(tp, DECREMENT_STEP);
+        else
+                rtl8126_set_clkadj_mode(tp, INCREMENT_STEP);
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        return 0;
+}
+
+static int rtl8126_phc_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+        struct rtl8126_private *tp = container_of(ptp, struct rtl8126_private, ptp_clock_info);
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc adjust time\n");
+
+        ret = _rtl8126_phc_adjtime(tp, delta);
+
+        return ret;
+}
+
+/*
+ * delta = delta * 10^6 ppm = delta * 10^9 ppb (in this equation ppm and ppb are not variable)
+ *
+ * in adjfreq ppb is a variable
+ * ppb = delta * 10^9
+ * delta = ppb / 10^9
+ * rate_value = |delta| * 2^32 = |ppb| / 10^9 * 2^32 = (|ppb| << 32) / 10^9
+ */
+static int _rtl8126_phc_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
+{
+        struct rtl8126_private *tp = container_of(ptp, struct rtl8126_private, ptp_clock_info);
+        unsigned long flags;
+        u32 rate_value;
+
+        if (ppb < 0) {
+                rate_value = ((u64)-ppb << 32) / 1000000000;
+                rate_value = ~rate_value + 1;
+        } else
+                rate_value = ((u64)ppb << 32) / 1000000000;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        /* nanoseconds */
+        //Ns[15:0]  E412[15:0]
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_CFG_NS_LO_8126, rate_value);
+        //Ns[22:16] E414[13:0]
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_CFG_NS_HI_8126, (rate_value & 0x003f0000) >> 16);
+
+        rtl8126_set_clkadj_mode(tp, RATE_WRITE);
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+static int rtl8126_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)
+{
+        s32 ppb = scaled_ppm_to_ppb(scaled_ppm);
+
+        if (ppb > ptp->max_adj || ppb < -ptp->max_adj)
+                return -EINVAL;
+
+        _rtl8126_phc_adjfreq(ptp, ppb);
+
+        return 0;
+}
+
+#else
+static int rtl8126_phc_adjfreq(struct ptp_clock_info *ptp, s32 delta)
+{
+        //struct rtl8126_private *tp = container_of(ptp, struct rtl8126_private, ptp_clock_info);
+
+        //netif_info(tp, drv, tp->dev, "phc adjust freq\n");
+
+        if (delta > ptp->max_adj || delta < -ptp->max_adj)
+                return -EINVAL;
+
+        _rtl8126_phc_adjfreq(ptp, delta);
+
+        return 0;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+static int rtl8126_phc_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts64,
+                               struct ptp_system_timestamp *sts)
+{
+        struct rtl8126_private *tp = container_of(ptp, struct rtl8126_private, ptp_clock_info);
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc get ts\n");
+
+        ptp_read_system_prets(sts);
+        ret = _rtl8126_phc_gettime(tp, ts64);
+        ptp_read_system_postts(sts);
+
+        return ret;
+}
+#else
+static int rtl8126_phc_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts64)
+{
+        struct rtl8126_private *tp = container_of(ptp, struct rtl8126_private, ptp_clock_info);
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc get ts\n");
+
+        ret = _rtl8126_phc_gettime(tp, ts64);
+
+        return ret;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0) */
+
+static int rtl8126_phc_settime(struct ptp_clock_info *ptp,
+                               const struct timespec64 *ts64)
+{
+        struct rtl8126_private *tp = container_of(ptp, struct rtl8126_private, ptp_clock_info);
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc set ts\n");
+
+        ret = _rtl8126_phc_settime(tp, ts64);
+
+        return ret;
+}
+
+static void _rtl8126_phc_enable(struct ptp_clock_info *ptp,
+                                struct ptp_clock_request *rq, int on)
+{
+        struct rtl8126_private *tp = container_of(ptp, struct rtl8126_private, ptp_clock_info);
+        unsigned long flags;
+        u16 phy_ocp_data;
+
+        if (on) {
+                tp->pps_enable = 1;
+                rtl8126_clear_mac_ocp_bit(tp, 0xDC00, BIT_6);
+                rtl8126_clear_mac_ocp_bit(tp, 0xDC20, BIT_1);
+
+                r8126_spin_lock(&tp->phy_lock, flags);
+
+                /* Set periodic pulse 1pps */
+                /* E432[8:0] = 0x017d */
+                phy_ocp_data = rtl8126_mdio_direct_read_phy_ocp(tp, 0xE432);
+                phy_ocp_data &= 0xFE00;
+                phy_ocp_data |= 0x017d;
+                rtl8126_mdio_direct_write_phy_ocp(tp, 0xE432, phy_ocp_data);
+
+                rtl8126_mdio_direct_write_phy_ocp(tp, 0xE434, 0x7840);
+
+                /* E436[8:0] = 0xbe */
+                phy_ocp_data = rtl8126_mdio_direct_read_phy_ocp(tp, 0xE436);
+                phy_ocp_data &= 0xFE00;
+                phy_ocp_data |= 0xbe;
+                rtl8126_mdio_direct_write_phy_ocp(tp, 0xE436, phy_ocp_data);
+
+                rtl8126_mdio_direct_write_phy_ocp(tp, 0xE438, 0xbc20);
+
+                r8126_spin_unlock(&tp->phy_lock, flags);
+
+                /* start hrtimer */
+                hrtimer_start(&tp->pps_timer, 1000000000, HRTIMER_MODE_REL);
+        } else
+                tp->pps_enable = 0;
+}
+
+static int rtl8126_phc_enable(struct ptp_clock_info *ptp,
+                              struct ptp_clock_request *rq, int on)
+{
+        switch (rq->type) {
+        case PTP_CLK_REQ_PPS:
+                _rtl8126_phc_enable(ptp, rq, on);
+                return 0;
+        default:
+                return -EOPNOTSUPP;
+        }
+}
+
+static void rtl8126_ptp_enable_config(struct rtl8126_private *tp)
+{
+        if (tp->syncE_en)
+                rtl8126_set_eth_phy_ocp_bit(tp, PTP_SYNCE_CTL, BIT_0);
+        else
+                rtl8126_clear_eth_phy_ocp_bit(tp, PTP_SYNCE_CTL, BIT_0);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_CTL, PTP_CTL_TYPE_3 | BIT_12);
+
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xA640, BIT_15);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,11,0)
+int rtl8126_get_ts_info(struct net_device *netdev,
+                        struct ethtool_ts_info *info)
+#else
+int rtl8126_get_ts_info(struct net_device *netdev,
+                        struct kernel_ethtool_ts_info *info)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(6,11,0) */
+{
+        struct rtl8126_private *tp = netdev_priv(netdev);
+
+        /* we always support timestamping disabled */
+        info->rx_filters = BIT(HWTSTAMP_FILTER_NONE);
+
+        if (tp->HwSuppPtpVer == 0)
+                return ethtool_op_get_ts_info(netdev, info);
+
+        info->so_timestamping =  SOF_TIMESTAMPING_TX_SOFTWARE |
+                                 SOF_TIMESTAMPING_RX_SOFTWARE |
+                                 SOF_TIMESTAMPING_SOFTWARE |
+                                 SOF_TIMESTAMPING_TX_HARDWARE |
+                                 SOF_TIMESTAMPING_RX_HARDWARE |
+                                 SOF_TIMESTAMPING_RAW_HARDWARE;
+
+        if (tp->ptp_clock)
+                info->phc_index = ptp_clock_index(tp->ptp_clock);
+        else
+                info->phc_index = -1;
+
+        info->tx_types = BIT(HWTSTAMP_TX_OFF) | BIT(HWTSTAMP_TX_ON);
+
+        info->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_EVENT) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_SYNC) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ);
+
+        return 0;
+}
+
+static const struct ptp_clock_info rtl_ptp_clock_info = {
+        .owner      = THIS_MODULE,
+        .n_alarm    = 0,
+        .n_ext_ts   = 0,
+        .n_per_out  = 0,
+        .n_pins     = 0,
+        .pps        = 1,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+        .adjfine   = rtl8126_ptp_adjfine,
+#else
+        .adjfreq    = rtl8126_phc_adjfreq,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0) */
+        .adjtime    = rtl8126_phc_adjtime,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+        .gettimex64 = rtl8126_phc_gettime,
+#else
+        .gettime64  = rtl8126_phc_gettime,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0) */
+
+        .settime64  = rtl8126_phc_settime,
+        .enable     = rtl8126_phc_enable,
+};
+
+static u16 rtl8126_ptp_get_tx_msgtype(struct rtl8126_private *tp)
+{
+        u16 tx_ts_ready = 0;
+        int i;
+
+        for (i = 0; i < R8126_CHANNEL_WAIT_COUNT; i++) {
+                tx_ts_ready = rtl8126_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_STA) & 0xF000;
+                if (tx_ts_ready)
+                        break;
+        }
+
+        switch (tx_ts_ready) {
+        case TX_TS_PDLYRSP_RDY:
+                return PTP_MSGTYPE_PDELAY_RESP;
+        case TX_TS_PDLYREQ_RDY:
+                return PTP_MSGTYPE_PDELAY_REQ;
+        case TX_TS_DLYREQ_RDY:
+                return PTP_MSGTYPE_DELAY_REQ;
+        case TX_TS_SYNC_RDY:
+        default:
+                return PTP_MSGTYPE_SYNC;
+        }
+}
+
+/*
+static u16 rtl8126_ptp_get_rx_msgtype(struct rtl8126_private *tp)
+{
+        u16 rx_ts_ready = 0;
+        int i;
+
+        for (i = 0; i < R8126_CHANNEL_WAIT_COUNT; i++) {
+                rx_ts_ready = rtl8126_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_STA) & 0x0F00;
+                if (rx_ts_ready)
+                        break;
+        }
+
+        switch (rx_ts_ready) {
+        case RX_TS_PDLYRSP_RDY:
+                return PTP_MSGTYPE_PDELAY_RESP;
+        case RX_TS_PDLYREQ_RDY:
+                return PTP_MSGTYPE_PDELAY_REQ;
+        case RX_TS_DLYREQ_RDY:
+                return PTP_MSGTYPE_DELAY_REQ;
+        case RX_TS_SYNC_RDY:
+        default:
+                return PTP_MSGTYPE_SYNC;
+        }
+}
+*/
+
+static void rtl8126_wait_trx_ts_ready(struct rtl8126_private *tp)
+{
+        int i;
+
+        for (i = 0; i < R8126_CHANNEL_WAIT_COUNT; i++)
+                if (!(rtl8126_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_STA) & TRX_TS_RD))
+                        break;
+}
+
+static void rtl8126_set_trx_ts_cmd(struct rtl8126_private *tp, u16 cmd)
+{
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              PTP_TRX_TS_STA,
+                                              TRXTS_SEL | BIT_3 | BIT_2,
+                                              TRX_TS_RD | cmd);
+
+        rtl8126_wait_trx_ts_ready(tp);
+}
+
+static void rtl8126_ptp_egresstime(struct rtl8126_private *tp, struct timespec64 *ts64)
+{
+        u16 msgtype;
+
+        msgtype = rtl8126_ptp_get_tx_msgtype(tp);
+
+        msgtype <<= 2;
+
+        rtl8126_set_trx_ts_cmd(tp, (msgtype | BIT_4));
+
+        /* nanoseconds */
+        //Ns[29:16] E448[13:0]
+        ts64->tv_nsec = rtl8126_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_NS_HI) & 0x3fff;
+        ts64->tv_nsec <<= 16;
+        //Ns[15:0]  E446[15:0]
+        ts64->tv_nsec |= rtl8126_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_NS_LO);
+
+        /* seconds */
+        //S[47:32] E44E[15:0]
+        ts64->tv_sec = rtl8126_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_S_HI);
+        ts64->tv_sec <<= 16;
+        //S[31:16] E44C[15:0]
+        ts64->tv_sec |= rtl8126_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_S_MI);
+        ts64->tv_sec <<= 16;
+        //S[15:0]  E44A[15:0]
+        ts64->tv_sec |= rtl8126_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_S_LO);
+}
+
+static void rtl8126_ptp_ingresstime(struct rtl8126_private *tp, struct timespec64 *ts64, u8 type)
+{
+        u16 msgtype;
+
+        switch (type) {
+        case PTP_MSGTYPE_PDELAY_RESP:
+        case PTP_MSGTYPE_PDELAY_REQ:
+        case PTP_MSGTYPE_DELAY_REQ:
+        case PTP_MSGTYPE_SYNC:
+                msgtype = type << 2;
+                break;
+        default:
+                return;
+        }
+
+        rtl8126_set_trx_ts_cmd(tp, (TRXTS_SEL | msgtype | BIT_4));
+
+        /* nanoseconds */
+        //Ns[29:16] E448[13:0]
+        ts64->tv_nsec = rtl8126_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_NS_HI) & 0x3fff;
+        ts64->tv_nsec <<= 16;
+        //Ns[15:0]  E446[15:0]
+        ts64->tv_nsec |= rtl8126_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_NS_LO);
+
+        /* seconds */
+        //S[47:32] E44E[15:0]
+        ts64->tv_sec = rtl8126_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_S_HI);
+        ts64->tv_sec <<= 16;
+        //S[31:16] E44C[15:0]
+        ts64->tv_sec |= rtl8126_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_S_MI);
+        ts64->tv_sec <<= 16;
+        //S[15:0]  E44A[15:0]
+        ts64->tv_sec |= rtl8126_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_S_LO);
+}
+
+static void rtl8126_ptp_tx_hwtstamp(struct rtl8126_private *tp)
+{
+        struct sk_buff *skb = tp->ptp_tx_skb;
+        struct skb_shared_hwtstamps shhwtstamps = { 0 };
+        struct timespec64 ts64;
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, PTP_INSR, TX_TX_INTR);
+
+        rtl8126_ptp_egresstime(tp, &ts64);
+
+        /* Upper 32 bits contain s, lower 32 bits contain ns. */
+        shhwtstamps.hwtstamp = ktime_set(ts64.tv_sec,
+                                         ts64.tv_nsec);
+
+        /* Clear the lock early before calling skb_tstamp_tx so that
+         * applications are not woken up before the lock bit is clear. We use
+         * a copy of the skb pointer to ensure other threads can't change it
+         * while we're notifying the stack.
+         */
+        tp->ptp_tx_skb = NULL;
+        clear_bit_unlock(__RTL8126_PTP_TX_IN_PROGRESS, &tp->state);
+
+        /* Notify the stack and free the skb after we've unlocked */
+        skb_tstamp_tx(skb, &shhwtstamps);
+        dev_kfree_skb_any(skb);
+}
+
+#define RTL8126_PTP_TX_TIMEOUT      (HZ * 15)
+static void rtl8126_ptp_tx_work(struct work_struct *work)
+{
+        struct rtl8126_private *tp = container_of(work, struct rtl8126_private,
+                                     ptp_tx_work);
+        unsigned long flags;
+        bool tx_intr;
+
+        if (!tp->ptp_tx_skb)
+                return;
+
+        if (time_is_before_jiffies(tp->ptp_tx_start +
+                                   RTL8126_PTP_TX_TIMEOUT)) {
+                dev_kfree_skb_any(tp->ptp_tx_skb);
+                tp->ptp_tx_skb = NULL;
+                clear_bit_unlock(__RTL8126_PTP_TX_IN_PROGRESS, &tp->state);
+                tp->tx_hwtstamp_timeouts++;
+                /* Clear the tx valid bit in TSYNCTXCTL register to enable
+                 * interrupt
+                 */
+                r8126_spin_lock(&tp->phy_lock, flags);
+                rtl8126_mdio_direct_write_phy_ocp(tp, PTP_INSR, TX_TX_INTR);
+                r8126_spin_unlock(&tp->phy_lock, flags);
+                return;
+        }
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+        if (rtl8126_mdio_direct_read_phy_ocp(tp, PTP_INSR) & TX_TX_INTR) {
+                tx_intr = true;
+                rtl8126_ptp_tx_hwtstamp(tp);
+        } else {
+                tx_intr = false;
+        }
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        if (!tx_intr) {
+                /* reschedule to check later */
+                schedule_work(&tp->ptp_tx_work);
+        }
+}
+
+static int rtl8126_hwtstamp_enable(struct rtl8126_private *tp, bool enable)
+{
+        unsigned long flags;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        if (enable) {
+                //trx timestamp interrupt enable
+                rtl8126_set_eth_phy_ocp_bit(tp, PTP_INER, BIT_2 | BIT_3);
+
+                //set isr clear mode
+                rtl8126_set_eth_phy_ocp_bit(tp, PTP_GEN_CFG, BIT_0);
+
+                //clear ptp isr
+                rtl8126_mdio_direct_write_phy_ocp(tp, PTP_INSR, 0xFFFF);
+
+                //enable ptp
+                rtl8126_ptp_enable_config(tp);
+
+                //rtl8126_set_local_time(tp);
+        } else {
+                /* trx timestamp interrupt disable */
+                rtl8126_clear_eth_phy_ocp_bit(tp, PTP_INER, BIT_2 | BIT_3);
+
+                /* disable ptp */
+                rtl8126_clear_eth_phy_ocp_bit(tp, PTP_SYNCE_CTL, BIT_0);
+                rtl8126_clear_eth_phy_ocp_bit(tp, PTP_CTL, BIT_0);
+                rtl8126_set_eth_phy_ocp_bit(tp, 0xA640, BIT_15);
+        }
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        return 0;
+}
+
+void rtl8126_set_local_time(struct rtl8126_private *tp)
+{
+        struct timespec64 ts64;
+        //set system time
+        ktime_get_real_ts64(&ts64);
+        _rtl8126_phc_settime(tp, &ts64);
+}
+
+static long rtl8126_ptp_create_clock(struct rtl8126_private *tp)
+{
+        struct net_device *netdev = tp->dev;
+        long err;
+
+        if (!IS_ERR_OR_NULL(tp->ptp_clock))
+                return 0;
+
+        if (tp->HwSuppPtpVer == 0) {
+                tp->ptp_clock = NULL;
+                return -EOPNOTSUPP;
+        }
+
+        tp->ptp_clock_info = rtl_ptp_clock_info;
+        tp->ptp_clock_info.max_adj = 488281;//0x1FFFFF * 10^9 / 2^32
+
+        snprintf(tp->ptp_clock_info.name, sizeof(tp->ptp_clock_info.name),
+                 "%pm", tp->dev->dev_addr);
+        tp->ptp_clock = ptp_clock_register(&tp->ptp_clock_info, &tp->pci_dev->dev);
+        if (IS_ERR(tp->ptp_clock)) {
+                err = PTR_ERR(tp->ptp_clock);
+                tp->ptp_clock = NULL;
+                netif_err(tp, drv, tp->dev, "ptp_clock_register failed\n");
+                return err;
+        } else
+                netif_info(tp, drv, tp->dev, "registered PHC device on %s\n", netdev->name);
+
+        return 0;
+}
+
+static enum hrtimer_restart
+rtl8126_hrtimer_for_pps(struct hrtimer *timer) {
+        struct rtl8126_private *tp = container_of(timer, struct rtl8126_private, pps_timer);
+        u16 tai_cfg = BIT_8 | BIT_3 | BIT_1 | BIT_0;
+        s64 pps_sec;
+
+        if (tp->pps_enable)
+        {
+                unsigned long flags;
+
+                r8126_spin_lock(&tp->phy_lock, flags);
+
+                //Direct Read
+                rtl8126_set_clkadj_mode(tp, DIRECT_READ);
+
+                pps_sec = rtl8126_mdio_direct_read_phy_ocp(tp, PTP_CFG_S_HI_8126);
+                pps_sec <<= 16;
+                pps_sec |= rtl8126_mdio_direct_read_phy_ocp(tp, PTP_CFG_S_MI_8126);
+                pps_sec <<= 16;
+                pps_sec |= rtl8126_mdio_direct_read_phy_ocp(tp, PTP_CFG_S_LO_8126);
+                pps_sec++;
+
+                //E42A[15:0]
+                rtl8126_mdio_direct_write_phy_ocp(tp, PTP_TAI_TS_S_LO, pps_sec & 0xffff);
+                //E42C[31:16]
+                rtl8126_mdio_direct_write_phy_ocp(tp, PTP_TAI_TS_S_HI, (pps_sec & 0xffff0000) >> 16);
+                //Periodic Tai start
+                rtl8126_mdio_direct_write_phy_ocp(tp, PTP_TAI_CFG, tai_cfg);
+
+                r8126_spin_unlock(&tp->phy_lock, flags);
+
+                hrtimer_forward_now(&tp->pps_timer, 1000000000); //rekick
+                return HRTIMER_RESTART;
+        } else
+                return HRTIMER_NORESTART;
+}
+
+void rtl8126_ptp_reset(struct rtl8126_private *tp)
+{
+        if (!tp->ptp_clock)
+                return;
+
+        netif_info(tp, drv, tp->dev, "reset PHC clock\n");
+
+        rtl8126_hwtstamp_enable(tp, false);
+}
+
+void rtl8126_ptp_init(struct rtl8126_private *tp)
+{
+        /* obtain a PTP device, or re-use an existing device */
+        if (rtl8126_ptp_create_clock(tp))
+                return;
+
+        /* we have a clock so we can initialize work now */
+        INIT_WORK(&tp->ptp_tx_work, rtl8126_ptp_tx_work);
+
+        /* init a hrtimer for pps */
+        tp->pps_enable = 0;
+        hrtimer_init(&tp->pps_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+        tp->pps_timer.function = rtl8126_hrtimer_for_pps;
+
+        /* reset the PTP related hardware bits */
+        rtl8126_ptp_reset(tp);
+
+        return;
+}
+
+void rtl8126_ptp_suspend(struct rtl8126_private *tp)
+{
+        if (!tp->ptp_clock)
+                return;
+
+        netif_info(tp, drv, tp->dev, "suspend PHC clock\n");
+
+        rtl8126_hwtstamp_enable(tp, false);
+
+        /* ensure that we cancel any pending PTP Tx work item in progress */
+        cancel_work_sync(&tp->ptp_tx_work);
+
+        hrtimer_cancel(&tp->pps_timer);
+}
+
+void rtl8126_ptp_stop(struct rtl8126_private *tp)
+{
+        struct net_device *netdev = tp->dev;
+
+        netif_info(tp, drv, tp->dev, "stop PHC clock\n");
+
+        /* first, suspend PTP activity */
+        rtl8126_ptp_suspend(tp);
+
+        /* disable the PTP clock device */
+        if (tp->ptp_clock) {
+                ptp_clock_unregister(tp->ptp_clock);
+                tp->ptp_clock = NULL;
+                netif_info(tp, drv, tp->dev, "removed PHC on %s\n",
+                           netdev->name);
+        }
+}
+
+static int rtl8126_set_tstamp(struct net_device *netdev, struct ifreq *ifr)
+{
+        struct rtl8126_private *tp = netdev_priv(netdev);
+        struct hwtstamp_config config;
+        bool hwtstamp = 0;
+
+        //netif_info(tp, drv, tp->dev, "ptp set ts\n");
+
+        if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+                return -EFAULT;
+
+        if (config.flags)
+                return -EINVAL;
+
+        switch (config.tx_type) {
+        case HWTSTAMP_TX_ON:
+                hwtstamp = 1;
+                break;
+        case HWTSTAMP_TX_OFF:
+                break;
+        case HWTSTAMP_TX_ONESTEP_SYNC:
+        default:
+                return -ERANGE;
+        }
+
+        switch (config.rx_filter) {
+        case HWTSTAMP_FILTER_PTP_V2_EVENT:
+        case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+        case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+        case HWTSTAMP_FILTER_PTP_V2_SYNC:
+        case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+        case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+        case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+        case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+        case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+                config.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;
+                hwtstamp = 1;
+                tp->flags |= RTL_FLAG_RX_HWTSTAMP_ENABLED;
+                break;
+        case HWTSTAMP_FILTER_NONE:
+                tp->flags &= ~RTL_FLAG_RX_HWTSTAMP_ENABLED;
+                break;
+        default:
+                tp->flags &= ~RTL_FLAG_RX_HWTSTAMP_ENABLED;
+                return -ERANGE;
+        }
+
+        if (tp->hwtstamp_config.tx_type != config.tx_type ||
+            tp->hwtstamp_config.rx_filter != config.rx_filter) {
+                tp->hwtstamp_config = config;
+
+                rtl8126_hwtstamp_enable(tp, hwtstamp);
+        }
+
+        return copy_to_user(ifr->ifr_data, &config,
+                            sizeof(config)) ? -EFAULT : 0;
+}
+
+static int rtl8126_get_tstamp(struct net_device *netdev, struct ifreq *ifr)
+{
+        struct rtl8126_private *tp = netdev_priv(netdev);
+
+        //netif_info(tp, drv, tp->dev, "ptp get ts\n");
+
+        return copy_to_user(ifr->ifr_data, &tp->hwtstamp_config,
+                            sizeof(tp->hwtstamp_config)) ? -EFAULT : 0;
+}
+
+int rtl8126_ptp_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "ptp ioctl\n");
+
+        switch (cmd) {
+#ifdef ENABLE_PTP_SUPPORT
+        case SIOCSHWTSTAMP:
+                ret = rtl8126_set_tstamp(netdev, ifr);
+                break;
+        case SIOCGHWTSTAMP:
+                ret = rtl8126_get_tstamp(netdev, ifr);
+                break;
+#endif
+        default:
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        return ret;
+}
+
+static void rtl8126_rx_ptp_pktstamp(struct rtl8126_private *tp, struct sk_buff *skb, u8 type)
+{
+        struct timespec64 ts64;
+        unsigned long flags;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        rtl8126_ptp_ingresstime(tp, &ts64, type);
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        skb_hwtstamps(skb)->hwtstamp = ktime_set(ts64.tv_sec, ts64.tv_nsec);
+
+        return;
+}
+
+void rtl8126_rx_ptp_timestamp(struct rtl8126_private *tp, struct sk_buff *skb)
+{
+        unsigned int ptp_class;
+        struct ptp_header *hdr;
+        u8 msgtype;
+
+        ptp_class = ptp_classify_raw(skb);
+        if (ptp_class == PTP_CLASS_NONE)
+                return;
+
+        skb_reset_mac_header(skb);
+        hdr = ptp_parse_header(skb, ptp_class);
+        if (unlikely(!hdr))
+                return;
+
+        msgtype = ptp_get_msgtype(hdr, ptp_class);
+        rtl8126_rx_ptp_pktstamp(tp, skb, msgtype);
+
+        return;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0)
+struct ptp_header *ptp_parse_header(struct sk_buff *skb, unsigned int type)
+{
+        u8 *ptr = skb_mac_header(skb);
+
+        if (type & PTP_CLASS_VLAN)
+                //ptr += VLAN_HLEN;
+                ptr += 4;
+
+        switch (type & PTP_CLASS_PMASK) {
+        case PTP_CLASS_IPV4:
+                ptr += IPV4_HLEN(ptr) + UDP_HLEN;
+                break;
+        case PTP_CLASS_IPV6:
+                ptr += IP6_HLEN + UDP_HLEN;
+                break;
+        case PTP_CLASS_L2:
+                break;
+        default:
+                return NULL;
+        }
+
+        ptr += ETH_HLEN;
+
+        /* Ensure that the entire header is present in this packet. */
+        if (ptr + sizeof(struct ptp_header) > skb->data + skb->len)
+                return NULL;
+
+        return (struct ptp_header *)ptr;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0) */
Index: drivers/net/ethernet/r8126-10.016.00/r8126_firmware.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/r8126_firmware.c b/drivers/net/ethernet/r8126-10.016.00/r8126_firmware.c
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/r8126_firmware.c	(date 1763109333415)
@@ -0,0 +1,264 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/version.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+
+#include "r8126_firmware.h"
+
+enum rtl_fw_opcode {
+        PHY_READ		= 0x0,
+        PHY_DATA_OR		= 0x1,
+        PHY_DATA_AND		= 0x2,
+        PHY_BJMPN		= 0x3,
+        PHY_MDIO_CHG		= 0x4,
+        PHY_CLEAR_READCOUNT	= 0x7,
+        PHY_WRITE		= 0x8,
+        PHY_READCOUNT_EQ_SKIP	= 0x9,
+        PHY_COMP_EQ_SKIPN	= 0xa,
+        PHY_COMP_NEQ_SKIPN	= 0xb,
+        PHY_WRITE_PREVIOUS	= 0xc,
+        PHY_SKIPN		= 0xd,
+        PHY_DELAY_MS		= 0xe,
+};
+
+struct fw_info {
+        u32	magic;
+        char	version[RTL8126_VER_SIZE];
+        __le32	fw_start;
+        __le32	fw_len;
+        u8	chksum;
+} __packed;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
+#define sizeof_field(TYPE, MEMBER) sizeof((((TYPE *)0)->MEMBER))
+#endif
+#define FW_OPCODE_SIZE sizeof_field(struct rtl8126_fw_phy_action, code[0])
+
+static bool rtl8126_fw_format_ok(struct rtl8126_fw *rtl_fw)
+{
+        const struct firmware *fw = rtl_fw->fw;
+        struct fw_info *fw_info = (struct fw_info *)fw->data;
+        struct rtl8126_fw_phy_action *pa = &rtl_fw->phy_action;
+
+        if (fw->size < FW_OPCODE_SIZE)
+                return false;
+
+        if (!fw_info->magic) {
+                size_t i, size, start;
+                u8 checksum = 0;
+
+                if (fw->size < sizeof(*fw_info))
+                        return false;
+
+                for (i = 0; i < fw->size; i++)
+                        checksum += fw->data[i];
+                if (checksum != 0)
+                        return false;
+
+                start = le32_to_cpu(fw_info->fw_start);
+                if (start > fw->size)
+                        return false;
+
+                size = le32_to_cpu(fw_info->fw_len);
+                if (size > (fw->size - start) / FW_OPCODE_SIZE)
+                        return false;
+
+                strscpy(rtl_fw->version, fw_info->version, RTL8126_VER_SIZE);
+
+                pa->code = (__le32 *)(fw->data + start);
+                pa->size = size;
+        } else {
+                if (fw->size % FW_OPCODE_SIZE)
+                        return false;
+
+                strscpy(rtl_fw->version, rtl_fw->fw_name, RTL8126_VER_SIZE);
+
+                pa->code = (__le32 *)fw->data;
+                pa->size = fw->size / FW_OPCODE_SIZE;
+        }
+
+        return true;
+}
+
+static bool rtl8126_fw_data_ok(struct rtl8126_fw *rtl_fw)
+{
+        struct rtl8126_fw_phy_action *pa = &rtl_fw->phy_action;
+        size_t index;
+
+        for (index = 0; index < pa->size; index++) {
+                u32 action = le32_to_cpu(pa->code[index]);
+                u32 val = action & 0x0000ffff;
+                u32 regno = (action & 0x0fff0000) >> 16;
+
+                switch (action >> 28) {
+                case PHY_READ:
+                case PHY_DATA_OR:
+                case PHY_DATA_AND:
+                case PHY_CLEAR_READCOUNT:
+                case PHY_WRITE:
+                case PHY_WRITE_PREVIOUS:
+                case PHY_DELAY_MS:
+                        break;
+
+                case PHY_MDIO_CHG:
+                        if (val > 1)
+                                goto out;
+                        break;
+
+                case PHY_BJMPN:
+                        if (regno > index)
+                                goto out;
+                        break;
+                case PHY_READCOUNT_EQ_SKIP:
+                        if (index + 2 >= pa->size)
+                                goto out;
+                        break;
+                case PHY_COMP_EQ_SKIPN:
+                case PHY_COMP_NEQ_SKIPN:
+                case PHY_SKIPN:
+                        if (index + 1 + regno >= pa->size)
+                                goto out;
+                        break;
+
+                default:
+                        dev_err(rtl_fw->dev, "Invalid action 0x%08x\n", action);
+                        return false;
+                }
+        }
+
+        return true;
+out:
+        dev_err(rtl_fw->dev, "Out of range of firmware\n");
+        return false;
+}
+
+void rtl8126_fw_write_firmware(struct rtl8126_private *tp, struct rtl8126_fw *rtl_fw)
+{
+        struct rtl8126_fw_phy_action *pa = &rtl_fw->phy_action;
+        rtl8126_fw_write_t fw_write = rtl_fw->phy_write;
+        rtl8126_fw_read_t fw_read = rtl_fw->phy_read;
+        int predata = 0, count = 0;
+        size_t index;
+
+        for (index = 0; index < pa->size; index++) {
+                u32 action = le32_to_cpu(pa->code[index]);
+                u32 data = action & 0x0000ffff;
+                u32 regno = (action & 0x0fff0000) >> 16;
+                enum rtl_fw_opcode opcode = action >> 28;
+
+                if (!action)
+                        break;
+
+                switch (opcode) {
+                case PHY_READ:
+                        predata = fw_read(tp, regno);
+                        count++;
+                        break;
+                case PHY_DATA_OR:
+                        predata |= data;
+                        break;
+                case PHY_DATA_AND:
+                        predata &= data;
+                        break;
+                case PHY_BJMPN:
+                        index -= (regno + 1);
+                        break;
+                case PHY_MDIO_CHG:
+                        if (data) {
+                                fw_write = rtl_fw->mac_mcu_write;
+                                fw_read = rtl_fw->mac_mcu_read;
+                        } else {
+                                fw_write = rtl_fw->phy_write;
+                                fw_read = rtl_fw->phy_read;
+                        }
+
+                        break;
+                case PHY_CLEAR_READCOUNT:
+                        count = 0;
+                        break;
+                case PHY_WRITE:
+                        fw_write(tp, regno, data);
+                        break;
+                case PHY_READCOUNT_EQ_SKIP:
+                        if (count == data)
+                                index++;
+                        break;
+                case PHY_COMP_EQ_SKIPN:
+                        if (predata == data)
+                                index += regno;
+                        break;
+                case PHY_COMP_NEQ_SKIPN:
+                        if (predata != data)
+                                index += regno;
+                        break;
+                case PHY_WRITE_PREVIOUS:
+                        fw_write(tp, regno, predata);
+                        break;
+                case PHY_SKIPN:
+                        index += regno;
+                        break;
+                case PHY_DELAY_MS:
+                        mdelay(data);
+                        break;
+                }
+        }
+}
+
+void rtl8126_fw_release_firmware(struct rtl8126_fw *rtl_fw)
+{
+        release_firmware(rtl_fw->fw);
+}
+
+int rtl8126_fw_request_firmware(struct rtl8126_fw *rtl_fw)
+{
+        int rc;
+
+        rc = request_firmware(&rtl_fw->fw, rtl_fw->fw_name, rtl_fw->dev);
+        if (rc < 0)
+                goto out;
+
+        if (!rtl8126_fw_format_ok(rtl_fw) || !rtl8126_fw_data_ok(rtl_fw)) {
+                release_firmware(rtl_fw->fw);
+                rc = -EINVAL;
+                goto out;
+        }
+
+        return 0;
+out:
+        dev_err(rtl_fw->dev, "Unable to load firmware %s (%d)\n",
+                rtl_fw->fw_name, rc);
+        return rc;
+}
Index: drivers/net/ethernet/r8126-10.016.00/r8126_realwow.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/r8126_realwow.h b/drivers/net/ethernet/r8126-10.016.00/r8126_realwow.h
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/r8126_realwow.h	(date 1763109333415)
@@ -0,0 +1,118 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_R8126_REALWOW_H
+#define _LINUX_R8126_REALWOW_H
+
+#define SIOCDEVPRIVATE_RTLREALWOW   SIOCDEVPRIVATE+3
+
+#define MAX_RealWoW_KCP_SIZE (100)
+#define MAX_RealWoW_Payload (64)
+
+#define KA_TX_PACKET_SIZE (100)
+#define KA_WAKEUP_PATTERN_SIZE (120)
+
+//HwSuppKeepAliveOffloadVer
+#define HW_SUPPORT_KCP_OFFLOAD(_M)        ((_M)->HwSuppKCPOffloadVer > 0)
+
+enum rtl_realwow_cmd {
+
+        RTL_REALWOW_SET_KCP_DISABLE=0,
+        RTL_REALWOW_SET_KCP_INFO,
+        RTL_REALWOW_SET_KCP_CONTENT,
+
+        RTL_REALWOW_SET_KCP_ACKPKTINFO,
+        RTL_REALWOW_SET_KCP_WPINFO,
+        RTL_REALWOW_SET_KCPDHCP_TIMEOUT,
+
+        RTLT_REALWOW_COMMAND_INVALID
+};
+
+struct rtl_realwow_ioctl_struct {
+        __u32	cmd;
+        __u32	offset;
+        __u32	len;
+        union {
+                __u32	data;
+                void *data_buffer;
+        };
+};
+
+typedef struct _MP_KCPInfo {
+        u8 DIPv4[4];
+        u8 MacID[6];
+        u16 UdpPort[2];
+        u8 PKTLEN[2];
+
+        u16 ackLostCnt;
+        u8 KCP_WakePattern[MAX_RealWoW_Payload];
+        u8 KCP_AckPacket[MAX_RealWoW_Payload];
+        u32 KCP_interval;
+        u8 KCP_WakePattern_Len;
+        u8 KCP_AckPacket_Len;
+        u8 KCP_TxPacket[2][KA_TX_PACKET_SIZE];
+} MP_KCP_INFO, *PMP_KCP_INFO;
+
+typedef struct _KCPInfo {
+        u32 nId; // = id
+        u8 DIPv4[4];
+        u8 MacID[6];
+        u16 UdpPort;
+        u16 PKTLEN;
+} KCPInfo, *PKCPInfo;
+
+typedef struct _KCPContent {
+        u32 id; // = id
+        u32 mSec; // = msec
+        u32 size; // =size
+        u8 bPacket[MAX_RealWoW_KCP_SIZE]; // put packet here
+} KCPContent, *PKCPContent;
+
+typedef struct _RealWoWAckPktInfo {
+        u16 ackLostCnt;
+        u16 patterntSize;
+        u8 pattern[MAX_RealWoW_Payload];
+} RealWoWAckPktInfo,*PRealWoWAckPktInfo;
+
+typedef struct _RealWoWWPInfo {
+        u16 patterntSize;
+        u8 pattern[MAX_RealWoW_Payload];
+} RealWoWWPInfo,*PRealWoWWPInfo;
+
+int rtl8126_realwow_ioctl(struct net_device *dev, struct ifreq *ifr);
+void rtl8126_realwow_hw_init(struct net_device *dev);
+void rtl8126_get_realwow_hw_version(struct net_device *dev);
+void rtl8126_set_realwow_d3_para(struct net_device *dev);
+
+#endif /* _LINUX_R8126_REALWOW_H */
Index: drivers/net/ethernet/r8125-9.016.01/r8125_firmware.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/r8125_firmware.c b/drivers/net/ethernet/r8125-9.016.01/r8125_firmware.c
new file mode 100755
--- /dev/null	(date 1763113879453)
+++ b/drivers/net/ethernet/r8125-9.016.01/r8125_firmware.c	(date 1763113879453)
@@ -0,0 +1,264 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/version.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+
+#include "r8125_firmware.h"
+
+enum rtl_fw_opcode {
+        PHY_READ		= 0x0,
+        PHY_DATA_OR		= 0x1,
+        PHY_DATA_AND		= 0x2,
+        PHY_BJMPN		= 0x3,
+        PHY_MDIO_CHG		= 0x4,
+        PHY_CLEAR_READCOUNT	= 0x7,
+        PHY_WRITE		= 0x8,
+        PHY_READCOUNT_EQ_SKIP	= 0x9,
+        PHY_COMP_EQ_SKIPN	= 0xa,
+        PHY_COMP_NEQ_SKIPN	= 0xb,
+        PHY_WRITE_PREVIOUS	= 0xc,
+        PHY_SKIPN		= 0xd,
+        PHY_DELAY_MS		= 0xe,
+};
+
+struct fw_info {
+        u32	magic;
+        char	version[RTL8125_VER_SIZE];
+        __le32	fw_start;
+        __le32	fw_len;
+        u8	chksum;
+} __packed;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
+#define sizeof_field(TYPE, MEMBER) sizeof((((TYPE *)0)->MEMBER))
+#endif
+#define FW_OPCODE_SIZE sizeof_field(struct rtl8125_fw_phy_action, code[0])
+
+static bool rtl8125_fw_format_ok(struct rtl8125_fw *rtl_fw)
+{
+        const struct firmware *fw = rtl_fw->fw;
+        struct fw_info *fw_info = (struct fw_info *)fw->data;
+        struct rtl8125_fw_phy_action *pa = &rtl_fw->phy_action;
+
+        if (fw->size < FW_OPCODE_SIZE)
+                return false;
+
+        if (!fw_info->magic) {
+                size_t i, size, start;
+                u8 checksum = 0;
+
+                if (fw->size < sizeof(*fw_info))
+                        return false;
+
+                for (i = 0; i < fw->size; i++)
+                        checksum += fw->data[i];
+                if (checksum != 0)
+                        return false;
+
+                start = le32_to_cpu(fw_info->fw_start);
+                if (start > fw->size)
+                        return false;
+
+                size = le32_to_cpu(fw_info->fw_len);
+                if (size > (fw->size - start) / FW_OPCODE_SIZE)
+                        return false;
+
+                strscpy(rtl_fw->version, fw_info->version, RTL8125_VER_SIZE);
+
+                pa->code = (__le32 *)(fw->data + start);
+                pa->size = size;
+        } else {
+                if (fw->size % FW_OPCODE_SIZE)
+                        return false;
+
+                strscpy(rtl_fw->version, rtl_fw->fw_name, RTL8125_VER_SIZE);
+
+                pa->code = (__le32 *)fw->data;
+                pa->size = fw->size / FW_OPCODE_SIZE;
+        }
+
+        return true;
+}
+
+static bool rtl8125_fw_data_ok(struct rtl8125_fw *rtl_fw)
+{
+        struct rtl8125_fw_phy_action *pa = &rtl_fw->phy_action;
+        size_t index;
+
+        for (index = 0; index < pa->size; index++) {
+                u32 action = le32_to_cpu(pa->code[index]);
+                u32 val = action & 0x0000ffff;
+                u32 regno = (action & 0x0fff0000) >> 16;
+
+                switch (action >> 28) {
+                case PHY_READ:
+                case PHY_DATA_OR:
+                case PHY_DATA_AND:
+                case PHY_CLEAR_READCOUNT:
+                case PHY_WRITE:
+                case PHY_WRITE_PREVIOUS:
+                case PHY_DELAY_MS:
+                        break;
+
+                case PHY_MDIO_CHG:
+                        if (val > 1)
+                                goto out;
+                        break;
+
+                case PHY_BJMPN:
+                        if (regno > index)
+                                goto out;
+                        break;
+                case PHY_READCOUNT_EQ_SKIP:
+                        if (index + 2 >= pa->size)
+                                goto out;
+                        break;
+                case PHY_COMP_EQ_SKIPN:
+                case PHY_COMP_NEQ_SKIPN:
+                case PHY_SKIPN:
+                        if (index + 1 + regno >= pa->size)
+                                goto out;
+                        break;
+
+                default:
+                        dev_err(rtl_fw->dev, "Invalid action 0x%08x\n", action);
+                        return false;
+                }
+        }
+
+        return true;
+out:
+        dev_err(rtl_fw->dev, "Out of range of firmware\n");
+        return false;
+}
+
+void rtl8125_fw_write_firmware(struct rtl8125_private *tp, struct rtl8125_fw *rtl_fw)
+{
+        struct rtl8125_fw_phy_action *pa = &rtl_fw->phy_action;
+        rtl8125_fw_write_t fw_write = rtl_fw->phy_write;
+        rtl8125_fw_read_t fw_read = rtl_fw->phy_read;
+        int predata = 0, count = 0;
+        size_t index;
+
+        for (index = 0; index < pa->size; index++) {
+                u32 action = le32_to_cpu(pa->code[index]);
+                u32 data = action & 0x0000ffff;
+                u32 regno = (action & 0x0fff0000) >> 16;
+                enum rtl_fw_opcode opcode = action >> 28;
+
+                if (!action)
+                        break;
+
+                switch (opcode) {
+                case PHY_READ:
+                        predata = fw_read(tp, regno);
+                        count++;
+                        break;
+                case PHY_DATA_OR:
+                        predata |= data;
+                        break;
+                case PHY_DATA_AND:
+                        predata &= data;
+                        break;
+                case PHY_BJMPN:
+                        index -= (regno + 1);
+                        break;
+                case PHY_MDIO_CHG:
+                        if (data) {
+                                fw_write = rtl_fw->mac_mcu_write;
+                                fw_read = rtl_fw->mac_mcu_read;
+                        } else {
+                                fw_write = rtl_fw->phy_write;
+                                fw_read = rtl_fw->phy_read;
+                        }
+
+                        break;
+                case PHY_CLEAR_READCOUNT:
+                        count = 0;
+                        break;
+                case PHY_WRITE:
+                        fw_write(tp, regno, data);
+                        break;
+                case PHY_READCOUNT_EQ_SKIP:
+                        if (count == data)
+                                index++;
+                        break;
+                case PHY_COMP_EQ_SKIPN:
+                        if (predata == data)
+                                index += regno;
+                        break;
+                case PHY_COMP_NEQ_SKIPN:
+                        if (predata != data)
+                                index += regno;
+                        break;
+                case PHY_WRITE_PREVIOUS:
+                        fw_write(tp, regno, predata);
+                        break;
+                case PHY_SKIPN:
+                        index += regno;
+                        break;
+                case PHY_DELAY_MS:
+                        mdelay(1 * data);
+                        break;
+                }
+        }
+}
+
+void rtl8125_fw_release_firmware(struct rtl8125_fw *rtl_fw)
+{
+        release_firmware(rtl_fw->fw);
+}
+
+int rtl8125_fw_request_firmware(struct rtl8125_fw *rtl_fw)
+{
+        int rc;
+
+        rc = request_firmware(&rtl_fw->fw, rtl_fw->fw_name, rtl_fw->dev);
+        if (rc < 0)
+                goto out;
+
+        if (!rtl8125_fw_format_ok(rtl_fw) || !rtl8125_fw_data_ok(rtl_fw)) {
+                release_firmware(rtl_fw->fw);
+                rc = -EINVAL;
+                goto out;
+        }
+
+        return 0;
+out:
+        dev_err(rtl_fw->dev, "Unable to load firmware %s (%d)\n",
+                rtl_fw->fw_name, rc);
+        return rc;
+}
Index: drivers/net/ethernet/r8126-10.016.00/r8126_rss.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/r8126_rss.c b/drivers/net/ethernet/r8126-10.016.00/r8126_rss.c
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/r8126_rss.c	(date 1763109333415)
@@ -0,0 +1,583 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/version.h>
+#include "r8126.h"
+
+enum rtl8126_rss_register_content {
+        /* RSS */
+        RSS_CTRL_TCP_IPV4_SUPP = (1 << 0),
+        RSS_CTRL_IPV4_SUPP  = (1 << 1),
+        RSS_CTRL_TCP_IPV6_SUPP  = (1 << 2),
+        RSS_CTRL_IPV6_SUPP  = (1 << 3),
+        RSS_CTRL_IPV6_EXT_SUPP  = (1 << 4),
+        RSS_CTRL_TCP_IPV6_EXT_SUPP  = (1 << 5),
+        RSS_HALF_SUPP  = (1 << 7),
+        RSS_CTRL_UDP_IPV4_SUPP  = (1 << 11),
+        RSS_CTRL_UDP_IPV6_SUPP  = (1 << 12),
+        RSS_CTRL_UDP_IPV6_EXT_SUPP  = (1 << 13),
+        RSS_QUAD_CPU_EN  = (1 << 16),
+        RSS_HQ_Q_SUP_R  = (1 << 31),
+};
+
+static int rtl8126_get_rss_hash_opts(struct rtl8126_private *tp,
+                                     struct ethtool_rxnfc *cmd)
+{
+        cmd->data = 0;
+
+        /* Report default options for RSS */
+        switch (cmd->flow_type) {
+        case TCP_V4_FLOW:
+                cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+                fallthrough;
+        case UDP_V4_FLOW:
+                if (tp->rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV4)
+                        cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+                fallthrough;
+        case IPV4_FLOW:
+                cmd->data |= RXH_IP_SRC | RXH_IP_DST;
+                break;
+        case TCP_V6_FLOW:
+                cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+                fallthrough;
+        case UDP_V6_FLOW:
+                if (tp->rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV6)
+                        cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+                fallthrough;
+        case IPV6_FLOW:
+                cmd->data |= RXH_IP_SRC | RXH_IP_DST;
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        return 0;
+}
+
+int rtl8126_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
+                      u32 *rule_locs)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int ret = -EOPNOTSUPP;
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return ret;
+
+        switch (cmd->cmd) {
+        case ETHTOOL_GRXRINGS:
+                cmd->data = rtl8126_tot_rx_rings(tp);
+                ret = 0;
+                break;
+        case ETHTOOL_GRXFH:
+                ret = rtl8126_get_rss_hash_opts(tp, cmd);
+                break;
+        default:
+                break;
+        }
+
+        return ret;
+}
+
+u32 rtl8126_rss_indir_tbl_entries(struct rtl8126_private *tp)
+{
+        return tp->HwSuppIndirTblEntries;
+}
+
+#define RSS_MASK_BITS_OFFSET (8)
+#define RSS_CPU_NUM_OFFSET (16)
+#define RTL8126_UDP_RSS_FLAGS (RTL_8125_RSS_FLAG_HASH_UDP_IPV4 | \
+		       RTL_8125_RSS_FLAG_HASH_UDP_IPV6)
+static int _rtl8126_set_rss_hash_opt(struct rtl8126_private *tp)
+{
+        u32 rss_flags = tp->rss_flags;
+        u32 hash_mask_len;
+        u32 rss_ctrl;
+
+        rss_ctrl = ilog2(rtl8126_tot_rx_rings(tp));
+        rss_ctrl &= (BIT_0 | BIT_1 | BIT_2);
+        rss_ctrl <<= RSS_CPU_NUM_OFFSET;
+
+        /* Perform hash on these packet types */
+        rss_ctrl |= RSS_CTRL_TCP_IPV4_SUPP
+                    | RSS_CTRL_IPV4_SUPP
+                    | RSS_CTRL_IPV6_SUPP
+                    | RSS_CTRL_IPV6_EXT_SUPP
+                    | RSS_CTRL_TCP_IPV6_SUPP
+                    | RSS_CTRL_TCP_IPV6_EXT_SUPP;
+
+        if (rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV4)
+                rss_ctrl |= RSS_CTRL_UDP_IPV4_SUPP;
+
+        if (rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV6)
+                rss_ctrl |= RSS_CTRL_UDP_IPV6_SUPP |
+                            RSS_CTRL_UDP_IPV6_EXT_SUPP;
+
+        hash_mask_len = ilog2(rtl8126_rss_indir_tbl_entries(tp));
+        hash_mask_len &= (BIT_0 | BIT_1 | BIT_2);
+        rss_ctrl |= hash_mask_len << RSS_MASK_BITS_OFFSET;
+
+        RTL_W32(tp, RSS_CTRL_8125, rss_ctrl);
+
+        return 0;
+}
+
+static int rtl8126_set_rss_hash_opt(struct rtl8126_private *tp,
+                                    struct ethtool_rxnfc *nfc)
+{
+        u32 rss_flags = tp->rss_flags;
+
+        /*
+         * RSS does not support anything other than hashing
+         * to queues on src and dst IPs and ports
+         */
+        if (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |
+                          RXH_L4_B_0_1 | RXH_L4_B_2_3))
+                return -EINVAL;
+
+        switch (nfc->flow_type) {
+        case TCP_V4_FLOW:
+        case TCP_V6_FLOW:
+                if (!(nfc->data & RXH_IP_SRC) ||
+                    !(nfc->data & RXH_IP_DST) ||
+                    !(nfc->data & RXH_L4_B_0_1) ||
+                    !(nfc->data & RXH_L4_B_2_3))
+                        return -EINVAL;
+                break;
+        case UDP_V4_FLOW:
+                if (!(nfc->data & RXH_IP_SRC) ||
+                    !(nfc->data & RXH_IP_DST))
+                        return -EINVAL;
+                switch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {
+                case 0:
+                        rss_flags &= ~RTL_8125_RSS_FLAG_HASH_UDP_IPV4;
+                        break;
+                case (RXH_L4_B_0_1 | RXH_L4_B_2_3):
+                        rss_flags |= RTL_8125_RSS_FLAG_HASH_UDP_IPV4;
+                        break;
+                default:
+                        return -EINVAL;
+                }
+                break;
+        case UDP_V6_FLOW:
+                if (!(nfc->data & RXH_IP_SRC) ||
+                    !(nfc->data & RXH_IP_DST))
+                        return -EINVAL;
+                switch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {
+                case 0:
+                        rss_flags &= ~RTL_8125_RSS_FLAG_HASH_UDP_IPV6;
+                        break;
+                case (RXH_L4_B_0_1 | RXH_L4_B_2_3):
+                        rss_flags |= RTL_8125_RSS_FLAG_HASH_UDP_IPV6;
+                        break;
+                default:
+                        return -EINVAL;
+                }
+                break;
+        case SCTP_V4_FLOW:
+        case AH_ESP_V4_FLOW:
+        case AH_V4_FLOW:
+        case ESP_V4_FLOW:
+        case SCTP_V6_FLOW:
+        case AH_ESP_V6_FLOW:
+        case AH_V6_FLOW:
+        case ESP_V6_FLOW:
+        case IP_USER_FLOW:
+        case ETHER_FLOW:
+                /* RSS is not supported for these protocols */
+                if (nfc->data) {
+                        netif_err(tp, drv, tp->dev, "Command parameters not supported\n");
+                        return -EINVAL;
+                }
+                return 0;
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        /* if we changed something we need to update flags */
+        if (rss_flags != tp->rss_flags) {
+                u32 rss_ctrl = RTL_R32(tp, RSS_CTRL_8125);
+
+                if ((rss_flags & RTL8126_UDP_RSS_FLAGS) &&
+                    !(tp->rss_flags & RTL8126_UDP_RSS_FLAGS))
+                        netdev_warn(tp->dev,
+                                    "enabling UDP RSS: fragmented packets may "
+                                    "arrive out of order to the stack above\n");
+
+                tp->rss_flags = rss_flags;
+
+                /* Perform hash on these packet types */
+                rss_ctrl |= RSS_CTRL_TCP_IPV4_SUPP
+                            | RSS_CTRL_IPV4_SUPP
+                            | RSS_CTRL_IPV6_SUPP
+                            | RSS_CTRL_IPV6_EXT_SUPP
+                            | RSS_CTRL_TCP_IPV6_SUPP
+                            | RSS_CTRL_TCP_IPV6_EXT_SUPP;
+
+                rss_ctrl &= ~(RSS_CTRL_UDP_IPV4_SUPP |
+                              RSS_CTRL_UDP_IPV6_SUPP |
+                              RSS_CTRL_UDP_IPV6_EXT_SUPP);
+
+                if (rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV4)
+                        rss_ctrl |= RSS_CTRL_UDP_IPV4_SUPP;
+
+                if (rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV6)
+                        rss_ctrl |= RSS_CTRL_UDP_IPV6_SUPP |
+                                    RSS_CTRL_UDP_IPV6_EXT_SUPP;
+
+                RTL_W32(tp, RSS_CTRL_8125, rss_ctrl);
+        }
+
+        return 0;
+}
+
+int rtl8126_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int ret = -EOPNOTSUPP;
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return ret;
+
+        switch (cmd->cmd) {
+        case ETHTOOL_SRXFH:
+                ret = rtl8126_set_rss_hash_opt(tp, cmd);
+                break;
+        default:
+                break;
+        }
+
+        return ret;
+}
+
+static u32 _rtl8126_get_rxfh_key_size(struct rtl8126_private *tp)
+{
+        return sizeof(tp->rss_key);
+}
+
+u32 rtl8126_get_rxfh_key_size(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return 0;
+
+        return _rtl8126_get_rxfh_key_size(tp);
+}
+
+u32 rtl8126_rss_indir_size(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return 0;
+
+        return rtl8126_rss_indir_tbl_entries(tp);
+}
+
+static void rtl8126_get_reta(struct rtl8126_private *tp, u32 *indir)
+{
+        int i, reta_size = rtl8126_rss_indir_tbl_entries(tp);
+
+        for (i = 0; i < reta_size; i++)
+                indir[i] = tp->rss_indir_tbl[i];
+}
+
+static u32 rtl8126_rss_key_reg(struct rtl8126_private *tp)
+{
+        return RSS_KEY_8125;
+}
+
+static u32 rtl8126_rss_indir_tbl_reg(struct rtl8126_private *tp)
+{
+        return RSS_INDIRECTION_TBL_8125_V2;
+}
+
+static void rtl8126_store_reta(struct rtl8126_private *tp)
+{
+        u16 indir_tbl_reg = rtl8126_rss_indir_tbl_reg(tp);
+        u32 i, reta_entries = rtl8126_rss_indir_tbl_entries(tp);
+        u32 reta = 0;
+        u8 *indir_tbl = tp->rss_indir_tbl;
+
+        /* Write redirection table to HW */
+        for (i = 0; i < reta_entries; i++) {
+                reta |= indir_tbl[i] << (i & 0x3) * 8;
+                if ((i & 3) == 3) {
+                        RTL_W32(tp, indir_tbl_reg, reta);
+
+                        indir_tbl_reg += 4;
+                        reta = 0;
+                }
+        }
+}
+
+static void rtl8126_store_rss_key(struct rtl8126_private *tp)
+{
+        const u16 rss_key_reg = rtl8126_rss_key_reg(tp);
+        u32 i, rss_key_size = _rtl8126_get_rxfh_key_size(tp);
+        u32 *rss_key = (u32*)tp->rss_key;
+
+        /* Write redirection table to HW */
+        for (i = 0; i < rss_key_size; i+=4)
+                RTL_W32(tp, rss_key_reg + i, *rss_key++);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,8,0)
+int rtl8126_get_rxfh(struct net_device *dev, struct ethtool_rxfh_param *rxfh)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return -EOPNOTSUPP;
+
+        rxfh->hfunc = ETH_RSS_HASH_TOP;
+
+        if (rxfh->indir)
+                rtl8126_get_reta(tp, rxfh->indir);
+
+        if (rxfh->key)
+                memcpy(rxfh->key, tp->rss_key, RTL8126_RSS_KEY_SIZE);
+
+        return 0;
+}
+
+int rtl8126_set_rxfh(struct net_device *dev, struct ethtool_rxfh_param *rxfh,
+                     struct netlink_ext_ack *extack)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i;
+        u32 reta_entries = rtl8126_rss_indir_tbl_entries(tp);
+
+        /* We require at least one supported parameter to be changed and no
+         * change in any of the unsupported parameters
+         */
+        if (rxfh->hfunc != ETH_RSS_HASH_NO_CHANGE && rxfh->hfunc != ETH_RSS_HASH_TOP)
+                return -EOPNOTSUPP;
+
+        /* Fill out the redirection table */
+        if (rxfh->indir) {
+                int max_queues = tp->num_rx_rings;
+
+                /* Verify user input. */
+                for (i = 0; i < reta_entries; i++)
+                        if (rxfh->indir[i] >= max_queues)
+                                return -EINVAL;
+
+                for (i = 0; i < reta_entries; i++)
+                        tp->rss_indir_tbl[i] = rxfh->indir[i];
+        }
+
+        /* Fill out the rss hash key */
+        if (rxfh->key)
+                memcpy(tp->rss_key, rxfh->key, RTL8126_RSS_KEY_SIZE);
+
+        rtl8126_store_reta(tp);
+
+        rtl8126_store_rss_key(tp);
+
+        return 0;
+}
+#else
+int rtl8126_get_rxfh(struct net_device *dev, u32 *indir, u8 *key,
+                     u8 *hfunc)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return -EOPNOTSUPP;
+
+        if (hfunc)
+                *hfunc = ETH_RSS_HASH_TOP;
+
+        if (indir)
+                rtl8126_get_reta(tp, indir);
+
+        if (key)
+                memcpy(key, tp->rss_key, RTL8126_RSS_KEY_SIZE);
+
+        return 0;
+}
+
+int rtl8126_set_rxfh(struct net_device *dev, const u32 *indir,
+                     const u8 *key, const u8 hfunc)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i;
+        u32 reta_entries = rtl8126_rss_indir_tbl_entries(tp);
+
+        /* We require at least one supported parameter to be changed and no
+         * change in any of the unsupported parameters
+         */
+        if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)
+                return -EOPNOTSUPP;
+
+        /* Fill out the redirection table */
+        if (indir) {
+                int max_queues = tp->num_rx_rings;
+
+                /* Verify user input. */
+                for (i = 0; i < reta_entries; i++)
+                        if (indir[i] >= max_queues)
+                                return -EINVAL;
+
+                for (i = 0; i < reta_entries; i++)
+                        tp->rss_indir_tbl[i] = indir[i];
+        }
+
+        /* Fill out the rss hash key */
+        if (key)
+                memcpy(tp->rss_key, key, RTL8126_RSS_KEY_SIZE);
+
+        rtl8126_store_reta(tp);
+
+        rtl8126_store_rss_key(tp);
+
+        return 0;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,8,0) */
+
+static u32 rtl8126_get_rx_desc_hash(struct rtl8126_private *tp,
+                                    struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                return le32_to_cpu(((struct RxDescV3 *)desc)->RxDescNormalDDWord2.RSSResult);
+        case RX_DESC_RING_TYPE_4:
+                return le32_to_cpu(((struct RxDescV4 *)desc)->RxDescNormalDDWord1.RSSResult);
+        default:
+                return 0;
+        }
+}
+
+#define RXS_8125B_RSS_UDP BIT(9)
+#define RXS_8125_RSS_IPV4 BIT(10)
+#define RXS_8125_RSS_IPV6 BIT(12)
+#define RXS_8125_RSS_TCP BIT(13)
+#define RTL8126_RXS_RSS_L3_TYPE_MASK (RXS_8125_RSS_IPV4 | RXS_8125_RSS_IPV6)
+#define RTL8126_RXS_RSS_L4_TYPE_MASK (RXS_8125_RSS_TCP | RXS_8125B_RSS_UDP)
+
+#define RXS_8125B_RSS_UDP_V4 BIT(27)
+#define RXS_8125_RSS_IPV4_V4 BIT(28)
+#define RXS_8125_RSS_IPV6_V4 BIT(29)
+#define RXS_8125_RSS_TCP_V4 BIT(30)
+#define RTL8126_RXS_RSS_L3_TYPE_MASK_V4 (RXS_8125_RSS_IPV4_V4 | RXS_8125_RSS_IPV6_V4)
+#define RTL8126_RXS_RSS_L4_TYPE_MASK_V4 (RXS_8125_RSS_TCP_V4 | RXS_8125B_RSS_UDP_V4)
+static void rtl8126_rx_hash_v3(struct rtl8126_private *tp,
+                               struct RxDescV3 *descv3,
+                               struct sk_buff *skb)
+{
+        u16 rss_header_info;
+
+        if (!(tp->dev->features & NETIF_F_RXHASH))
+                return;
+
+        rss_header_info = le16_to_cpu(descv3->RxDescNormalDDWord2.HeaderInfo);
+
+        if (!(rss_header_info & RTL8126_RXS_RSS_L3_TYPE_MASK))
+                return;
+
+        skb_set_hash(skb, rtl8126_get_rx_desc_hash(tp, (struct RxDesc *)descv3),
+                     (RTL8126_RXS_RSS_L4_TYPE_MASK & rss_header_info) ?
+                     PKT_HASH_TYPE_L4 : PKT_HASH_TYPE_L3);
+}
+
+static void rtl8126_rx_hash_v4(struct rtl8126_private *tp,
+                               struct RxDescV4 *descv4,
+                               struct sk_buff *skb)
+{
+        u32 rss_header_info;
+
+        if (!(tp->dev->features & NETIF_F_RXHASH))
+                return;
+
+        rss_header_info = le32_to_cpu(descv4->RxDescNormalDDWord1.RSSInfo);
+
+        if (!(rss_header_info & RTL8126_RXS_RSS_L3_TYPE_MASK_V4))
+                return;
+
+        skb_set_hash(skb, rtl8126_get_rx_desc_hash(tp, (struct RxDesc *)descv4),
+                     (RTL8126_RXS_RSS_L4_TYPE_MASK_V4 & rss_header_info) ?
+                     PKT_HASH_TYPE_L4 : PKT_HASH_TYPE_L3);
+}
+
+void rtl8126_rx_hash(struct rtl8126_private *tp,
+                     struct RxDesc *desc,
+                     struct sk_buff *skb)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                rtl8126_rx_hash_v3(tp, (struct RxDescV3 *)desc, skb);
+                break;
+        case RX_DESC_RING_TYPE_4:
+                rtl8126_rx_hash_v4(tp, (struct RxDescV4 *)desc, skb);
+                break;
+        default:
+                return;
+        }
+}
+
+void rtl8126_disable_rss(struct rtl8126_private *tp)
+{
+        RTL_W32(tp, RSS_CTRL_8125, 0x00);
+}
+
+void _rtl8126_config_rss(struct rtl8126_private *tp)
+{
+        _rtl8126_set_rss_hash_opt(tp);
+
+        rtl8126_store_reta(tp);
+
+        rtl8126_store_rss_key(tp);
+}
+
+void rtl8126_config_rss(struct rtl8126_private *tp)
+{
+        if (!tp->EnableRss) {
+                rtl8126_disable_rss(tp);
+                return;
+        }
+
+        _rtl8126_config_rss(tp);
+}
+
+void rtl8126_init_rss(struct rtl8126_private *tp)
+{
+        int i;
+
+        for (i = 0; i < rtl8126_rss_indir_tbl_entries(tp); i++)
+                tp->rss_indir_tbl[i] = ethtool_rxfh_indir_default(i, tp->num_rx_rings);
+
+        netdev_rss_key_fill(tp->rss_key, RTL8126_RSS_KEY_SIZE);
+}
Index: drivers/net/ethernet/r8125-9.016.01/rtl_eeprom.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/rtl_eeprom.h b/drivers/net/ethernet/r8125-9.016.01/rtl_eeprom.h
new file mode 100755
--- /dev/null	(date 1763113879457)
+++ b/drivers/net/ethernet/r8125-9.016.01/rtl_eeprom.h	(date 1763113879457)
@@ -0,0 +1,53 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+//EEPROM opcodes
+#define RTL_EEPROM_READ_OPCODE      06
+#define RTL_EEPROM_WRITE_OPCODE     05
+#define RTL_EEPROM_ERASE_OPCODE     07
+#define RTL_EEPROM_EWEN_OPCODE      19
+#define RTL_EEPROM_EWDS_OPCODE      16
+
+#define RTL_CLOCK_RATE  3
+
+void rtl8125_eeprom_type(struct rtl8125_private *tp);
+void rtl8125_eeprom_cleanup(struct rtl8125_private *tp);
+u16 rtl8125_eeprom_read_sc(struct rtl8125_private *tp, u16 reg);
+void rtl8125_eeprom_write_sc(struct rtl8125_private *tp, u16 reg, u16 data);
+void rtl8125_shift_out_bits(struct rtl8125_private *tp, int data, int count);
+u16 rtl8125_shift_in_bits(struct rtl8125_private *tp);
+void rtl8125_raise_clock(struct rtl8125_private *tp, u8 *x);
+void rtl8125_lower_clock(struct rtl8125_private *tp, u8 *x);
+void rtl8125_stand_by(struct rtl8125_private *tp);
+void rtl8125_set_eeprom_sel_low(struct rtl8125_private *tp);
Index: drivers/net/ethernet/r8126-10.016.00/Makefile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/Makefile b/drivers/net/ethernet/r8126-10.016.00/Makefile
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/Makefile	(date 1763109333415)
@@ -0,0 +1,138 @@
+# SPDX-License-Identifier: GPL-2.0-only
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+
+################################################################################
+#  This product is covered by one or more of the following patents:
+#  US6,570,884, US6,115,776, and US6,327,625.
+################################################################################
+
+CONFIG_SOC_LAN = y
+ENABLE_FIBER_SUPPORT = n
+ENABLE_REALWOW_SUPPORT = n
+CONFIG_DOWN_SPEED_100 = n
+CONFIG_ASPM = n
+ENABLE_S5WOL = y
+ENABLE_S5_KEEP_CURR_MAC = n
+ENABLE_EEE = y
+ENABLE_S0_MAGIC_PACKET = n
+ENABLE_TX_NO_CLOSE = y
+ENABLE_MULTIPLE_TX_QUEUE = n
+ENABLE_PTP_SUPPORT = n
+ENABLE_RSS_SUPPORT = y
+ENABLE_LIB_SUPPORT = n
+ENABLE_USE_FIRMWARE_FILE = n
+DISABLE_WOL_SUPPORT = n
+DISABLE_MULTI_MSIX_VECTOR = n
+ENABLE_DOUBLE_VLAN = n
+ENABLE_PAGE_REUSE = n
+ENABLE_RX_PACKET_FRAGMENT = n
+ENABLE_GIGA_LITE = n
+
+obj-$(CONFIG_R8126) += r8126.o
+r8126-objs := r8126_n.o rtl_eeprom.o rtltool.o
+ifeq ($(CONFIG_SOC_LAN), y)
+	EXTRA_CFLAGS += -DCONFIG_SOC_LAN
+endif
+ifeq ($(ENABLE_FIBER_SUPPORT), y)
+	r8126-objs += r8126_fiber.o
+	EXTRA_CFLAGS += -DENABLE_FIBER_SUPPORT
+endif
+ifeq ($(ENABLE_REALWOW_SUPPORT), y)
+	r8126-objs += r8126_realwow.o
+	EXTRA_CFLAGS += -DENABLE_REALWOW_SUPPORT
+endif
+ifeq ($(ENABLE_DASH_SUPPORT), y)
+	r8126-objs += r8126_dash.o
+	EXTRA_CFLAGS += -DENABLE_DASH_SUPPORT
+endif
+ifeq ($(ENABLE_DASH_PRINTER_SUPPORT), y)
+	r8126-objs += r8126_dash.o
+	EXTRA_CFLAGS += -DENABLE_DASH_SUPPORT -DENABLE_DASH_PRINTER_SUPPORT
+endif
+EXTRA_CFLAGS += -DCONFIG_R8126_NAPI
+EXTRA_CFLAGS += -DCONFIG_R8126_VLAN
+ifeq ($(CONFIG_DOWN_SPEED_100), y)
+	EXTRA_CFLAGS += -DCONFIG_DOWN_SPEED_100
+endif
+ifeq ($(CONFIG_ASPM), y)
+	EXTRA_CFLAGS += -DCONFIG_ASPM
+endif
+ifeq ($(ENABLE_S5WOL), y)
+	EXTRA_CFLAGS += -DENABLE_S5WOL
+endif
+ifeq ($(ENABLE_S5_KEEP_CURR_MAC), y)
+	EXTRA_CFLAGS += -DENABLE_S5_KEEP_CURR_MAC
+endif
+ifeq ($(ENABLE_EEE), y)
+	EXTRA_CFLAGS += -DENABLE_EEE
+endif
+ifeq ($(ENABLE_S0_MAGIC_PACKET), y)
+	EXTRA_CFLAGS += -DENABLE_S0_MAGIC_PACKET
+endif
+ifeq ($(ENABLE_TX_NO_CLOSE), y)
+	EXTRA_CFLAGS += -DENABLE_TX_NO_CLOSE
+endif
+ifeq ($(ENABLE_MULTIPLE_TX_QUEUE), y)
+	EXTRA_CFLAGS += -DENABLE_MULTIPLE_TX_QUEUE
+endif
+ifeq ($(ENABLE_PTP_SUPPORT), y)
+	r8126-objs += r8126_ptp.o
+	EXTRA_CFLAGS += -DENABLE_PTP_SUPPORT
+endif
+ifeq ($(ENABLE_RSS_SUPPORT), y)
+	r8126-objs += r8126_rss.o
+	EXTRA_CFLAGS += -DENABLE_RSS_SUPPORT
+endif
+ifeq ($(ENABLE_LIB_SUPPORT), y)
+	r8126-objs += r8126_lib.o
+	EXTRA_CFLAGS += -DENABLE_LIB_SUPPORT
+endif
+ifeq ($(ENABLE_USE_FIRMWARE_FILE), y)
+	r8126-objs += r8126_firmware.o
+	EXTRA_CFLAGS += -DENABLE_USE_FIRMWARE_FILE
+endif
+ifeq ($(DISABLE_WOL_SUPPORT), y)
+	EXTRA_CFLAGS += -DDISABLE_WOL_SUPPORT
+endif
+ifeq ($(DISABLE_MULTI_MSIX_VECTOR), y)
+	EXTRA_CFLAGS += -DDISABLE_MULTI_MSIX_VECTOR
+endif
+ifeq ($(ENABLE_DOUBLE_VLAN), y)
+	EXTRA_CFLAGS += -DENABLE_DOUBLE_VLAN
+endif
+ifeq ($(ENABLE_PAGE_REUSE), y)
+	EXTRA_CFLAGS += -DENABLE_PAGE_REUSE
+endif
+ifeq ($(ENABLE_RX_PACKET_FRAGMENT), y)
+	EXTRA_CFLAGS += -DENABLE_RX_PACKET_FRAGMENT
+endif
+ifeq ($(ENABLE_GIGA_LITE), y)
+	EXTRA_CFLAGS += -DENABLE_GIGA_LITE
+endif
+
+# Backward compatibility
+ccflags-y  += $(EXTRA_CFLAGS)
Index: drivers/net/ethernet/r8125-9.016.01/r8125_ptp.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/r8125_ptp.c b/drivers/net/ethernet/r8125-9.016.01/r8125_ptp.c
new file mode 100755
--- /dev/null	(date 1763113879455)
+++ b/drivers/net/ethernet/r8125-9.016.01/r8125_ptp.c	(date 1763113879455)
@@ -0,0 +1,1472 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/mii.h>
+#include <linux/in.h>
+#include <linux/ethtool.h>
+#include <linux/rtnetlink.h>
+#include <linux/hrtimer.h>
+
+#include "r8125.h"
+#include "r8125_ptp.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+static inline struct timespec timespec64_to_timespec(const struct timespec64 ts64)
+{
+        return *(const struct timespec *)&ts64;
+}
+
+static inline struct timespec64 timespec_to_timespec64(const struct timespec ts)
+{
+        return *(const struct timespec64 *)&ts;
+}
+#endif
+
+static int _rtl8125_mac_phc_gettime(struct rtl8125_private *tp, struct timespec64 *ts64)
+{
+        //get local time
+        RTL_W16(tp, PTP_TIME_CORRECT_CMD_8125, (PTP_CMD_LATCHED_LOCAL_TIME | PTP_EXEC_CMD));
+
+        /* nanoseconds */
+        //0x6808[29:0]
+        ts64->tv_nsec = (RTL_R32(tp, PTP_SOFT_CONFIG_Time_NS_8125) & 0x3fffffff);
+
+        /* seconds */
+        //0x680C[47:0]
+        ts64->tv_sec = RTL_R16(tp, PTP_SOFT_CONFIG_Time_S_8125 + 4);
+        ts64->tv_sec <<= 32;
+        ts64->tv_sec |= RTL_R32(tp, PTP_SOFT_CONFIG_Time_S_8125);
+
+        return 0;
+}
+
+static void rtl8125_wait_phy_clkadj_ready(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++)
+                if (!(rtl8125_mdio_direct_read_phy_ocp(tp, PTP_CLK_CFG_8126) & CLKADJ_MODE_SET))
+                        break;
+}
+
+static void rtl8125_phy_set_clkadj_mode(struct rtl8125_private *tp, u16 cmd)
+{
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              PTP_CLK_CFG_8126,
+                                              BIT_3 | BIT_2 | BIT_1,
+                                              CLKADJ_MODE_SET | cmd);
+
+        rtl8125_wait_phy_clkadj_ready(tp);
+}
+
+static int _rtl8125_phy_phc_gettime(struct rtl8125_private *tp, struct timespec64 *ts64)
+{
+        unsigned long flags;
+        int i;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        //Direct Read
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              PTP_CLK_CFG_8126,
+                                              BIT_3 | BIT_2 | BIT_1,
+                                              (PTP_CLKADJ_MODE_SET | DIRECT_READ));
+
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
+
+                if (!(rtl8125_mdio_direct_read_phy_ocp(tp, PTP_CLK_CFG_8126) & PTP_CLKADJ_MODE_SET))
+                        break;
+        }
+
+        /* nanoseconds */
+        //Ns[29:16] E414[13:0]
+        ts64->tv_nsec = rtl8125_mdio_direct_read_phy_ocp(tp, PTP_CFG_NS_HI_8126) & 0x3fff;
+        ts64->tv_nsec <<= 16;
+        //Ns[15:0]  E412[15:0]
+        ts64->tv_nsec |= rtl8125_mdio_direct_read_phy_ocp(tp, PTP_CFG_NS_LO_8126);
+
+
+        /* seconds */
+        //S[47:32] E41A[15:0]
+        ts64->tv_sec = rtl8125_mdio_direct_read_phy_ocp(tp, PTP_CFG_S_HI_8126);
+        ts64->tv_sec <<= 16;
+        //S[31:16] E418[15:0]
+        ts64->tv_sec |= rtl8125_mdio_direct_read_phy_ocp(tp, PTP_CFG_S_MI_8126);
+        ts64->tv_sec <<= 16;
+        //S[15:0]  E416[15:0]
+        ts64->tv_sec |= rtl8125_mdio_direct_read_phy_ocp(tp, PTP_CFG_S_LO_8126);
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        return 0;
+}
+
+static int _rtl8125_mac_phc_settime(struct rtl8125_private *tp, const struct timespec64 *ts64)
+{
+        /* nanoseconds */
+        //0x6808[29:0]
+        RTL_W32(tp, PTP_SOFT_CONFIG_Time_NS_8125, (ts64->tv_nsec & 0x3fffffff));
+
+        /* seconds */
+        //0x680C[47:0]
+        RTL_W32(tp, PTP_SOFT_CONFIG_Time_S_8125, ts64->tv_sec);
+        RTL_W16(tp, PTP_SOFT_CONFIG_Time_S_8125 + 4, (ts64->tv_sec >> 32));
+
+        //set local time
+        RTL_W16(tp, PTP_TIME_CORRECT_CMD_8125, (PTP_CMD_SET_LOCAL_TIME | PTP_EXEC_CMD));
+
+        return 0;
+}
+
+static int _rtl8125_phy_phc_settime(struct rtl8125_private *tp, const struct timespec64 *ts64)
+{
+        unsigned long flags;
+        int i;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        /* nanoseconds */
+        //Ns[15:0]  E412[15:0]
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_CFG_NS_LO_8126, ts64->tv_nsec);
+        //Ns[29:16] E414[13:0]
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_CFG_NS_HI_8126, (ts64->tv_nsec & 0x3fff0000) >> 16);
+
+        /* seconds */
+        //S[15:0]  E416[15:0]
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_CFG_S_LO_8126, ts64->tv_sec);
+        //S[31:16] E418[15:0]
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_CFG_S_MI_8126, (ts64->tv_sec >> 16));
+        //S[47:32] E41A[15:0]
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_CFG_S_HI_8126, (ts64->tv_sec >> 32));
+
+        //Direct Write
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              PTP_CLK_CFG_8126,
+                                              BIT_3 | BIT_2 | BIT_1,
+                                              (PTP_CLKADJ_MODE_SET | DIRECT_WRITE));
+
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
+
+                if (!(rtl8125_mdio_direct_read_phy_ocp(tp, PTP_CLK_CFG_8126) & PTP_CLKADJ_MODE_SET))
+                        break;
+        }
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        return 0;
+}
+
+static int _rtl8125_mac_phc_adjtime(struct rtl8125_private *tp, s64 delta)
+{
+        struct timespec64 d;
+        bool negative = false;
+        u64 tohw;
+        u32 nsec;
+        u64 sec;
+
+        if (delta < 0) {
+                negative = true;
+                tohw = -delta;
+        } else {
+                tohw = delta;
+        }
+
+        d = ns_to_timespec64(tohw);
+
+        nsec = d.tv_nsec;
+        sec = d.tv_sec;
+
+        if (negative) {
+                nsec = -nsec;
+                sec = -sec;
+        }
+
+        nsec &= 0x3fffffff;
+        sec &= 0x0000ffffffffffff;
+
+        if (negative) {
+                nsec |= PTP_SOFT_CONFIG_TIME_NS_NEGATIVE;
+                sec |= PTP_SOFT_CONFIG_TIME_S_NEGATIVE;
+        }
+
+        /* nanoseconds */
+        //0x6808[29:0]
+        RTL_W32(tp, PTP_SOFT_CONFIG_Time_NS_8125, nsec);
+
+        /* seconds */
+        //0x680C[47:0]
+        RTL_W32(tp, PTP_SOFT_CONFIG_Time_S_8125, sec);
+        RTL_W16(tp, PTP_SOFT_CONFIG_Time_S_8125 + 4, (sec >> 32));
+
+        //adjust local time
+        //RTL_W16(tp, PTP_TIME_CORRECT_CMD_8125, (PTP_CMD_DRIFT_LOCAL_TIME | PTP_EXEC_CMD));
+        RTL_W16(tp, PTP_TIME_CORRECT_CMD_8125, (PTP_CMD_SET_LOCAL_TIME | PTP_EXEC_CMD));
+
+        return 0;
+}
+
+static int rtl8125_mac_phc_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc adjust time\n");
+
+        rtnl_lock();
+        ret = _rtl8125_mac_phc_adjtime(tp, delta);
+        rtnl_unlock();
+
+        return ret;
+}
+
+static int _rtl8125_phy_phc_adjtime(struct rtl8125_private *tp, s64 delta)
+{
+        unsigned long flags;
+        struct timespec64 d;
+        bool negative = false;
+        int i;
+        u64 tohw;
+        u32 nsec;
+        u64 sec;
+
+        if (delta < 0) {
+                negative = true;
+                tohw = -delta;
+        } else {
+                tohw = delta;
+        }
+
+        d = ns_to_timespec64(tohw);
+
+        nsec = d.tv_nsec;
+        sec = d.tv_sec;
+
+        nsec &= 0x3fffffff;
+        sec &= 0x0000ffffffffffff;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        /* nanoseconds */
+        //Ns[15:0]  E412[15:0]
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_CFG_NS_LO_8126, nsec);
+        //Ns[29:16] E414[13:0]
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_CFG_NS_HI_8126, (nsec >> 16));
+
+        /* seconds */
+        //S[15:0]  E416[15:0]
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_CFG_S_LO_8126, sec);
+        //S[31:16] E418[15:0]
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_CFG_S_MI_8126, (sec >> 16));
+        //S[47:32] E41A[15:0]
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_CFG_S_HI_8126, (sec >> 32));
+
+        if (negative)
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      PTP_CLK_CFG_8126,
+                                                      BIT_3 | BIT_2 | BIT_1,
+                                                      (PTP_CLKADJ_MODE_SET | DECREMENT_STEP));
+        else
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      PTP_CLK_CFG_8126,
+                                                      BIT_3 | BIT_2 | BIT_1,
+                                                      (PTP_CLKADJ_MODE_SET | INCREMENT_STEP));
+
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
+
+                if (!(rtl8125_mdio_direct_read_phy_ocp(tp, PTP_CLK_CFG_8126) & PTP_CLKADJ_MODE_SET))
+                        break;
+        }
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        return 0;
+}
+
+static int rtl8125_phy_phc_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc adjust time\n");
+
+        ret = _rtl8125_phy_phc_adjtime(tp, delta);
+
+        return ret;
+}
+
+/*
+ * 1ppm means every 125MHz plus 125Hz. It also means every 8ns minus 8ns*10^(-6)
+ * 1ns=2^30 sub_ns
+ * 8ns*10^(-6) = 8 * 2^30 sub_ns * 10^(-6) = 2^33 sub_ns * 10^(-6) = 8590 = 0x218E sub_ns
+ *
+ * 1ppb means every 125MHz plus 0.125Hz. It also means every 8ns minus 8ns*10^(-9)
+ * 1ns=2^30 sub_ns
+ * 8ns*10^(-9) = 8 * 2^30 sub_ns * 10^(-9) = 2^33 sub_ns * 10^(-9) = 8.59 sub_ns = 9 sub_ns
+ */
+static int _rtl8125_mac_phc_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        bool negative = false;
+        u32 sub_ns;
+
+        if (ppb < 0) {
+                negative = true;
+                ppb = -ppb;
+        }
+
+        sub_ns = ppb * 9;
+        if (negative) {
+                sub_ns = -sub_ns;
+                sub_ns &= 0x3fffffff;
+                sub_ns |= PTP_ADJUST_TIME_NS_NEGATIVE;
+        } else
+                sub_ns &= 0x3fffffff;
+
+        /* nanoseconds */
+        //0x6808[29:0]
+        RTL_W32(tp, PTP_SOFT_CONFIG_Time_NS_8125, sub_ns);
+
+        //adjust local time
+        RTL_W16(tp, PTP_TIME_CORRECT_CMD_8125, (PTP_CMD_DRIFT_LOCAL_TIME | PTP_EXEC_CMD));
+        //RTL_W16(tp, PTP_TIME_CORRECT_CMD_8125, (PTP_CMD_SET_LOCAL_TIME | PTP_EXEC_CMD));
+
+        return 0;
+}
+
+/*
+ * delta = delta * 10^6 ppm = delta * 10^9 ppb (in this equation ppm and ppb are not variable)
+ *
+ * in adjfreq ppb is a variable
+ * ppb = delta * 10^9
+ * delta = ppb / 10^9
+ * rate_value = |delta| * 2^32 = |ppb| / 10^9 * 2^32 = (|ppb| << 32) / 10^9
+ */
+static int _rtl8125_phy_phc_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        unsigned long flags;
+        u32 rate_value;
+
+        if (ppb < 0) {
+                rate_value = ((u64)-ppb << 32) / 1000000000;
+                rate_value = ~rate_value + 1;
+        } else
+                rate_value = ((u64)ppb << 32) / 1000000000;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        /* nanoseconds */
+        //Ns[15:0]  E412[15:0]
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_CFG_NS_LO_8126, rate_value);
+        //Ns[22:16] E414[13:0]
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_CFG_NS_HI_8126, (rate_value & 0x003f0000) >> 16);
+
+        rtl8125_phy_set_clkadj_mode(tp, RATE_WRITE);
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+static int rtl8125_mac_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)
+{
+        s32 ppb = scaled_ppm_to_ppb(scaled_ppm);
+
+        if (ppb > ptp->max_adj || ppb < -ptp->max_adj)
+                return -EINVAL;
+
+        rtnl_lock();
+        _rtl8125_mac_phc_adjfreq(ptp, ppb);
+        rtnl_unlock();
+
+        return 0;
+}
+#else
+static int rtl8125_mac_phc_adjfreq(struct ptp_clock_info *ptp, s32 delta)
+{
+        //struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+
+        //netif_info(tp, drv, tp->dev, "phc adjust freq\n");
+
+        if (delta > ptp->max_adj || delta < -ptp->max_adj)
+                return -EINVAL;
+
+        rtnl_lock();
+        _rtl8125_mac_phc_adjfreq(ptp, delta);
+        rtnl_unlock();
+
+        return 0;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+static int rtl8125_mac_phc_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts64,
+                                   struct ptp_system_timestamp *sts)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc get ts\n");
+
+        rtnl_lock();
+        ptp_read_system_prets(sts);
+        ret = _rtl8125_mac_phc_gettime(tp, ts64);
+        ptp_read_system_postts(sts);
+        rtnl_unlock();
+
+        return ret;
+}
+#else
+static int rtl8125_mac_phc_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts64)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc get ts\n");
+
+        rtnl_lock();
+        ret = _rtl8125_mac_phc_gettime(tp, ts64);
+        rtnl_unlock();
+
+        return ret;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+static int rtl8125_phy_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)
+{
+        s32 ppb = scaled_ppm_to_ppb(scaled_ppm);
+
+        if (ppb > ptp->max_adj || ppb < -ptp->max_adj)
+                return -EINVAL;
+
+        _rtl8125_phy_phc_adjfreq(ptp, ppb);
+
+        return 0;
+}
+
+#else
+static int rtl8125_phy_phc_adjfreq(struct ptp_clock_info *ptp, s32 delta)
+{
+        //netif_info(tp, drv, tp->dev, "phc adjust freq\n");
+
+        if (delta > ptp->max_adj || delta < -ptp->max_adj)
+                return -EINVAL;
+
+        _rtl8125_phy_phc_adjfreq(ptp, delta);
+
+        return 0;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+static int rtl8125_phy_phc_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts64,
+                                   struct ptp_system_timestamp *sts)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc get ts\n");
+
+        ptp_read_system_prets(sts);
+        ret = _rtl8125_phy_phc_gettime(tp, ts64);
+        ptp_read_system_postts(sts);
+
+        return ret;
+}
+#else
+static int rtl8125_phy_phc_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts64)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc get ts\n");
+
+        ret = _rtl8125_phy_phc_gettime(tp, ts64);
+
+        return ret;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0) */
+
+static int rtl8125_mac_phc_settime(struct ptp_clock_info *ptp,
+                                   const struct timespec64 *ts64)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc set ts\n");
+
+        rtnl_lock();
+        ret = _rtl8125_mac_phc_settime(tp, ts64);
+        rtnl_unlock();
+
+        return ret;
+}
+
+static int rtl8125_phy_phc_settime(struct ptp_clock_info *ptp,
+                                   const struct timespec64 *ts64)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc set ts\n");
+
+        ret = _rtl8125_phy_phc_settime(tp, ts64);
+
+        return ret;
+}
+
+static int rtl8125_mac_phc_enable(struct ptp_clock_info *ptp,
+                                  struct ptp_clock_request *rq, int on)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        u16 ptp_ctrl;
+
+        //netif_info(tp, drv, tp->dev, "phc enable type %x on %d\n", rq->type, on);
+
+        switch (rq->type) {
+        case PTP_CLK_REQ_PPS:
+                rtnl_lock();
+                ptp_ctrl = RTL_R16(tp, PTP_CTRL_8125);
+                ptp_ctrl &= ~BIT_15;
+                if (on)
+                        ptp_ctrl |= BIT_14;
+                else
+                        ptp_ctrl &= ~BIT_14;
+                RTL_W16(tp, PTP_CTRL_8125, ptp_ctrl);
+                rtnl_unlock();
+                return 0;
+        default:
+                return -EOPNOTSUPP;
+        }
+}
+
+static int rtl8125_phy_phc_enable(struct ptp_clock_info *ptp,
+                                  struct ptp_clock_request *rq, int on)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        unsigned long flags;
+        u16 phy_ocp_data;
+
+        switch (rq->type) {
+        case PTP_CLK_REQ_PPS:
+                rtnl_lock();
+                if (on) {
+                        tp->pps_enable = 1;
+                        rtl8125_mac_ocp_write(tp, 0xDC00, rtl8125_mac_ocp_read(tp, 0xDC00) & ~BIT_6);
+                        rtl8125_mac_ocp_write(tp, 0xDC60, rtl8125_mac_ocp_read(tp, 0xDC60) | BIT_6);
+
+                        r8125_spin_lock(&tp->phy_lock, flags);
+
+                        /* Set periodic pulse 1pps */
+                        /* E432[8:0] = 0x017d */
+                        phy_ocp_data = rtl8125_mdio_direct_read_phy_ocp(tp, 0xE432);
+                        phy_ocp_data &= 0xFE00;
+                        phy_ocp_data |= 0x017d;
+                        rtl8125_mdio_direct_write_phy_ocp(tp, 0xE432, phy_ocp_data);
+
+                        rtl8125_mdio_direct_write_phy_ocp(tp, 0xE434, 0x7840);
+
+                        /* E436[8:0] = 0xbe */
+                        phy_ocp_data = rtl8125_mdio_direct_read_phy_ocp(tp, 0xE436);
+                        phy_ocp_data &= 0xFE00;
+                        phy_ocp_data |= 0xbe;
+                        rtl8125_mdio_direct_write_phy_ocp(tp, 0xE436, phy_ocp_data);
+
+                        rtl8125_mdio_direct_write_phy_ocp(tp, 0xE438, 0xbc20);
+
+                        r8125_spin_unlock(&tp->phy_lock, flags);
+
+                        /* start hrtimer */
+                        hrtimer_start(&tp->pps_timer, 1000000000, HRTIMER_MODE_REL);
+                } else
+                        tp->pps_enable = 0;
+                rtnl_unlock();
+                return 0;
+        default:
+                return -EOPNOTSUPP;
+        }
+}
+
+static void rtl8125_phy_ptp_enable_config(struct rtl8125_private *tp)
+{
+        u16 ptp_ctrl;
+
+        if (tp->syncE_en)
+                rtl8125_set_eth_phy_ocp_bit(tp, PTP_SYNCE_CTL, BIT_0);
+        else
+                rtl8125_clear_eth_phy_ocp_bit(tp, PTP_SYNCE_CTL, BIT_0);
+
+        ptp_ctrl = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 | BIT_12;
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_CTL, ptp_ctrl);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA640, BIT_15);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,11,0)
+int rtl8125_get_ts_info(struct net_device *netdev,
+                        struct ethtool_ts_info *info)
+#else
+int rtl8125_get_ts_info(struct net_device *netdev,
+                        struct kernel_ethtool_ts_info *info)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(6,11,0) */
+{
+        struct rtl8125_private *tp = netdev_priv(netdev);
+
+        /* we always support timestamping disabled */
+        info->rx_filters = BIT(HWTSTAMP_FILTER_NONE);
+
+        if (tp->HwSuppPtpVer == 0)
+                return ethtool_op_get_ts_info(netdev, info);
+
+        info->so_timestamping =  SOF_TIMESTAMPING_TX_SOFTWARE |
+                                 SOF_TIMESTAMPING_RX_SOFTWARE |
+                                 SOF_TIMESTAMPING_SOFTWARE |
+                                 SOF_TIMESTAMPING_TX_HARDWARE |
+                                 SOF_TIMESTAMPING_RX_HARDWARE |
+                                 SOF_TIMESTAMPING_RAW_HARDWARE;
+
+        if (tp->ptp_clock)
+                info->phc_index = ptp_clock_index(tp->ptp_clock);
+        else
+                info->phc_index = -1;
+
+        info->tx_types = BIT(HWTSTAMP_TX_OFF) | BIT(HWTSTAMP_TX_ON);
+
+        info->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_EVENT) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_SYNC) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ);
+
+        return 0;
+}
+
+static const struct ptp_clock_info rtl8125_mac_ptp_clock_info = {
+        .owner      = THIS_MODULE,
+        .n_alarm    = 0,
+        .n_ext_ts   = 0,
+        .n_per_out  = 0,
+        .n_pins     = 0,
+        .pps        = 1,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+        .adjfine   = rtl8125_mac_ptp_adjfine,
+#else
+        .adjfreq    = rtl8125_mac_phc_adjfreq,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0) */
+        .adjtime    = rtl8125_mac_phc_adjtime,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+        .gettimex64  = rtl8125_mac_phc_gettime,
+#else
+        .gettime64  = rtl8125_mac_phc_gettime,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0) */
+        .settime64  = rtl8125_mac_phc_settime,
+        .enable     = rtl8125_mac_phc_enable,
+};
+
+static const struct ptp_clock_info rtl8125_phy_ptp_clock_info = {
+        .owner      = THIS_MODULE,
+        .n_alarm    = 0,
+        .n_ext_ts   = 0,
+        .n_per_out  = 0,
+        .n_pins     = 0,
+        .pps        = 1,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+        .adjfine   = rtl8125_phy_ptp_adjfine,
+#else
+        .adjfreq    = rtl8125_phy_phc_adjfreq,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0) */
+        .adjtime    = rtl8125_phy_phc_adjtime,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+        .gettimex64 = rtl8125_phy_phc_gettime,
+#else
+        .gettime64  = rtl8125_phy_phc_gettime,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0) */
+
+        .settime64  = rtl8125_phy_phc_settime,
+        .enable     = rtl8125_phy_phc_enable,
+};
+
+static void rtl8125_mac_ptp_egresstime(struct rtl8125_private *tp, struct timespec64 *ts64, u32 regnum)
+{
+        /* nanoseconds */
+        //[29:0]
+        ts64->tv_nsec = rtl8125_mac_ocp_read(tp, PTP_EGRESS_TIME_BASE_NS_8125 + regnum * 16 + 2);
+        ts64->tv_nsec <<= 16;
+        ts64->tv_nsec |= rtl8125_mac_ocp_read(tp, PTP_EGRESS_TIME_BASE_NS_8125 + regnum * 16);
+        ts64->tv_nsec &= 0x3fffffff;
+
+        /* seconds */
+        //[47:0]
+        ts64->tv_sec = rtl8125_mac_ocp_read(tp, PTP_EGRESS_TIME_BASE_S_8125 + regnum * 16 + 4);
+        ts64->tv_sec <<= 16;
+        ts64->tv_sec |= rtl8125_mac_ocp_read(tp, PTP_EGRESS_TIME_BASE_S_8125 + regnum * 16 + 2);
+        ts64->tv_sec <<= 16;
+        ts64->tv_sec |= rtl8125_mac_ocp_read(tp, PTP_EGRESS_TIME_BASE_S_8125 + regnum * 16);
+        ts64->tv_sec &= 0x0000ffffffffffff;
+}
+
+static u16 rtl8125_phy_ptp_get_tx_msgtype(struct rtl8125_private *tp)
+{
+        u16 tx_ts_ready = 0;
+        int i;
+
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                tx_ts_ready = rtl8125_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_STA) & 0xF000;
+                if (tx_ts_ready)
+                        break;
+        }
+
+        switch (tx_ts_ready) {
+        case TX_TS_PDLYRSP_RDY:
+                return PTP_MSGTYPE_PDELAY_RESP;
+        case TX_TS_PDLYREQ_RDY:
+                return PTP_MSGTYPE_PDELAY_REQ;
+        case TX_TS_DLYREQ_RDY:
+                return PTP_MSGTYPE_DELAY_REQ;
+        case TX_TS_SYNC_RDY:
+        default:
+                return PTP_MSGTYPE_SYNC;
+        }
+}
+
+/*
+static u16 rtl8125_phy_ptp_get_rx_msgtype(struct rtl8125_private *tp)
+{
+        u16 rx_ts_ready = 0;
+        int i;
+
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                rx_ts_ready = rtl8125_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_STA) & 0x0F00;
+                if (rx_ts_ready)
+                        break;
+        }
+
+        switch (rx_ts_ready) {
+        case RX_TS_PDLYRSP_RDY:
+                return PTP_MSGTYPE_PDELAY_RESP;
+        case RX_TS_PDLYREQ_RDY:
+                return PTP_MSGTYPE_PDELAY_REQ;
+        case RX_TS_DLYREQ_RDY:
+                return PTP_MSGTYPE_DELAY_REQ;
+        case RX_TS_SYNC_RDY:
+        default:
+                return PTP_MSGTYPE_SYNC;
+        }
+}
+*/
+
+static void rtl8125_wait_phy_trx_ts_ready(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++)
+                if (!(rtl8125_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_STA) & TRX_TS_RD))
+                        break;
+}
+
+static void rtl8125_set_phy_trx_ts_cmd(struct rtl8125_private *tp, u16 cmd)
+{
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              PTP_TRX_TS_STA,
+                                              TRXTS_SEL | BIT_3 | BIT_2,
+                                              TRX_TS_RD | cmd);
+
+        rtl8125_wait_phy_trx_ts_ready(tp);
+}
+
+static void rtl8125_phy_ptp_egresstime(struct rtl8125_private *tp, struct timespec64 *ts64)
+{
+        u16 msgtype;
+
+        msgtype = rtl8125_phy_ptp_get_tx_msgtype(tp);
+
+        msgtype <<= 2;
+
+        rtl8125_set_phy_trx_ts_cmd(tp, (msgtype | BIT_4));
+
+        /* nanoseconds */
+        //Ns[29:16] E448[13:0]
+        ts64->tv_nsec = rtl8125_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_NS_HI) & 0x3fff;
+        ts64->tv_nsec <<= 16;
+        //Ns[15:0]  E446[15:0]
+        ts64->tv_nsec |= rtl8125_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_NS_LO);
+
+        /* seconds */
+        //S[47:32] E44E[15:0]
+        ts64->tv_sec = rtl8125_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_S_HI);
+        ts64->tv_sec <<= 16;
+        //S[31:16] E44C[15:0]
+        ts64->tv_sec |= rtl8125_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_S_MI);
+        ts64->tv_sec <<= 16;
+        //S[15:0]  E44A[15:0]
+        ts64->tv_sec |= rtl8125_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_S_LO);
+}
+static void rtl8125_phy_ptp_ingresstime(struct rtl8125_private *tp, struct timespec64 *ts64, u8 type)
+{
+        u16 msgtype;
+
+        switch (type) {
+        case PTP_MSGTYPE_PDELAY_RESP:
+        case PTP_MSGTYPE_PDELAY_REQ:
+        case PTP_MSGTYPE_DELAY_REQ:
+        case PTP_MSGTYPE_SYNC:
+                msgtype = type << 2;
+                break;
+        default:
+                return;
+        }
+
+        rtl8125_set_phy_trx_ts_cmd(tp, (TRXTS_SEL | msgtype | BIT_4));
+
+        /* nanoseconds */
+        //Ns[29:16] E448[13:0]
+        ts64->tv_nsec = rtl8125_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_NS_HI) & 0x3fff;
+        ts64->tv_nsec <<= 16;
+        //Ns[15:0]  E446[15:0]
+        ts64->tv_nsec |= rtl8125_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_NS_LO);
+
+        /* seconds */
+        //S[47:32] E44E[15:0]
+        ts64->tv_sec = rtl8125_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_S_HI);
+        ts64->tv_sec <<= 16;
+        //S[31:16] E44C[15:0]
+        ts64->tv_sec |= rtl8125_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_S_MI);
+        ts64->tv_sec <<= 16;
+        //S[15:0]  E44A[15:0]
+        ts64->tv_sec |= rtl8125_mdio_direct_read_phy_ocp(tp, PTP_TRX_TS_S_LO);
+}
+
+static void rtl8125_mac_ptp_tx_hwtstamp(struct rtl8125_private *tp)
+{
+        struct sk_buff *skb = tp->ptp_tx_skb;
+        struct skb_shared_hwtstamps shhwtstamps = {0};
+        struct timespec64 ts64;
+        u32 regnum;
+
+        RTL_W8(tp, PTP_ISR_8125, PTP_ISR_TOK | PTP_ISR_TER);
+
+        //IO 0x2302 bit 10~11 WR_PTR
+        regnum = RTL_R16(tp, 0x2032) & 0x0C00;
+        regnum >>= 10;
+        regnum = (regnum + 3) % 4;
+
+        rtnl_lock();
+        rtl8125_mac_ptp_egresstime(tp, &ts64, regnum);
+        rtnl_unlock();
+
+        /* Upper 32 bits contain s, lower 32 bits contain ns. */
+        shhwtstamps.hwtstamp = ktime_set(ts64.tv_sec,
+                                         ts64.tv_nsec);
+
+        /* Clear the lock early before calling skb_tstamp_tx so that
+         * applications are not woken up before the lock bit is clear. We use
+         * a copy of the skb pointer to ensure other threads can't change it
+         * while we're notifying the stack.
+         */
+        tp->ptp_tx_skb = NULL;
+        clear_bit_unlock(__RTL8125_PTP_TX_IN_PROGRESS, &tp->state);
+
+        /* Notify the stack and free the skb after we've unlocked */
+        skb_tstamp_tx(skb, &shhwtstamps);
+        dev_kfree_skb_any(skb);
+}
+
+static void rtl8125_phy_ptp_tx_hwtstamp(struct rtl8125_private *tp)
+{
+        struct sk_buff *skb = tp->ptp_tx_skb;
+        struct skb_shared_hwtstamps shhwtstamps = { 0 };
+        struct timespec64 ts64;
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, PTP_INSR, TX_TX_INTR);
+
+        rtl8125_phy_ptp_egresstime(tp, &ts64);
+
+        /* Upper 32 bits contain s, lower 32 bits contain ns. */
+        shhwtstamps.hwtstamp = ktime_set(ts64.tv_sec,
+                                         ts64.tv_nsec);
+
+        /* Clear the lock early before calling skb_tstamp_tx so that
+         * applications are not woken up before the lock bit is clear. We use
+         * a copy of the skb pointer to ensure other threads can't change it
+         * while we're notifying the stack.
+         */
+        tp->ptp_tx_skb = NULL;
+        clear_bit_unlock(__RTL8125_PTP_TX_IN_PROGRESS, &tp->state);
+
+        /* Notify the stack and free the skb after we've unlocked */
+        skb_tstamp_tx(skb, &shhwtstamps);
+        dev_kfree_skb_any(skb);
+}
+
+#define RTL8125_PTP_TX_TIMEOUT      (HZ * 15)
+static void rtl8125_mac_ptp_tx_work(struct work_struct *work)
+{
+        struct rtl8125_private *tp = container_of(work, struct rtl8125_private,
+                                     ptp_tx_work);
+
+        if (!tp->ptp_tx_skb)
+                return;
+
+        if (time_is_before_jiffies(tp->ptp_tx_start +
+                                   RTL8125_PTP_TX_TIMEOUT)) {
+                dev_kfree_skb_any(tp->ptp_tx_skb);
+                tp->ptp_tx_skb = NULL;
+                clear_bit_unlock(__RTL8125_PTP_TX_IN_PROGRESS, &tp->state);
+                tp->tx_hwtstamp_timeouts++;
+                /* Clear the tx valid bit in TSYNCTXCTL register to enable
+                 * interrupt
+                 */
+                RTL_W8(tp, PTP_ISR_8125, PTP_ISR_TOK | PTP_ISR_TER);
+                return;
+        }
+
+        if (RTL_R8(tp, PTP_ISR_8125) & (PTP_ISR_TOK))
+                rtl8125_mac_ptp_tx_hwtstamp(tp);
+        else
+                /* reschedule to check later */
+                schedule_work(&tp->ptp_tx_work);
+}
+
+static void rtl8125_phy_ptp_tx_work(struct work_struct *work)
+{
+        struct rtl8125_private *tp = container_of(work, struct rtl8125_private,
+                                     ptp_tx_work);
+        unsigned long flags;
+        bool tx_intr;
+
+        if (!tp->ptp_tx_skb)
+                return;
+
+        if (time_is_before_jiffies(tp->ptp_tx_start +
+                                   RTL8125_PTP_TX_TIMEOUT)) {
+                dev_kfree_skb_any(tp->ptp_tx_skb);
+                tp->ptp_tx_skb = NULL;
+                clear_bit_unlock(__RTL8125_PTP_TX_IN_PROGRESS, &tp->state);
+                tp->tx_hwtstamp_timeouts++;
+                /* Clear the tx valid bit in TSYNCTXCTL register to enable
+                 * interrupt
+                 */
+                r8125_spin_lock(&tp->phy_lock, flags);
+                rtl8125_mdio_direct_write_phy_ocp(tp, PTP_INSR, TX_TX_INTR);
+                r8125_spin_unlock(&tp->phy_lock, flags);
+                return;
+        }
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+        if (rtl8125_mdio_direct_read_phy_ocp(tp, PTP_INSR) & TX_TX_INTR) {
+                tx_intr = true;
+                rtl8125_phy_ptp_tx_hwtstamp(tp);
+        } else {
+                tx_intr = false;
+        }
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        if (!tx_intr) {
+                /* reschedule to check later */
+                schedule_work(&tp->ptp_tx_work);
+        }
+}
+
+static int rtl8125_mac_hwtstamp_enable(struct rtl8125_private *tp, bool enable)
+{
+        RTL_W16(tp, PTP_CTRL_8125, 0);
+        if (enable) {
+                u16 ptp_ctrl;
+                struct timespec64 ts64;
+
+                //clear ptp isr
+                RTL_W8(tp, PTP_ISR_8125, 0xff);
+                //ptp source 0:gphy 1:mac
+                rtl8125_mac_ocp_write(tp, 0xDC00, rtl8125_mac_ocp_read(tp, 0xDC00) | BIT_6);
+                //enable ptp
+                ptp_ctrl = (BIT_0 | BIT_3 | BIT_4 | BIT_6 | BIT_10 | BIT_12);
+                if (tp->ptp_master_mode)
+                        ptp_ctrl |= BIT_1;
+                RTL_W16(tp, PTP_CTRL_8125, ptp_ctrl);
+
+                //set system time
+                /*
+                if (ktime_to_timespec64_cond(ktime_get_real(), &ts64))
+                _rtl8125_mac_phc_settime(tp, timespec64_to_timespec(ts64));
+                */
+                ktime_get_real_ts64(&ts64);
+                _rtl8125_mac_phc_settime(tp, &ts64);
+        }
+
+        return 0;
+}
+
+static int rtl8125_phy_hwtstamp_enable(struct rtl8125_private *tp, bool enable)
+{
+        unsigned long flags;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        if (enable) {
+                //trx timestamp interrupt enable
+                rtl8125_set_eth_phy_ocp_bit(tp, PTP_INER, BIT_2 | BIT_3);
+
+                //set isr clear mode
+                rtl8125_set_eth_phy_ocp_bit(tp, PTP_GEN_CFG, BIT_0);
+
+                //clear ptp isr
+                rtl8125_mdio_direct_write_phy_ocp(tp, PTP_INSR, 0xFFFF);
+
+                //enable ptp
+                rtl8125_phy_ptp_enable_config(tp);
+
+                //rtl8125_set_phy_local_time(tp);
+        } else {
+                /* trx timestamp interrupt disable */
+                rtl8125_clear_eth_phy_ocp_bit(tp, PTP_INER, BIT_2 | BIT_3);
+
+                /* disable ptp */
+                rtl8125_clear_eth_phy_ocp_bit(tp, PTP_SYNCE_CTL, BIT_0);
+                rtl8125_clear_eth_phy_ocp_bit(tp, PTP_CTL, BIT_0);
+                rtl8125_set_eth_phy_ocp_bit(tp, 0xA640, BIT_15);
+        }
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        return 0;
+}
+
+void rtl8125_set_phy_local_time(struct rtl8125_private *tp)
+{
+        struct timespec64 ts64;
+        //set system time
+        ktime_get_real_ts64(&ts64);
+        _rtl8125_phy_phc_settime(tp, &ts64);
+}
+
+static long rtl8125_ptp_create_clock(struct rtl8125_private *tp)
+{
+        struct net_device *netdev = tp->dev;
+        long err;
+
+        if (!IS_ERR_OR_NULL(tp->ptp_clock))
+                return 0;
+
+        if (tp->HwSuppPtpVer == 0) {
+                tp->ptp_clock = NULL;
+                return -EOPNOTSUPP;
+        }
+
+        switch (tp->HwSuppPtpVer) {
+        case 1:
+                tp->ptp_clock_info = rtl8125_mac_ptp_clock_info;
+                tp->ptp_clock_info.max_adj = 119304647;
+                break;
+        case 3:
+                tp->ptp_clock_info = rtl8125_phy_ptp_clock_info;
+                tp->ptp_clock_info.max_adj = 488281;//0x1FFFFF * 10^9 / 2^32
+                break;
+        default:
+                break;
+        }
+
+        snprintf(tp->ptp_clock_info.name, sizeof(tp->ptp_clock_info.name),
+                 "%pm", tp->dev->dev_addr);
+        tp->ptp_clock = ptp_clock_register(&tp->ptp_clock_info, &tp->pci_dev->dev);
+        if (IS_ERR(tp->ptp_clock)) {
+                err = PTR_ERR(tp->ptp_clock);
+                tp->ptp_clock = NULL;
+                netif_err(tp, drv, tp->dev, "ptp_clock_register failed\n");
+                return err;
+        } else
+                netif_info(tp, drv, tp->dev, "registered PHC device on %s\n", netdev->name);
+
+        return 0;
+}
+
+void rtl8125_ptp_reset(struct rtl8125_private *tp)
+{
+        if (!tp->ptp_clock)
+                return;
+
+        netif_info(tp, drv, tp->dev, "reset PHC clock\n");
+
+        switch (tp->HwSuppPtpVer) {
+        case 1:
+                rtl8125_mac_hwtstamp_enable(tp, false);
+                break;
+        case 3:
+                rtl8125_phy_hwtstamp_enable(tp, false);
+                break;
+        default:
+                break;
+        }
+}
+
+static enum hrtimer_restart
+rtl8125_phy_hrtimer_for_pps(struct hrtimer *timer) {
+        struct rtl8125_private *tp = container_of(timer, struct rtl8125_private, pps_timer);
+        s64 pps_sec;
+        u16 tai_cfg;
+        int i;
+
+        if (tp->pps_enable)
+        {
+                switch (tp->HwSuppPtpVer) {
+                case 3:
+                        tai_cfg = BIT_8 | BIT_5 | BIT_1 | BIT_0;
+                        break;
+                default:
+                        break;
+                }
+
+                //Direct Read
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      PTP_CLK_CFG_8126,
+                                                      BIT_3 | BIT_2 | BIT_1,
+                                                      (PTP_CLKADJ_MODE_SET | DIRECT_READ));
+
+                for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                        udelay(R8125_CHANNEL_WAIT_TIME);
+
+                        if (!(rtl8125_mdio_direct_read_phy_ocp(tp, PTP_CLK_CFG_8126) & PTP_CLKADJ_MODE_SET))
+                                break;
+                }
+
+                pps_sec = rtl8125_mdio_direct_read_phy_ocp(tp, PTP_CFG_S_HI_8126);
+                pps_sec <<= 16;
+                pps_sec |= rtl8125_mdio_direct_read_phy_ocp(tp, PTP_CFG_S_MI_8126);
+                pps_sec <<= 16;
+                pps_sec |= rtl8125_mdio_direct_read_phy_ocp(tp, PTP_CFG_S_LO_8126);
+                pps_sec++;
+
+                //E42A[15:0]
+                rtl8125_mdio_direct_write_phy_ocp(tp, PTP_TAI_TS_S_LO, pps_sec & 0xffff);
+                //E42C[31:16]
+                rtl8125_mdio_direct_write_phy_ocp(tp, PTP_TAI_TS_S_HI, (pps_sec & 0xffff0000) >> 16);
+                //Periodic Tai start
+                rtl8125_mdio_direct_write_phy_ocp(tp, PTP_TAI_CFG, tai_cfg);
+
+                hrtimer_forward_now(&tp->pps_timer, 1000000000); //rekick
+                return HRTIMER_RESTART;
+        } else
+                return HRTIMER_NORESTART;
+}
+
+void rtl8125_ptp_init(struct rtl8125_private *tp)
+{
+        /* obtain a PTP device, or re-use an existing device */
+        if (rtl8125_ptp_create_clock(tp))
+                return;
+
+        /* we have a clock so we can initialize work now */
+        switch (tp->HwSuppPtpVer) {
+        case 1:
+                INIT_WORK(&tp->ptp_tx_work, rtl8125_mac_ptp_tx_work);
+                break;
+        case 3:
+                INIT_WORK(&tp->ptp_tx_work, rtl8125_phy_ptp_tx_work);
+                break;
+        default:
+                break;
+        }
+
+        /* init a hrtimer for pps */
+        switch (tp->HwSuppPtpVer) {
+        case 3:
+                tp->pps_enable = 0;
+                hrtimer_init(&tp->pps_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+                tp->pps_timer.function = rtl8125_phy_hrtimer_for_pps;
+                break;
+        default:
+                break;
+        }
+
+        /* reset the PTP related hardware bits */
+        rtl8125_ptp_reset(tp);
+
+        return;
+}
+
+void rtl8125_ptp_suspend(struct rtl8125_private *tp)
+{
+        if (!tp->ptp_clock)
+                return;
+
+        netif_info(tp, drv, tp->dev, "suspend PHC clock\n");
+
+        switch (tp->HwSuppPtpVer) {
+        case 1:
+                rtl8125_mac_hwtstamp_enable(tp, false);
+                break;
+        case 3:
+                rtl8125_phy_hwtstamp_enable(tp, false);
+                break;
+        default:
+                break;
+        }
+
+        /* ensure that we cancel any pending PTP Tx work item in progress */
+        cancel_work_sync(&tp->ptp_tx_work);
+
+        switch (tp->HwSuppPtpVer) {
+        case 3:
+                hrtimer_cancel(&tp->pps_timer);
+                break;
+        default:
+                break;
+        }
+}
+
+void rtl8125_ptp_stop(struct rtl8125_private *tp)
+{
+        struct net_device *netdev = tp->dev;
+
+        netif_info(tp, drv, tp->dev, "stop PHC clock\n");
+
+        /* first, suspend PTP activity */
+        rtl8125_ptp_suspend(tp);
+
+        /* disable the PTP clock device */
+        if (tp->ptp_clock) {
+                ptp_clock_unregister(tp->ptp_clock);
+                tp->ptp_clock = NULL;
+                netif_info(tp, drv, tp->dev, "removed PHC on %s\n",
+                           netdev->name);
+        }
+}
+
+static int rtl8125_set_tstamp(struct net_device *netdev, struct ifreq *ifr)
+{
+        struct rtl8125_private *tp = netdev_priv(netdev);
+        struct hwtstamp_config config;
+        bool hwtstamp = 0;
+
+        //netif_info(tp, drv, tp->dev, "ptp set ts\n");
+
+        if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+                return -EFAULT;
+
+        if (config.flags)
+                return -EINVAL;
+
+        switch (config.tx_type) {
+        case HWTSTAMP_TX_ON:
+                hwtstamp = 1;
+                break;
+        case HWTSTAMP_TX_OFF:
+                break;
+        case HWTSTAMP_TX_ONESTEP_SYNC:
+        default:
+                return -ERANGE;
+        }
+
+        switch (config.rx_filter) {
+        case HWTSTAMP_FILTER_PTP_V2_EVENT:
+        case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+        case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+        case HWTSTAMP_FILTER_PTP_V2_SYNC:
+        case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+        case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+        case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+        case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+        case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+                config.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;
+                hwtstamp = 1;
+                tp->flags |= RTL_FLAG_RX_HWTSTAMP_ENABLED;
+                break;
+        case HWTSTAMP_FILTER_NONE:
+                tp->flags &= ~RTL_FLAG_RX_HWTSTAMP_ENABLED;
+                break;
+        default:
+                tp->flags &= ~RTL_FLAG_RX_HWTSTAMP_ENABLED;
+                return -ERANGE;
+        }
+
+        if (tp->hwtstamp_config.tx_type != config.tx_type ||
+            tp->hwtstamp_config.rx_filter != config.rx_filter) {
+                tp->hwtstamp_config = config;
+
+                switch (tp->HwSuppPtpVer) {
+                case 1:
+                        rtl8125_mac_hwtstamp_enable(tp, hwtstamp);
+                        break;
+                case 3:
+                        rtl8125_phy_hwtstamp_enable(tp, hwtstamp);
+                        break;
+                default:
+                        break;
+                }
+        }
+
+        return copy_to_user(ifr->ifr_data, &config,
+                            sizeof(config)) ? -EFAULT : 0;
+}
+
+static int rtl8125_get_tstamp(struct net_device *netdev, struct ifreq *ifr)
+{
+        struct rtl8125_private *tp = netdev_priv(netdev);
+
+        //netif_info(tp, drv, tp->dev, "ptp get ts\n");
+
+        return copy_to_user(ifr->ifr_data, &tp->hwtstamp_config,
+                            sizeof(tp->hwtstamp_config)) ? -EFAULT : 0;
+}
+
+int rtl8125_ptp_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "ptp ioctl\n");
+
+        switch (cmd) {
+#ifdef ENABLE_PTP_SUPPORT
+        case SIOCSHWTSTAMP:
+                ret = rtl8125_set_tstamp(netdev, ifr);
+                break;
+        case SIOCGHWTSTAMP:
+                ret = rtl8125_get_tstamp(netdev, ifr);
+                break;
+#endif
+        default:
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        return ret;
+}
+
+void rtl8125_rx_mac_ptp_pktstamp(struct rtl8125_private *tp, struct sk_buff *skb,
+                                 struct RxDescV3 *descv3)
+{
+        time64_t tv_sec;
+        long tv_nsec;
+
+        tv_sec = le32_to_cpu(descv3->RxDescTimeStamp.TimeStampHigh) +
+                 ((u64)le32_to_cpu(descv3->RxDescPTPDDWord4.TimeStampHHigh) << 32);
+        tv_nsec = le32_to_cpu(descv3->RxDescTimeStamp.TimeStampLow);
+
+        skb_hwtstamps(skb)->hwtstamp = ktime_set(tv_sec, tv_nsec);
+}
+
+static void rtl8125_rx_phy_ptp_pktstamp(struct rtl8125_private *tp, struct sk_buff *skb, u8 type)
+{
+        struct timespec64 ts64;
+        unsigned long flags;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        rtl8125_phy_ptp_ingresstime(tp, &ts64, type);
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        skb_hwtstamps(skb)->hwtstamp = ktime_set(ts64.tv_sec, ts64.tv_nsec);
+
+        return;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0)
+static struct ptp_header *ptp_parse_header(struct sk_buff *skb, unsigned int type)
+{
+        u8 *ptr = skb_mac_header(skb);
+
+        if (type & PTP_CLASS_VLAN)
+                //ptr += VLAN_HLEN;
+                ptr += 4;
+
+        switch (type & PTP_CLASS_PMASK) {
+        case PTP_CLASS_IPV4:
+                ptr += IPV4_HLEN(ptr) + UDP_HLEN;
+                break;
+        case PTP_CLASS_IPV6:
+                ptr += IP6_HLEN + UDP_HLEN;
+                break;
+        case PTP_CLASS_L2:
+                break;
+        default:
+                return NULL;
+        }
+
+        ptr += ETH_HLEN;
+
+        /* Ensure that the entire header is present in this packet. */
+        if (ptr + sizeof(struct ptp_header) > skb->data + skb->len)
+                return NULL;
+
+        return (struct ptp_header *)ptr;
+}
+
+static inline u8 ptp_get_msgtype(const struct ptp_header *hdr,
+                                 unsigned int type)
+{
+        u8 msgtype;
+
+        if (unlikely(type & PTP_CLASS_V1)) {
+                /* msg type is located at the control field for ptp v1 */
+                msgtype = hdr->control;
+        } else {
+                msgtype = hdr->tsmt & 0x0f;
+        }
+
+        return msgtype;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0) */
+
+void rtl8125_rx_phy_ptp_timestamp(struct rtl8125_private *tp, struct sk_buff *skb)
+{
+        unsigned int ptp_class;
+        struct ptp_header *hdr;
+        u8 msgtype;
+
+        ptp_class = ptp_classify_raw(skb);
+        if (ptp_class == PTP_CLASS_NONE)
+                return;
+
+        skb_reset_mac_header(skb);
+        hdr = ptp_parse_header(skb, ptp_class);
+        if (unlikely(!hdr))
+                return;
+
+        msgtype = ptp_get_msgtype(hdr, ptp_class);
+        rtl8125_rx_phy_ptp_pktstamp(tp, skb, msgtype);
+
+        return;
+}
Index: drivers/net/ethernet/r8126-10.016.00/rtltool.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/rtltool.h b/drivers/net/ethernet/r8126-10.016.00/rtltool.h
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/rtltool.h	(date 1763109333415)
@@ -0,0 +1,89 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_RTLTOOL_H
+#define _LINUX_RTLTOOL_H
+
+#define SIOCRTLTOOL		SIOCDEVPRIVATE+1
+
+enum rtl_cmd {
+        RTLTOOL_READ_MAC=0,
+        RTLTOOL_WRITE_MAC,
+        RTLTOOL_READ_PHY,
+        RTLTOOL_WRITE_PHY,
+        RTLTOOL_READ_EPHY,
+        RTLTOOL_WRITE_EPHY,
+        RTLTOOL_READ_ERI,
+        RTLTOOL_WRITE_ERI,
+        RTLTOOL_READ_PCI,
+        RTLTOOL_WRITE_PCI,
+        RTLTOOL_READ_EEPROM,
+        RTLTOOL_WRITE_EEPROM,
+
+        RTL_READ_OOB_MAC,
+        RTL_WRITE_OOB_MAC,
+
+        RTL_ENABLE_PCI_DIAG,
+        RTL_DISABLE_PCI_DIAG,
+
+        RTL_READ_MAC_OCP,
+        RTL_WRITE_MAC_OCP,
+
+        RTL_DIRECT_READ_PHY_OCP,
+        RTL_DIRECT_WRITE_PHY_OCP,
+
+        RTL_READ_FIBER_PHY,
+        RTL_WRITE_FIBER_PHY,
+
+        RTLTOOL_INVALID
+};
+
+struct rtltool_cmd {
+        __u32	cmd;
+        __u32	offset;
+        __u32	len;
+        __u32	data;
+};
+
+enum mode_access {
+        MODE_NONE=0,
+        MODE_READ,
+        MODE_WRITE
+};
+
+#ifdef __KERNEL__
+int rtl8126_tool_ioctl(struct rtl8126_private *tp, struct ifreq *ifr);
+#endif
+
+#endif /* _LINUX_RTLTOOL_H */
Index: drivers/net/ethernet/r8126-10.016.00/r8126_rss.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/r8126_rss.h b/drivers/net/ethernet/r8126-10.016.00/r8126_rss.h
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/r8126_rss.h	(date 1763109333415)
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_R8126_RSS_H
+#define _LINUX_R8126_RSS_H
+
+#include <linux/netdevice.h>
+#include <linux/types.h>
+
+#define RTL8126_RSS_KEY_SIZE     40  /* size of RSS Hash Key in bytes */
+#define RTL8126_MAX_INDIRECTION_TABLE_ENTRIES 128
+
+enum rtl8126_rss_flag {
+        RTL_8125_RSS_FLAG_HASH_UDP_IPV4  = (1 << 0),
+        RTL_8125_RSS_FLAG_HASH_UDP_IPV6  = (1 << 1),
+};
+
+struct rtl8126_private;
+struct RxDesc;
+
+int rtl8126_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
+                      u32 *rule_locs);
+int rtl8126_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd);
+u32 rtl8126_get_rxfh_key_size(struct net_device *netdev);
+u32 rtl8126_rss_indir_size(struct net_device *netdev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,8,0)
+int rtl8126_get_rxfh(struct net_device *dev, struct ethtool_rxfh_param *rxfh);
+int rtl8126_set_rxfh(struct net_device *dev, struct ethtool_rxfh_param *rxfh,
+                     struct netlink_ext_ack *extack);
+#else
+int rtl8126_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
+                     u8 *hfunc);
+int rtl8126_set_rxfh(struct net_device *netdev, const u32 *indir,
+                     const u8 *key, const u8 hfunc);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,8,0) */
+void rtl8126_rx_hash(struct rtl8126_private *tp,
+                     struct RxDesc *desc,
+                     struct sk_buff *skb);
+void _rtl8126_config_rss(struct rtl8126_private *tp);
+void rtl8126_config_rss(struct rtl8126_private *tp);
+void rtl8126_init_rss(struct rtl8126_private *tp);
+u32 rtl8126_rss_indir_tbl_entries(struct rtl8126_private *tp);
+void rtl8126_disable_rss(struct rtl8126_private *tp);
+
+#endif /* _LINUX_R8126_RSS_H */
Index: drivers/net/ethernet/r8125-9.016.01/r8125_fiber.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/r8125_fiber.c b/drivers/net/ethernet/r8125-9.016.01/r8125_fiber.c
new file mode 100755
--- /dev/null	(date 1763113879453)
+++ b/drivers/net/ethernet/r8125-9.016.01/r8125_fiber.c	(date 1763113879453)
@@ -0,0 +1,464 @@
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+
+#include "r8125.h"
+#include "r8125_fiber.h"
+
+static void
+rtl8125_fiber_set_mdc_gpio_c45(struct rtl8125_private *tp, bool pu)
+{
+        if (pu)
+                rtl8125_set_mac_ocp_bit(tp, 0xDC52, BIT_7);
+        else
+                rtl8125_clear_mac_ocp_bit(tp, 0xDC52, BIT_7);
+
+        //RtPciCommittp);
+}
+
+static void
+rtl8125_fiber_set_mdc(struct rtl8125_private *tp, bool pu)
+{
+        rtl8125_fiber_set_mdc_gpio_c45(tp, pu);
+}
+
+static void
+rtl8125_fiber_set_mdcDownUp(struct rtl8125_private *tp)
+{
+        udelay(1);
+        rtl8125_fiber_set_mdc(tp, 0);
+        udelay(1);
+        rtl8125_fiber_set_mdc(tp, 1);
+}
+
+static void
+rtl8125_fiber_set_mdio_bit_gpio_c45(struct rtl8125_private *tp, bool pu)
+{
+        if (pu)
+                rtl8125_set_mac_ocp_bit(tp, 0xDC52, BIT_2);
+        else
+                rtl8125_clear_mac_ocp_bit(tp, 0xDC52, BIT_2);
+
+        //RtPciCommittp);
+
+        rtl8125_fiber_set_mdcDownUp(tp);
+}
+
+static void
+rtl8125_fiber_set_mdio_bit(struct rtl8125_private *tp, bool pu)
+{
+        rtl8125_fiber_set_mdio_bit_gpio_c45(tp, pu);
+}
+
+static u16
+rtl8125_fiber_get_mdio_bit_gpio_c45(struct rtl8125_private *tp)
+{
+        rtl8125_fiber_set_mdcDownUp(tp);
+
+        return !!(rtl8125_mac_ocp_read(tp, 0xDC58) & BIT(2));
+}
+
+static u16
+rtl8125_fiber_get_mdio_bit(struct rtl8125_private *tp)
+{
+        return rtl8125_fiber_get_mdio_bit_gpio_c45(tp);
+}
+
+static void
+rtl8125_fiber_shift_bit_in(struct rtl8125_private *tp, u32 val, int count)
+{
+        int i;
+
+        for (i = (count - 1); i >= 0; i--)
+                rtl8125_fiber_set_mdio_bit(tp, !!(val & BIT(i)));
+}
+
+static u16
+rtl8125_fiber_shift_bit_out(struct rtl8125_private *tp)
+{
+        u16 data = 0;
+        int i;
+
+        for (i = 15; i >= 0; i--)
+                data += (rtl8125_fiber_get_mdio_bit(tp) << i);
+
+        return data;
+}
+
+static void
+rtl8125_fiber_dir_gpio_c45(struct rtl8125_private *tp, bool output_mode)
+{
+        if (output_mode)
+                rtl8125_set_mac_ocp_bit(tp, 0xDC4C, BIT_2);
+        else
+                rtl8125_clear_mac_ocp_bit(tp, 0xDC4C, BIT_2);
+}
+
+static void
+rtl8125_fiber_dir(struct rtl8125_private *tp, bool output_mode)
+{
+        rtl8125_fiber_dir_gpio_c45(tp, output_mode);
+}
+
+//fiber
+#define R8125_FIBER_C22 (0)
+#define R8125_FIBER_C45 (1)
+
+// sfp opcodes
+#define R8125_FIBER_ST (1)
+#define R8125_FIBER_OP_W (1)
+#define R8125_FIBER_OP_R (2)
+#define R8125_FIBER_TA (2)
+
+// sfp C45 opcodes
+#define R8125_FIBER_MDIO_C45 (BIT(15))
+#define R8125_FIBER_C45_ST (R8125_FIBER_MDIO_C45 | 0)
+#define R8125_FIBER_C45_OP_ADDR (R8125_FIBER_MDIO_C45 | 0)
+#define R8125_FIBER_C45_OP_W (R8125_FIBER_MDIO_C45 | 1)
+#define R8125_FIBER_C45_OP_R (R8125_FIBER_MDIO_C45 | 3)
+
+static void
+rtl8125_fiber_cmd(struct rtl8125_private *tp, u32 cmd, u8 phy_addr,
+                  u32 reg)
+{
+        /* change to output mode */
+        rtl8125_fiber_dir(tp, 1);
+
+        /* preamble 32bit of 1 */
+        rtl8125_fiber_shift_bit_in(tp, UINT_MAX, 32);
+
+        /* start bit */
+        if (cmd & R8125_FIBER_MDIO_C45)
+                rtl8125_fiber_shift_bit_in(tp, R8125_FIBER_C45_ST, 2);
+        else
+                rtl8125_fiber_shift_bit_in(tp, R8125_FIBER_ST, 2);
+
+        /* opcode */
+        rtl8125_fiber_shift_bit_in(tp, cmd, 2);
+
+        /* phy address */
+        rtl8125_fiber_shift_bit_in(tp, phy_addr, 5);
+
+        /* phy reg */
+        rtl8125_fiber_shift_bit_in(tp, reg, 5);
+}
+
+static u8
+rtl8125_fiber_cmdAddr(struct rtl8125_private *tp, u8 phy_addr, u32 reg)
+{
+        u8 dev_addr = (reg >> 16) & 0x1F;
+        u16 addr = (u16)reg;
+
+        rtl8125_fiber_cmd(tp, R8125_FIBER_C45_OP_ADDR, phy_addr, dev_addr);
+
+        /* turn-around(TA) */
+        rtl8125_fiber_shift_bit_in(tp, R8125_FIBER_TA, 2);
+
+        rtl8125_fiber_shift_bit_in(tp, addr, 16);
+
+        rtl8125_fiber_dir(tp, 0);
+
+        rtl8125_fiber_get_mdio_bit(tp);
+
+        return dev_addr;
+}
+
+static void
+rtl8125_fiber_reset_gpio_c45(struct rtl8125_private *tp)
+{
+        rtl8125_set_mac_ocp_bit(tp, 0xDC4C, (BIT_7 | BIT_2));
+
+        /* init sfp interface */
+        rtl8125_clear_mac_ocp_bit(tp, 0xDC52, BIT_7);
+        rtl8125_set_mac_ocp_bit(tp, 0xDC52, BIT_2);
+}
+
+static void
+rtl8125_fiber_write_common(struct rtl8125_private *tp, u16 val)
+{
+        /* turn-around(TA) */
+        rtl8125_fiber_shift_bit_in(tp, R8125_FIBER_TA, 2);
+
+        /* write phy data */
+        rtl8125_fiber_shift_bit_in(tp, val, 16);
+
+        /* change to input mode */
+        rtl8125_fiber_dir(tp, 0);
+
+        rtl8125_fiber_get_mdio_bit(tp);
+}
+
+static void
+rtl8125_fiber_mdio_write_gpio_c45(
+        struct rtl8125_private *tp,
+        u32 reg,
+        u16 val,
+        u8 phy_addr)
+{
+        /* opcode write */
+        reg = rtl8125_fiber_cmdAddr(tp, phy_addr, reg);
+        rtl8125_fiber_cmd(tp, R8125_FIBER_C45_OP_W, phy_addr, reg);
+
+        rtl8125_fiber_write_common(tp, val);
+}
+
+static u16
+rtl8125_fiber_read_common(struct rtl8125_private *tp)
+{
+        u16 data = 0;
+
+        /* change to input mode */
+        rtl8125_fiber_dir(tp, 0);
+
+        /* TA 0 */
+        rtl8125_fiber_get_mdio_bit(tp);
+
+        /* read phy data */
+        data = rtl8125_fiber_shift_bit_out(tp);
+
+        rtl8125_fiber_get_mdio_bit(tp);
+
+        return data;
+}
+
+static u16
+rtl8125_fiber_mdio_read_gpio_c45(
+        struct rtl8125_private *tp,
+        u32 reg,
+        u8 phy_addr)
+{
+        reg = rtl8125_fiber_cmdAddr(tp, phy_addr, reg);
+        rtl8125_fiber_cmd(tp, R8125_FIBER_C45_OP_R, phy_addr, reg);
+
+        return rtl8125_fiber_read_common(tp);
+}
+
+void
+rtl8125_fiber_mdio_write(
+        struct rtl8125_private *tp,
+        u32 reg,
+        u16 val)
+{
+        switch(tp->HwFiberStat) {
+        case FIBER_STAT_CONNECT_GPO_C45:
+                return rtl8125_fiber_mdio_write_gpio_c45(tp, reg, val, 0);
+        default:
+                return;
+        }
+}
+
+u16
+rtl8125_fiber_mdio_read(
+        struct rtl8125_private *tp,
+        u32 reg)
+{
+        switch(tp->HwFiberStat) {
+        case FIBER_STAT_CONNECT_GPO_C45:
+                return rtl8125_fiber_mdio_read_gpio_c45(tp, reg, 0);
+        default:
+                return 0xffff;
+        }
+}
+
+static void
+rtl8125_fiber_clear_and_set_phy_bit(struct rtl8125_private *tp, u32 addr, u16 clearmask, u16 setmask)
+{
+        u16 PhyRegValue;
+
+        PhyRegValue = rtl8125_fiber_mdio_read(tp, addr);
+        PhyRegValue &= ~clearmask;
+        PhyRegValue |= setmask;
+        rtl8125_fiber_mdio_write(tp, addr, PhyRegValue);
+}
+
+static void
+rtl8125_fiber_clear_phy_bit(struct rtl8125_private *tp, u32 addr, u16 mask)
+{
+        rtl8125_fiber_clear_and_set_phy_bit(tp, addr, mask, 0);
+}
+
+static void
+rtl8125_fiber_set_phy_bit(struct rtl8125_private *tp, u32 addr, u16 mask)
+{
+        rtl8125_fiber_clear_and_set_phy_bit(tp, addr, 0, mask);
+}
+
+#define R8125_MAKE_C45_ADDR(_mmd, _addr) (_mmd << 16 | _addr)
+
+static void
+rtl8125_fiber_phy_reset_8221d(struct rtl8125_private *tp)
+{
+        u16 PhyRegValue;
+        u32 Timeout;
+
+        rtl8125_fiber_set_phy_bit(tp, R8125_MAKE_C45_ADDR(0x01, 0x00), BIT_15);
+
+        Timeout = 0;
+        do {
+                udelay(1000);
+
+                PhyRegValue = rtl8125_fiber_mdio_read(tp, R8125_MAKE_C45_ADDR(0x01, 0x00));
+
+                Timeout++;
+        } while ((PhyRegValue & BIT_15) && (Timeout < 20));
+}
+
+static void
+rtl8125_fiber_phy_reset(struct rtl8125_private *tp)
+{
+        switch (tp->HwFiberModeVer) {
+        case FIBER_MODE_RTL8125D_RTL8221D:
+                rtl8125_fiber_phy_reset_8221d(tp);
+                break;
+        }
+}
+
+static void
+rtl8125_fiber_set_rtl8221d_phy_mode(struct rtl8125_private *tp, u16 mode)
+{
+        mode &= 0x3f;
+
+        rtl8125_fiber_clear_phy_bit(tp, R8125_MAKE_C45_ADDR(30, 0x75F3), BIT_0);
+        rtl8125_fiber_clear_and_set_phy_bit(tp,
+                                            R8125_MAKE_C45_ADDR(30, 0x697A),
+                                            0x003F,
+                                            mode);
+}
+
+static void
+rtl8125_fiber_set_phy_mode(struct rtl8125_private *tp, u16 mode)
+{
+        switch (tp->HwFiberModeVer) {
+        case FIBER_MODE_RTL8125D_RTL8221D:
+                rtl8125_fiber_set_rtl8221d_phy_mode(tp, mode);
+                break;
+        default:
+                break;
+        }
+}
+
+static void
+rtl8125_hw_rtl8221d_phy_config(struct rtl8125_private *tp)
+{
+        rtl8125_fiber_reset_gpio_c45(tp);
+
+        rtl8125_fiber_set_phy_mode(tp, (tp->speed == SPEED_2500) ? 0x02 : 0x04);
+
+
+        rtl8125_fiber_clear_phy_bit(tp, R8125_MAKE_C45_ADDR(0x07, 0x3C), (BIT_2 | BIT_1));
+        rtl8125_fiber_clear_phy_bit(tp, R8125_MAKE_C45_ADDR(0x07, 0x3E), (BIT_1 | BIT_0));
+
+
+        rtl8125_fiber_phy_reset(tp);
+}
+
+void
+rtl8125_hw_fiber_phy_config(struct rtl8125_private *tp)
+{
+        switch (tp->HwFiberModeVer) {
+        case FIBER_MODE_RTL8125D_RTL8221D:
+                rtl8125_hw_rtl8221d_phy_config(tp);
+                break;
+        default:
+                break;
+        }
+}
+
+#define RTL8221D_PHY_ID_1 0x001C
+#define RTL8221D_PHY_ID_2 0xC849
+static u32
+rtl8125_fiber_get_connect_status_8221d(struct rtl8125_private *tp)
+{
+        int i;
+        int const checkcnt = 4;
+
+        rtl8125_fiber_reset_gpio_c45(tp);
+
+        for (i = 0; i < checkcnt; i++) {
+                if (RTL8221D_PHY_ID_1 != rtl8125_fiber_mdio_read_gpio_c45(tp, R8125_MAKE_C45_ADDR(0x01, 0x02), 0) ||
+                    RTL8221D_PHY_ID_2 != rtl8125_fiber_mdio_read_gpio_c45(tp, R8125_MAKE_C45_ADDR(0x01, 0x03), 0))
+                        return FIBER_STAT_DISCONNECT;
+        }
+
+        return FIBER_STAT_CONNECT_GPO_C45;
+}
+
+static u32
+rtl8125_fiber_get_connect_status(struct rtl8125_private *tp)
+{
+        switch (tp->HwFiberModeVer) {
+        case FIBER_MODE_RTL8125D_RTL8221D:
+                return rtl8125_fiber_get_connect_status_8221d(tp);
+        default:
+                return FIBER_STAT_NOT_CHECKED;
+        }
+}
+
+void
+rtl8125_check_fiber_mode_support(struct rtl8125_private *tp)
+{
+        switch(tp->mcfg) {
+        case CFG_METHOD_10:
+        case CFG_METHOD_11: {
+                u8 tmp = (u8)rtl8125_mac_ocp_read(tp, 0xD006);
+                if (tmp == 0x03)
+                        tp->HwFiberModeVer = FIBER_MODE_RTL8125D_RTL8221D;
+        }
+        break;
+        }
+
+        if (HW_FIBER_MODE_ENABLED(tp))
+                tp->HwFiberStat = rtl8125_fiber_get_connect_status(tp);
+}
+
+unsigned int
+rtl8125_fiber_link_ok(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 status;
+
+        switch (tp->HwFiberStat) {
+        case FIBER_STAT_CONNECT_GPO_C45:
+                status = rtl8125_fiber_mdio_read(tp, R8125_MAKE_C45_ADDR(30, 0x758D));
+                if (status != USHRT_MAX && status & BIT_1)
+                        return 1;
+                else
+                        return 0;
+                break;
+        default:
+                return 0;
+        }
+}
Index: drivers/net/ethernet/r8152-2.20.1/Makefile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8152-2.20.1/Makefile b/drivers/net/ethernet/r8152-2.20.1/Makefile
new file mode 100644
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8152-2.20.1/Makefile	(date 1763109333415)
@@ -0,0 +1,20 @@
+#
+#
+#
+
+CONFIG_CTAP_SHORT = ON
+
+obj-m	 := r8152.o
+#	ccflags-y += -DRTL8152_S5_WOL
+#	ccflags-y += -DRTL8152_DEBUG
+
+ifneq (,$(filter OFF off, $(CONFIG_CTAP_SHORT)))
+	ccflags-y += -DCONFIG_CTAP_SHORT_OFF
+endif
+
+ifeq (TRUE, $(shell test $(VERSION) -lt 5 && echo "TRUE" || \
+	test $(VERSION) -eq 5 && test $(PATCHLEVEL) -lt 12 && echo "TRUE"))
+	ccflags-y += -DLINUX_VERSION_MAJOR=$(VERSION)
+	ccflags-y += -DLINUX_VERSION_PATCHLEVEL=$(PATCHLEVEL)
+	ccflags-y += -DLINUX_VERSION_SUBLEVEL=$(SUBLEVEL)
+endif
Index: drivers/net/ethernet/r8152-2.20.1/50-usb-realtek-net.rules
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8152-2.20.1/50-usb-realtek-net.rules b/drivers/net/ethernet/r8152-2.20.1/50-usb-realtek-net.rules
new file mode 100644
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8152-2.20.1/50-usb-realtek-net.rules	(date 1763109333415)
@@ -0,0 +1,46 @@
+# This is used to change the default configuration of Realtek USB ethernet adapters
+
+ACTION!="add", GOTO="usb_realtek_net_end"
+SUBSYSTEM!="usb", GOTO="usb_realtek_net_end"
+ENV{DEVTYPE}!="usb_device", GOTO="usb_realtek_net_end"
+
+# Modify this to change the default value
+ENV{REALTEK_MODE1}="1"
+ENV{REALTEK_MODE2}="3"
+
+# Realtek
+ATTR{idVendor}=="0bda", ATTR{idProduct}=="815[2,3,5,6,7,a]", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="0bda", ATTR{idProduct}=="8053", ATTR{bcdDevice}=="e???", ATTR{bConfigurationValue}!="$env{REALTEK_MODE2}", ATTR{bConfigurationValue}="$env{REALTEK_MODE2}"
+
+# Samsung
+ATTR{idVendor}=="04e8", ATTR{idProduct}=="a101", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+
+# Lenovo
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="304f", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="3052", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="3054", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="3057", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="3062", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="3069", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="3082", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="3098", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="7205", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="720a", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="720b", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="720c", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="7214", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="721e", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="8153", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="a359", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+ATTR{idVendor}=="17ef", ATTR{idProduct}=="a387", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+
+# TP-LINK
+ATTR{idVendor}=="2357", ATTR{idProduct}=="0601", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+
+# Nvidia
+ATTR{idVendor}=="0955", ATTR{idProduct}=="09ff", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+
+# LINKSYS
+ATTR{idVendor}=="13b1", ATTR{idProduct}=="0041", ATTR{bConfigurationValue}!="$env{REALTEK_MODE1}", ATTR{bConfigurationValue}="$env{REALTEK_MODE1}"
+
+LABEL="usb_realtek_net_end"
Index: drivers/net/ethernet/r8152-2.20.1/compatibility.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8152-2.20.1/compatibility.h b/drivers/net/ethernet/r8152-2.20.1/compatibility.h
new file mode 100644
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8152-2.20.1/compatibility.h	(date 1763109333415)
@@ -0,0 +1,685 @@
+#ifndef LINUX_COMPATIBILITY_H
+#define LINUX_COMPATIBILITY_H
+
+/*
+ * Definition and macro
+ */
+
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/in.h>
+#include <linux/acpi.h>
+
+#if defined(RTL8152_S5_WOL) && defined(CONFIG_PM)
+#include <linux/reboot.h>
+#endif /* defined(RTL8152_S5_WOL) && defined(CONFIG_PM) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+	#include <linux/mdio.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0)
+	#include <uapi/linux/mdio.h>
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0) */
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,9,0)
+	#define ethtool_keee ethtool_eee
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,19,0)
+	#define TSO_LEGACY_MAX_SIZE		65536
+	#define netif_napi_add_weight		netif_napi_add
+	#define netif_set_tso_max_size		netif_set_gso_max_size
+	#define netif_set_tso_max_segs		netif_set_gso_max_segs
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,17,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,12,0)
+	#define PHY_MAC_INTERRUPT		PHY_IGNORE_INTERRUPT
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
+	#ifdef CONFIG_PM
+	#define pm_ptr(_ptr) (_ptr)
+	#else
+	#define pm_ptr(_ptr) NULL
+	#endif
+
+	#define from_tasklet(var, callback_tasklet, tasklet_fieldname)	\
+		container_of((struct tasklet_struct *)callback_tasklet, typeof(*var), tasklet_fieldname)
+
+	#define tasklet_setup(t, fun)	tasklet_init(t, fun, (unsigned long)t)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
+	/* Iterate through singly-linked GSO fragments of an skb. */
+	#define skb_list_walk_safe(first, skb, next_skb)                               \
+		for ((skb) = (first), (next_skb) = (skb) ? (skb)->next : NULL; (skb);  \
+		     (skb) = (next_skb), (next_skb) = (skb) ? (skb)->next : NULL)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)
+	#ifndef __has_attribute
+	# define __has_attribute(x)         0
+	#endif
+
+	#if __has_attribute(__fallthrough__)
+	# define fallthrough                    __attribute__((__fallthrough__))
+	#else
+	# define fallthrough                    do {} while (0)  /* fallthrough */
+	#endif
+
+	#define MDIO_EEE_2_5GT			0x0001  /* 2.5GT EEE cap */
+	#define MDIO_EEE_5GT			0x0002  /* 5GT EEE cap */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,2,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,1,0)
+	#define MDIO_AN_10GBT_CTRL_ADV2_5G	0x0080  /* Advertise 2.5GBASE-T */
+	#define MDIO_AN_10GBT_CTRL_ADV5G	0x0100  /* Advertise 5GBASE-T */
+	#define MDIO_AN_10GBT_STAT_LP2_5G	0x0020  /* LP is 2.5GBT capable */
+	#define MDIO_AN_10GBT_STAT_LP5G		0x0040  /* LP is 5GBT capable */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
+	#define SPEED_2500				2500
+	#define SPEED_5000				5000
+	#define SPEED_25000				25000
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+	#ifndef ETHTOOL_LINK_MODE_2500baseT_Full_BIT
+	#define ETHTOOL_LINK_MODE_2500baseT_Full_BIT	ETHTOOL_LINK_MODE_2500baseX_Full_BIT
+	#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0)
+	#define BMCR_SPEED10				0x0000
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+	#define NETIF_F_CSUM_MASK			NETIF_F_ALL_CSUM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,1,0)
+	#define IS_REACHABLE(option)			(defined(option) || \
+							 (defined(option##_MODULE) && defined(MODULE)))
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+	#define skb_vlan_tag_present(__skb)		vlan_tx_tag_present(__skb)
+	#define skb_vlan_tag_get(__skb)			vlan_tx_tag_get(__skb)
+	#define skb_vlan_tag_get_id(__skb)		vlan_tx_tag_get_id(__skb)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0)
+	#define napi_alloc_skb(napi, length)		netdev_alloc_skb_ip_align(netdev,length)
+	#define napi_complete_done(n, d)		napi_complete(n)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0)
+	#ifndef smp_mb__before_atomic
+	#define smp_mb__before_atomic()			smp_mb()
+	#endif
+
+	#ifndef smp_mb__after_atomic
+	#define smp_mb__after_atomic()			smp_mb()
+	#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+	#define IS_ERR_OR_NULL(ptr)			(!ptr)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
+	#define ether_addr_copy(dst, src)		memcpy(dst, src, ETH_ALEN)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
+	#define BIT(nr)					(1UL << (nr))
+	#define BIT_ULL(nr)				(1ULL << (nr))
+	#define BITS_PER_BYTE				8
+	#define reinit_completion(x)			((x)->done = 0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
+	#define DEVICE_ATTR_RW(_name) \
+		struct device_attribute dev_attr_##_name = __ATTR(_name, 0644, _name##_show, _name##_store)
+	#define DEVICE_ATTR_RO(_name) \
+		struct device_attribute dev_attr_##_name = __ATTR_RO(_name)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+	#define NETIF_F_HW_VLAN_CTAG_RX			NETIF_F_HW_VLAN_RX
+	#define NETIF_F_HW_VLAN_CTAG_TX			NETIF_F_HW_VLAN_TX
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0)
+	#define USB_DEVICE_INTERFACE_CLASS(vend, prod, cl) \
+		.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \
+			       USB_DEVICE_ID_MATCH_INT_CLASS, \
+		.idVendor = (vend), \
+		.idProduct = (prod), \
+		.bInterfaceClass = (cl)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+	#ifndef SPEED_UNKNOWN
+		#define SPEED_UNKNOWN		0
+	#endif
+
+	#ifndef DUPLEX_UNKNOWN
+		#define DUPLEX_UNKNOWN		0xff
+	#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+	#define eth_random_addr(addr)			random_ether_addr(addr)
+	#define usb_enable_lpm(udev)
+	#define MDIO_EEE_100TX				MDIO_AN_EEE_ADV_100TX	/* 100TX EEE cap */
+	#define MDIO_EEE_1000T				MDIO_AN_EEE_ADV_1000T	/* 1000T EEE cap */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+	#define ETH_MDIO_SUPPORTS_C22			MDIO_SUPPORTS_C22
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+	#define module_usb_driver(__driver) \
+	static int __init __driver##_init(void) \
+	{ \
+		return usb_register(&(__driver)); \
+	} \
+	module_init(__driver##_init); \
+	static void __exit __driver##_exit(void) \
+	{ \
+		usb_deregister(&(__driver)); \
+	} \
+	module_exit(__driver##_exit);
+
+	#define netdev_features_t			u32
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0)
+	#define PMSG_IS_AUTO(msg)	(((msg).event & PM_EVENT_AUTO) != 0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0)
+	#define ndo_set_rx_mode				ndo_set_multicast_list
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+	#define NETIF_F_RXCSUM				(1 << 29) /* Receive checksumming offload */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	#define MDIO_AN_EEE_ADV				60	/* EEE advertisement */
+	#define MDIO_AN_EEE_ADV_100TX			0x0002	/* Advertise 100TX EEE cap */
+	#define MDIO_AN_EEE_ADV_1000T			0x0004	/* Advertise 1000T EEE cap */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+	#define skb_checksum_none_assert(skb_ptr)	(skb_ptr)->ip_summed = CHECKSUM_NONE
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+	#define skb_tx_timestamp(skb)
+
+	#define queue_delayed_work(long_wq, work, delay)	schedule_delayed_work(work, delay)
+
+	#define work_busy(x)				0
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)
+	#define netdev_mc_count(netdev)			((netdev)->mc_count)
+	#define netdev_mc_empty(netdev)			(netdev_mc_count(netdev) == 0)
+
+	#define netif_printk(priv, type, level, netdev, fmt, args...)	\
+	do {								\
+		if (netif_msg_##type(priv))				\
+			printk(level "%s: " fmt,(netdev)->name , ##args); \
+	} while (0)
+
+	#define netif_emerg(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_EMERG, netdev, fmt, ##args)
+	#define netif_alert(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ALERT, netdev, fmt, ##args)
+	#define netif_crit(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_CRIT, netdev, fmt, ##args)
+	#define netif_err(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ERR, netdev, fmt, ##args)
+	#define netif_warn(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_WARNING, netdev, fmt, ##args)
+	#define netif_notice(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_NOTICE, netdev, fmt, ##args)
+	#define netif_info(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_INFO, (netdev), fmt, ##args)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	#define get_sset_count				get_stats_count
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	#define pm_request_resume(para)
+	#define pm_runtime_set_suspended(para)
+	#define pm_schedule_suspend(para1, para2)
+	#define pm_runtime_get_sync(para)
+	#define pm_runtime_put_sync(para)
+	#define pm_runtime_put_noidle(para)
+	#define pm_runtime_idle(para)
+	#define pm_runtime_set_active(para)
+	#define pm_runtime_enable(para)
+	#define pm_runtime_disable(para)
+	typedef int netdev_tx_t;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+	#define USB_SPEED_SUPER				(USB_SPEED_VARIABLE + 1)
+	#define MDIO_MMD_AN				7	/* Auto-Negotiation */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	#define napi_gro_receive(napi, skb)		netif_receive_skb(skb)
+	#define vlan_gro_receive(napi, grp, vlan_tci, skb) \
+		vlan_hwaccel_receive_skb(skb, grp, vlan_tci)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+	#define PM_EVENT_AUTO		0x0400
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+	struct napi_struct {
+		struct list_head	poll_list;
+		unsigned long		state;
+		int			weight;
+		int			(*poll)(struct napi_struct *, int);
+	#ifdef CONFIG_NETPOLL
+		spinlock_t		poll_lock;
+		int			poll_owner;
+		struct net_device	*dev;
+		struct list_head	dev_list;
+	#endif
+	};
+
+	#define napi_enable(napi_ptr)			netif_poll_enable(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define napi_disable(napi_ptr)			netif_poll_disable(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define napi_schedule(napi_ptr)			netif_rx_schedule(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define napi_complete(napi_ptr)			netif_rx_complete(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define netif_napi_add(ndev, napi_ptr, function, weight_t) \
+		ndev->poll = function; \
+		ndev->weight = weight_t;
+	typedef unsigned long				uintptr_t;
+	#define DMA_BIT_MASK(value) \
+		(value < 64 ? ((1ULL << value) - 1) : 0xFFFFFFFFFFFFFFFFULL)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	#define NETIF_F_IPV6_CSUM			16
+	#define cancel_delayed_work_sync		cancel_delayed_work
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	#define ip_hdr(skb_ptr)				(skb_ptr)->nh.iph
+	#define ipv6hdr(skb_ptr)			(skb_ptr)->nh.ipv6h
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+	#define vlan_group_set_device(vlgrp, vid, value) \
+		if (vlgrp) \
+			(vlgrp)->vlan_devices[vid] = value;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+	#define delayed_work				work_struct
+	#define INIT_DELAYED_WORK(a,b)			INIT_WORK(a,b,tp)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	#define CHECKSUM_PARTIAL			CHECKSUM_HW
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	#define skb_is_gso(skb_ptr)			skb_shinfo(skb_ptr)->tso_size
+	#define netdev_alloc_skb(dev, len)		dev_alloc_skb(len)
+	#define IRQF_SHARED				SA_SHIRQ
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+	#ifndef __LINUX_MUTEX_H
+	#define mutex					semaphore
+	#define mutex_lock				down
+	#define mutex_unlock				up
+	#define mutex_trylock				down_trylock
+	#define mutex_lock_interruptible		down_interruptible
+	#define mutex_init				init_MUTEX
+	#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+	#define ADVERTISED_Pause			(1 << 13)
+	#define ADVERTISED_Asym_Pause			(1 << 14)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
+	#define skb_header_cloned(skb)			skb_cloned(skb)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16) */
+	static inline struct sk_buff *skb_gso_segment(struct sk_buff *skb, int features)
+	{
+		return NULL;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18) */
+	static inline void *kmemdup(const void *src, size_t len, gfp_t gfp)
+	{
+		void *p;
+
+		p = kmalloc_track_caller(len, gfp);
+		if (p)
+			memcpy(p, src, len);
+		return p;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21) */
+	static inline void skb_copy_from_linear_data(const struct sk_buff *skb,
+						     void *to,
+						     const unsigned int len)
+	{
+		memcpy(to, skb->data, len);
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) */
+	static inline int skb_cow_head(struct sk_buff *skb, unsigned int headroom)
+	{
+		int delta = 0;
+
+		if (headroom > skb_headroom(skb))
+			delta = headroom - skb_headroom(skb);
+
+		if (delta || skb_header_cloned(skb))
+			return pskb_expand_head(skb, ALIGN(delta, NET_SKB_PAD),
+						0, GFP_ATOMIC);
+		return 0;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24) */
+	static inline void __list_splice2(const struct list_head *list,
+					  struct list_head *prev,
+					  struct list_head *next)
+	{
+		struct list_head *first = list->next;
+		struct list_head *last = list->prev;
+
+		first->prev = prev;
+		prev->next = first;
+
+		last->next = next;
+		next->prev = last;
+	}
+
+	static inline void list_splice_tail(struct list_head *list,
+					    struct list_head *head)
+	{
+		if (!list_empty(list))
+			__list_splice2(list, head->prev, head);
+	}
+
+	static inline void netif_napi_del(struct napi_struct *napi)
+	{
+	#ifdef CONFIG_NETPOLL
+		list_del(&napi->dev_list);
+	#endif
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27) */
+	static inline void __skb_queue_splice(const struct sk_buff_head *list,
+					      struct sk_buff *prev,
+					      struct sk_buff *next)
+	{
+		struct sk_buff *first = list->next;
+		struct sk_buff *last = list->prev;
+
+		first->prev = prev;
+		prev->next = first;
+
+		last->next = next;
+		next->prev = last;
+	}
+
+	static inline void skb_queue_splice(const struct sk_buff_head *list,
+					    struct sk_buff_head *head)
+	{
+		if (!skb_queue_empty(list)) {
+			__skb_queue_splice(list, (struct sk_buff *) head, head->next);
+			head->qlen += list->qlen;
+		}
+	}
+
+	static inline void __skb_queue_head_init(struct sk_buff_head *list)
+	{
+		list->prev = list->next = (struct sk_buff *)list;
+		list->qlen = 0;
+	}
+
+	static inline void skb_queue_splice_init(struct sk_buff_head *list,
+						 struct sk_buff_head *head)
+	{
+		if (!skb_queue_empty(list)) {
+			__skb_queue_splice(list, (struct sk_buff *) head, head->next);
+			head->qlen += list->qlen;
+			__skb_queue_head_init(list);
+		}
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28) */
+	static inline void usb_autopm_put_interface_async(struct usb_interface *intf)
+	{
+		struct usb_device *udev = interface_to_usbdev(intf);
+		int status = 0;
+
+		if (intf->condition == USB_INTERFACE_UNBOUND) {
+			status = -ENODEV;
+		} else {
+			udev->last_busy = jiffies;
+			--intf->pm_usage_cnt;
+			if (udev->autosuspend_disabled || udev->autosuspend_delay < 0)
+				status = -EPERM;
+		}
+	}
+
+	static inline int usb_autopm_get_interface_async(struct usb_interface *intf)
+	{
+		struct usb_device *udev = interface_to_usbdev(intf);
+		int status = 0;
+
+		if (intf->condition == USB_INTERFACE_UNBOUND)
+			status = -ENODEV;
+		else if (udev->autoresume_disabled)
+			status = -EPERM;
+		else
+			++intf->pm_usage_cnt;
+		return status;
+	}
+
+	static inline int eth_change_mtu(struct net_device *dev, int new_mtu)
+	{
+		if (new_mtu < 68 || new_mtu > ETH_DATA_LEN)
+			return -EINVAL;
+		dev->mtu = new_mtu;
+		return 0;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32) */
+	static inline
+	struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev,
+						  unsigned int length)
+	{
+		struct sk_buff *skb = netdev_alloc_skb(dev, length + NET_IP_ALIGN);
+
+		if (NET_IP_ALIGN && skb)
+			skb_reserve(skb, NET_IP_ALIGN);
+		return skb;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33) */
+	static inline int usb_enable_autosuspend(struct usb_device *udev)
+	{ return 0; }
+	static inline int usb_disable_autosuspend(struct usb_device *udev)
+	{ return 0; }
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34) */
+	static inline bool pci_dev_run_wake(struct pci_dev *dev)
+	{
+		return 1;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35) */
+	static inline void usleep_range(unsigned long min, unsigned long max)
+	{
+		unsigned long ms = min / 1000;
+
+		if (ms)
+			mdelay(ms);
+
+		udelay(min % 1000);
+	}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36) */
+	static inline __be16 vlan_get_protocol(const struct sk_buff *skb)
+	{
+		__be16 protocol = 0;
+
+		if (vlan_tx_tag_present(skb) ||
+		    skb->protocol != cpu_to_be16(ETH_P_8021Q))
+			protocol = skb->protocol;
+		else {
+			__be16 proto, *protop;
+			protop = skb_header_pointer(skb, offsetof(struct vlan_ethhdr,
+						    h_vlan_encapsulated_proto),
+						    sizeof(proto), &proto);
+			if (likely(protop))
+				protocol = *protop;
+		}
+
+		return protocol;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0) */
+	static inline struct page *skb_frag_page(const skb_frag_t *frag)
+	{
+		return frag->page;
+	}
+
+	static inline void *skb_frag_address(const skb_frag_t *frag)
+	{
+		return page_address(skb_frag_page(frag)) + frag->page_offset;
+	}
+
+	static inline unsigned int skb_frag_size(const skb_frag_t *frag)
+	{
+		return frag->size;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0) */
+	static inline void eth_hw_addr_random(struct net_device *dev)
+	{
+		random_ether_addr(dev->dev_addr);
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0) */
+	static inline __sum16 tcp_v6_check(int len,
+					   const struct in6_addr *saddr,
+					   const struct in6_addr *daddr,
+					   __wsum base)
+	{
+		return csum_ipv6_magic(saddr, daddr, len, IPPROTO_TCP, base);
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0) */
+	static inline bool usb_device_no_sg_constraint(struct usb_device *udev)
+	{
+		return 0;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0) */
+	static inline int skb_to_sgvec_nomark(struct sk_buff *skb,
+					      struct scatterlist *sg,
+					      int offset, int len)
+	{
+		int nsg = skb_to_sgvec(skb, sg, offset, len);
+
+		if (nsg <= 0)
+			return nsg;
+
+		sg_unmark_end(&sg[nsg - 1]);
+
+		return nsg;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,1,0) */
+	static inline int eth_platform_get_mac_address(struct device *dev, u8 *mac_addr)
+	{
+		return -EOPNOTSUPP;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0) */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,19,10) && \
+    !(LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,217) && LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0))
+	static inline void skb_mark_not_on_list(struct sk_buff *skb)
+	{
+		skb->next = NULL;
+	}
+#endif
+	static inline void linkmode_set_bit(int nr, volatile unsigned long *addr)
+	{
+		__set_bit(nr, addr);
+	}
+
+	static inline void linkmode_clear_bit(int nr, volatile unsigned long *addr)
+	{
+		__clear_bit(nr, addr);
+	}
+
+	static inline int linkmode_test_bit(int nr, volatile unsigned long *addr)
+	{
+		return test_bit(nr, addr);
+	}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0) */
+	static inline void linkmode_mod_bit(int nr, volatile unsigned long *addr,
+					    int set)
+	{
+		if (set)
+			linkmode_set_bit(nr, addr);
+		else
+			linkmode_clear_bit(nr, addr);
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,1,0) */
+//	static inline u16 pci_dev_id(struct pci_dev *dev)
+//	{
+//		return PCI_DEVID(dev->bus->number, dev->devfn);
+//	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,2,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0) */
+	static inline void tcp_v6_gso_csum_prep(struct sk_buff *skb)
+	{
+		struct ipv6hdr *ipv6h = ipv6_hdr(skb);
+		struct tcphdr *th = tcp_hdr(skb);
+
+		ipv6h->payload_len = 0;
+		th->check = ~tcp_v6_check(0, &ipv6h->saddr, &ipv6h->daddr, 0);
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0) */
+	static inline void fsleep(unsigned long usecs)
+	{
+		if (usecs <= 10)
+			udelay(usecs);
+		else if (usecs <= 20000)
+			usleep_range(usecs, 2 * usecs);
+		else
+			msleep(DIV_ROUND_UP(usecs, 1000));
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,12,0) */
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(5,10,188) || LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(5,4,251) || LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0)
+	#if LINUX_VERSION_MAJOR != 4 || LINUX_VERSION_PATCHLEVEL != 19 || LINUX_VERSION_SUBLEVEL < 291
+	static inline void eth_hw_addr_set(struct net_device *dev, const u8 *addr)
+	{
+		memcpy(dev->dev_addr, addr, 6);
+	}
+	#endif /* LINUX_VERSION_MAJOR != 4 || LINUX_VERSION_PATCHLEVEL != 19 || LINUX_VERSION_SUBLEVEL < 291 */
+	#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,4,251) || LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0) */
+	#endif /*LINUX_VERSION_CODE < KERNEL_VERSION(5,10,188) || LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
+	static inline void netif_set_gso_max_segs(struct net_device *dev,
+						  unsigned int segs)
+	{
+		/* dev->gso_max_segs is read locklessly from sk_setup_caps() */
+		WRITE_ONCE(dev->gso_max_segs, segs);
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,17,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,19,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(6,9,0) */
+
+#ifndef FALSE
+	#define TRUE	1
+	#define FALSE	0
+#endif
+
+enum rtl_cmd {
+	RTLTOOL_PLA_OCP_READ_DWORD = 0,
+	RTLTOOL_PLA_OCP_WRITE_DWORD,
+	RTLTOOL_USB_OCP_READ_DWORD,
+	RTLTOOL_USB_OCP_WRITE_DWORD,
+	RTLTOOL_PLA_OCP_READ,
+	RTLTOOL_PLA_OCP_WRITE,
+	RTLTOOL_USB_OCP_READ,
+	RTLTOOL_USB_OCP_WRITE,
+	RTLTOOL_USB_INFO,
+	RTL_ENABLE_USB_DIAG,
+	RTL_DISABLE_USB_DIAG,
+
+	RTLTOOL_INVALID
+};
+
+struct usb_device_info {
+	__u16		idVendor;
+	__u16		idProduct;
+	__u16		bcdDevice;
+	__u8		dev_addr[8];
+	char		devpath[16];
+};
+
+struct rtltool_cmd {
+	__u32	cmd;
+	__u32	offset;
+	__u32	byteen;
+	__u32	data;
+	void	*buf;
+	struct usb_device_info nic_info;
+	struct sockaddr ifru_addr;
+	struct sockaddr ifru_netmask;
+	struct sockaddr ifru_hwaddr;
+};
+
+#endif /* LINUX_COMPATIBILITY_H */
Index: drivers/net/ethernet/r8126-10.016.00/r8126_fiber.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/r8126_fiber.c b/drivers/net/ethernet/r8126-10.016.00/r8126_fiber.c
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/r8126_fiber.c	(date 1763109333415)
@@ -0,0 +1,466 @@
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+
+#include "r8126.h"
+#include "r8126_fiber.h"
+
+static void
+rtl8126_fiber_set_mdc_gpio_c45(struct rtl8126_private *tp, bool pu)
+{
+        if (pu)
+                rtl8126_set_mac_ocp_bit(tp, 0xDC52, BIT_7);
+        else
+                rtl8126_clear_mac_ocp_bit(tp, 0xDC52, BIT_7);
+
+        //RtPciCommittp);
+}
+
+static void
+rtl8126_fiber_set_mdc(struct rtl8126_private *tp, bool pu)
+{
+        rtl8126_fiber_set_mdc_gpio_c45(tp, pu);
+}
+
+static void
+rtl8126_fiber_set_mdcDownUp(struct rtl8126_private *tp)
+{
+        udelay(1);
+        rtl8126_fiber_set_mdc(tp, 0);
+        udelay(1);
+        rtl8126_fiber_set_mdc(tp, 1);
+}
+
+static void
+rtl8126_fiber_set_mdio_bit_gpio_c45(struct rtl8126_private *tp, bool pu)
+{
+        if (pu)
+                rtl8126_set_mac_ocp_bit(tp, 0xDC52, BIT_2);
+        else
+                rtl8126_clear_mac_ocp_bit(tp, 0xDC52, BIT_2);
+
+        //RtPciCommittp);
+
+        rtl8126_fiber_set_mdcDownUp(tp);
+}
+
+static void
+rtl8126_fiber_set_mdio_bit(struct rtl8126_private *tp, bool pu)
+{
+        rtl8126_fiber_set_mdio_bit_gpio_c45(tp, pu);
+}
+
+static u16
+rtl8126_fiber_get_mdio_bit_gpio_c45(struct rtl8126_private *tp)
+{
+        rtl8126_fiber_set_mdcDownUp(tp);
+
+        return !!(rtl8126_mac_ocp_read(tp, 0xDC58) & BIT(2));
+}
+
+static u16
+rtl8126_fiber_get_mdio_bit(struct rtl8126_private *tp)
+{
+        return rtl8126_fiber_get_mdio_bit_gpio_c45(tp);
+}
+
+static void
+rtl8126_fiber_shift_bit_in(struct rtl8126_private *tp, u32 val, int count)
+{
+        int i;
+
+        for (i = (count - 1); i >= 0; i--)
+                rtl8126_fiber_set_mdio_bit(tp, !!(val & BIT(i)));
+}
+
+static u16
+rtl8126_fiber_shift_bit_out(struct rtl8126_private *tp)
+{
+        u16 data = 0;
+        int i;
+
+        for (i = 15; i >= 0; i--)
+                data += (rtl8126_fiber_get_mdio_bit(tp) << i);
+
+        return data;
+}
+
+static void
+rtl8126_fiber_dir_gpio_c45(struct rtl8126_private *tp, bool output_mode)
+{
+        if (output_mode)
+                rtl8126_set_mac_ocp_bit(tp, 0xDC4C, BIT_2);
+        else
+                rtl8126_clear_mac_ocp_bit(tp, 0xDC4C, BIT_2);
+}
+
+static void
+rtl8126_fiber_dir(struct rtl8126_private *tp, bool output_mode)
+{
+        rtl8126_fiber_dir_gpio_c45(tp, output_mode);
+}
+
+//fiber
+#define R8126_FIBER_C22 (0)
+#define R8126_FIBER_C45 (1)
+
+// sfp opcodes
+#define R8126_FIBER_ST (1)
+#define R8126_FIBER_OP_W (1)
+#define R8126_FIBER_OP_R (2)
+#define R8126_FIBER_TA (2)
+
+// sfp C45 opcodes
+#define R8126_FIBER_MDIO_C45 (BIT(15))
+#define R8126_FIBER_C45_ST (R8126_FIBER_MDIO_C45 | 0)
+#define R8126_FIBER_C45_OP_ADDR (R8126_FIBER_MDIO_C45 | 0)
+#define R8126_FIBER_C45_OP_W (R8126_FIBER_MDIO_C45 | 1)
+#define R8126_FIBER_C45_OP_R (R8126_FIBER_MDIO_C45 | 3)
+
+static void
+rtl8126_fiber_cmd(struct rtl8126_private *tp, u32 cmd, u8 phy_addr,
+                  u32 reg)
+{
+        /* change to output mode */
+        rtl8126_fiber_dir(tp, 1);
+
+        /* preamble 32bit of 1 */
+        rtl8126_fiber_shift_bit_in(tp, UINT_MAX, 32);
+
+        /* start bit */
+        if (cmd & R8126_FIBER_MDIO_C45)
+                rtl8126_fiber_shift_bit_in(tp, R8126_FIBER_C45_ST, 2);
+        else
+                rtl8126_fiber_shift_bit_in(tp, R8126_FIBER_ST, 2);
+
+        /* opcode */
+        rtl8126_fiber_shift_bit_in(tp, cmd, 2);
+
+        /* phy address */
+        rtl8126_fiber_shift_bit_in(tp, phy_addr, 5);
+
+        /* phy reg */
+        rtl8126_fiber_shift_bit_in(tp, reg, 5);
+}
+
+static u8
+rtl8126_fiber_cmdAddr(struct rtl8126_private *tp, u8 phy_addr, u32 reg)
+{
+        u8 dev_addr = (reg >> 16) & 0x1F;
+        u16 addr = (u16)reg;
+
+        rtl8126_fiber_cmd(tp, R8126_FIBER_C45_OP_ADDR, phy_addr, dev_addr);
+
+        /* turn-around(TA) */
+        rtl8126_fiber_shift_bit_in(tp, R8126_FIBER_TA, 2);
+
+        rtl8126_fiber_shift_bit_in(tp, addr, 16);
+
+        rtl8126_fiber_dir(tp, 0);
+
+        rtl8126_fiber_get_mdio_bit(tp);
+
+        return dev_addr;
+}
+
+static void
+rtl8126_fiber_reset_gpio_c45(struct rtl8126_private *tp)
+{
+        rtl8126_set_mac_ocp_bit(tp, 0xDC4C, (BIT_7 | BIT_2));
+
+        /* init sfp interface */
+        rtl8126_clear_mac_ocp_bit(tp, 0xDC52, BIT_7);
+        rtl8126_set_mac_ocp_bit(tp, 0xDC52, BIT_2);
+}
+
+static void
+rtl8126_fiber_write_common(struct rtl8126_private *tp, u16 val)
+{
+        /* turn-around(TA) */
+        rtl8126_fiber_shift_bit_in(tp, R8126_FIBER_TA, 2);
+
+        /* write phy data */
+        rtl8126_fiber_shift_bit_in(tp, val, 16);
+
+        /* change to input mode */
+        rtl8126_fiber_dir(tp, 0);
+
+        rtl8126_fiber_get_mdio_bit(tp);
+}
+
+static void
+rtl8126_fiber_mdio_write_gpio_c45(
+        struct rtl8126_private *tp,
+        u32 reg,
+        u16 val,
+        u8 phy_addr)
+{
+        /* opcode write */
+        reg = rtl8126_fiber_cmdAddr(tp, phy_addr, reg);
+        rtl8126_fiber_cmd(tp, R8126_FIBER_C45_OP_W, phy_addr, reg);
+
+        rtl8126_fiber_write_common(tp, val);
+}
+
+static u16
+rtl8126_fiber_read_common(struct rtl8126_private *tp)
+{
+        u16 data = 0;
+
+        /* change to input mode */
+        rtl8126_fiber_dir(tp, 0);
+
+        /* TA 0 */
+        rtl8126_fiber_get_mdio_bit(tp);
+
+        /* read phy data */
+        data = rtl8126_fiber_shift_bit_out(tp);
+
+        rtl8126_fiber_get_mdio_bit(tp);
+
+        return data;
+}
+
+static u16
+rtl8126_fiber_mdio_read_gpio_c45(
+        struct rtl8126_private *tp,
+        u32 reg,
+        u8 phy_addr)
+{
+        reg = rtl8126_fiber_cmdAddr(tp, phy_addr, reg);
+        rtl8126_fiber_cmd(tp, R8126_FIBER_C45_OP_R, phy_addr, reg);
+
+        return rtl8126_fiber_read_common(tp);
+}
+
+void
+rtl8126_fiber_mdio_write(
+        struct rtl8126_private *tp,
+        u32 reg,
+        u16 val)
+{
+        switch(tp->HwFiberStat) {
+        case FIBER_STAT_CONNECT_GPO_C45:
+                return rtl8126_fiber_mdio_write_gpio_c45(tp, reg, val, 0);
+        default:
+                return;
+        }
+}
+
+u16
+rtl8126_fiber_mdio_read(
+        struct rtl8126_private *tp,
+        u32 reg)
+{
+        switch(tp->HwFiberStat) {
+        case FIBER_STAT_CONNECT_GPO_C45:
+                return rtl8126_fiber_mdio_read_gpio_c45(tp, reg, 0);
+        default:
+                return 0xffff;
+        }
+}
+
+static void
+rtl8126_fiber_clear_and_set_phy_bit(struct rtl8126_private *tp, u32 addr, u16 clearmask, u16 setmask)
+{
+        u16 PhyRegValue;
+
+        PhyRegValue = rtl8126_fiber_mdio_read(tp, addr);
+        PhyRegValue &= ~clearmask;
+        PhyRegValue |= setmask;
+        rtl8126_fiber_mdio_write(tp, addr, PhyRegValue);
+}
+
+static void
+rtl8126_fiber_clear_phy_bit(struct rtl8126_private *tp, u32 addr, u16 mask)
+{
+        rtl8126_fiber_clear_and_set_phy_bit(tp, addr, mask, 0);
+}
+
+static void
+rtl8126_fiber_set_phy_bit(struct rtl8126_private *tp, u32 addr, u16 mask)
+{
+        rtl8126_fiber_clear_and_set_phy_bit(tp, addr, 0, mask);
+}
+
+#define R8126_MAKE_C45_ADDR(_mmd, _addr) (_mmd << 16 | _addr)
+
+static void
+rtl8126_fiber_set_ra_8251b(struct rtl8126_private *tp)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+        u16 const svid = pdev->subsystem_vendor;
+
+        rtl8126_fiber_clear_and_set_phy_bit(tp,
+                                            R8126_MAKE_C45_ADDR(30, 0x6973),
+                                            0x00FF,
+                                            (svid == PCI_VENDOR_ID_DELL) ?
+                                            0x03 : 0x12);
+        rtl8126_fiber_clear_and_set_phy_bit(tp,
+                                            R8126_MAKE_C45_ADDR(30, 0x6974),
+                                            0x00FF,
+                                            0x0005);
+        rtl8126_fiber_clear_and_set_phy_bit(tp,
+                                            R8126_MAKE_C45_ADDR(30, 0x6975),
+                                            0x00FF,
+                                            0x0008);
+}
+
+static void
+rtl8126_fiber_set_ra(struct rtl8126_private *tp)
+{
+        switch (tp->HwFiberModeVer) {
+        case FIBER_MODE_RTL8126_RTL8251B:
+                rtl8126_fiber_set_ra_8251b(tp);
+                break;
+        }
+}
+
+static void
+rtl8126_fiber_phy_reset_8251b(struct rtl8126_private *tp)
+{
+        u16 PhyRegValue;
+        u32 Timeout;
+
+        rtl8126_fiber_set_phy_bit(tp, R8126_MAKE_C45_ADDR(0x01, 0x00), BIT_15);
+
+        Timeout = 0;
+        do {
+                udelay(1000);
+
+                PhyRegValue = rtl8126_fiber_mdio_read(tp, R8126_MAKE_C45_ADDR(0x01, 0x00));
+
+                Timeout++;
+        } while ((PhyRegValue & BIT_15) && (Timeout < 20));
+}
+
+static void
+rtl8126_fiber_phy_reset(struct rtl8126_private *tp)
+{
+        switch (tp->HwFiberModeVer) {
+        case FIBER_MODE_RTL8126_RTL8251B:
+                rtl8126_fiber_phy_reset_8251b(tp);
+                break;
+        }
+}
+
+static void
+rtl8126_hw_rtl8251b_phy_config(struct rtl8126_private *tp)
+{
+        rtl8126_fiber_reset_gpio_c45(tp);
+
+        rtl8126_fiber_set_ra(tp);
+
+        rtl8126_fiber_clear_phy_bit(tp, R8126_MAKE_C45_ADDR(0x07, 0x3C), (BIT_2 | BIT_1));
+        rtl8126_fiber_clear_phy_bit(tp, R8126_MAKE_C45_ADDR(0x07, 0x3E), (BIT_1 | BIT_0));
+
+        rtl8126_fiber_phy_reset(tp);
+}
+
+void
+rtl8126_hw_fiber_phy_config(struct rtl8126_private *tp)
+{
+        switch (tp->HwFiberModeVer) {
+        case FIBER_MODE_RTL8126_RTL8251B:
+                rtl8126_hw_rtl8251b_phy_config(tp);
+                break;
+        }
+}
+
+#define RTL8251B_PHY_ID_1 0x001C
+#define RTL8251B_PHY_ID_2 0xC868
+static u32
+rtl8126_fiber_get_connect_status_8251b(struct rtl8126_private *tp)
+{
+        int i;
+        int const checkcnt = 4;
+
+        rtl8126_fiber_reset_gpio_c45(tp);
+
+        for (i = 0; i < checkcnt; i++) {
+                if (RTL8251B_PHY_ID_1 != rtl8126_fiber_mdio_read_gpio_c45(tp, R8126_MAKE_C45_ADDR(0x01, 0x02), 0) ||
+                    RTL8251B_PHY_ID_2 != rtl8126_fiber_mdio_read_gpio_c45(tp, R8126_MAKE_C45_ADDR(0x01, 0x03), 0))
+                        return FIBER_STAT_DISCONNECT;
+        }
+
+        return FIBER_STAT_CONNECT_GPO_C45;
+}
+
+static u32
+rtl8126_fiber_get_connect_status(struct rtl8126_private *tp)
+{
+        switch (tp->HwFiberModeVer) {
+        case FIBER_MODE_RTL8126_RTL8251B:
+                return rtl8126_fiber_get_connect_status_8251b(tp);
+        default:
+                return FIBER_STAT_NOT_CHECKED;
+        }
+}
+
+void
+rtl8126_check_fiber_mode_support(struct rtl8126_private *tp)
+{
+        switch(tp->mcfg) {
+        case CFG_METHOD_3: {
+                u8 tmp = (u8)rtl8126_mac_ocp_read(tp, 0xD006);
+                if (tmp == 0x03)
+                        tp->HwFiberModeVer = FIBER_MODE_RTL8126_RTL8251B;
+        }
+        break;
+        }
+
+        if (HW_FIBER_MODE_ENABLED(tp))
+                tp->HwFiberStat = rtl8126_fiber_get_connect_status(tp);
+}
+
+unsigned int
+rtl8126_fiber_link_ok(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u16 status;
+
+        switch (tp->HwFiberStat) {
+        case FIBER_STAT_CONNECT_GPO_C45:
+                status = rtl8126_fiber_mdio_read(tp, R8126_MAKE_C45_ADDR(30, 0x758D));
+                if (status != USHRT_MAX && status & BIT_1)
+                        return 1;
+                else
+                        return 0;
+                break;
+        default:
+                return 0;
+        }
+}
Index: drivers/net/ethernet/r8152-2.20.1/r8152.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8152-2.20.1/r8152.c b/drivers/net/ethernet/r8152-2.20.1/r8152.c
new file mode 100644
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8152-2.20.1/r8152.c	(date 1763109333415)
@@ -0,0 +1,29775 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ *  Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ */
+
+#include <linux/signal.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/phy.h>
+#include <linux/usb.h>
+#include <linux/crc32.h>
+#include <linux/if_vlan.h>
+#include <linux/uaccess.h>
+#include <linux/list.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <net/ip6_checksum.h>
+#include <linux/usb/cdc.h>
+#include <linux/suspend.h>
+#include <linux/atomic.h>
+#include <linux/acpi.h>
+#include "compatibility.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,4,10)
+#include <net/gso.h>
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,4,10) */
+
+/* Version Information */
+#define DRIVER_SUFFIX
+#define DRIVER_VERSION "v2.20.1"DRIVER_SUFFIX" (2025/05/13)"
+#define DRIVER_AUTHOR "Realtek nic sw <nic_swsd@realtek.com>"
+#define DRIVER_DESC "Realtek RTL8152/RTL8153 Based USB Ethernet Adapters"
+#define MODULENAME "r8152"
+
+#define PATENTS		"This product is covered by one or more of the " \
+			"following patents:\n" \
+			"\t\tUS6,570,884, US6,115,776, and US6,327,625.\n"
+
+#define R8152_PHY_ID		32
+
+#define PLA_IDR			0xc000
+#define PLA_RCR			0xc010
+#define PLA_RCR1		0xc012
+#define PLA_RMS			0xc016
+#define PLA_RXFIFO_CTRL0	0xc0a0
+#define PLA_RXFIFO_FULL		0xc0a2
+#define PLA_RXFIFO_CTRL1	0xc0a4
+#define PLA_RX_FIFO_FULL	0xc0a6
+#define PLA_RXFIFO_CTRL2	0xc0a8
+#define PLA_RX_FIFO_EMPTY	0xc0aa
+#define PLA_DMY_REG0		0xc0b0
+#define PLA_FMC			0xc0b4
+#define PLA_CFG_WOL		0xc0b6
+#define PLA_TEREDO_CFG		0xc0bc
+#define PLA_TEREDO_WAKE_BASE	0xc0c4
+#define PLA_MAR			0xcd00
+#define PLA_BACKUP		0xd000
+#define PLA_BDC_CR		0xd1a0
+#define PLA_TEREDO_TIMER	0xd2cc
+#define PLA_REALWOW_TIMER	0xd2e8
+#define PLA_UPHY_TIMER		0xd388
+#define PLA_SUSPEND_FLAG	0xd38a
+#define PLA_INDICATE_FALG	0xd38c
+#define PLA_MACDBG_PRE		0xd38c	/* RTL_VER_04 only */
+#define PLA_MACDBG_POST		0xd38e	/* RTL_VER_04 only */
+#define PLA_EXTRA_STATUS	0xd398
+#define PLA_GPHY_CTRL		0xd3ae
+#define PLA_POL_GPIO_CTRL	0xdc6a
+#define PLA_EFUSE_DATA		0xdd00
+#define PLA_EFUSE_CMD		0xdd02
+#define PLA_LEDSEL		0xdd90
+#define PLA_LED_FEATURE		0xdd92
+#define PLA_PHYAR		0xde00
+#define PLA_BOOT_CTRL		0xe004
+#define PLA_LWAKE_CTRL_REG	0xe007
+#define PLA_GPHY_INTR_IMR	0xe022
+#define PLA_EEE_CR		0xe040
+#define PLA_EEE_TXTWSYS		0xe04c
+#define PLA_EEE_TXTWSYS_2P5G	0xe058
+#define PLA_EEEP_CR		0xe080
+#define PLA_MAC_PWR_CTRL	0xe0c0
+#define PLA_MAC_PWR_CTRL2	0xe0ca
+#define PLA_MAC_PWR_CTRL3	0xe0cc
+#define PLA_MAC_PWR_CTRL4	0xe0ce
+#define PLA_WDT6_CTRL		0xe428
+#define PLA_TCR0		0xe610
+#define PLA_TCR1		0xe612
+#define PLA_MTPS		0xe615
+#define PLA_TXFIFO_CTRL		0xe618
+#define PLA_TXFIFO_FULL		0xe61a
+#define PLA_RSTTALLY		0xe800
+#define PLA_CR			0xe813
+#define PLA_CRWECR		0xe81c
+#define PLA_CONFIG12		0xe81e	/* CONFIG1, CONFIG2 */
+#define PLA_CONFIG34		0xe820	/* CONFIG3, CONFIG4 */
+#define PLA_CONFIG5		0xe822
+#define PLA_PHY_PWR		0xe84c
+#define PLA_OOB_CTRL		0xe84f
+#define PLA_CPCR		0xe854
+#define PLA_MISC_0		0xe858
+#define PLA_MISC_1		0xe85a
+#define PLA_OCP_GPHY_BASE	0xe86c
+#define PLA_TALLYCNT		0xe890
+#define PLA_SFF_STS_7		0xe8de
+#define PLA_PHYSTATUS		0xe908
+#define PLA_CONFIG6		0xe90a /* CONFIG6 */
+#define PLA_USB_CFG		0xe952
+#define PLA_BP_BA		0xfc26
+#define PLA_BP_0		0xfc28
+#define PLA_BP_1		0xfc2a
+#define PLA_BP_2		0xfc2c
+#define PLA_BP_3		0xfc2e
+#define PLA_BP_4		0xfc30
+#define PLA_BP_5		0xfc32
+#define PLA_BP_6		0xfc34
+#define PLA_BP_7		0xfc36
+#define PLA_BP_EN		0xfc38
+#define PLA_BP_8		0xfc38		/* RTL8153C */
+#define PLA_BP_9		0xfc3a
+#define PLA_BP_10		0xfc3c
+#define PLA_BP_11		0xfc3e
+#define PLA_BP_12		0xfc40
+#define PLA_BP_13		0xfc42
+#define PLA_BP_14		0xfc44
+#define PLA_BP_15		0xfc46
+#define PLA_BP2_EN		0xfc48
+
+#define USB_USB2PHY		0xb41e
+#define USB_SSPHYLINK1		0xb426
+#define USB_SSPHYLINK2		0xb428
+#define USB_L1_CTRL		0xb45e
+#define USB_U2P3_CTRL		0xb460
+#define USB_CSR_DUMMY1		0xb464
+#define USB_CSR_DUMMY2		0xb466
+#define USB_DEV_STAT		0xb808
+#define USB_CONNECT_TIMER	0xcbf8
+#define USB_MSC_TIMER		0xcbfc
+#define USB_OUTER_FW_VER	0xcd54
+#define USB_BURST_SIZE		0xcfc0
+#define USB_FW_FIX_EN0		0xcfca
+#define USB_FW_FIX_EN1		0xcfcc
+#define USB_FW_PLA_VER		0xcfd6
+#define USB_FW_USB_VER		0xcfd7
+#define USB_LPM_CONFIG		0xcfd8
+#define USB_EFUSE		0xcfdb
+#define USB_ECM_OPTION		0xcfee
+#define USB_CSTMR		0xcfef	/* RTL8153A */
+#define USB_MISC_2		0xcfff
+#define USB_ECM_OP		0xd26b
+#define USB_GPHY_CTRL		0xd284
+#define USB_SPEED_OPTION	0xd32a
+#define USB_FW_CTRL		0xd334	/* RTL8153B */
+#define USB_FC_TIMER		0xd340
+#define USB_OUTSIDE_FW_VER	0xd3cc
+#define USB_USB_CTRL		0xd406
+#define USB_PHY_CTRL		0xd408
+#define USB_TX_AGG		0xd40a
+#define USB_RX_BUF_TH		0xd40c
+#define USB_USB_TIMER		0xd428
+#define USB_RX_EARLY_TIMEOUT	0xd42c
+#define USB_RX_EARLY_SIZE	0xd42e
+#define USB_PM_CTRL_STATUS	0xd432	/* RTL8153A */
+#define USB_RX_EXTRA_AGGR_TMR	0xd432	/* RTL8153B */
+#define USB_TX_DMA		0xd434
+#define USB_UPT_RXDMA_OWN	0xd437
+#define USB_UPHY3_MDCMDIO	0xd480
+#define USB_TOLERANCE		0xd490
+#define USB_LPM_CTRL		0xd41a
+#define USB_BMU_RESET		0xd4b0
+#define USB_BMU_CONFIG		0xd4b4
+#define USB_U1U2_TIMER		0xd4da
+#define USB_FW_TASK		0xd4e8	/* RTL8153B */
+#define USB_RX_AGGR_NUM		0xd4ee
+#define USB_ADV_ADDR		0xd5d6
+#define USB_ADV_DATA		0xd5d8
+#define USB_ADV_CMD		0xd5dc
+#define USB_TGPHY_ADDR		0xd630
+#define USB_TGPHY_DATA		0xd632
+#define USB_TGPHY_CMD		0xd634
+#define USB_UPS_CTRL		0xd800
+#define USB_POWER_CUT		0xd80a
+#define USB_MISC_0		0xd81a
+#define USB_MISC_1		0xd81f
+#define USB_AFE_CTRL2		0xd824
+#define USB_UPHY_XTAL		0xd826
+#define USB_UPS_CFG		0xd842
+#define USB_UPS_FLAGS		0xd848
+#define USB_WDT1_CTRL		0xe404
+#define USB_WDT11_CTRL		0xe43c
+#define USB_BP_BA		PLA_BP_BA
+#define USB_BP_0		PLA_BP_0
+#define USB_BP_1		PLA_BP_1
+#define USB_BP_2		PLA_BP_2
+#define USB_BP_3		PLA_BP_3
+#define USB_BP_4		PLA_BP_4
+#define USB_BP_5		PLA_BP_5
+#define USB_BP_6		PLA_BP_6
+#define USB_BP_7		PLA_BP_7
+#define USB_BP_EN		PLA_BP_EN	/* RTL8153A */
+#define USB_BP_8		0xfc38		/* RTL8153B */
+#define USB_BP_9		0xfc3a
+#define USB_BP_10		0xfc3c
+#define USB_BP_11		0xfc3e
+#define USB_BP_12		0xfc40
+#define USB_BP_13		0xfc42
+#define USB_BP_14		0xfc44
+#define USB_BP_15		0xfc46
+#define USB_BP2_EN		0xfc48
+
+/* OCP Registers */
+#define OCP_ALDPS_CONFIG	0x2010
+#define OCP_EEE_CONFIG1		0x2080
+#define OCP_EEE_CONFIG2		0x2092
+#define OCP_EEE_CONFIG3		0x2094
+#define OCP_BASE_MII		0xa400
+#define OCP_EEE_AR		0xa41a
+#define OCP_EEE_DATA		0xa41c
+#define OCP_PHY_STATUS		0xa420
+#define OCP_INTR_EN		0xa424
+#define OCP_NCTL_CFG		0xa42c
+#define OCP_POWER_CFG		0xa430
+#define OCP_EEE_CFG		0xa432
+#define OCP_SRAM_ADDR		0xa436
+#define OCP_SRAM_DATA		0xa438
+#define OCP_DOWN_SPEED		0xa442
+#define OCP_EEE_ABLE		0xa5c4
+#define OCP_EEE_ABLE2		0xa6ec
+#define OCP_EEE_ADV		0xa5d0
+#define OCP_EEE_LPABLE		0xa5d2
+#define OCP_EEE_LPABLE2		0xa6d0
+#define OCP_10GBT_CTRL		0xa5d4
+#define OCP_10GBT_STAT		0xa5d6
+#define OCP_EEE_ADV2		0xa6d4
+#define OCP_PHY_STATE		0xa708		/* nway state for 8153 */
+#define OCP_PHY_PATCH_STAT	0xb800
+#define OCP_PHY_PATCH_CMD	0xb820
+#define OCP_PHY_LOCK		0xb82e
+#define OCP_SRAM2_ADDR		0xb87c
+#define OCP_SRAM2_DATA		0xb87e
+#define OCP_ADC_IOFFSET		0xbcfc
+#define OCP_ADC_CFG		0xbc06
+#define OCP_SYSCLK_CFG		0xc416
+
+/* SRAM Register */
+#define SRAM_GREEN_CFG		0x8011
+#define SRAM_LPF_CFG		0x8012
+#define SRAM_GPHY_FW_VER	0x801e
+#define SRAM_10M_AMP1		0x8080
+#define SRAM_10M_AMP2		0x8082
+#define SRAM_IMPEDANCE		0x8084
+#define SRAM_PHY_LOCK		0xb82e
+
+/* PLA_RCR */
+#define RCR_AAP			0x00000001
+#define RCR_APM			0x00000002
+#define RCR_AM			0x00000004
+#define RCR_AB			0x00000008
+#define RCR_ACPT_ALL		(RCR_AAP | RCR_APM | RCR_AM | RCR_AB)
+#define SLOT_EN			BIT(11)
+
+/* PLA_RCR1 */
+#define OUTER_VLAN		BIT(7)
+#define INNER_VLAN		BIT(6)
+
+/* PLA_RXFIFO_CTRL0 */
+#define RXFIFO_THR1_NORMAL	0x00080002
+#define RXFIFO_THR1_OOB		0x01800003
+
+/* PLA_RXFIFO_FULL */
+#define RXFIFO_FULL_MASK	0xfff
+
+/* PLA_RXFIFO_CTRL1 */
+#define RXFIFO_THR2_FULL	0x00000060
+#define RXFIFO_THR2_HIGH	0x00000038
+#define RXFIFO_THR2_OOB		0x0000004a
+#define RXFIFO_THR2_NORMAL	0x00a0
+
+/* PLA_RXFIFO_CTRL2 */
+#define RXFIFO_THR3_FULL	0x00000078
+#define RXFIFO_THR3_HIGH	0x00000048
+#define RXFIFO_THR3_OOB		0x0000005a
+#define RXFIFO_THR3_NORMAL	0x0110
+
+/* PLA_TXFIFO_CTRL */
+#define TXFIFO_THR_NORMAL	0x00400008
+#define TXFIFO_THR_NORMAL2	0x01000008
+
+/* PLA_DMY_REG0 */
+#define ECM_ALDPS		0x0002
+
+/* PLA_FMC */
+#define FMC_FCR_MCU_EN		0x0001
+
+/* PLA_EEEP_CR */
+#define EEEP_CR_EEEP_TX		0x0002
+
+/* PLA_WDT6_CTRL */
+#define WDT6_SET_MODE		0x0010
+
+/* PLA_TCR0 */
+#define TCR0_TX_EMPTY		0x0800
+#define TCR0_AUTO_FIFO		0x0080
+
+/* PLA_TCR1 */
+#define VERSION_MASK		0x7cf0
+#define IFG_MASK		(BIT(3) | BIT(9) | BIT(8))
+#define IFG_144NS		BIT(9)
+#define IFG_96NS		(BIT(9) | BIT(8))
+
+/* PLA_MTPS */
+#define MTPS_JUMBO		(12 * 1024 / 64)
+#define MTPS_DEFAULT		(6 * 1024 / 64)
+
+/* PLA_RSTTALLY */
+#define TALLY_RESET		0x0001
+
+/* PLA_CR */
+#define CR_RST			0x10
+#define CR_RE			0x08
+#define CR_TE			0x04
+
+/* PLA_CRWECR */
+#define CRWECR_NORAML		0x00
+#define CRWECR_CONFIG		0xc0
+
+/* PLA_OOB_CTRL */
+#define NOW_IS_OOB		0x80
+#define TXFIFO_EMPTY		0x20
+#define RXFIFO_EMPTY		0x10
+#define LINK_LIST_READY		0x02
+#define DIS_MCU_CLROOB		0x01
+#define FIFO_EMPTY		(TXFIFO_EMPTY | RXFIFO_EMPTY)
+
+/* PLA_MISC_1 */
+#define RXDY_GATED_EN		0x0008
+
+/* PLA_SFF_STS_7 */
+#define RE_INIT_LL		0x8000
+#define MCU_BORW_EN		0x4000
+
+/* PLA_CPCR */
+#define FLOW_CTRL_EN		BIT(0)
+#define CPCR_RX_VLAN		0x0040
+
+/* PLA_CFG_WOL */
+#define MAGIC_EN		0x0001
+
+/* PLA_TEREDO_CFG */
+#define TEREDO_SEL		0x8000
+#define TEREDO_WAKE_MASK	0x7f00
+#define TEREDO_RS_EVENT_MASK	0x00fe
+#define OOB_TEREDO_EN		0x0001
+
+/* PLA_BDC_CR */
+#define ALDPS_PROXY_MODE	0x0001
+
+/* PLA_EFUSE_CMD */
+#define EFUSE_READ_CMD		BIT(15)
+#define EFUSE_DATA_BIT16	BIT(7)
+
+/* PLA_CONFIG34 */
+#define LINK_ON_WAKE_EN		0x0010
+#define LINK_OFF_WAKE_EN	0x0008
+
+/* PLA_CONFIG6 */
+#define LANWAKE_CLR_EN		BIT(0)
+
+/* PLA_USB_CFG */
+#define EN_XG_LIP		BIT(1)
+#define EN_G_LIP		BIT(2)
+
+/* PLA_CONFIG5 */
+#define BWF_EN			0x0040
+#define MWF_EN			0x0020
+#define UWF_EN			0x0010
+#define SPI_EN			BIT(3)
+#define LAN_WAKE_EN		0x0002
+
+/* PLA_LED_FEATURE */
+#define LED_MODE_MASK		0x0700
+
+/* PLA_PHY_PWR */
+#define TX_10M_IDLE_EN		0x0080
+#define PFM_PWM_SWITCH		0x0040
+#define TEST_IO_OFF		BIT(4)
+
+/* PLA_MAC_PWR_CTRL */
+#define D3_CLK_GATED_EN		0x00004000
+#define MCU_CLK_RATIO		0x07010f07
+#define MCU_CLK_RATIO_MASK	0x0f0f0f0f
+#define ALDPS_SPDWN_RATIO	0x0f87
+
+/* PLA_MAC_PWR_CTRL2 */
+#define EEE_SPDWN_RATIO		0x8007
+#define MAC_CLK_SPDWN_EN	BIT(15)
+#define EEE_SPDWN_RATIO_MASK	0xff
+
+/* PLA_MAC_PWR_CTRL3 */
+#define PLA_MCU_SPDWN_EN	BIT(14)
+#define PKT_AVAIL_SPDWN_EN	0x0100
+#define SUSPEND_SPDWN_EN	0x0004
+#define U1U2_SPDWN_EN		0x0002
+#define L1_SPDWN_EN		0x0001
+
+/* PLA_MAC_PWR_CTRL4 */
+#define PWRSAVE_SPDWN_EN	0x1000
+#define RXDV_SPDWN_EN		0x0800
+#define TX10MIDLE_EN		0x0100
+#define IDLE_SPDWN_EN		BIT(6)
+#define TP100_SPDWN_EN		0x0020
+#define TP500_SPDWN_EN		0x0010
+#define TP1000_SPDWN_EN		0x0008
+#define EEE_SPDWN_EN		0x0001
+
+/* PLA_GPHY_INTR_IMR */
+#define GPHY_STS_MSK		0x0001
+#define SPEED_DOWN_MSK		0x0002
+#define SPDWN_RXDV_MSK		0x0004
+#define SPDWN_LINKCHG_MSK	0x0008
+
+/* PLA_PHYAR */
+#define PHYAR_FLAG		0x80000000
+
+/* PLA_EEE_CR */
+#define EEE_RX_EN		0x0001
+#define EEE_TX_EN		0x0002
+
+/* PLA_BOOT_CTRL */
+#define AUTOLOAD_DONE		0x0002
+
+/* PLA_LWAKE_CTRL_REG */
+#define LANWAKE_PIN		BIT(7)
+
+/* PLA_SUSPEND_FLAG */
+#define LINK_CHG_EVENT		BIT(0)
+
+/* PLA_INDICATE_FALG */
+#define UPCOMING_RUNTIME_D3	BIT(0)
+
+/* PLA_MACDBG_PRE and PLA_MACDBG_POST */
+#define DEBUG_OE		BIT(0)
+#define DEBUG_LTSSM		0x0082
+
+/* PLA_EXTRA_STATUS */
+#define CUR_LINK_OK		BIT(15)
+#define U3P3_CHECK_EN		BIT(7)	/* RTL_VER_05 only */
+#define LINK_CHANGE_FLAG	BIT(8)
+#define POLL_LINK_CHG		BIT(0)
+
+/* PLA_GPHY_CTRL */
+#define GPHY_FLASH		BIT(1)
+
+/* PLA_POL_GPIO_CTRL */
+#define DACK_DET_EN		BIT(15)
+#define POL_GPHY_PATCH		BIT(4)
+
+/* USB_USB2PHY */
+#define USB2PHY_SUSPEND		0x0001
+#define USB2PHY_L1		0x0002
+
+/* USB_SSPHYLINK1 */
+#define DELAY_PHY_PWR_CHG	BIT(1)
+
+/* USB_SSPHYLINK2 */
+#define pwd_dn_scale_mask	0x3ffe
+#define pwd_dn_scale(x)		((x) << 1)
+
+/* USB_CSR_DUMMY1 */
+#define DYNAMIC_BURST		0x0001
+
+/* USB_CSR_DUMMY2 */
+#define EP4_FULL_FC		0x0001
+
+/* USB_DEV_STAT */
+#define STAT_SPEED_MASK		0x0006
+#define STAT_SPEED_HIGH		0x0000
+#define STAT_SPEED_FULL		0x0002
+
+/* USB_FW_FIX_EN0 */
+#define FW_FIX_SUSPEND		BIT(14)
+
+/* USB_FW_FIX_EN1 */
+#define FW_IP_RESET_EN		BIT(9)
+
+/* USB_LPM_CONFIG */
+#define LPM_U1U2_EN		BIT(0)
+
+/* USB_EFUSE */
+#define PASS_THRU_MASK		BIT(0)
+
+/* USB_TX_AGG */
+#define TX_AGG_MAX_THRESHOLD	0x03
+
+/* USB_RX_BUF_TH */
+#define RX_THR_SUPPER		0x0c350180
+#define RX_THR_HIGH		0x7a120180
+#define RX_THR_SLOW		0xffff0180
+#define RX_THR_B		0x00010001
+
+/* USB_TX_DMA */
+#define TEST_MODE_DISABLE	0x00000001
+#define TX_SIZE_ADJUST1		0x00000100
+
+/* USB_BMU_RESET */
+#define BMU_RESET_EP_IN		0x01
+#define BMU_RESET_EP_OUT	0x02
+
+/* USB_BMU_CONFIG */
+#define ACT_ODMA		BIT(1)
+
+/* USB_UPT_RXDMA_OWN */
+#define OWN_UPDATE		BIT(0)
+#define OWN_CLEAR		BIT(1)
+
+/* USB_FW_TASK */
+#define FC_PATCH_TASK		BIT(1)
+
+/* USB_RX_AGGR_NUM */
+#define RX_AGGR_NUM_MASK	0x1ff
+
+/* USB_ADV_CMD */
+#define ADV_CMD_BUSY		BIT(0)
+#define ADV_CMD_WR		BIT(1)
+#define ADV_CMD_BMU		0
+#define ADV_CMD_IP		BIT(2)
+
+/* USB_TGPHY_CMD */
+#define TGPHY_CMD_BUSY		BIT(0)
+#define TGPHY_CMD_WR		BIT(1)
+
+/* USB_UPS_CTRL */
+#define POWER_CUT		0x0100
+
+/* USB_PM_CTRL_STATUS */
+#define RESUME_INDICATE		0x0001
+
+/* USB_ECM_OPTION */
+#define BYPASS_MAC_RESET	BIT(5)
+
+/* USB_CSTMR */
+#define FORCE_SUPER		BIT(0)
+
+/* USB_MISC_2 */
+#define UPS_NO_UPS		BIT(7)
+#define UPS_FORCE_PWR_DOWN	BIT(0)
+
+/* USB_ECM_OP */
+#define	EN_ALL_SPEED		BIT(0)
+
+/* USB_GPHY_CTRL */
+#define GPHY_PATCH_DONE		BIT(2)
+#define BYPASS_FLASH		BIT(5)
+#define BACKUP_RESTRORE		BIT(6)
+
+/* USB_SPEED_OPTION */
+#define RG_PWRDN_EN		BIT(8)
+#define ALL_SPEED_OFF		BIT(9)
+
+/* USB_FW_CTRL */
+#define FLOW_CTRL_PATCH_OPT	BIT(1)
+#define AUTO_SPEEDUP		BIT(3)
+#define FLOW_CTRL_PATCH_2	BIT(8)
+
+/* USB_FC_TIMER */
+#define CTRL_TIMER_EN		BIT(15)
+
+/* USB_USB_CTRL */
+#define CDC_ECM_EN		BIT(3)
+#define RX_AGG_DISABLE		0x0010
+#define RX_ZERO_EN		0x0080
+
+/* USB_U2P3_CTRL */
+#define U2P3_ENABLE		0x0001
+#define RX_DETECT8		BIT(3)
+
+/* USB_POWER_CUT */
+#define PWR_EN			0x0001
+#define PHASE2_EN		0x0008
+#define UPS_EN			BIT(4)
+#define USP_PREWAKE		BIT(5)
+
+/* USB_MISC_0 */
+#define PCUT_STATUS		0x0001
+#define AD_MASK			0xfee0
+
+/* USB_MISC_1 */
+#define BD_MASK			BIT(0)
+#define BND_MASK		BIT(2)
+#define BL_MASK			BIT(3)
+
+/* USB_RX_EARLY_TIMEOUT */
+#define COALESCE_SUPER		 85000U
+#define COALESCE_HIGH		250000U
+#define COALESCE_SLOW		524280U
+
+/* USB_WDT1_CTRL */
+#define WTD1_EN			BIT(0)
+
+/* USB_WDT11_CTRL */
+#define TIMER11_EN		0x0001
+
+/* USB_LPM_CTRL */
+/* bit 4 ~ 5: fifo empty boundary */
+#define FIFO_EMPTY_1FB		0x30	/* 0x1fb * 64 = 32448 bytes */
+/* bit 2 ~ 3: LMP timer */
+#define LPM_TIMER_MASK		0x0c
+#define LPM_TIMER_500MS		0x04	/* 500 ms */
+#define LPM_TIMER_500US		0x0c	/* 500 us */
+#define ROK_EXIT_LPM		0x02
+
+/* USB_AFE_CTRL2 */
+#define SEN_VAL_MASK		0xf800
+#define SEN_VAL_NORMAL		0xa000
+#define SEL_RXIDLE		0x0100
+
+/* USB_UPHY_XTAL */
+#define OOBS_POLLING		BIT(8)
+
+/* USB_UPS_CFG */
+#define SAW_CNT_1MS_MASK	0x0fff
+#define MID_REVERSE		BIT(5)	/* RTL8156A */
+
+/* USB_UPS_FLAGS */
+#define UPS_FLAGS_R_TUNE		BIT(0)
+#define UPS_FLAGS_EN_10M_CKDIV		BIT(1)
+#define UPS_FLAGS_250M_CKDIV		BIT(2)
+#define UPS_FLAGS_EN_ALDPS		BIT(3)
+#define UPS_FLAGS_CTAP_SHORT_DIS	BIT(4)
+#define UPS_FLAGS_SPEED_MASK		(0xf << 16)
+#define ups_flags_speed(x)		((x) << 16)
+#define UPS_FLAGS_EN_EEE		BIT(20)
+#define UPS_FLAGS_EN_500M_EEE		BIT(21)
+#define UPS_FLAGS_EN_EEE_CKDIV		BIT(22)
+#define UPS_FLAGS_EEE_PLLOFF_100	BIT(23)
+#define UPS_FLAGS_EEE_PLLOFF_GIGA	BIT(24)
+#define UPS_FLAGS_EEE_CMOD_LV_EN	BIT(25)
+#define UPS_FLAGS_EN_GREEN		BIT(26)
+#define UPS_FLAGS_EN_FLOW_CTR		BIT(27)
+
+enum spd_duplex {
+	NWAY_10M_HALF,
+	NWAY_10M_FULL,
+	NWAY_100M_HALF,
+	NWAY_100M_FULL,
+	NWAY_1000M_FULL,
+	FORCE_10M_HALF,
+	FORCE_10M_FULL,
+	FORCE_100M_HALF,
+	FORCE_100M_FULL,
+	FORCE_1000M_FULL,
+	NWAY_2500M_FULL,
+	NWAY_5000M_FULL,
+	NWAY_10G_FULL,
+};
+
+/* OCP_ALDPS_CONFIG */
+#define ENPWRSAVE		0x8000
+#define ENPDNPS			0x0200
+#define LINKENA			0x0100
+#define DIS_SDSAVE		0x0010
+
+/* OCP_PHY_STATUS */
+#define PHY_STAT_MASK		0x0007
+#define PHY_STAT_EXT_INIT	2
+#define PHY_STAT_LAN_ON		3
+#define PHY_STAT_PWRDN		5
+
+/* OCP_INTR_EN */
+#define INTR_SPEED_FORCE	BIT(3)
+
+/* OCP_NCTL_CFG */
+#define PGA_RETURN_EN		BIT(1)
+
+/* OCP_POWER_CFG */
+#define EEE_CLKDIV_EN		0x8000
+#define EN_ALDPS		0x0004
+#define EN_10M_PLLOFF		0x0001
+
+/* OCP_EEE_CONFIG1 */
+#define RG_TXLPI_MSK_HFDUP	0x8000
+#define RG_MATCLR_EN		0x4000
+#define EEE_10_CAP		0x2000
+#define EEE_NWAY_EN		0x1000
+#define TX_QUIET_EN		0x0200
+#define RX_QUIET_EN		0x0100
+#define sd_rise_time_mask	0x0070
+#define sd_rise_time(x)		(min(x, 7) << 4)	/* bit 4 ~ 6 */
+#define RG_RXLPI_MSK_HFDUP	0x0008
+#define SDFALLTIME		0x0007	/* bit 0 ~ 2 */
+
+/* OCP_EEE_CONFIG2 */
+#define RG_LPIHYS_NUM		0x7000	/* bit 12 ~ 15 */
+#define RG_DACQUIET_EN		0x0400
+#define RG_LDVQUIET_EN		0x0200
+#define RG_CKRSEL		0x0020
+#define RG_EEEPRG_EN		0x0010
+
+/* OCP_EEE_CONFIG3 */
+#define fast_snr_mask		0xff80
+#define fast_snr(x)		(min(x, 0x1ff) << 7)	/* bit 7 ~ 15 */
+#define RG_LFS_SEL		0x0060	/* bit 6 ~ 5 */
+#define MSK_PH			0x0006	/* bit 0 ~ 3 */
+
+/* OCP_EEE_AR */
+/* bit[15:14] function */
+#define FUN_ADDR		0x0000
+#define FUN_DATA		0x4000
+/* bit[4:0] device addr */
+
+/* OCP_EEE_CFG */
+#define CTAP_SHORT_EN		0x0040
+#define EEE10_EN		0x0010
+
+/* OCP_DOWN_SPEED */
+#define EN_EEE_CMODE		BIT(14)
+#define EN_EEE_1000		BIT(13)
+#define EN_EEE_100		BIT(12)
+#define EN_10M_CLKDIV		BIT(11)
+#define EN_10M_BGOFF		0x0080
+
+/* OCP_10GBT_CTRL */
+#define RTL_ADV2_5G_F_R		BIT(5)	/* Advertise 2.5GBASE-T fast-retrain */
+
+/* OCP_PHY_STATE */
+#define TXDIS_STATE		0x01
+#define ABD_STATE		0x02
+
+/* OCP_PHY_PATCH_STAT */
+#define PATCH_READY		BIT(6)
+
+/* OCP_PHY_PATCH_CMD */
+#define PATCH_REQUEST		BIT(4)
+
+/* OCP_PHY_LOCK */
+#define PATCH_LOCK		BIT(0)
+
+/* OCP_ADC_CFG */
+#define CKADSEL_L		0x0100
+#define ADC_EN			0x0080
+#define EN_EMI_L		0x0040
+
+/* OCP_SYSCLK_CFG */
+#define sysclk_div_expo(x)	(min(x, 5) << 8)
+#define clk_div_expo(x)		(min(x, 5) << 4)
+
+/* SRAM_GREEN_CFG */
+#define GREEN_ETH_EN		BIT(15)
+#define R_TUNE_EN		BIT(11)
+
+/* SRAM_LPF_CFG */
+#define LPF_AUTO_TUNE		0x8000
+
+/* SRAM_10M_AMP1 */
+#define GDAC_IB_UPALL		0x0008
+
+/* SRAM_10M_AMP2 */
+#define AMP_DN			0x0200
+
+/* SRAM_IMPEDANCE */
+#define RX_DRIVING_MASK		0x6000
+
+/* SRAM_PHY_LOCK */
+#define PHY_PATCH_LOCK		0x0001
+
+enum rtl_register_content {
+	_10000bps	= BIT(14),
+	_5000bps	= BIT(12),
+	_2500bps	= BIT(10),
+	_1250bps	= BIT(9),
+	_500bps		= BIT(8),
+	_tx_flow	= BIT(6),
+	_rx_flow	= BIT(5),
+	_1000bps	= 0x10,
+	_100bps		= 0x08,
+	_10bps		= 0x04,
+	LINK_STATUS	= 0x02,
+	FULL_DUP	= 0x01,
+};
+
+#define is_speed_2500(_speed)	(((_speed) & (_2500bps | LINK_STATUS)) == (_2500bps | LINK_STATUS))
+#define is_flow_control(_speed)	(((_speed) & (_tx_flow | _rx_flow)) == (_tx_flow | _rx_flow))
+
+#define RTL8152_MAX_TX		4
+#define RTL8152_MAX_RX		10
+#define INTBUFSIZE		2
+
+#define RTL8152_RX_MAX_PENDING	4096
+#define RTL8152_RXFG_HEADSZ	256
+
+#define INTR_LINK		0x0004
+
+#define RTL8152_REQT_READ	0xc0
+#define RTL8152_REQT_WRITE	0x40
+#define RTL8152_REQ_GET_REGS	0x05
+#define RTL8152_REQ_SET_REGS	0x05
+
+#define BYTE_EN_DWORD		0xff
+#define BYTE_EN_WORD		0x33
+#define BYTE_EN_BYTE		0x11
+#define BYTE_EN_SIX_BYTES	0x3f
+#define BYTE_EN_START_MASK	0x0f
+#define BYTE_EN_END_MASK	0xf0
+
+#define RTL8152_RMS		(VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)
+#define RTL8153_RMS		RTL8153_MAX_PACKET
+#define RTL8152_TX_TIMEOUT	(5 * HZ)
+#define mtu_to_size(m)		((m) + VLAN_ETH_HLEN + ETH_FCS_LEN)
+#define size_to_mtu(s)		((s) - VLAN_ETH_HLEN - ETH_FCS_LEN)
+
+#define RTL_MAX_SG_NUM		16
+
+/* rtl8152 flags */
+enum rtl8152_flags {
+	RTL8152_UNPLUG = 0,
+	RTL8152_SET_RX_MODE,
+	WORK_ENABLE,
+	RTL8152_LINK_CHG,
+	SELECTIVE_SUSPEND,
+	PHY_RESET,
+	SCHEDULE_TASKLET,
+	GREEN_ETHERNET,
+	RX_EPROTO,
+	RECOVER_SPEED,
+	DISABLE_EEE_BOTTOM,
+};
+
+/* Define these values to match your device */
+#define VENDOR_ID_REALTEK		0x0bda
+#define VENDOR_ID_MICROSOFT		0x045e
+#define VENDOR_ID_SAMSUNG		0x04e8
+#define VENDOR_ID_LENOVO		0x17ef
+#define VENDOR_ID_LINKSYS		0x13b1
+#define VENDOR_ID_NVIDIA		0x0955
+#define VENDOR_ID_TPLINK		0x2357
+
+#define MCU_TYPE_PLA			0x0100
+#define MCU_TYPE_USB			0x0000
+
+#define DEVICE_ID_LENOVO_USB_C_TRAVEL_HUB		0x721e
+#define DEVICE_ID_THINKPAD_ONELINK_PLUS_DOCK		0x3054
+#define DEVICE_ID_THINKPAD_THUNDERBOLT3_DOCK_GEN2	0x3082
+#define DEVICE_ID_THINKPAD_USB_C_DONGLE			0x720c
+#define DEVICE_ID_THINKPAD_USB_C_DOCK_GEN2		0xa387
+#define DEVICE_ID_THINKPAD_USB_C_DOCK_GEN3		0x3062
+
+struct tally_counter {
+	__le64	tx_packets;
+	__le64	rx_packets;
+	__le64	tx_errors;
+	__le32	rx_errors;
+	__le16	rx_missed;
+	__le16	align_errors;
+	__le32	tx_one_collision;
+	__le32	tx_multi_collision;
+	__le64	rx_unicast;
+	__le64	rx_broadcast;
+	__le32	rx_multicast;
+	__le16	tx_aborted;
+	__le16	tx_underrun;
+};
+
+struct rx_desc {
+	__le32 opts1;
+#define RD_CRC				BIT(15)
+#define RX_LEN_MASK			0x7fff
+
+	__le32 opts2;
+#define RD_UDP_CS			BIT(23)
+#define RD_TCP_CS			BIT(22)
+#define RD_IPV6_CS			BIT(20)
+#define RD_IPV4_CS			BIT(19)
+
+	__le32 opts3;
+#define IPF				BIT(23) /* IP checksum fail */
+#define UDPF				BIT(22) /* UDP checksum fail */
+#define TCPF				BIT(21) /* TCP checksum fail */
+#define RX_VLAN_TAG			BIT(16)
+
+	__le32 opts4;
+	__le32 opts5;
+	__le32 opts6;
+};
+
+struct tx_desc {
+	__le32 opts1;
+#define TX_FS			BIT(31) /* First segment of a packet */
+#define TX_LS			BIT(30) /* Final segment of a packet */
+#define LGSEND			BIT(29)
+#define GTSENDV4		BIT(28)
+#define GTSENDV6		BIT(27)
+#define GTTCPHO_SHIFT		18
+#define GTTCPHO_MAX		0x7fU
+#define TX_LEN_MAX		0x3ffffU
+
+	__le32 opts2;
+#define UDP_CS			BIT(31) /* Calculate UDP/IP checksum */
+#define TCP_CS			BIT(30) /* Calculate TCP/IP checksum */
+#define IPV4_CS			BIT(29) /* Calculate IPv4 checksum */
+#define IPV6_CS			BIT(28) /* Calculate IPv6 checksum */
+#define MSS_SHIFT		17
+#define MSS_MAX			0x7ffU
+#define TCPHO_SHIFT		17
+#define TCPHO_MAX		0x7ffU
+#define TX_VLAN_TAG		BIT(16)
+};
+
+struct rx_desc_v2 {
+	__le32 opts1;
+#define RX_LEN_MASK_2			0xfffe0000
+#define rx_v2_get_len(x)		(((x) & RX_LEN_MASK_2) >> 17)
+#define RX_VLAN_TAG_2			BIT(3)
+#define RX_VER_MASK			0x3
+
+	__le32 opts2;
+
+	__le32 opts3;
+#define IPF_2				BIT(26) /* IP checksum fail */
+#define UDPF_2				BIT(25) /* UDP checksum fail */
+#define TCPF_2				BIT(24) /* TCP checksum fail */
+#define RD_IPV6_CS_2			BIT(15)
+#define RD_IPV4_CS_2			BIT(14)
+#define RD_UDP_CS_2			BIT(11)
+#define RD_TCP_CS_2			BIT(10)
+
+	__le32 opts4;
+};
+
+struct tx_desc_v2 {
+	__le32 opts1;
+
+	__le32 opts2;
+#define TCPHO_MAX_2		0x3ffU
+
+	__le32 opts3;
+#define tx_v2_set_len(x)	((x) << 4)
+
+	__le32 opts4;
+#define TX_SIG			(0x15 << 27)
+};
+
+struct r8152;
+
+struct rx_agg {
+	struct list_head list, info_list;
+	struct urb *urb;
+	struct r8152 *context;
+	struct page *page;
+	void *buffer;
+};
+
+struct tx_agg {
+	struct list_head list;
+	struct urb *urb;
+	struct r8152 *context;
+	struct sk_buff_head tx_skb;
+	void *buffer;
+	void *head;
+	u32 skb_num;
+	u32 skb_len;
+	u32 skb_bytes;
+};
+
+struct r8152 {
+	unsigned long flags;
+	struct usb_device *udev;
+	struct napi_struct napi;
+	struct usb_interface *intf;
+	struct net_device *netdev;
+	struct urb *intr_urb;
+	struct tx_agg tx_info[RTL8152_MAX_TX];
+	struct list_head rx_info, rx_used;
+	struct list_head rx_done, tx_free;
+	struct sk_buff_head tx_queue, rx_queue;
+	spinlock_t rx_lock, tx_lock;
+	struct delayed_work schedule, hw_phy_work;
+	struct mii_if_info mii;
+	struct mutex control;	/* use for hw setting */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+	struct vlan_group *vlgrp;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	struct net_device_stats stats;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP)
+	struct notifier_block pm_notifier;
+#endif
+#if defined(RTL8152_S5_WOL) && defined(CONFIG_PM)
+	struct notifier_block reboot_notifier;
+#endif /* defined(RTL8152_S5_WOL) && defined(CONFIG_PM) */
+	struct tasklet_struct tx_tl;
+
+	struct rtl_ops {
+		int (*init)(struct r8152 *tp);
+		int (*enable)(struct r8152 *tp);
+		int (*disable)(struct r8152 *tp);
+		int (*up)(struct r8152 *tp);
+		int (*down)(struct r8152 *tp);
+		void (*unload)(struct r8152 *tp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		int (*eee_get)(struct r8152 *tp, struct ethtool_keee *eee);
+		int (*eee_set)(struct r8152 *tp, struct ethtool_keee *eee);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		bool (*in_nway)(struct r8152 *tp);
+		void (*hw_phy_cfg)(struct r8152 *tp);
+		int (*autosuspend_en)(struct r8152 *tp, bool enable);
+		int (*change_mtu)(struct r8152 *tp);
+		int (*phy_read)(struct r8152 *tp, u16 addr, u16 *data);
+		int (*phy_write)(struct r8152 *tp, u16 addr, u16 data);
+	} rtl_ops;
+
+	struct ups_info {
+		u32 r_tune:1;
+		u32 _10m_ckdiv:1;
+		u32 _250m_ckdiv:1;
+		u32 aldps:1;
+		u32 lite_mode:2;
+		u32 speed_duplex:4;
+		u32 eee:1;
+		u32 eee_lite:1;
+		u32 eee_ckdiv:1;
+		u32 eee_plloff_100:1;
+		u32 eee_plloff_giga:1;
+		u32 eee_cmod_lv:1;
+		u32 green:1;
+		u32 flow_control:1;
+		u32 ctap_short_off:1;
+	} ups_info;
+
+	struct desc_info {
+		bool (*vlan_tag)(struct r8152 *tp, void *desc,
+				 struct sk_buff *skb);
+		int (*csum)(struct r8152 *tp, void *desc, struct sk_buff *skb);
+		void (*len)(struct r8152 *tp, void *desc, u32 *len);
+		u8 align;
+		u8 size;
+	} rx_desc, tx_desc;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+	void (*vlan_put_tag)(struct r8152 *tp, void *desc, struct sk_buff *skb);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) */
+
+	atomic_t rx_count;
+
+	bool eee_en;
+	int intr_interval;
+	u32 saved_wolopts;
+	u32 msg_enable;
+	u32 tx_qlen;
+	u32 coalesce;
+	u32 advertising;
+	u32 rx_buf_sz;
+	u32 rx_copybreak;
+	u32 rx_pending;
+	u32 fc_pause_on, fc_pause_off;
+	u32 rx_agg_free_ref;
+
+	unsigned int pipe_in, pipe_out, pipe_intr, pipe_ctrl_in, pipe_ctrl_out;
+
+	u32 support_2500full:1;
+	u32 support_5000full:1;
+	u32 support_10gfull:1;
+	u32 sg_use:1;
+//	u32 dash_mode:1;
+	u32 lenovo_macpassthru:1;
+	u32 dell_macpassthru:1;
+
+	u16 ocp_base;
+	u16 speed;
+	u16 eee_adv;
+	u16 eee_adv2;
+	u8 *intr_buff;
+	u8 version;
+	u8 rtk_enable_diag;
+	u8 duplex;
+	u8 autoneg;
+};
+
+enum rtl_version {
+	RTL_VER_UNKNOWN = 0,
+	RTL_VER_01,
+	RTL_VER_02,
+	RTL_VER_03,
+	RTL_VER_04,
+	RTL_VER_05,
+	RTL_VER_06,
+	RTL_VER_07,
+	RTL_VER_08,
+	RTL_VER_09,
+
+	RTL_TEST_01,
+	RTL_VER_10,
+	RTL_VER_11,
+	RTL_VER_12,
+	RTL_VER_13,
+	RTL_VER_14,
+	RTL_VER_15,
+
+	RTL_VER_16,
+	RTL_VER_17,
+
+	RTL_VER_MAX
+};
+
+enum tx_csum_stat {
+	TX_CSUM_SUCCESS = 0,
+	TX_CSUM_TSO,
+	TX_CSUM_NONE
+};
+
+enum adv_access_type {
+	ADV_TYPE_BMU = 0,
+	ADV_TYPE_IP,
+	ADV_TYPE_MAX
+};
+
+#define RTL_ADVERTISED_10_HALF			BIT(0)
+#define RTL_ADVERTISED_10_FULL			BIT(1)
+#define RTL_ADVERTISED_100_HALF			BIT(2)
+#define RTL_ADVERTISED_100_FULL			BIT(3)
+#define RTL_ADVERTISED_1000_HALF		BIT(4)
+#define RTL_ADVERTISED_1000_FULL		BIT(5)
+#define RTL_ADVERTISED_2500_FULL		BIT(6)
+#define RTL_ADVERTISED_5000_FULL		BIT(7)
+#define RTL_ADVERTISED_10GT_FULL		BIT(8)
+
+/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
+ * The RTL chips use a 64 element hash table based on the Ethernet CRC.
+ */
+static const int multicast_filter_limit = 32;
+static unsigned int agg_buf_sz = 16384;
+
+#define RTL_LIMITED_TSO_SIZE	(size_to_mtu(agg_buf_sz) - tp->tx_desc.size)
+
+static
+int get_registers(struct r8152 *tp, u16 value, u16 index, u16 size, void *data)
+{
+	int ret;
+	void *tmp;
+
+	tmp = kmalloc(size, GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+
+	ret = usb_control_msg(tp->udev, tp->pipe_ctrl_in,
+			      RTL8152_REQ_GET_REGS, RTL8152_REQT_READ,
+			      value, index, tmp, size, USB_CTRL_GET_TIMEOUT);
+	if (ret < 0)
+		memset(data, 0xff, size);
+	else
+		memcpy(data, tmp, size);
+
+	kfree(tmp);
+
+	return ret;
+}
+
+static
+int set_registers(struct r8152 *tp, u16 value, u16 index, u16 size, void *data)
+{
+	int ret;
+	void *tmp;
+
+	tmp = kmemdup(data, size, GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+
+	ret = usb_control_msg(tp->udev, tp->pipe_ctrl_out,
+			      RTL8152_REQ_SET_REGS, RTL8152_REQT_WRITE,
+			      value, index, tmp, size, USB_CTRL_SET_TIMEOUT);
+
+	kfree(tmp);
+
+	return ret;
+}
+
+static void rtl_set_unplug(struct r8152 *tp)
+{
+	if (tp->udev->state == USB_STATE_NOTATTACHED) {
+		set_bit(RTL8152_UNPLUG, &tp->flags);
+		smp_mb__after_atomic();
+	}
+}
+
+static int generic_ocp_read(struct r8152 *tp, u16 index, u16 size,
+			    void *data, u16 type)
+{
+	u16 limit = 64;
+	int ret = 0;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	/* both size and indix must be 4 bytes align */
+	if ((size & 3) || !size || (index & 3) || !data) {
+		WARN_ON_ONCE(1);
+		return -EPERM;
+	}
+
+	if ((u32)index + (u32)size > 0xffff)
+		return -EPERM;
+
+	while (size) {
+		if (size > limit) {
+			ret = get_registers(tp, index, type, limit, data);
+			if (ret < 0)
+				break;
+
+			index += limit;
+			data += limit;
+			size -= limit;
+		} else {
+			ret = get_registers(tp, index, type, size, data);
+			if (ret < 0)
+				break;
+
+			index += size;
+			data += size;
+			size = 0;
+			break;
+		}
+	}
+
+	if (ret == -ENODEV)
+		rtl_set_unplug(tp);
+
+	if (ret < 0)
+		dev_err(&tp->intf->dev,
+			"read type=0x%04x, index=0x%04x fail %d\n",
+			type, index, ret);
+
+	return ret;
+}
+
+static int generic_ocp_write(struct r8152 *tp, u16 index, u16 byteen,
+			     u16 size, void *data, u16 type)
+{
+	int ret;
+	u16 byteen_start, byteen_end, byen;
+	u16 limit = 512;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	/* both size and indix must be 4 bytes align */
+	if ((size & 3) || !size || (index & 3) || !data) {
+		WARN_ON_ONCE(1);
+		return -EPERM;
+	}
+
+	if ((u32)index + (u32)size > 0xffff)
+		return -EPERM;
+
+	byteen_start = byteen & BYTE_EN_START_MASK;
+	byteen_end = byteen & BYTE_EN_END_MASK;
+
+	byen = byteen_start | (byteen_start << 4);
+
+	/* Split the first DWORD if the byte_en is not 0xff */
+	if (byen != BYTE_EN_DWORD) {
+		ret = set_registers(tp, index, type | byen, 4, data);
+		if (ret < 0)
+			goto error1;
+
+		index += 4;
+		data += 4;
+		size -= 4;
+	}
+
+	if (size) {
+		byen = byteen_end | (byteen_end >> 4);
+
+		/* Split the last DWORD if the byte_en is not 0xff */
+		if (byen != BYTE_EN_DWORD)
+			size -= 4;
+
+		while (size) {
+			if (size > limit) {
+				ret = set_registers(tp, index,
+						    type | BYTE_EN_DWORD,
+						    limit, data);
+				if (ret < 0)
+					goto error1;
+
+				index += limit;
+				data += limit;
+				size -= limit;
+			} else {
+				ret = set_registers(tp, index,
+						    type | BYTE_EN_DWORD,
+						    size, data);
+				if (ret < 0)
+					goto error1;
+
+				index += size;
+				data += size;
+				size = 0;
+				break;
+			}
+		}
+
+		/* Set the last DWORD */
+		if (byen != BYTE_EN_DWORD)
+			ret = set_registers(tp, index, type | byen, 4, data);
+	}
+
+error1:
+	if (ret == -ENODEV)
+		rtl_set_unplug(tp);
+
+	if (ret < 0)
+		dev_err(&tp->intf->dev,
+			"write type=0x%04x, index=0x%04x fail %d\n",
+			type | byteen, index, ret);
+
+	return ret;
+}
+
+static inline
+int pla_ocp_read(struct r8152 *tp, u16 index, u16 size, void *data)
+{
+	return generic_ocp_read(tp, index, size, data, MCU_TYPE_PLA);
+}
+
+static inline
+int pla_ocp_write(struct r8152 *tp, u16 index, u16 byteen, u16 size, void *data)
+{
+	return generic_ocp_write(tp, index, byteen, size, data, MCU_TYPE_PLA);
+}
+
+static inline
+int usb_ocp_read(struct r8152 *tp, u16 index, u16 size, void *data)
+{
+	return generic_ocp_read(tp, index, size, data, MCU_TYPE_USB);
+}
+
+static inline
+int usb_ocp_write(struct r8152 *tp, u16 index, u16 byteen, u16 size, void *data)
+{
+	return generic_ocp_write(tp, index, byteen, size, data, MCU_TYPE_USB);
+}
+
+static int ocp_read_dword(struct r8152 *tp, u16 type, u16 index, u32 *value)
+{
+	__le32 data;
+	int ret;
+
+	ret = generic_ocp_read(tp, index, sizeof(data), &data, type);
+	WARN_ON_ONCE(ret != sizeof(data));
+
+	*value = __le32_to_cpu(data);
+
+	return ret;
+}
+
+static int ocp_write_dword(struct r8152 *tp, u16 type, u16 index, u32 data)
+{
+	__le32 tmp = __cpu_to_le32(data);
+	int ret;
+
+	ret = generic_ocp_write(tp, index, BYTE_EN_DWORD, sizeof(tmp), &tmp,
+				type);
+	WARN_ON_ONCE(ret != sizeof(tmp));
+	return ret;
+}
+
+static int ocp_read_word(struct r8152 *tp, u16 type, u16 index, u32 *value)
+{
+	u16 byen = BYTE_EN_WORD;
+	u8 shift = index & 2;
+	__le32 tmp;
+	u32 data;
+	int ret;
+
+	index &= ~3;
+	byen <<= shift;
+
+	ret = generic_ocp_read(tp, index, sizeof(tmp), &tmp, type | byen);
+	WARN_ON_ONCE(ret != sizeof(tmp));
+
+	data = __le32_to_cpu(tmp);
+	data >>= (shift * 8);
+	data &= 0xffff;
+
+	*value = (u16)data;
+
+	return ret;
+}
+
+static int ocp_write_word(struct r8152 *tp, u16 type, u16 index, u32 data)
+{
+	u16 byen = BYTE_EN_WORD;
+	u8 shift = index & 2;
+	u32 mask = 0xffff;
+	__le32 tmp;
+	int ret;
+
+	data &= mask;
+
+	if (shift) {
+		byen <<= shift;
+		data <<= (shift * 8);
+		index &= ~3;
+	}
+
+	tmp = __cpu_to_le32(data);
+
+	ret = generic_ocp_write(tp, index, byen, sizeof(tmp), &tmp, type);
+	WARN_ON_ONCE(ret != sizeof(tmp));
+
+	return ret;
+}
+
+static int ocp_read_byte(struct r8152 *tp, u16 type, u16 index, u32 *value)
+{
+	u8 shift = index & 3;
+	__le32 tmp;
+	u32 data;
+	int ret;
+
+	index &= ~3;
+
+	ret = generic_ocp_read(tp, index, sizeof(tmp), &tmp, type);
+	WARN_ON_ONCE(ret != sizeof(tmp));
+
+	data = __le32_to_cpu(tmp);
+	data >>= (shift * 8);
+	data &= 0xff;
+
+	*value = (u8)data;
+
+	return ret;
+}
+
+static int ocp_write_byte(struct r8152 *tp, u16 type, u16 index, u32 data)
+{
+	u16 byen = BYTE_EN_BYTE;
+	u8 shift = index & 3;
+	u32 mask = 0xff;
+	__le32 tmp;
+	int ret;
+
+	data &= mask;
+
+	if (shift) {
+		byen <<= shift;
+		data <<= (shift * 8);
+		index &= ~3;
+	}
+
+	tmp = __cpu_to_le32(data);
+
+	ret = generic_ocp_write(tp, index, byen, sizeof(tmp), &tmp, type);
+	WARN_ON_ONCE(ret != sizeof(tmp));
+
+	return ret;
+}
+
+static int r8152_phy_read(struct r8152 *tp, u16 addr, u16 *data)
+{
+	u16 ocp_base, ocp_index;
+	u32 ocp_data;
+	int ret;
+
+	ocp_base = addr & 0xf000;
+	if (ocp_base != tp->ocp_base) {
+		ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE,
+				     ocp_base);
+		if (ret < 0) {
+			tp->ocp_base = 0;
+			goto out;
+		}
+		tp->ocp_base = ocp_base;
+	}
+
+	ocp_index = (addr & 0x0fff) | 0xb000;
+	ret = ocp_read_word(tp, MCU_TYPE_PLA, ocp_index, &ocp_data);
+	*data = (u16)ocp_data;
+
+out:
+	return ret;
+}
+
+static int r8152_phy_write(struct r8152 *tp, u16 addr, u16 data)
+{
+	u16 ocp_base, ocp_index;
+	int ret;
+
+	ocp_base = addr & 0xf000;
+	if (ocp_base != tp->ocp_base) {
+		ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE,
+				     ocp_base);
+		if (ret < 0) {
+			tp->ocp_base = 0;
+			goto out;
+		}
+		tp->ocp_base = ocp_base;
+	}
+
+	ocp_index = (addr & 0x0fff) | 0xb000;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, ocp_index, data);
+
+out:
+	return ret;
+}
+
+static int ocp_reg_read(struct r8152 *tp, u16 addr, u16 *data)
+{
+	return tp->rtl_ops.phy_read(tp, addr, data);
+}
+
+static int ocp_reg_write(struct r8152 *tp, u16 addr, u16 data)
+{
+	return tp->rtl_ops.phy_write(tp, addr, data);
+}
+
+static int r8152_mdio_write(struct r8152 *tp, u32 reg_addr, u32 value)
+{
+	return ocp_reg_write(tp, OCP_BASE_MII + reg_addr * 2, value);
+}
+
+static int r8152_mdio_read(struct r8152 *tp, u32 reg_addr)
+{
+	int ret;
+	u16 var;
+
+	ret = ocp_reg_read(tp, OCP_BASE_MII + reg_addr * 2, &var);
+
+	return (ret < 0) ? ret : var;
+}
+
+static int sram_write(struct r8152 *tp, u16 addr, u16 data)
+{
+	int ret;
+
+	ret = ocp_reg_write(tp, OCP_SRAM_ADDR, addr);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_reg_write(tp, OCP_SRAM_DATA, data);
+
+out:
+	return ret;
+}
+
+static int sram_read(struct r8152 *tp, u16 addr, u16 *data)
+{
+	int ret;
+
+	ret = ocp_reg_write(tp, OCP_SRAM_ADDR, addr);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_reg_read(tp, OCP_SRAM_DATA, data);
+
+out:
+	return ret;
+}
+
+static int read_mii_word(struct net_device *netdev, int phy_id, int reg)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	int ret, lock;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	if (phy_id != R8152_PHY_ID)
+		return -EINVAL;
+
+	lock = mutex_trylock(&tp->control);
+
+	ret = r8152_mdio_read(tp, reg);
+
+	if (lock) {
+		mutex_unlock(&tp->control);
+		netif_warn(tp, drv, netdev, "miss mutex for read_mii_word?\n");
+	}
+
+	return ret;
+}
+
+static
+void write_mii_word(struct net_device *netdev, int phy_id, int reg, int val)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	int lock;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (phy_id != R8152_PHY_ID)
+		return;
+
+	lock = mutex_trylock(&tp->control);
+
+	r8152_mdio_write(tp, reg, val);
+
+	if (lock) {
+		mutex_unlock(&tp->control);
+		netif_warn(tp, drv, netdev, "miss mutex for write_mii_word?\n");
+	}
+}
+
+static int
+ocp_dword_w0w1(struct r8152 *tp, u16 type, u16 index, u32 clear, u32 set)
+{
+	u32 ocp_data;
+	int ret;
+
+	ret = ocp_read_dword(tp, type, index, &ocp_data);
+	if (ret < 0)
+		goto out;
+
+	ocp_data = (ocp_data & ~clear) | set;
+	ret = ocp_write_dword(tp, type, index, ocp_data);
+
+out:
+	return ret;
+}
+
+static int
+ocp_word_w0w1(struct r8152 *tp, u16 type, u16 index, u16 clear, u16 set)
+{
+	u32 ocp_data;
+	int ret;
+
+	ret = ocp_read_word(tp, type, index, &ocp_data);
+	if (ret < 0)
+		goto out;
+
+	ocp_data = (ocp_data & ~clear) | set;
+	ret = ocp_write_word(tp, type, index, ocp_data);
+
+out:
+	return ret;
+}
+
+static int
+ocp_byte_w0w1(struct r8152 *tp, u16 type, u16 index, u8 clear, u8 set)
+{
+	u32 ocp_data;
+	int ret;
+
+	ret = ocp_read_byte(tp, type, index, &ocp_data);
+	if (ret < 0)
+		goto out;
+
+	ocp_data = (ocp_data & ~clear) | set;
+	ret = ocp_write_byte(tp, type, index, ocp_data);
+
+out:
+	return ret;
+}
+
+static int
+ocp_dword_clr_bits(struct r8152 *tp, u16 type, u16 index, u32 clear)
+{
+	return ocp_dword_w0w1(tp, type, index, clear, 0);
+}
+
+static int
+ocp_dword_set_bits(struct r8152 *tp, u16 type, u16 index, u32 set)
+{
+	return ocp_dword_w0w1(tp, type, index, 0, set);
+}
+
+static int
+ocp_word_clr_bits(struct r8152 *tp, u16 type, u16 index, u16 clear)
+{
+	return ocp_word_w0w1(tp, type, index, clear, 0);
+}
+
+static int
+ocp_word_set_bits(struct r8152 *tp, u16 type, u16 index, u16 set)
+{
+	return ocp_word_w0w1(tp, type, index, 0, set);
+}
+
+static int
+ocp_word_test_and_clr_bits(struct r8152 *tp, u16 type, u16 index, u16 clear)
+{
+	u32 ocp_data;
+	int ret;
+
+	ret = ocp_read_word(tp, type, index, &ocp_data);
+	if (ret < 0)
+		goto out;
+
+	if (ocp_data & clear) {
+		ret = ocp_write_word(tp, type, index, ocp_data & ~clear);
+		if (ret < 0)
+			goto out;
+	}
+	ret = ocp_data & clear;
+
+out:
+	return ret;
+}
+
+static int
+ocp_byte_clr_bits(struct r8152 *tp, u16 type, u16 index, u8 clear)
+{
+	return ocp_byte_w0w1(tp, type, index, clear, 0);
+}
+
+static int
+ocp_byte_set_bits(struct r8152 *tp, u16 type, u16 index, u8 set)
+{
+	return ocp_byte_w0w1(tp, type, index, 0, set);
+}
+
+static int ocp_reg_w0w1(struct r8152 *tp, u16 addr, u16 clear, u16 set)
+{
+	u16 data;
+	int ret;
+
+	ret = ocp_reg_read(tp, addr, &data);
+	if (ret < 0)
+		goto out;
+	data = (data & ~clear) | set;
+	ret = ocp_reg_write(tp, addr, data);
+
+out:
+	return ret;
+}
+
+static int ocp_reg_clr_bits(struct r8152 *tp, u16 addr, u16 clear)
+{
+	return ocp_reg_w0w1(tp, addr, clear, 0);
+}
+
+static int ocp_reg_set_bits(struct r8152 *tp, u16 addr, u16 set)
+{
+	return ocp_reg_w0w1(tp, addr, 0, set);
+}
+
+static int sram_write_w0w1(struct r8152 *tp, u16 addr, u16 clear, u16 set)
+{
+	u16 data;
+	int ret;
+
+	ret = sram_read(tp, addr, &data);
+	if (ret < 0)
+		goto out;
+
+	data = (data & ~clear) | set;
+	ret = ocp_reg_write(tp, OCP_SRAM_DATA, data);
+
+out:
+	return ret;
+}
+
+static int sram_set_bits(struct r8152 *tp, u16 addr, u16 set)
+{
+	return sram_write_w0w1(tp, addr, 0, set);
+}
+
+static int sram_clr_bits(struct r8152 *tp, u16 addr, u16 clear)
+{
+	return sram_write_w0w1(tp, addr, clear, 0);
+}
+
+static int sram2_write(struct r8152 *tp, u16 addr, u16 data)
+{
+	int ret;
+
+	ret = ocp_reg_write(tp, OCP_SRAM2_ADDR, addr);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_reg_write(tp, OCP_SRAM2_DATA, data);
+
+out:
+	return ret;
+}
+
+static int sram2_read(struct r8152 *tp, u16 addr, u16 *data)
+{
+	int ret;
+
+	ret = ocp_reg_write(tp, OCP_SRAM2_ADDR, addr);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_reg_read(tp, OCP_SRAM2_DATA, data);
+
+out:
+	return ret;
+}
+
+static int sram2_write_w0w1(struct r8152 *tp, u16 addr, u16 clear, u16 set)
+{
+	u16 data;
+	int ret;
+
+	ret = sram2_read(tp, addr, &data);
+	if (ret < 0)
+		goto out;
+
+	data = (data & ~clear) | set;
+	ret = ocp_reg_write(tp, OCP_SRAM2_DATA, data);
+
+out:
+	return ret;
+}
+
+static int sram2_set_bits(struct r8152 *tp, u16 addr, u16 set)
+{
+	return sram2_write_w0w1(tp, addr, 0, set);
+}
+
+static int sram2_clr_bits(struct r8152 *tp, u16 addr, u16 clear)
+{
+	return sram2_write_w0w1(tp, addr, clear, 0);
+}
+
+static int r8152_mdio_set_bit(struct r8152 *tp, u16 addr, u16 set)
+{
+	int data;
+
+	data = r8152_mdio_read(tp, addr);
+	if (data < 0)
+		goto out;
+
+	data = r8152_mdio_write(tp, addr, data | set);
+
+out:
+	return data;
+}
+
+static int r8152_mdio_clr_bit(struct r8152 *tp, u16 addr, u16 clear)
+{
+	int data;
+
+	data = r8152_mdio_read(tp, addr);
+	if (data < 0)
+		goto out;
+
+	data = r8152_mdio_write(tp, addr, data & ~clear);
+
+out:
+	return data;
+}
+
+static int r8152_mdio_test_and_clr_bit(struct r8152 *tp, u16 addr, u16 clear)
+{
+	int data, ret;
+
+	ret = r8152_mdio_read(tp, addr);
+	if (ret < 0)
+		goto out;
+
+	data = ret;
+	if (data & clear) {
+		data &= ~clear;
+		ret = r8152_mdio_write(tp, addr, data);
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = !!(data & clear);
+
+out:
+	return ret;
+}
+
+static int wait_adv_cmd_ready(struct r8152 *tp)
+{
+	int i, ret;
+
+	for (i = 0; i < 10; i++) {
+		u32 ocp_data;
+
+		ret = ocp_read_word(tp, MCU_TYPE_USB, USB_ADV_CMD, &ocp_data);
+		if (ret < 0)
+			break;
+		else if (!(ocp_data & ADV_CMD_BUSY))
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	if (i == 10)
+		ret = -ETIMEDOUT;
+
+	return ret;
+}
+
+static int
+ocp_adv_access(struct r8152 *tp, int type, u16 addr, u32 *data, bool write)
+{
+	u16 cmd;
+	int ret;
+
+	switch (type) {
+	case ADV_TYPE_BMU:
+		cmd = ADV_CMD_BMU;
+		break;
+	case ADV_TYPE_IP:
+		cmd = ADV_CMD_IP;
+		break;
+	default:
+		WARN_ON_ONCE(1);
+		return -EPERM;
+	}
+
+	ret = wait_adv_cmd_ready(tp);
+	if (ret < 0)
+		goto out;
+
+	if (write) {
+		cmd |= ADV_CMD_WR;
+		ret = ocp_write_dword(tp, MCU_TYPE_USB, USB_ADV_DATA, *data);
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_ADV_ADDR, addr);
+	if (ret < 0)
+		goto out;
+
+	cmd |= ADV_CMD_BUSY;
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_ADV_CMD, cmd);
+	if (ret < 0)
+		goto out;
+
+	if (!write) {
+		ret = wait_adv_cmd_ready(tp);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_read_dword(tp, MCU_TYPE_USB, USB_ADV_DATA, data);
+	}
+
+out:
+	return ret;
+}
+
+static int rtl_bmu_read(struct r8152 *tp, u16 addr, u32 *data)
+{
+	return ocp_adv_access(tp, ADV_TYPE_BMU, addr, data, false);
+}
+
+static int rtl_bmu_write(struct r8152 *tp, u16 addr, u32 data)
+{
+	return ocp_adv_access(tp, ADV_TYPE_BMU, addr, &data, true);
+}
+
+static int rtl_bmu_w0w1(struct r8152 *tp, u16 addr, u32 clear, u32 set)
+{
+	u32 bmu;
+	int ret;
+
+	ret = rtl_bmu_read(tp, addr, &bmu);
+	if (ret < 0)
+		goto out;
+
+	bmu = (bmu & ~clear) | set;
+	ret = rtl_bmu_write(tp, addr, bmu);
+
+out:
+	return ret;
+}
+
+static int rtl_bmu_clr_bits(struct r8152 *tp, u16 addr, u32 clear)
+{
+	return rtl_bmu_w0w1(tp, addr, clear, 0);
+}
+
+static int rtl_bmu_set_bits(struct r8152 *tp, u16 addr, u32 set)
+{
+	return rtl_bmu_w0w1(tp, addr, 0, set);
+}
+
+static int rtl_ip_read(struct r8152 *tp, u16 addr, u32 *data)
+{
+	return ocp_adv_access(tp, ADV_TYPE_IP, addr, data, false);
+}
+
+static int rtl_ip_write(struct r8152 *tp, u16 addr, u32 data)
+{
+	return ocp_adv_access(tp, ADV_TYPE_IP, addr, &data, true);
+}
+
+static int rtl_ip_w0w1(struct r8152 *tp, u16 addr, u32 clear, u32 set)
+{
+	int ret;
+	u32 ip;
+
+	ret = rtl_ip_read(tp, addr, &ip);
+	if (ret < 0)
+		goto out;
+
+	ip = (ip & ~clear) | set;
+	ret = rtl_ip_write(tp, addr, ip);
+
+out:
+	return ret;
+}
+
+static int rtl_ip_clr_bits(struct r8152 *tp, u16 addr, u32 clear)
+{
+	return rtl_ip_w0w1(tp, addr, clear, 0);
+}
+
+static int rtl_ip_set_bits(struct r8152 *tp, u16 addr, u32 set)
+{
+	return rtl_ip_w0w1(tp, addr, 0, set);
+}
+
+static int wait_tgphy_cmd_ready(struct r8152 *tp)
+{
+	int i, ret;
+
+	for (i = 0; i < 10; i++) {
+		u32 ocp_data;
+
+		ret = ocp_read_word(tp, MCU_TYPE_USB, USB_TGPHY_CMD, &ocp_data);
+		if (ret < 0)
+			break;
+		else if (!(ocp_data & TGPHY_CMD_BUSY))
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	if (i == 10)
+		ret = -ETIMEDOUT;
+
+	return ret;
+}
+
+static int rtl_tgphy_access(struct r8152 *tp, u16 addr, u16 *data, bool write)
+{
+	u16 cmd = 0;
+	int ret;
+
+	ret = wait_tgphy_cmd_ready(tp);
+	if (ret < 0)
+		goto out;
+
+	if (write) {
+		cmd |= TGPHY_CMD_WR;
+		ret = ocp_write_word(tp, MCU_TYPE_USB, USB_TGPHY_DATA, *data);
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_TGPHY_ADDR, addr);
+	if (ret < 0)
+		goto out;
+
+	cmd |= TGPHY_CMD_BUSY;
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_TGPHY_CMD, cmd);
+	if (ret < 0)
+		goto out;
+
+	if (!write) {
+		u32 ocp_data;
+
+		ret = wait_tgphy_cmd_ready(tp);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_read_word(tp, MCU_TYPE_USB, USB_TGPHY_DATA,
+				    &ocp_data);
+		if (ret < 0)
+			goto out;
+
+		*data = (u16)ocp_data;
+	}
+
+out:
+	return ret;
+}
+
+static int r8157_phy_read(struct r8152 *tp, u16 addr, u16 *data)
+{
+	return rtl_tgphy_access(tp, addr, data, false);
+}
+
+static int r8157_phy_write(struct r8152 *tp, u16 addr, u16 data)
+{
+	return rtl_tgphy_access(tp, addr, &data, true);
+}
+
+static int
+r8152_submit_rx(struct r8152 *tp, struct rx_agg *agg, gfp_t mem_flags);
+
+static int
+rtl8152_set_speed(struct r8152 *tp, u8 autoneg, u32 speed, u8 duplex,
+		  u32 advertising);
+
+static int __rtl8152_set_mac_address(struct net_device *netdev, void *p,
+				     bool in_resume)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	struct sockaddr *addr = p;
+	int ret = -EADDRNOTAVAIL;
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		goto out1;
+
+	if (!in_resume) {
+		ret = usb_autopm_get_interface(tp->intf);
+		if (ret < 0)
+			goto out1;
+	}
+
+	mutex_lock(&tp->control);
+
+	eth_hw_addr_set(netdev, addr->sa_data);
+
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
+	pla_ocp_write(tp, PLA_IDR, BYTE_EN_SIX_BYTES, 8, addr->sa_data);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
+
+	mutex_unlock(&tp->control);
+
+	if (!in_resume)
+		usb_autopm_put_interface(tp->intf);
+out1:
+	return ret;
+}
+
+static int rtl8152_set_mac_address(struct net_device *netdev, void *p)
+{
+	return __rtl8152_set_mac_address(netdev, p, false);
+}
+
+static int rtl_mapt_read(struct r8152 *tp, char *mac_obj_name,
+			 acpi_object_type mac_obj_type, int mac_strlen,
+			 struct sockaddr *sa)
+{
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+	unsigned char buf[6];
+	acpi_status status;
+	int ret = -EINVAL;
+
+	/* returns _AUXMAC_#AABBCCDDEEFF# */
+	status = acpi_evaluate_object(NULL, mac_obj_name, NULL, &buffer);
+	obj = (union acpi_object *)buffer.pointer;
+	if (!ACPI_SUCCESS(status))
+		return -ENODEV;
+	if (obj->type != mac_obj_type || obj->string.length != mac_strlen) {
+		netif_warn(tp, probe, tp->netdev,
+			   "Invalid buffer for pass-thru MAC addr: (%d, %d)\n",
+			   obj->type, obj->string.length);
+		goto amacout;
+	}
+
+	if (strncmp(obj->string.pointer, "_AUXMAC_#", 9) != 0 ||
+	    strncmp(obj->string.pointer + 0x15, "#", 1) != 0) {
+		netif_warn(tp, probe, tp->netdev,
+			   "Invalid header when reading pass-thru MAC addr\n");
+		goto amacout;
+	}
+
+	ret = hex2bin(buf, obj->string.pointer + 9, sizeof(buf));
+	if (!(ret == 0 && is_valid_ether_addr(buf))) {
+		netif_warn(tp, probe, tp->netdev,
+			   "Invalid MAC for pass-thru MAC addr: %d, %pM\n",
+			   ret, buf);
+		ret = -EINVAL;
+		goto amacout;
+	}
+
+	memcpy(sa->sa_data, buf, sizeof(buf));
+	netif_info(tp, probe, tp->netdev,
+		   "Using pass-thru MAC addr %pM\n", sa->sa_data);
+
+amacout:
+	kfree(obj);
+	return ret;
+}
+
+/* Devices containing proper chips can support a persistent
+ * host system provided MAC address.
+ * Examples of this are Dell TB15 and Dell WD15 docks
+ */
+static int vendor_mac_passthru_addr_read(struct r8152 *tp, struct sockaddr *sa)
+{
+	int ret = -EOPNOTSUPP;
+
+	if (tp->dell_macpassthru)
+		ret = rtl_mapt_read(tp, "\\_SB.AMAC", ACPI_TYPE_BUFFER, 0x17,
+				    sa);
+	else if (tp->lenovo_macpassthru)
+		ret = rtl_mapt_read(tp, "\\MACA", ACPI_TYPE_STRING, 0x16, sa);
+
+	return ret;
+}
+
+static int rtl_hw_ether_addr(struct r8152 *tp, struct sockaddr *sa)
+{
+	u32 ocp_data = 0;
+	int ret;
+
+	if (tp->version == RTL_VER_05) {
+		/* Determine the hardware default ethernet address.
+		 * Check USB 0xcf0e bit 0
+		 *  1: read from USB 0xcf08
+		 *  0: read from PLA_BACKUP
+		 */
+		ret = ocp_read_byte(tp, MCU_TYPE_USB, 0xcf0e, &ocp_data);
+		if (ret < 0)
+			goto out;
+
+		if (ocp_data & BIT(0))
+			return usb_ocp_read(tp, 0xcf08, 8, sa->sa_data);
+
+		ocp_data |= BIT(0);
+	}
+
+	ret = pla_ocp_read(tp, PLA_BACKUP, 8, sa->sa_data);
+	if (ret < 0)
+		goto out;
+
+	if (tp->version == RTL_VER_05) {
+		/* Backup default ethernet address to USB 0xcf08.
+		 * Set USB 0xcf0e bit 0 to 1. Then, next time, read the default
+		 * ethernet address from USB 0xcf08 rather than PLA_BACKUP.
+		 */
+		ret = usb_ocp_write(tp, 0xcf08, BYTE_EN_SIX_BYTES, 8,
+				    sa->sa_data);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_write_byte(tp, MCU_TYPE_USB, 0xcf0e, ocp_data);
+		if (ret < 0)
+			goto out;
+	}
+
+out:
+	return ret;
+}
+
+static int determine_ethernet_addr(struct r8152 *tp, struct sockaddr *sa)
+{
+	struct net_device *dev = tp->netdev;
+	int ret;
+
+	sa->sa_family = dev->type;
+
+	ret = eth_platform_get_mac_address(&tp->udev->dev, sa->sa_data);
+	if (ret < 0) {
+		if (tp->version == RTL_VER_01) {
+			ret = pla_ocp_read(tp, PLA_IDR, 8, sa->sa_data);
+		} else {
+			/* if device doesn't support MAC pass through this will
+			 * be expected to be non-zero
+			 */
+			ret = vendor_mac_passthru_addr_read(tp, sa);
+			if (ret < 0)
+				ret = rtl_hw_ether_addr(tp, sa);
+		}
+	}
+
+	if (ret < 0) {
+		netif_err(tp, probe, dev, "Get ether addr fail\n");
+	} else if (!is_valid_ether_addr(sa->sa_data)) {
+		netif_err(tp, probe, dev, "Invalid ether addr %pM\n",
+			  sa->sa_data);
+		eth_hw_addr_random(dev);
+		ether_addr_copy(sa->sa_data, dev->dev_addr);
+		netif_info(tp, probe, dev, "Random ether addr %pM\n",
+			   sa->sa_data);
+		return 0;
+	}
+
+	return ret;
+}
+
+static int set_ethernet_addr(struct r8152 *tp, bool in_resume)
+{
+	struct net_device *dev = tp->netdev;
+	struct sockaddr sa;
+	int ret;
+
+	ret = determine_ethernet_addr(tp, &sa);
+	if (ret < 0)
+		return ret;
+
+	if (tp->version == RTL_VER_01)
+		eth_hw_addr_set(dev, sa.sa_data);
+	else
+		ret = __rtl8152_set_mac_address(dev, &sa, in_resume);
+
+	return ret;
+}
+
+static inline struct net_device_stats *rtl8152_get_stats(struct net_device *dev)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	struct rtl8152 *tp = netdev_priv(dev);
+
+	return (struct net_device_stats *)&tp->stats;
+#else
+	return &dev->stats;
+#endif
+}
+
+static void read_bulk_callback(struct urb *urb)
+{
+	struct net_device *netdev;
+	int status = urb->status;
+	struct rx_agg *agg;
+	struct r8152 *tp;
+	unsigned long flags;
+
+	agg = urb->context;
+	if (!agg)
+		return;
+
+	tp = agg->context;
+	if (!tp)
+		return;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (!test_bit(WORK_ENABLE, &tp->flags))
+		return;
+
+	netdev = tp->netdev;
+
+	/* When link down, the driver would cancel all bulks. */
+	/* This avoid the re-submitting bulk */
+	if (!netif_carrier_ok(netdev))
+		return;
+
+	usb_mark_last_busy(tp->udev);
+
+	switch (status) {
+	case 0:
+		if (urb->actual_length < ETH_ZLEN)
+			break;
+
+		spin_lock_irqsave(&tp->rx_lock, flags);
+		list_add_tail(&agg->list, &tp->rx_done);
+		spin_unlock_irqrestore(&tp->rx_lock, flags);
+		napi_schedule(&tp->napi);
+		return;
+	case -ESHUTDOWN:
+		rtl_set_unplug(tp);
+		netif_device_detach(tp->netdev);
+		return;
+	case -EPROTO:
+		urb->actual_length = 0;
+		spin_lock_irqsave(&tp->rx_lock, flags);
+		list_add_tail(&agg->list, &tp->rx_done);
+		spin_unlock_irqrestore(&tp->rx_lock, flags);
+		set_bit(RX_EPROTO, &tp->flags);
+		schedule_delayed_work(&tp->schedule, 1);
+		return;
+	case -ENOENT:
+		return;	/* the urb is in unlink state */
+	case -ETIME:
+		if (net_ratelimit())
+			netif_warn(tp, rx_err, netdev,
+				   "maybe reset is needed?\n");
+		break;
+	default:
+		if (net_ratelimit())
+			netif_warn(tp, rx_err, netdev,
+				   "Rx status %d\n", status);
+		break;
+	}
+
+	r8152_submit_rx(tp, agg, GFP_ATOMIC);
+}
+
+static void write_bulk_callback(struct urb *urb)
+{
+	struct net_device_stats *stats;
+	struct net_device *netdev;
+	struct tx_agg *agg;
+	struct r8152 *tp;
+	unsigned long flags;
+	int status = urb->status;
+
+	agg = urb->context;
+	if (!agg)
+		return;
+
+	tp = agg->context;
+	if (!tp)
+		return;
+
+	netdev = tp->netdev;
+	stats = rtl8152_get_stats(netdev);
+	if (status) {
+		if (net_ratelimit())
+			netif_warn(tp, tx_err, netdev,
+				   "Tx status %d\n", status);
+		stats->tx_errors += agg->skb_num;
+	} else {
+		stats->tx_packets += agg->skb_num;
+		stats->tx_bytes += agg->skb_bytes;
+	}
+
+	netdev_completed_queue(netdev, agg->skb_num, agg->skb_bytes);
+
+	spin_lock_irqsave(&tp->tx_lock, flags);
+	list_add_tail(&agg->list, &tp->tx_free);
+	spin_unlock_irqrestore(&tp->tx_lock, flags);
+
+	usb_autopm_put_interface_async(tp->intf);
+
+	if (!netif_carrier_ok(netdev))
+		return;
+
+	if (!test_bit(WORK_ENABLE, &tp->flags))
+		return;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (!skb_queue_empty(&tp->tx_queue))
+		tasklet_schedule(&tp->tx_tl);
+}
+
+static void write_bulk_sg_callback(struct urb *urb)
+{
+	struct net_device_stats *stats;
+	struct net_device *netdev;
+	int status = urb->status;
+	unsigned long flags;
+	struct tx_agg *agg;
+	struct r8152 *tp;
+
+	agg = urb->context;
+	if (!agg)
+		return;
+
+	tp = agg->context;
+	if (!tp)
+		return;
+
+	netdev = tp->netdev;
+	if (status && net_ratelimit())
+		netif_warn(tp, tx_err, netdev, "Tx status %d\n", status);
+
+	stats = rtl8152_get_stats(netdev);
+
+	while (!skb_queue_empty(&agg->tx_skb)) {
+		struct sk_buff *skb = __skb_dequeue(&agg->tx_skb);
+
+		if (status)
+			dev_kfree_skb_any(skb);
+		else
+			dev_consume_skb_any(skb);
+	}
+
+	if (status) {
+		stats->tx_errors += agg->skb_num;
+	} else {
+		stats->tx_packets += agg->skb_num;
+		stats->tx_bytes += agg->skb_bytes;
+	}
+
+	netdev_completed_queue(netdev, agg->skb_num, agg->skb_bytes);
+
+	spin_lock_irqsave(&tp->tx_lock, flags);
+	list_add_tail(&agg->list, &tp->tx_free);
+	spin_unlock_irqrestore(&tp->tx_lock, flags);
+
+	usb_autopm_put_interface_async(tp->intf);
+
+	if (!netif_carrier_ok(netdev))
+		return;
+
+	if (!test_bit(WORK_ENABLE, &tp->flags))
+		return;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (!skb_queue_empty(&tp->tx_queue))
+		tasklet_schedule(&tp->tx_tl);
+}
+
+static void intr_callback(struct urb *urb)
+{
+	struct r8152 *tp;
+	__le16 *d;
+	int status = urb->status;
+	int res;
+
+	tp = urb->context;
+	if (!tp)
+		return;
+
+	if (!test_bit(WORK_ENABLE, &tp->flags))
+		return;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	switch (status) {
+	case 0:			/* success */
+		break;
+	case -ECONNRESET:	/* unlink */
+	case -ESHUTDOWN:
+		netif_device_detach(tp->netdev);
+		fallthrough;
+	case -ENOENT:
+	case -EPROTO:
+		netif_info(tp, intr, tp->netdev,
+			   "Stop submitting intr, status %d\n", status);
+		return;
+	case -EOVERFLOW:
+		if (net_ratelimit())
+			netif_info(tp, intr, tp->netdev,
+				   "intr status -EOVERFLOW\n");
+		goto resubmit;
+	/* -EPIPE:  should clear the halt */
+	default:
+		netif_info(tp, intr, tp->netdev, "intr status %d\n", status);
+		goto resubmit;
+	}
+
+	d = urb->transfer_buffer;
+	if (INTR_LINK & __le16_to_cpu(d[0])) {
+		if (!netif_carrier_ok(tp->netdev)) {
+			set_bit(RTL8152_LINK_CHG, &tp->flags);
+			schedule_delayed_work(&tp->schedule, 0);
+		}
+	} else {
+		if (netif_carrier_ok(tp->netdev)) {
+			netif_stop_queue(tp->netdev);
+			set_bit(RTL8152_LINK_CHG, &tp->flags);
+			schedule_delayed_work(&tp->schedule, 0);
+		}
+	}
+
+resubmit:
+	res = usb_submit_urb(urb, GFP_ATOMIC);
+	if (res == -ENODEV) {
+		rtl_set_unplug(tp);
+		netif_device_detach(tp->netdev);
+	} else if (res) {
+		netif_err(tp, intr, tp->netdev,
+			  "can't resubmit intr, status %d\n", res);
+	}
+}
+
+static void *rx_agg_align(struct r8152 *tp, void *data)
+{
+	return (void *)ALIGN((uintptr_t)data, tp->rx_desc.align);
+}
+
+static void *tx_agg_align(struct r8152 *tp, void *data)
+{
+	return (void *)ALIGN((uintptr_t)data, tp->tx_desc.align);
+}
+
+static void free_rx_agg(struct r8152 *tp, struct rx_agg *agg)
+{
+	list_del(&agg->info_list);
+
+	usb_free_urb(agg->urb);
+	put_page(agg->page);
+	kfree(agg);
+
+	atomic_dec(&tp->rx_count);
+}
+
+static struct rx_agg *alloc_rx_agg(struct r8152 *tp, gfp_t mflags)
+{
+	struct net_device *netdev = tp->netdev;
+	int node = netdev->dev.parent ? dev_to_node(netdev->dev.parent) : -1;
+	unsigned int order = get_order(tp->rx_buf_sz);
+	struct rx_agg *rx_agg;
+	unsigned long flags;
+
+	rx_agg = kmalloc_node(sizeof(*rx_agg), mflags, node);
+	if (!rx_agg)
+		return NULL;
+
+	rx_agg->page = alloc_pages(mflags | __GFP_COMP | __GFP_NOWARN, order);
+	if (!rx_agg->page)
+		goto free_rx;
+
+	rx_agg->buffer = page_address(rx_agg->page);
+
+	rx_agg->urb = usb_alloc_urb(0, mflags);
+	if (!rx_agg->urb)
+		goto free_buf;
+
+	rx_agg->context = tp;
+
+	INIT_LIST_HEAD(&rx_agg->list);
+	INIT_LIST_HEAD(&rx_agg->info_list);
+	spin_lock_irqsave(&tp->rx_lock, flags);
+	list_add_tail(&rx_agg->info_list, &tp->rx_info);
+	spin_unlock_irqrestore(&tp->rx_lock, flags);
+
+	atomic_inc(&tp->rx_count);
+
+	return rx_agg;
+
+free_buf:
+	__free_pages(rx_agg->page, order);
+free_rx:
+	kfree(rx_agg);
+	return NULL;
+}
+
+static void free_all_mem(struct r8152 *tp)
+{
+	struct rx_agg *agg, *agg_next;
+	unsigned long flags;
+	int i;
+
+	spin_lock_irqsave(&tp->rx_lock, flags);
+
+	list_for_each_entry_safe(agg, agg_next, &tp->rx_info, info_list)
+		free_rx_agg(tp, agg);
+
+	spin_unlock_irqrestore(&tp->rx_lock, flags);
+
+	WARN_ON(atomic_read(&tp->rx_count));
+
+	for (i = 0; i < RTL8152_MAX_TX; i++) {
+		usb_free_urb(tp->tx_info[i].urb);
+		tp->tx_info[i].urb = NULL;
+
+		kfree(tp->tx_info[i].buffer);
+		tp->tx_info[i].buffer = NULL;
+		tp->tx_info[i].head = NULL;
+		WARN_ON(!skb_queue_empty(&tp->tx_info[i].tx_skb));
+	}
+
+	usb_free_urb(tp->intr_urb);
+	tp->intr_urb = NULL;
+
+	kfree(tp->intr_buff);
+	tp->intr_buff = NULL;
+}
+
+static int alloc_all_mem(struct r8152 *tp)
+{
+	struct net_device *netdev = tp->netdev;
+	struct usb_interface *intf = tp->intf;
+	struct usb_host_interface *alt = intf->cur_altsetting;
+	struct usb_host_endpoint *ep_intr = alt->endpoint + 2;
+	int node, i;
+
+	node = netdev->dev.parent ? dev_to_node(netdev->dev.parent) : -1;
+
+	spin_lock_init(&tp->rx_lock);
+	spin_lock_init(&tp->tx_lock);
+	INIT_LIST_HEAD(&tp->rx_info);
+	INIT_LIST_HEAD(&tp->tx_free);
+	INIT_LIST_HEAD(&tp->rx_done);
+	skb_queue_head_init(&tp->tx_queue);
+	skb_queue_head_init(&tp->rx_queue);
+	atomic_set(&tp->rx_count, 0);
+
+	for (i = 0; i < RTL8152_MAX_RX; i++) {
+		if (!alloc_rx_agg(tp, GFP_KERNEL))
+			goto err1;
+	}
+
+	for (i = 0; i < RTL8152_MAX_TX; i++) {
+		struct urb *urb;
+		u8 *buf;
+
+		buf = kmalloc_node(agg_buf_sz, GFP_KERNEL, node);
+		if (!buf)
+			goto err1;
+
+		if (buf != tx_agg_align(tp, buf)) {
+			kfree(buf);
+			buf = kmalloc_node(agg_buf_sz + tp->tx_desc.align,
+					   GFP_KERNEL, node);
+			if (!buf)
+				goto err1;
+		}
+
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			kfree(buf);
+			goto err1;
+		}
+
+		INIT_LIST_HEAD(&tp->tx_info[i].list);
+		tp->tx_info[i].context = tp;
+		tp->tx_info[i].urb = urb;
+		tp->tx_info[i].buffer = buf;
+		tp->tx_info[i].head = tx_agg_align(tp, buf);
+
+		list_add_tail(&tp->tx_info[i].list, &tp->tx_free);
+		skb_queue_head_init(&tp->tx_info[i].tx_skb);
+	}
+
+	tp->intr_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!tp->intr_urb)
+		goto err1;
+
+	tp->intr_buff = kmalloc(INTBUFSIZE, GFP_KERNEL);
+	if (!tp->intr_buff)
+		goto err1;
+
+	tp->intr_interval = (int)ep_intr->desc.bInterval;
+	usb_fill_int_urb(tp->intr_urb, tp->udev, tp->pipe_intr,
+			 tp->intr_buff, INTBUFSIZE, intr_callback,
+			 tp, tp->intr_interval);
+
+	return 0;
+
+err1:
+	free_all_mem(tp);
+	return -ENOMEM;
+}
+
+static struct tx_agg *r8152_get_tx_agg(struct r8152 *tp)
+{
+	struct tx_agg *agg = NULL;
+	unsigned long flags;
+
+	if (list_empty(&tp->tx_free))
+		return NULL;
+
+	spin_lock_irqsave(&tp->tx_lock, flags);
+	if (!list_empty(&tp->tx_free)) {
+		struct list_head *cursor;
+
+		cursor = tp->tx_free.next;
+		list_del_init(cursor);
+		agg = list_entry(cursor, struct tx_agg, list);
+	}
+	spin_unlock_irqrestore(&tp->tx_lock, flags);
+
+	return agg;
+}
+
+/* r8152_csum_workaround()
+ * The hw limits the value of the transport offset. When the offset is out of
+ * range, calculate the checksum by sw.
+ */
+static void r8152_csum_workaround(struct r8152 *tp, struct sk_buff *skb,
+				  struct sk_buff_head *list)
+{
+	if (skb_shinfo(skb)->gso_size) {
+		netdev_features_t features = tp->netdev->features;
+		struct sk_buff *segs, *seg, *next;
+		struct sk_buff_head seg_list;
+
+		features &= ~(NETIF_F_SG | NETIF_F_IPV6_CSUM | NETIF_F_TSO6);
+		segs = skb_gso_segment(skb, features);
+		if (IS_ERR(segs) || !segs)
+			goto drop;
+
+		__skb_queue_head_init(&seg_list);
+
+		skb_list_walk_safe(segs, seg, next) {
+			skb_mark_not_on_list(seg);
+			netdev_sent_queue(tp->netdev, seg->len);
+			__skb_queue_tail(&seg_list, seg);
+		}
+
+		skb_queue_splice(&seg_list, list);
+		netdev_completed_queue(tp->netdev,
+				       skb_shinfo(skb)->gso_segs ?: 1, skb->len);
+		dev_kfree_skb(skb);
+	} else if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		if (skb_checksum_help(skb) < 0)
+			goto drop;
+
+		__skb_queue_head(list, skb);
+	} else {
+		struct net_device_stats *stats;
+
+drop:
+		stats = rtl8152_get_stats(tp->netdev);
+		stats->tx_dropped++;
+		dev_kfree_skb(skb);
+	}
+}
+
+static void r8152_rx_len(struct r8152 *tp, void *desc, u32 *len)
+{
+	struct rx_desc *d = desc;
+
+	*len = le32_to_cpu(d->opts1) & RX_LEN_MASK;
+}
+
+static bool r8152_tx_vlan_tag(struct r8152 *tp, void *d, struct sk_buff *skb)
+{
+	struct tx_desc *desc = d;
+
+	if (skb_vlan_tag_present(skb)) {
+		u32 opts2;
+
+		opts2 = TX_VLAN_TAG | swab16(skb_vlan_tag_get(skb));
+		desc->opts2 |= cpu_to_le32(opts2);
+		return true;
+	}
+	return false;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+static bool
+r8152_rx_vlan_tag(struct r8152 *tp, void *d, struct sk_buff *skb)
+{
+	struct rx_desc *desc = d;
+	u32 opts2 = le32_to_cpu(desc->opts2);
+
+	if (tp->vlgrp && (opts2 & RX_VLAN_TAG)) {
+		vlan_gro_receive(&tp->napi, tp->vlgrp, swab16(opts2 & 0xffff),
+				 skb);
+		return true;
+	}
+
+	return false;
+}
+
+static void
+r8152_vlan_put_tag(struct r8152 *tp, void *d, struct sk_buff *skb)
+{
+	struct rx_desc *desc = d;
+	u32 opts2 = le32_to_cpu(desc->opts2);
+
+	if (tp->vlgrp && (opts2 & RX_VLAN_TAG))
+		__vlan_hwaccel_put_tag(skb, swab16(opts2 & 0xffff));
+}
+
+static inline __u16
+rtl_vlan_get_tag(struct sk_buff *skb)
+{
+	__u16 tag;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+	__vlan_hwaccel_get_tag(skb, &tag);
+#else
+	tag = skb->vlan_tci;
+#endif
+
+	return tag;
+}
+
+#else
+static bool
+r8152_rx_vlan_tag(struct r8152 *tp, void *d, struct sk_buff *skb)
+{
+	struct rx_desc *desc = d;
+	u32 opts2 = le32_to_cpu(desc->opts2);
+
+	if (opts2 & RX_VLAN_TAG) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+		__vlan_hwaccel_put_tag(skb, swab16(opts2 & 0xffff));
+#else
+		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
+				       swab16(opts2 & 0xffff));
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) */
+		return true;
+	}
+	return false;
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) */
+
+static int r8152_tx_csum(struct r8152 *tp, void *tx_desc, struct sk_buff *skb)
+{
+	u32 mss = skb_shinfo(skb)->gso_size;
+	struct tx_desc *desc = tx_desc;
+	int ret = TX_CSUM_SUCCESS;
+	u32 opts1, opts2 = 0;
+
+	opts1 = TX_FS | TX_LS;
+
+	if (mss) {
+		u32 transport_offset = (u32)skb_transport_offset(skb);
+
+		if (transport_offset > GTTCPHO_MAX) {
+			netif_warn(tp, tx_err, tp->netdev,
+				   "Invalid transport offset 0x%x for TSO\n",
+				   transport_offset);
+			ret = TX_CSUM_TSO;
+			goto unavailable;
+		}
+
+		switch (vlan_get_protocol(skb)) {
+		case htons(ETH_P_IP):
+			opts1 |= GTSENDV4;
+			break;
+
+		case htons(ETH_P_IPV6):
+			if (skb_cow_head(skb, 0)) {
+				ret = TX_CSUM_TSO;
+				goto unavailable;
+			}
+			tcp_v6_gso_csum_prep(skb);
+			opts1 |= GTSENDV6;
+			break;
+
+		default:
+			WARN_ON_ONCE(1);
+			break;
+		}
+
+		opts1 |= transport_offset << GTTCPHO_SHIFT;
+		opts2 |= min(mss, MSS_MAX) << MSS_SHIFT;
+	} else if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		u32 transport_offset = (u32)skb_transport_offset(skb);
+		u8 ip_protocol;
+
+		if (transport_offset > TCPHO_MAX) {
+			netif_warn(tp, tx_err, tp->netdev,
+				   "Invalid transport offset 0x%x\n",
+				   transport_offset);
+			ret = TX_CSUM_NONE;
+			goto unavailable;
+		}
+
+		switch (vlan_get_protocol(skb)) {
+		case htons(ETH_P_IP):
+			opts2 |= IPV4_CS;
+			ip_protocol = ip_hdr(skb)->protocol;
+			break;
+
+		case htons(ETH_P_IPV6):
+			opts2 |= IPV6_CS;
+			ip_protocol = ipv6_hdr(skb)->nexthdr;
+			break;
+
+		default:
+			ip_protocol = IPPROTO_RAW;
+			break;
+		}
+
+		if (ip_protocol == IPPROTO_TCP)
+			opts2 |= TCP_CS;
+		else if (ip_protocol == IPPROTO_UDP)
+			opts2 |= UDP_CS;
+		else
+			WARN_ON_ONCE(1);
+
+		opts2 |= transport_offset << TCPHO_SHIFT;
+	}
+
+	desc->opts2 = cpu_to_le32(opts2);
+	desc->opts1 = cpu_to_le32(opts1);
+
+unavailable:
+	return ret;
+}
+
+static void r8152_tx_len(struct r8152 *tp, void *tx_desc, u32 *len)
+{
+	struct tx_desc *desc = tx_desc;
+
+	desc->opts1 |= cpu_to_le32(*len);
+}
+
+static void r8157_rx_len(struct r8152 *tp, void *desc, u32 *len)
+{
+	struct rx_desc_v2 *d = desc;
+
+	*len = rx_v2_get_len(le32_to_cpu(d->opts1));
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+static bool
+r8157_rx_vlan_tag(struct r8152 *tp, void *desc, struct sk_buff *skb)
+{
+	struct rx_desc_v2 *d = desc;
+	u32 opts1 = le32_to_cpu(d->opts1);
+
+	if (tp->vlgrp && (opts1 & RX_VLAN_TAG_2)) {
+		u32 opts2 = le32_to_cpu(d->opts2);
+
+		vlan_gro_receive(&tp->napi, tp->vlgrp,
+				 swab16((opts2 >> 16) & 0xffff), skb);
+		return true;
+	}
+	return false
+}
+
+static void
+r8157_vlan_put_tag(struct r8152 *tp, void *desc, struct sk_buff *skb)
+{
+	struct rx_desc_v2 *d = desc;
+	u32 opts1 = le32_to_cpu(d->opts1);
+
+	if (tp->vlgrp && (opts1 & RX_VLAN_TAG_2)) {
+		u32 opts2 = le32_to_cpu(d->opts2);
+
+		__vlan_hwaccel_put_tag(skb, swab16((opts2 >> 16) & 0xffff));
+	}
+}
+
+#else
+static bool
+r8157_rx_vlan_tag(struct r8152 *tp, void *desc, struct sk_buff *skb)
+{
+	struct rx_desc_v2 *d = desc;
+	u32 opts1 = le32_to_cpu(d->opts1);
+
+	if (opts1 & RX_VLAN_TAG_2) {
+		u32 opts2 = le32_to_cpu(d->opts2);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+		__vlan_hwaccel_put_tag(skb, swab16((opts2 >> 16) & 0xffff));
+#else
+		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
+				       swab16((opts2 >> 16) & 0xffff));
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) */
+		return true;
+	}
+	return false;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) */
+
+static int r8157_tx_csum(struct r8152 *tp, void *tx_desc, struct sk_buff *skb)
+{
+	u32 mss = skb_shinfo(skb)->gso_size;
+	int ret = TX_CSUM_SUCCESS;
+
+	if (!mss && skb->ip_summed == CHECKSUM_PARTIAL) {
+		u32 transport_offset = (u32)skb_transport_offset(skb);
+
+		if (transport_offset > TCPHO_MAX_2) {
+			netif_warn(tp, tx_err, tp->netdev,
+				   "Invalid transport offset 0x%x\n",
+				   transport_offset);
+			return TX_CSUM_NONE;
+		}
+	}
+
+	ret = r8152_tx_csum(tp, tx_desc, skb);
+
+	return ret;
+}
+
+static void r8157_tx_len(struct r8152 *tp, void *tx_desc, u32 *len)
+{
+	struct tx_desc_v2 *desc = tx_desc;
+
+	desc->opts3 = cpu_to_le32(tx_v2_set_len(*len));
+	desc->opts4 = cpu_to_le32(TX_SIG);
+}
+
+static int rtl_tx_csum(struct r8152 *tp, void *desc, struct sk_buff *skb,
+		       u32 len)
+{
+	int ret = TX_CSUM_SUCCESS;
+
+	WARN_ON_ONCE(len > TX_LEN_MAX);
+
+	ret = tp->tx_desc.csum(tp, desc, skb);
+	if (!ret)
+		tp->tx_desc.len(tp, desc, &len);
+
+	return ret;
+}
+
+static int r8152_tx_agg_fill(struct r8152 *tp, struct tx_agg *agg)
+{
+	struct sk_buff_head skb_head, *tx_queue = &tp->tx_queue;
+	struct net_device *netdev = tp->netdev;
+	int remain, ret;
+	u8 *tx_data;
+
+	__skb_queue_head_init(&skb_head);
+	spin_lock(&tx_queue->lock);
+	skb_queue_splice_init(tx_queue, &skb_head);
+	spin_unlock(&tx_queue->lock);
+
+	tx_data = agg->head;
+	agg->skb_num = 0;
+	agg->skb_len = 0;
+	agg->skb_bytes = 0;
+	remain = agg_buf_sz;
+
+	while (remain >= ETH_ZLEN + tp->tx_desc.size) {
+		struct sk_buff *skb;
+		unsigned int len;
+		void *tx_desc;
+
+		skb = __skb_dequeue(&skb_head);
+		if (!skb)
+			break;
+
+		len = skb->len + tp->tx_desc.size;
+
+		if (len > remain) {
+			__skb_queue_head(&skb_head, skb);
+			break;
+		}
+
+		tx_data = tx_agg_align(tp, tx_data);
+		tx_desc = (void *)tx_data;
+
+		if (rtl_tx_csum(tp, tx_desc, skb, skb->len)) {
+			r8152_csum_workaround(tp, skb, &skb_head);
+			continue;
+		}
+
+		tp->tx_desc.vlan_tag(tp, tx_desc, skb);
+
+		tx_data += tp->tx_desc.size;
+
+		len = skb->len;
+		if (skb_copy_bits(skb, 0, tx_data, len) < 0) {
+			struct net_device_stats *stats = &netdev->stats;
+
+			netdev_completed_queue(netdev,
+					       skb_shinfo(skb)->gso_segs ?: 1,
+					       len);
+			stats->tx_dropped++;
+			dev_kfree_skb_any(skb);
+			tx_data -= tp->tx_desc.size;
+			continue;
+		}
+
+		tx_data += len;
+		agg->skb_bytes += len;
+		agg->skb_num += skb_shinfo(skb)->gso_segs ?: 1;
+
+		dev_consume_skb_any(skb);
+
+		remain = agg_buf_sz -
+			 (int)(tx_agg_align(tp, tx_data) - agg->head);
+	}
+
+	if (!skb_queue_empty(&skb_head)) {
+		spin_lock(&tx_queue->lock);
+		skb_queue_splice(&skb_head, tx_queue);
+		spin_unlock(&tx_queue->lock);
+	}
+
+	netif_tx_lock(netdev);
+
+	if (netif_queue_stopped(netdev) &&
+	    skb_queue_len(&tp->tx_queue) < tp->tx_qlen)
+		netif_wake_queue(netdev);
+
+	netif_tx_unlock(netdev);
+
+	ret = usb_autopm_get_interface_async(tp->intf);
+	if (ret < 0)
+		goto out_tx_fill;
+
+	usb_fill_bulk_urb(agg->urb, tp->udev, tp->pipe_out,
+			  agg->head, (int)(tx_data - (u8 *)agg->head),
+			  (usb_complete_t)write_bulk_callback, agg);
+
+	agg->urb->sg = NULL;
+	agg->urb->num_sgs = 0;
+
+	ret = usb_submit_urb(agg->urb, GFP_ATOMIC);
+	if (ret < 0)
+		usb_autopm_put_interface_async(tp->intf);
+
+out_tx_fill:
+	if (ret < 0)
+		netdev_completed_queue(netdev, agg->skb_num, agg->skb_bytes);
+
+	return ret;
+}
+
+static int r8152_tx_agg_sg_fill(struct r8152 *tp, struct tx_agg *agg)
+{
+	struct sk_buff_head skb_head, *tx_queue = &tp->tx_queue;
+	struct net_device *netdev = tp->netdev;
+	int max_sg_num, ret, sg_num;
+	struct scatterlist *sg;
+	int padding = 0;
+
+	__skb_queue_head_init(&skb_head);
+	spin_lock(&tx_queue->lock);
+	skb_queue_splice_init(tx_queue, &skb_head);
+	spin_unlock(&tx_queue->lock);
+
+	sg = agg->head;
+	max_sg_num = (agg_buf_sz / sizeof(*sg)) - 1;
+	max_sg_num = min_t(int, RTL_MAX_SG_NUM, max_sg_num);
+	sg_init_table(sg, max_sg_num + 1);
+	agg->skb_num = 0;
+	agg->skb_len = 0;
+	agg->skb_bytes = 0;
+
+	for (sg_num = 0; sg_num < max_sg_num;) {
+		struct sk_buff *skb;
+		int num_sgs, headroom;
+		unsigned int len;
+		union {
+			struct tx_desc v1;
+			struct tx_desc_v2 v2;
+		} tx_desc;
+
+		skb = __skb_dequeue(&skb_head);
+		if (!skb)
+			break;
+
+		headroom = skb_headroom(skb) - padding - tp->tx_desc.size;
+
+		if (skb_header_cloned(skb) || headroom < 0) {
+			struct sk_buff *tx_skb;
+
+			headroom = padding + tp->tx_desc.size;
+			tx_skb = skb_copy_expand(skb, headroom, 0, GFP_ATOMIC);
+			if (!tx_skb) {
+				__skb_queue_head(&skb_head, skb);
+				break;
+			}
+			dev_kfree_skb_any(skb);
+			skb = tx_skb;
+			headroom = skb_headroom(skb) - headroom;
+		}
+
+		 /* calculate the fragment numbers for skb */
+		num_sgs = 1 + skb_shinfo(skb)->nr_frags;
+		len = skb->len;
+
+		if ((num_sgs + sg_num) > max_sg_num) {
+			__skb_queue_head(&skb_head, skb);
+			break;
+		}
+
+		if (rtl_tx_csum(tp, &tx_desc, skb, len)) {
+			r8152_csum_workaround(tp, skb, &skb_head);
+			continue;
+		}
+
+		tp->tx_desc.vlan_tag(tp, &tx_desc, skb);
+
+		WARN_ON(padding < 0);
+
+		/* use skb_headroom for tx desc */
+		skb->cb[0] = padding + tp->tx_desc.size;
+		memcpy(skb_push(skb, tp->tx_desc.size), &tx_desc,
+		       tp->tx_desc.size);
+		if (padding)
+			memset(skb_push(skb, padding), 0, padding);
+
+		num_sgs = skb_to_sgvec_nomark(skb, sg, 0, skb->len);
+		if (num_sgs < 0) {
+			netif_err(tp, tx_err, netdev,
+				  "skb_to_sgvec fail %d\n", num_sgs);
+			__skb_queue_head(&skb_head, skb);
+			break;
+		}
+
+		sg += num_sgs;
+
+		__skb_queue_tail(&agg->tx_skb, skb);
+
+		sg_num += num_sgs;
+		agg->skb_len += skb->len;
+		agg->skb_bytes += len;
+		agg->skb_num += skb_shinfo(skb)->gso_segs ?: 1;
+
+		padding = len + tp->tx_desc.size;
+		padding = ALIGN(padding, tp->tx_desc.align) - padding;
+	}
+
+	if (!skb_queue_empty(&skb_head)) {
+		spin_lock(&tx_queue->lock);
+		skb_queue_splice(&skb_head, tx_queue);
+		spin_unlock(&tx_queue->lock);
+	}
+
+	netif_tx_lock(netdev);
+
+	if (netif_queue_stopped(netdev) &&
+	    skb_queue_len(&tp->tx_queue) < tp->tx_qlen)
+		netif_wake_queue(netdev);
+
+	netif_tx_unlock(netdev);
+
+	if (sg_num == 0) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&tp->tx_lock, flags);
+		list_add_tail(&agg->list, &tp->tx_free);
+		spin_unlock_irqrestore(&tp->tx_lock, flags);
+
+		ret = 0;
+		goto out_tx_fill;
+	}
+
+	ret = usb_autopm_get_interface_async(tp->intf);
+	if (ret < 0)
+		goto out_tx_fill;
+
+	sg_mark_end(sg);
+
+	usb_fill_bulk_urb(agg->urb, tp->udev, tp->pipe_out,
+			  NULL, (int)agg->skb_len,
+			  (usb_complete_t)write_bulk_sg_callback, agg);
+
+	agg->urb->sg = agg->head;
+	agg->urb->num_sgs = sg_num;
+
+	ret = usb_submit_urb(agg->urb, GFP_ATOMIC);
+	if (ret < 0)
+		usb_autopm_put_interface_async(tp->intf);
+
+out_tx_fill:
+	if (ret < 0) {
+		netdev_completed_queue(netdev, agg->skb_num, agg->skb_bytes);
+		while (!skb_queue_empty(&agg->tx_skb))
+			dev_kfree_skb_any(__skb_dequeue(&agg->tx_skb));
+	}
+
+	return ret;
+}
+
+static int
+r8152_rx_csum(struct r8152 *tp, void *d, struct sk_buff *skb)
+{
+	struct rx_desc *rx_desc = d;
+	u8 checksum = CHECKSUM_NONE;
+	u32 opts2, opts3;
+
+	if (!(tp->netdev->features & NETIF_F_RXCSUM))
+		goto return_result;
+
+	opts2 = le32_to_cpu(rx_desc->opts2);
+	opts3 = le32_to_cpu(rx_desc->opts3);
+
+	if (opts2 & RD_IPV4_CS) {
+		if (opts3 & IPF)
+			checksum = CHECKSUM_NONE;
+		else if ((opts2 & RD_UDP_CS) && !(opts3 & UDPF))
+			checksum = CHECKSUM_UNNECESSARY;
+		else if ((opts2 & RD_TCP_CS) && !(opts3 & TCPF))
+			checksum = CHECKSUM_UNNECESSARY;
+	} else if (opts2 & RD_IPV6_CS) {
+		if ((opts2 & RD_UDP_CS) && !(opts3 & UDPF))
+			checksum = CHECKSUM_UNNECESSARY;
+		else if ((opts2 & RD_TCP_CS) && !(opts3 & TCPF))
+			checksum = CHECKSUM_UNNECESSARY;
+	}
+
+return_result:
+	skb->ip_summed = checksum;
+
+	return 0;
+}
+
+static int
+r8157_rx_csum(struct r8152 *tp, void *desc, struct sk_buff *skb)
+{
+	struct rx_desc_v2 *d = desc;
+	u8 checksum = CHECKSUM_NONE;
+	u32 opts3;
+
+	if (!(tp->netdev->features & NETIF_F_RXCSUM))
+		goto return_result;
+
+	opts3 = le32_to_cpu(d->opts3);
+
+	if ((opts3 & (RD_IPV4_CS_2 | IPF_2)) == (RD_IPV4_CS_2 | IPF_2)) {
+		checksum = CHECKSUM_NONE;
+	} else if (opts3 & (RD_IPV4_CS_2 | RD_IPV6_CS_2)) {
+		if ((opts3 & (RD_UDP_CS_2 | UDPF_2)) ==  RD_UDP_CS_2)
+			checksum = CHECKSUM_UNNECESSARY;
+		else if ((opts3 & (RD_TCP_CS_2 | TCPF_2)) == RD_TCP_CS_2)
+			checksum = CHECKSUM_UNNECESSARY;
+	}
+
+return_result:
+	skb->ip_summed = checksum;
+
+	return  0;
+}
+
+static inline bool rx_count_exceed(struct r8152 *tp)
+{
+	return atomic_read(&tp->rx_count) > RTL8152_MAX_RX;
+}
+
+static int agg_offset(struct rx_agg *agg, void *addr)
+{
+	WARN_ON_ONCE(agg->buffer > addr);
+	return (int)(addr - agg->buffer);
+}
+
+static struct rx_agg *rtl_get_free_rx(struct r8152 *tp, gfp_t mflags)
+{
+	struct rx_agg *agg, *agg_next, *agg_free = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&tp->rx_lock, flags);
+
+	list_for_each_entry_safe(agg, agg_next, &tp->rx_used, list) {
+		if (page_count(agg->page) == 1) {
+			if (!agg_free) {
+				list_del_init(&agg->list);
+				agg_free = agg;
+				continue;
+			}
+			if (tp->rx_agg_free_ref) {
+				tp->rx_agg_free_ref--;
+			} else if (rx_count_exceed(tp)) {
+				list_del_init(&agg->list);
+				free_rx_agg(tp, agg);
+			}
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&tp->rx_lock, flags);
+
+	if (!agg_free && atomic_read(&tp->rx_count) < tp->rx_pending) {
+		agg_free = alloc_rx_agg(tp, mflags);
+		tp->rx_agg_free_ref += RTL8152_MAX_RX;
+	}
+
+	return agg_free;
+}
+
+static int rx_bottom(struct r8152 *tp, int budget)
+{
+	unsigned long flags;
+	struct list_head *cursor, *next, rx_queue;
+	int ret = 0, work_done = 0;
+	struct napi_struct *napi = &tp->napi;
+
+	if (!skb_queue_empty(&tp->rx_queue)) {
+		while (work_done < budget) {
+			struct sk_buff *skb = __skb_dequeue(&tp->rx_queue);
+			struct net_device *netdev = tp->netdev;
+			struct net_device_stats *stats;
+			unsigned int pkt_len;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+			u16 vlan_tci;
+#endif
+
+			if (!skb)
+				break;
+
+			pkt_len = skb->len;
+			stats = rtl8152_get_stats(netdev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+			vlan_tci = rtl_vlan_get_tag(skb);
+
+			if (vlan_tci)
+				vlan_gro_receive(napi, tp->vlgrp, vlan_tci,
+						 skb);
+			else
+				napi_gro_receive(napi, skb);
+#else
+			napi_gro_receive(napi, skb);
+#endif
+
+			work_done++;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+			netdev->last_rx = jiffies;
+#endif
+			stats->rx_packets++;
+			stats->rx_bytes += pkt_len;
+		}
+	}
+
+	if (list_empty(&tp->rx_done) || work_done >= budget)
+		goto out1;
+
+	clear_bit(RX_EPROTO, &tp->flags);
+	INIT_LIST_HEAD(&rx_queue);
+	spin_lock_irqsave(&tp->rx_lock, flags);
+	list_splice_init(&tp->rx_done, &rx_queue);
+	spin_unlock_irqrestore(&tp->rx_lock, flags);
+
+	list_for_each_safe(cursor, next, &rx_queue) {
+		struct rx_agg *agg, *agg_free;
+		int len_used = 0;
+		struct urb *urb;
+		void *rx_desc;
+		u8 *rx_data;
+
+		/* A bulk transfer of USB may contain may packets, so the
+		 * total packets may more than the budget. Deal with all
+		 * packets in current bulk transfer, and stop to handle the
+		 * next bulk transfer until next schedule, if budget is
+		 * exhausted.
+		 */
+		if (work_done >= budget)
+			break;
+
+		list_del_init(cursor);
+
+		agg = list_entry(cursor, struct rx_agg, list);
+		urb = agg->urb;
+		if (urb->status != 0 || urb->actual_length < ETH_ZLEN)
+			goto submit;
+
+		agg_free = rtl_get_free_rx(tp, GFP_ATOMIC);
+
+		rx_desc = agg->buffer;
+		rx_data = agg->buffer;
+		len_used += tp->rx_desc.size;
+
+		while (urb->actual_length > len_used) {
+			struct net_device *netdev = tp->netdev;
+			struct net_device_stats *stats;
+			unsigned int pkt_len, rx_frag_head_sz, len;
+			struct sk_buff *skb;
+			bool use_frags;
+
+			WARN_ON_ONCE(skb_queue_len(&tp->rx_queue) >= 1000);
+
+			tp->rx_desc.len(tp, rx_desc, &pkt_len);
+			if (pkt_len < ETH_ZLEN)
+				break;
+
+			len_used += pkt_len;
+			if (urb->actual_length < len_used)
+				break;
+
+			stats = rtl8152_get_stats(netdev);
+
+			pkt_len -= ETH_FCS_LEN;
+			len = pkt_len;
+			rx_data += tp->rx_desc.size;
+
+			if (!agg_free || tp->rx_copybreak > len)
+				use_frags = false;
+			else
+				use_frags = true;
+
+			if (use_frags) {
+				/* If the budget is exhausted, the packet
+				 * would be queued in the driver. That is,
+				 * napi_gro_frags() wouldn't be called, so
+				 * we couldn't use napi_get_frags().
+				 */
+				if (work_done >= budget) {
+					rx_frag_head_sz = tp->rx_copybreak;
+					skb = napi_alloc_skb(napi,
+							     rx_frag_head_sz);
+				} else {
+					rx_frag_head_sz = 0;
+					skb = napi_get_frags(napi);
+				}
+			} else {
+				rx_frag_head_sz = 0;
+				skb = napi_alloc_skb(napi, len);
+			}
+
+			if (!skb) {
+				stats->rx_dropped++;
+				goto find_next_rx;
+			}
+
+			tp->rx_desc.csum(tp, rx_desc, skb);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+			skb->dev = netdev;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) */
+			tp->rx_desc.vlan_put_tag(tp, rx_desc, skb);
+#else
+			tp->rx_desc.vlan_tag(tp, rx_desc, skb);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) */
+
+			if (use_frags) {
+				if (rx_frag_head_sz) {
+					memcpy(skb->data, rx_data,
+					       rx_frag_head_sz);
+					skb_put(skb, rx_frag_head_sz);
+					len -= rx_frag_head_sz;
+					rx_data += rx_frag_head_sz;
+					skb->protocol = eth_type_trans(skb,
+								       netdev);
+				}
+
+				skb_add_rx_frag(skb, 0, agg->page,
+						agg_offset(agg, rx_data),
+						len, SKB_DATA_ALIGN(len));
+				get_page(agg->page);
+			} else {
+				memcpy(skb->data, rx_data, len);
+				skb_put(skb, len);
+				skb->protocol = eth_type_trans(skb, netdev);
+			}
+
+			if (work_done < budget) {
+				if (use_frags)
+					napi_gro_frags(napi);
+				else
+					napi_gro_receive(napi, skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+				netdev->last_rx = jiffies;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29) */
+				work_done++;
+				stats->rx_packets++;
+				stats->rx_bytes += pkt_len;
+			} else {
+				__skb_queue_tail(&tp->rx_queue, skb);
+			}
+
+find_next_rx:
+			rx_data = rx_agg_align(tp, rx_data + len + ETH_FCS_LEN);
+			rx_desc = rx_data;
+			len_used = agg_offset(agg, rx_data);
+			len_used += tp->rx_desc.size;
+		}
+
+		WARN_ON(!agg_free && page_count(agg->page) > 1);
+
+		if (agg_free) {
+			spin_lock_irqsave(&tp->rx_lock, flags);
+			if (page_count(agg->page) == 1) {
+				list_add(&agg_free->list, &tp->rx_used);
+			} else {
+				list_add_tail(&agg->list, &tp->rx_used);
+				agg = agg_free;
+				urb = agg->urb;
+			}
+			spin_unlock_irqrestore(&tp->rx_lock, flags);
+		}
+
+submit:
+		if (!ret) {
+			ret = r8152_submit_rx(tp, agg, GFP_ATOMIC);
+		} else {
+			urb->actual_length = 0;
+			list_add_tail(&agg->list, next);
+		}
+	}
+
+	/* Splice the remained list back to rx_done for next schedule */
+	if (!list_empty(&rx_queue)) {
+		spin_lock_irqsave(&tp->rx_lock, flags);
+		list_splice(&rx_queue, &tp->rx_done);
+		spin_unlock_irqrestore(&tp->rx_lock, flags);
+	}
+
+out1:
+	return work_done;
+}
+
+static void tx_bottom(struct r8152 *tp)
+{
+	int res;
+
+	do {
+		struct net_device *netdev = tp->netdev;
+		struct tx_agg *agg;
+
+		if (skb_queue_empty(&tp->tx_queue))
+			break;
+
+		agg = r8152_get_tx_agg(tp);
+		if (!agg)
+			break;
+
+		if (tp->sg_use)
+			res = r8152_tx_agg_sg_fill(tp, agg);
+		else
+			res = r8152_tx_agg_fill(tp, agg);
+
+		if (!res)
+			continue;
+
+		if (res == -ENODEV) {
+			rtl_set_unplug(tp);
+			netif_device_detach(netdev);
+		} else {
+			struct net_device_stats *stats = &netdev->stats;
+			unsigned long flags;
+
+			netif_warn(tp, tx_err, netdev,
+				   "failed tx_urb %d\n", res);
+			stats->tx_dropped += agg->skb_num;
+
+			spin_lock_irqsave(&tp->tx_lock, flags);
+			list_add_tail(&agg->list, &tp->tx_free);
+			spin_unlock_irqrestore(&tp->tx_lock, flags);
+		}
+	} while (res == 0);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
+static void bottom_half(unsigned long t)
+#else
+static void bottom_half(struct tasklet_struct *t)
+#endif
+{
+	struct r8152 *tp = from_tasklet(tp, t, tx_tl);
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (!test_bit(WORK_ENABLE, &tp->flags))
+		return;
+
+	/* When link down, the driver would cancel all bulks. */
+	/* This avoid the re-submitting bulk */
+	if (!netif_carrier_ok(tp->netdev))
+		return;
+
+	clear_bit(SCHEDULE_TASKLET, &tp->flags);
+
+	tx_bottom(tp);
+}
+
+static inline int __r8152_poll(struct r8152 *tp, int budget)
+{
+	struct napi_struct *napi = &tp->napi;
+	int work_done;
+
+	if (!budget)
+		return 0;
+
+	work_done = rx_bottom(tp, budget);
+
+	if (work_done < budget) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+		napi_complete_done(napi, work_done);
+#else
+		if (!napi_complete_done(napi, work_done))
+			goto out;
+#endif
+		if (!list_empty(&tp->rx_done))
+			napi_schedule(napi);
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+out:
+#endif
+	return work_done;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+
+static int r8152_poll(struct net_device *dev, int *budget)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	int quota = min(dev->quota, *budget);
+	int work_done;
+
+	work_done = __r8152_poll(tp, quota);
+
+	*budget -= work_done;
+	dev->quota -= work_done;
+
+	return (work_done >= quota);
+}
+
+#else
+
+static int r8152_poll(struct napi_struct *napi, int budget)
+{
+	struct r8152 *tp = container_of(napi, struct r8152, napi);
+
+	return __r8152_poll(tp, budget);
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24) */
+
+static
+int r8152_submit_rx(struct r8152 *tp, struct rx_agg *agg, gfp_t mem_flags)
+{
+	int ret;
+
+	/* The rx would be stopped, so skip submitting */
+	if (test_bit(RTL8152_UNPLUG, &tp->flags) ||
+	    !test_bit(WORK_ENABLE, &tp->flags) || !netif_carrier_ok(tp->netdev))
+		return 0;
+
+	usb_fill_bulk_urb(agg->urb, tp->udev, tp->pipe_in,
+			  agg->buffer, tp->rx_buf_sz,
+			  (usb_complete_t)read_bulk_callback, agg);
+
+	ret = usb_submit_urb(agg->urb, mem_flags);
+	if (ret == -ENODEV) {
+		rtl_set_unplug(tp);
+		netif_device_detach(tp->netdev);
+	} else if (ret) {
+		struct urb *urb = agg->urb;
+		unsigned long flags;
+
+		urb->actual_length = 0;
+		spin_lock_irqsave(&tp->rx_lock, flags);
+		list_add_tail(&agg->list, &tp->rx_done);
+		spin_unlock_irqrestore(&tp->rx_lock, flags);
+
+		netif_err(tp, rx_err, tp->netdev,
+			  "Couldn't submit rx[%p], ret = %d\n", agg, ret);
+
+		napi_schedule(&tp->napi);
+	}
+
+	return ret;
+}
+
+static void rtl_drop_queued_tx(struct r8152 *tp)
+{
+	struct net_device_stats *stats = rtl8152_get_stats(tp->netdev);
+	struct sk_buff_head skb_head, *tx_queue = &tp->tx_queue;
+	struct sk_buff *skb;
+
+	if (skb_queue_empty(tx_queue))
+		return;
+
+	__skb_queue_head_init(&skb_head);
+	spin_lock_bh(&tx_queue->lock);
+	skb_queue_splice_init(tx_queue, &skb_head);
+	spin_unlock_bh(&tx_queue->lock);
+
+	while ((skb = __skb_dequeue(&skb_head))) {
+		dev_kfree_skb(skb);
+		stats->tx_dropped++;
+	}
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
+static void rtl8152_tx_timeout(struct net_device *netdev)
+#else
+static void rtl8152_tx_timeout(struct net_device *netdev, unsigned int txqueue)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0) */
+{
+	struct r8152 *tp = netdev_priv(netdev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	int i;
+#endif
+
+	netif_warn(tp, tx_err, netdev, "Tx timeout\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	for (i = 0; i < RTL8152_MAX_TX; i++)
+		usb_unlink_urb(tp->tx_info[i].urb);
+#else
+	usb_queue_reset_device(tp->intf);
+#endif
+}
+
+static void rtl8152_set_rx_mode(struct net_device *netdev)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	u32 mc_filter[2];	/* Multicast hash filter */
+	__le32 tmp[2];
+	u32 ocp_data;
+
+	if (in_atomic()) {
+		if (netif_carrier_ok(netdev)) {
+			set_bit(RTL8152_SET_RX_MODE, &tp->flags);
+			schedule_delayed_work(&tp->schedule, 0);
+		}
+		return;
+	}
+
+	clear_bit(RTL8152_SET_RX_MODE, &tp->flags);
+
+	if (!netif_carrier_ok(netdev))
+		return;
+
+	netif_stop_queue(netdev);
+	if (ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR, &ocp_data) < 0)
+		goto out;
+
+	ocp_data &= ~RCR_ACPT_ALL;
+	ocp_data |= RCR_AB | RCR_APM;
+
+	if (netdev->flags & IFF_PROMISC) {
+		/* Unconditionally log net taps. */
+		netif_notice(tp, link, netdev, "Promiscuous mode enabled\n");
+		ocp_data |= RCR_AM | RCR_AAP;
+		mc_filter[1] = 0xffffffff;
+		mc_filter[0] = 0xffffffff;
+	} else if ((netdev->flags & IFF_MULTICAST &&
+				netdev_mc_count(netdev) > multicast_filter_limit) ||
+			   (netdev->flags & IFF_ALLMULTI)) {
+		/* Too many to filter perfectly -- accept all multicasts. */
+		ocp_data |= RCR_AM;
+		mc_filter[1] = 0xffffffff;
+		mc_filter[0] = 0xffffffff;
+	} else {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+		struct dev_mc_list *mclist;
+		unsigned int i;
+
+		mc_filter[1] = mc_filter[0] = 0;
+		for (i = 0, mclist = netdev->mc_list;
+		     mclist && i < netdev->mc_count;
+		     i++, mclist = mclist->next) {
+			int bit_nr;
+
+			bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+			ocp_data |= RCR_AM;
+		}
+#else
+		mc_filter[1] = 0;
+		mc_filter[0] = 0;
+
+		if (netdev->flags & IFF_MULTICAST) {
+			struct netdev_hw_addr *ha;
+
+			netdev_for_each_mc_addr(ha, netdev) {
+				int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
+
+				mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+				ocp_data |= RCR_AM;
+			}
+		}
+#endif
+	}
+
+	tmp[0] = __cpu_to_le32(swab32(mc_filter[1]));
+	tmp[1] = __cpu_to_le32(swab32(mc_filter[0]));
+
+	pla_ocp_write(tp, PLA_MAR, BYTE_EN_DWORD, sizeof(tmp), tmp);
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+
+out: /* to do */
+	netif_wake_queue(netdev);
+}
+
+static inline bool rtl_gso_check(struct net_device *dev, struct sk_buff *skb)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	if (tp->sg_use)
+		return true;
+	else if ((skb->len + tp->tx_desc.size) <= agg_buf_sz)
+		return true;
+	else
+		return false;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,4)
+
+static netdev_features_t
+rtl8152_features_check(struct sk_buff *skb, struct net_device *dev,
+		       netdev_features_t features)
+{
+	u32 mss = skb_shinfo(skb)->gso_size;
+	int max_offset = mss ? GTTCPHO_MAX : TCPHO_MAX;
+
+	if ((mss || skb->ip_summed == CHECKSUM_PARTIAL) &&
+	    skb_transport_offset(skb) > max_offset)
+		features &= ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);
+	else if (!rtl_gso_check(dev, skb))
+		features &= ~NETIF_F_GSO_MASK;
+
+	return features;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,4) */
+
+static netdev_tx_t rtl8152_start_xmit(struct sk_buff *skb,
+				      struct net_device *netdev)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,18,4)
+	if (unlikely(!rtl_gso_check(netdev, skb))) {
+		netdev_features_t features = netdev->features;
+		struct sk_buff *segs, *nskb;
+
+		features &= ~(NETIF_F_TSO | NETIF_F_TSO6);
+		segs = skb_gso_segment(skb, features);
+		if (IS_ERR(segs) || !segs)
+			goto free_skb;
+
+		do {
+			nskb = segs;
+			segs = segs->next;
+			nskb->next = NULL;
+			rtl8152_start_xmit(nskb, netdev);
+		} while (segs);
+
+free_skb:
+		dev_kfree_skb_any(skb);
+
+		return NETDEV_TX_OK;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+	netdev->trans_start = jiffies
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,18,4) */
+
+	skb_tx_timestamp(skb);
+	netdev_sent_queue(netdev, skb->len);
+
+	skb_queue_tail(&tp->tx_queue, skb);
+
+	if (!list_empty(&tp->tx_free)) {
+		if (test_bit(SELECTIVE_SUSPEND, &tp->flags)) {
+			set_bit(SCHEDULE_TASKLET, &tp->flags);
+			schedule_delayed_work(&tp->schedule, 0);
+		} else {
+			usb_mark_last_busy(tp->udev);
+			tasklet_schedule(&tp->tx_tl);
+		}
+	} else if (skb_queue_len(&tp->tx_queue) > tp->tx_qlen) {
+		netif_stop_queue(netdev);
+	}
+
+	return NETDEV_TX_OK;
+}
+
+static int r8152b_reset_packet_filter(struct r8152 *tp)
+{
+	int ret;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_FMC, FMC_FCR_MCU_EN);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_FMC, FMC_FCR_MCU_EN);
+
+out:
+	return ret;
+}
+
+static int rtl8152_nic_reset(struct r8152 *tp)
+{
+	int i, ret;
+
+	switch (tp->version) {
+	case RTL_TEST_01:
+	case RTL_VER_10:
+	case RTL_VER_11:
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_CR, CR_TE);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_BMU_RESET,
+					BMU_RESET_EP_IN);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_USB_CTRL,
+					CDC_ECM_EN);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_CR, CR_RE);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_BMU_RESET,
+					BMU_RESET_EP_IN);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_USB_CTRL,
+					CDC_ECM_EN);
+		break;
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_07:
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_14:
+	case RTL_VER_15:
+		ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, CR_RST);
+		if (ret < 0)
+			goto out;
+
+		for (i = 0; i < 1000; i++) {
+			u32 ocp_data;
+
+			ret = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CR,
+					    &ocp_data);
+			if (ret < 0 || !(ocp_data & CR_RST))
+				break;
+			usleep_range(100, 400);
+		}
+		break;
+	case RTL_VER_16:
+	case RTL_VER_17:
+	default:
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_CR,
+					CR_RE | CR_TE);
+		break;
+
+	}
+out:
+	return ret;
+}
+
+static void set_tx_qlen(struct r8152 *tp)
+{
+	if (tp->sg_use)
+		tp->tx_qlen = RTL_MAX_SG_NUM;
+	else
+		tp->tx_qlen = agg_buf_sz / (mtu_to_size(tp->netdev->mtu) +
+					    tp->tx_desc.size);
+}
+
+static u16 rtl8152_get_speed(struct r8152 *tp)
+{
+	u32 ocp_data;
+
+	if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHYSTATUS, &ocp_data) < 0)
+		return 0; /* to do */
+	else
+		return (u16)ocp_data;
+}
+
+static int rtl_eee_plus_en(struct r8152 *tp, bool enable)
+{
+	if (enable)
+		return ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_EEEP_CR,
+					 EEEP_CR_EEEP_TX);
+	else
+		return ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_EEEP_CR,
+					 EEEP_CR_EEEP_TX);
+}
+
+static int rtl_set_eee_plus(struct r8152 *tp)
+{
+	if (tp->version == RTL_VER_17)
+		return rtl_eee_plus_en(tp, false);
+
+	if (rtl8152_get_speed(tp) & _10bps)
+		return rtl_eee_plus_en(tp, true);
+	else
+		return rtl_eee_plus_en(tp, false);
+}
+
+static int rxdy_gated_en(struct r8152 *tp, bool enable)
+{
+	if (enable)
+		return ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_MISC_1,
+					 RXDY_GATED_EN);
+	else
+		return ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_MISC_1,
+					 RXDY_GATED_EN);
+}
+
+static int rtl_start_rx(struct r8152 *tp)
+{
+	struct rx_agg *agg, *agg_next;
+	struct list_head tmp_list;
+	unsigned long flags;
+	int ret = 0, i = 0;
+
+	INIT_LIST_HEAD(&tmp_list);
+
+	spin_lock_irqsave(&tp->rx_lock, flags);
+
+	INIT_LIST_HEAD(&tp->rx_done);
+	INIT_LIST_HEAD(&tp->rx_used);
+
+	list_splice_init(&tp->rx_info, &tmp_list);
+
+	spin_unlock_irqrestore(&tp->rx_lock, flags);
+
+	list_for_each_entry_safe(agg, agg_next, &tmp_list, info_list) {
+		INIT_LIST_HEAD(&agg->list);
+
+		/* Only RTL8152_MAX_RX rx_agg need to be submitted. */
+		if (++i > RTL8152_MAX_RX) {
+			spin_lock_irqsave(&tp->rx_lock, flags);
+			list_add_tail(&agg->list, &tp->rx_used);
+			spin_unlock_irqrestore(&tp->rx_lock, flags);
+		} else if (unlikely(ret < 0)) {
+			spin_lock_irqsave(&tp->rx_lock, flags);
+			list_add_tail(&agg->list, &tp->rx_done);
+			spin_unlock_irqrestore(&tp->rx_lock, flags);
+		} else {
+			ret = r8152_submit_rx(tp, agg, GFP_KERNEL);
+		}
+	}
+
+	spin_lock_irqsave(&tp->rx_lock, flags);
+	WARN_ON(!list_empty(&tp->rx_info));
+	list_splice(&tmp_list, &tp->rx_info);
+	spin_unlock_irqrestore(&tp->rx_lock, flags);
+
+	return ret;
+}
+
+static int rtl_stop_rx(struct r8152 *tp)
+{
+	struct rx_agg *agg, *agg_next;
+	struct list_head tmp_list;
+	unsigned long flags;
+
+	INIT_LIST_HEAD(&tmp_list);
+
+	/* The usb_kill_urb() couldn't be used in atomic.
+	 * Therefore, move the list of rx_info to a tmp one.
+	 * Then, list_for_each_entry_safe could be used without
+	 * spin lock.
+	 */
+
+	spin_lock_irqsave(&tp->rx_lock, flags);
+	list_splice_init(&tp->rx_info, &tmp_list);
+	spin_unlock_irqrestore(&tp->rx_lock, flags);
+
+	list_for_each_entry_safe(agg, agg_next, &tmp_list, info_list)
+		usb_kill_urb(agg->urb);
+
+	/* Move back the list of temp to the rx_info */
+	spin_lock_irqsave(&tp->rx_lock, flags);
+	WARN_ON(!list_empty(&tp->rx_info));
+	list_splice(&tmp_list, &tp->rx_info);
+	spin_unlock_irqrestore(&tp->rx_lock, flags);
+
+	while (!skb_queue_empty(&tp->rx_queue))
+		dev_kfree_skb(__skb_dequeue(&tp->rx_queue));
+
+	return 0;
+}
+
+static int rtl_set_ifg(struct r8152 *tp, u16 speed)
+{
+	int ret;
+
+	if ((speed & (_10bps | _100bps)) && !(speed & FULL_DUP)) {
+		ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, PLA_TCR1, IFG_MASK,
+				    IFG_144NS);
+		if (ret < 0)
+			goto out;
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4,
+					TX10MIDLE_EN);
+	} else {
+		ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, PLA_TCR1, IFG_MASK,
+				    IFG_96NS);
+		if (ret < 0)
+			goto out;
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4,
+					TX10MIDLE_EN);
+	}
+
+out:
+	return ret;
+}
+
+static inline void r8153b_rx_agg_chg_indicate(struct r8152 *tp)
+{
+	ocp_write_byte(tp, MCU_TYPE_USB, USB_UPT_RXDMA_OWN,
+		       OWN_UPDATE | OWN_CLEAR);
+}
+
+static int rtl_enable(struct r8152 *tp)
+{
+	int ret;
+
+	ret = r8152b_reset_packet_filter(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_PLA, PLA_CR, CR_RE | CR_TE);
+	if (ret < 0)
+		goto out;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_07:
+		break;
+	default:
+		r8153b_rx_agg_chg_indicate(tp);
+		break;
+	}
+
+	ret = rxdy_gated_en(tp, false);
+
+	netdev_reset_queue(tp->netdev);
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static int rtl8152_enable(struct r8152 *tp)
+{
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	set_tx_qlen(tp);
+	ret = rtl_set_eee_plus(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_enable(tp);
+
+out:
+	return ret;
+}
+
+static int r8153_set_rx_early_timeout(struct r8152 *tp)
+{
+	u32 ocp_data = tp->coalesce / 8;
+	int ret;
+
+	switch (tp->version) {
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+		ret = ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_TIMEOUT,
+				     ocp_data);
+		break;
+
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_VER_14:
+		/* The RTL8153B uses USB_RX_EXTRA_AGGR_TMR for rx timeout
+		 * primarily. For USB_RX_EARLY_TIMEOUT, we fix it to 1264ns.
+		 */
+		ret = ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_TIMEOUT,
+				     1264 / 8);
+		if (ret < 0)
+			break;
+		ret = ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EXTRA_AGGR_TMR,
+				     ocp_data);
+		break;
+
+	case RTL_VER_10:
+	case RTL_VER_11:
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_15:
+	case RTL_VER_16:
+	case RTL_VER_17:
+		ret = ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_TIMEOUT,
+				     640 / 8);
+		if (ret < 0)
+			break;
+		ret = ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EXTRA_AGGR_TMR,
+				     ocp_data);
+		break;
+
+	default:
+		ret = -ENODEV;
+		break;
+	}
+
+	return ret;
+}
+
+static u32 rx_reserved_size(struct r8152 *tp, u32 mtu)
+{
+	return mtu_to_size(mtu) + tp->rx_desc.size + tp->rx_desc.align;
+}
+
+static int r8153_set_rx_early_size(struct r8152 *tp)
+{
+	u32 ocp_data = tp->rx_buf_sz - rx_reserved_size(tp, tp->netdev->mtu);
+	int ret;
+
+	switch (tp->version) {
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+		ret = ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_SIZE,
+				     ocp_data / 4);
+		break;
+	case RTL_TEST_01:
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_VER_10:
+	case RTL_VER_11:
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_14:
+	case RTL_VER_15:
+		ret = ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_SIZE,
+				     ocp_data / 8);
+		break;
+	case RTL_VER_16:
+	case RTL_VER_17:
+		ret = ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_SIZE,
+				     ocp_data / 16);
+		break;
+	default:
+		ret = -ENODEV;
+		WARN_ON_ONCE(1);
+		break;
+	}
+
+	return ret;
+}
+
+static int rtl8153_enable(struct r8152 *tp)
+{
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	set_tx_qlen(tp);
+	ret = rtl_set_eee_plus(tp);
+	if (ret < 0)
+		goto out;
+	ret = r8153_set_rx_early_timeout(tp);
+	if (ret < 0)
+		goto out;
+	ret = r8153_set_rx_early_size(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_set_ifg(tp, rtl8152_get_speed(tp));
+	if (ret < 0)
+		goto out;
+
+	switch (tp->version) {
+	case RTL_VER_14:
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_FW_TASK,
+					FC_PATCH_TASK);
+		if (ret < 0)
+			goto out;
+		usleep_range(1000, 2000);
+		ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_TASK,
+					FC_PATCH_TASK);
+		if (ret < 0)
+			goto out;
+		break;
+	default:
+		break;
+	}
+
+	ret = rtl_enable(tp);
+
+out:
+	return ret;
+}
+
+static int rtl_disable(struct r8152 *tp)
+{
+	int i, ret, err = 0;
+	u32 ocp_data;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		rtl_stop_rx(tp);
+		return -ENODEV;
+	}
+
+	ret = ocp_dword_clr_bits(tp, MCU_TYPE_PLA, PLA_RCR, RCR_ACPT_ALL);
+	if (ret < 0)
+		err = ret;
+
+	rtl_drop_queued_tx(tp);
+
+	for (i = 0; i < RTL8152_MAX_TX; i++)
+		usb_kill_urb(tp->tx_info[i].urb);
+
+	ret = rxdy_gated_en(tp, true);
+	if (ret < 0)
+		err = ret;
+
+	for (i = 0; i < 1000; i++) {
+		ret = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, &ocp_data);
+		if (ret < 0 || (ocp_data & FIFO_EMPTY) == FIFO_EMPTY)
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	for (i = 0; i < 1000; i++) {
+		ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0, &ocp_data);
+		if (ret < 0 || (ocp_data & TCR0_TX_EMPTY))
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	rtl_stop_rx(tp);
+
+	ret = rtl8152_nic_reset(tp);
+
+	if (err < 0)
+		return err;
+	else
+		return ret;
+}
+
+static int r8152_power_cut_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable)
+		ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_UPS_CTRL,
+					POWER_CUT);
+	else
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_UPS_CTRL,
+					POWER_CUT);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_PM_CTRL_STATUS,
+			  RESUME_INDICATE);
+
+out:
+	return ret;
+}
+
+static int rtl_rx_vlan_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_07:
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_VER_14:
+		if (enable)
+			ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_CPCR,
+						CPCR_RX_VLAN);
+		else
+			ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_CPCR,
+						CPCR_RX_VLAN);
+		break;
+
+	case RTL_TEST_01:
+	case RTL_VER_10:
+	case RTL_VER_11:
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_15:
+	case RTL_VER_16:
+	case RTL_VER_17:
+	default:
+		if (enable)
+			ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_RCR1,
+						OUTER_VLAN | INNER_VLAN);
+		else
+			ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_RCR1,
+						OUTER_VLAN | INNER_VLAN);
+		break;
+	}
+
+	return (ret < 0) ? ret : 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+static void
+rtl8152_vlan_rx_register(struct net_device *dev, struct vlan_group *grp)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	if (unlikely(tp->rtk_enable_diag))
+		return;
+
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
+
+	mutex_lock(&tp->control);
+
+	tp->vlgrp = grp;
+	if (tp->vlgrp)
+		rtl_rx_vlan_en(tp, true);
+	else
+		rtl_rx_vlan_en(tp, false);
+
+	mutex_unlock(&tp->control);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+
+static void rtl8152_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	vlan_group_set_device(tp->vlgrp, vid, NULL);
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) */
+
+#else
+
+static int rtl8152_set_features(struct net_device *dev,
+				netdev_features_t features)
+{
+	netdev_features_t changed = features ^ dev->features;
+	struct r8152 *tp = netdev_priv(dev);
+	int ret;
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	mutex_lock(&tp->control);
+
+	if (changed & NETIF_F_HW_VLAN_CTAG_RX) {
+		if (features & NETIF_F_HW_VLAN_CTAG_RX)
+			ret = rtl_rx_vlan_en(tp, true);
+		else
+			ret = rtl_rx_vlan_en(tp, false);
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) */
+
+#define WAKE_ANY (WAKE_PHY | WAKE_MAGIC | WAKE_UCAST | WAKE_BCAST | WAKE_MCAST)
+
+static u32 __rtl_get_wol(struct r8152 *tp)
+{
+	u32 ocp_data;
+	u32 wolopts = 0;
+	int ret;
+
+	ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, &ocp_data);
+	if (ret < 0)
+		goto out;
+
+	if (ocp_data & LINK_ON_WAKE_EN)
+		wolopts |= WAKE_PHY;
+
+	ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG5, &ocp_data);
+	if (ret < 0)
+		goto out;
+
+	if (ocp_data & UWF_EN)
+		wolopts |= WAKE_UCAST;
+	if (ocp_data & BWF_EN)
+		wolopts |= WAKE_BCAST;
+	if (ocp_data & MWF_EN)
+		wolopts |= WAKE_MCAST;
+
+	ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CFG_WOL, &ocp_data);
+	if (ret < 0)
+		goto out;
+
+	if (ocp_data & MAGIC_EN)
+		wolopts |= WAKE_MAGIC;
+
+out:
+	return wolopts;
+}
+
+static int __rtl_set_wol(struct r8152 *tp, u32 wolopts)
+{
+	u16 ocp_data;
+	int ret;
+
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
+	if (ret < 0)
+		goto out;
+
+	if (wolopts & WAKE_PHY)
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_CONFIG34,
+					LINK_ON_WAKE_EN);
+	else
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_CONFIG34,
+					LINK_ON_WAKE_EN);
+	if (ret < 0)
+		goto out;
+
+	ocp_data = 0;
+	if (wolopts & WAKE_UCAST)
+		ocp_data |= UWF_EN;
+	if (wolopts & WAKE_BCAST)
+		ocp_data |= BWF_EN;
+	if (wolopts & WAKE_MCAST)
+		ocp_data |= MWF_EN;
+	ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, PLA_CONFIG5,
+			    UWF_EN | BWF_EN | MWF_EN, ocp_data);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
+	if (ret < 0)
+		goto out;
+
+	if (wolopts & WAKE_MAGIC)
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_CFG_WOL, MAGIC_EN);
+	else
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_CFG_WOL, MAGIC_EN);
+	if (ret < 0)
+		goto out;
+
+	if (wolopts & WAKE_ANY)
+		device_set_wakeup_enable(&tp->udev->dev, true);
+	else
+		device_set_wakeup_enable(&tp->udev->dev, false);
+
+out:
+	return ret;
+}
+
+static int r8153_mac_clk_speed_down(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	/* MAC clock speed down */
+	if (enable)
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL2,
+					MAC_CLK_SPDWN_EN);
+	else
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL2,
+					MAC_CLK_SPDWN_EN);
+
+	return ret;
+}
+
+static int r8156_mac_clk_spd(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	/* MAC clock speed down */
+	if (enable) {
+		/* aldps_spdwn_ratio, tp10_spdwn_ratio */
+		ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL,
+				     0x0403);
+		if (ret < 0)
+			goto out;
+
+		/* eee_spdwn_ratio */
+		ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL2,
+				    EEE_SPDWN_RATIO_MASK,
+				    MAC_CLK_SPDWN_EN | 0x03);
+	} else {
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL2,
+					MAC_CLK_SPDWN_EN);
+	}
+
+out:
+	return ret;
+}
+
+static int r8153_u1u2en(struct r8152 *tp, bool enable)
+{
+	u8 u1u2[8];
+
+	if (enable)
+		memset(u1u2, 0xff, sizeof(u1u2));
+	else
+		memset(u1u2, 0x00, sizeof(u1u2));
+
+	return usb_ocp_write(tp, USB_TOLERANCE, BYTE_EN_SIX_BYTES, sizeof(u1u2),
+			     u1u2);
+}
+
+static int r8153b_u1u2en(struct r8152 *tp, bool enable)
+{
+	if (enable)
+		return ocp_word_set_bits(tp, MCU_TYPE_USB, USB_LPM_CONFIG,
+					 LPM_U1U2_EN);
+	else
+		return ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_LPM_CONFIG,
+					 LPM_U1U2_EN);
+}
+
+static int r8153_u2p3en(struct r8152 *tp, bool enable)
+{
+	if (enable)
+		return ocp_word_set_bits(tp, MCU_TYPE_USB, USB_U2P3_CTRL,
+					 U2P3_ENABLE);
+	else
+		return ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_U2P3_CTRL,
+					 U2P3_ENABLE);
+}
+
+static int r8157_u2p3en(struct r8152 *tp, bool enable)
+{
+	if (enable)
+		return rtl_ip_set_bits(tp, 0xc2c0, BIT(29));
+	else
+		return rtl_ip_clr_bits(tp, 0xc2c0, BIT(29));
+}
+
+static bool r8156b_flash_used(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int ret;
+
+	ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_GPHY_CTRL, &ocp_data);
+	if (ret < 0)
+		return false;
+	if (!(ocp_data & GPHY_FLASH))
+		return false;
+
+	ret = ocp_read_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL, &ocp_data);
+	if (ret < 0)
+		return false;
+	if (!(ocp_data & BYPASS_FLASH))
+		return true;
+	else
+		return false;
+}
+
+static int r8153b_ups_flags(struct r8152 *tp)
+{
+	u32 ups_flags = 0;
+
+	if (tp->ups_info.green)
+		ups_flags |= UPS_FLAGS_EN_GREEN;
+
+	if (tp->ups_info.aldps)
+		ups_flags |= UPS_FLAGS_EN_ALDPS;
+
+	if (tp->ups_info.eee)
+		ups_flags |= UPS_FLAGS_EN_EEE;
+
+	if (tp->ups_info.flow_control)
+		ups_flags |= UPS_FLAGS_EN_FLOW_CTR;
+
+	if (tp->ups_info.eee_ckdiv)
+		ups_flags |= UPS_FLAGS_EN_EEE_CKDIV;
+
+	if (tp->ups_info.eee_cmod_lv)
+		ups_flags |= UPS_FLAGS_EEE_CMOD_LV_EN;
+
+	if (tp->ups_info.r_tune)
+		ups_flags |= UPS_FLAGS_R_TUNE;
+
+	if (tp->ups_info._10m_ckdiv)
+		ups_flags |= UPS_FLAGS_EN_10M_CKDIV;
+
+	if (tp->ups_info.eee_plloff_100)
+		ups_flags |= UPS_FLAGS_EEE_PLLOFF_100;
+
+	if (tp->ups_info.eee_plloff_giga)
+		ups_flags |= UPS_FLAGS_EEE_PLLOFF_GIGA;
+
+	if (tp->ups_info._250m_ckdiv)
+		ups_flags |= UPS_FLAGS_250M_CKDIV;
+
+	if (tp->ups_info.ctap_short_off)
+		ups_flags |= UPS_FLAGS_CTAP_SHORT_DIS;
+
+	switch (tp->ups_info.speed_duplex) {
+	case NWAY_10M_HALF:
+		ups_flags |= ups_flags_speed(1);
+		break;
+	case NWAY_10M_FULL:
+		ups_flags |= ups_flags_speed(2);
+		break;
+	case NWAY_100M_HALF:
+		ups_flags |= ups_flags_speed(3);
+		break;
+	case NWAY_100M_FULL:
+		ups_flags |= ups_flags_speed(4);
+		break;
+	case NWAY_1000M_FULL:
+		ups_flags |= ups_flags_speed(5);
+		break;
+	case FORCE_10M_HALF:
+		ups_flags |= ups_flags_speed(6);
+		break;
+	case FORCE_10M_FULL:
+		ups_flags |= ups_flags_speed(7);
+		break;
+	case FORCE_100M_HALF:
+		ups_flags |= ups_flags_speed(8);
+		break;
+	case FORCE_100M_FULL:
+		ups_flags |= ups_flags_speed(9);
+		break;
+	default:
+		break;
+	}
+
+	return ocp_write_dword(tp, MCU_TYPE_USB, USB_UPS_FLAGS, ups_flags);
+}
+
+static int r8156_ups_flags(struct r8152 *tp)
+{
+	u32 ups_flags = 0;
+
+	if (tp->ups_info.green)
+		ups_flags |= UPS_FLAGS_EN_GREEN;
+
+	if (tp->ups_info.aldps)
+		ups_flags |= UPS_FLAGS_EN_ALDPS;
+
+	if (tp->ups_info.eee)
+		ups_flags |= UPS_FLAGS_EN_EEE;
+
+	if (tp->ups_info.flow_control)
+		ups_flags |= UPS_FLAGS_EN_FLOW_CTR;
+
+	if (tp->ups_info.eee_ckdiv)
+		ups_flags |= UPS_FLAGS_EN_EEE_CKDIV;
+
+	if (tp->ups_info._10m_ckdiv)
+		ups_flags |= UPS_FLAGS_EN_10M_CKDIV;
+
+	if (tp->ups_info.eee_plloff_100)
+		ups_flags |= UPS_FLAGS_EEE_PLLOFF_100;
+
+	if (tp->ups_info.eee_plloff_giga)
+		ups_flags |= UPS_FLAGS_EEE_PLLOFF_GIGA;
+
+	if (tp->ups_info._250m_ckdiv)
+		ups_flags |= UPS_FLAGS_250M_CKDIV;
+
+	switch (tp->ups_info.speed_duplex) {
+	case FORCE_10M_HALF:
+		ups_flags |= ups_flags_speed(0);
+		break;
+	case FORCE_10M_FULL:
+		ups_flags |= ups_flags_speed(1);
+		break;
+	case FORCE_100M_HALF:
+		ups_flags |= ups_flags_speed(2);
+		break;
+	case FORCE_100M_FULL:
+		ups_flags |= ups_flags_speed(3);
+		break;
+	case NWAY_10M_HALF:
+		ups_flags |= ups_flags_speed(4);
+		break;
+	case NWAY_10M_FULL:
+		ups_flags |= ups_flags_speed(5);
+		break;
+	case NWAY_100M_HALF:
+		ups_flags |= ups_flags_speed(6);
+		break;
+	case NWAY_100M_FULL:
+		ups_flags |= ups_flags_speed(7);
+		break;
+	case NWAY_1000M_FULL:
+		ups_flags |= ups_flags_speed(8);
+		break;
+	case NWAY_2500M_FULL:
+		ups_flags |= ups_flags_speed(9);
+		break;
+	default:
+		break;
+	}
+
+	switch (tp->ups_info.lite_mode) {
+	case 1:
+		ups_flags |= 0 << 5;
+		break;
+	case 2:
+		ups_flags |= 2 << 5;
+		break;
+	case 0:
+	default:
+		ups_flags |= 1 << 5;
+		break;
+	}
+
+	return ocp_write_dword(tp, MCU_TYPE_USB, USB_UPS_FLAGS, ups_flags);
+}
+
+static int rtl_green_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable)
+		ret = sram_set_bits(tp, SRAM_GREEN_CFG, GREEN_ETH_EN);
+	else
+		ret = sram_clr_bits(tp, SRAM_GREEN_CFG, GREEN_ETH_EN);
+
+	tp->ups_info.green = enable;
+
+	return ret;
+}
+
+static int r8153b_green_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		/* 10M abiq&ldvbias */
+		ret = sram_write(tp, 0x8045, 0);
+		if (ret < 0)
+			goto out;
+
+		/* 100M short abiq&ldvbias */
+		ret = sram_write(tp, 0x804d, 0x1222);
+		if (ret < 0)
+			goto out;
+
+		/* 1000M short abiq&ldvbias */
+		ret = sram_write(tp, 0x805d, 0x0022);
+	} else {
+		/* 10M abiq&ldvbias */
+		ret = sram_write(tp, 0x8045, 0x2444);
+		if (ret < 0)
+			goto out;
+
+		/* 100M short abiq&ldvbias */
+		ret = sram_write(tp, 0x804d, 0x2444);
+		if (ret < 0)
+			goto out;
+
+		/* 1000M short abiq&ldvbias */
+		ret = sram_write(tp, 0x805d, 0x2444);
+	}
+
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_green_en(tp, true);
+
+out:
+	return ret;
+}
+
+static int r8153_phy_status(struct r8152 *tp, u16 desired)
+{
+	int i, ret;
+	u16 data;
+
+	for (i = 0; i < 500; i++) {
+		ret = ocp_reg_read(tp, OCP_PHY_STATUS, &data);
+		if (ret < 0)
+			return ret;
+
+		data &= PHY_STAT_MASK;
+		if (desired) {
+			if (data == desired)
+				break;
+		} else if (data == PHY_STAT_LAN_ON || data == PHY_STAT_PWRDN ||
+			   data == PHY_STAT_EXT_INIT) {
+			break;
+		}
+
+		msleep(20);
+		if (test_bit(RTL8152_UNPLUG, &tp->flags))
+			break;
+	}
+
+	return data;
+}
+
+static int r8153b_ups_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = r8153b_ups_flags(tp);
+
+		ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_POWER_CUT,
+					UPS_EN | USP_PREWAKE | PHASE2_EN);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_MISC_2,
+					UPS_FORCE_PWR_DOWN);
+	} else {
+		u32 ocp_data;
+
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_POWER_CUT,
+					UPS_EN | USP_PREWAKE);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_MISC_2,
+					UPS_FORCE_PWR_DOWN | UPS_NO_UPS);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0, &ocp_data);
+		if (ret < 0)
+			goto out;
+
+		if (ocp_data & PCUT_STATUS) {
+			int i;
+
+			for (i = 0; i < 500; i++) {
+				ret = ocp_read_word(tp, MCU_TYPE_PLA,
+						    PLA_BOOT_CTRL, &ocp_data);
+				if (ret < 0)
+					goto out;
+				if (ocp_data & AUTOLOAD_DONE)
+					break;
+				msleep(20);
+			}
+
+			tp->rtl_ops.hw_phy_cfg(tp);
+
+			ret = rtl8152_set_speed(tp, tp->autoneg, tp->speed,
+						tp->duplex, tp->advertising);
+		}
+	}
+
+out:
+	return ret;
+}
+
+static int r8153c_ups_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = r8153b_ups_flags(tp);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_POWER_CUT,
+					UPS_EN | USP_PREWAKE | PHASE2_EN);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_byte_w0w1(tp, MCU_TYPE_USB, USB_MISC_2, BIT(7),
+				    UPS_FORCE_PWR_DOWN);
+	} else {
+		u32 ocp_data;
+
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_POWER_CUT,
+					UPS_EN | USP_PREWAKE);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_MISC_2,
+					UPS_FORCE_PWR_DOWN | UPS_NO_UPS);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0, &ocp_data);
+		if (ret < 0)
+			goto out;
+
+		if (ocp_data & PCUT_STATUS) {
+			int i;
+
+			for (i = 0; i < 500; i++) {
+				ret = ocp_read_word(tp, MCU_TYPE_PLA,
+						    PLA_BOOT_CTRL, &ocp_data);
+				if (ret < 0)
+					goto out;
+				if (ocp_data & AUTOLOAD_DONE)
+					break;
+				msleep(20);
+			}
+
+			tp->rtl_ops.hw_phy_cfg(tp);
+
+			ret = rtl8152_set_speed(tp, tp->autoneg, tp->speed,
+						tp->duplex, tp->advertising);
+			if (ret < 0)
+				goto out;
+		}
+
+		ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR,
+				     CRWECR_CONFIG);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_CONFIG34, BIT(8));
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR,
+				     CRWECR_NORAML);
+	}
+
+out:
+	return ret;
+}
+
+static int r8156_ups_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = r8156_ups_flags(tp);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_POWER_CUT,
+					UPS_EN | USP_PREWAKE | PHASE2_EN);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_MISC_2,
+					UPS_FORCE_PWR_DOWN);
+		if (ret < 0)
+			goto out;
+
+		switch (tp->version) {
+		case RTL_VER_13:
+		case RTL_VER_15:
+			ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_UPHY_XTAL,
+						OOBS_POLLING);
+			if (ret < 0)
+				goto out;
+
+			if (r8156b_flash_used(tp))
+				ret = ocp_word_clr_bits(tp, MCU_TYPE_USB,
+							USB_GPHY_CTRL,
+							GPHY_PATCH_DONE);
+			break;
+		default:
+			break;
+		}
+	} else {
+		u32 ocp_data;
+
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_POWER_CUT,
+					UPS_EN | USP_PREWAKE);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_MISC_2,
+					UPS_FORCE_PWR_DOWN | UPS_NO_UPS);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0, &ocp_data);
+		if (ret < 0)
+			goto out;
+
+		if (ocp_data & PCUT_STATUS) {
+			tp->rtl_ops.hw_phy_cfg(tp);
+
+			ret = rtl8152_set_speed(tp, tp->autoneg, tp->speed,
+						tp->duplex, tp->advertising);
+		} else {
+			switch (tp->version) {
+			case RTL_VER_13:
+			case RTL_VER_15:
+				if (r8156b_flash_used(tp))
+					ret = ocp_word_set_bits(tp,
+							MCU_TYPE_USB,
+							USB_GPHY_CTRL,
+							GPHY_PATCH_DONE);
+				break;
+			default:
+				break;
+			}
+		}
+	}
+
+out:
+	return ret;
+}
+
+static int r8153_power_cut_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable)
+		ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_POWER_CUT,
+					PWR_EN | PHASE2_EN);
+	else
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_POWER_CUT,
+					PWR_EN | PHASE2_EN);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_MISC_0, PCUT_STATUS);
+
+out:
+	return ret;
+}
+
+static int r8153b_power_cut_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable)
+		ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_POWER_CUT,
+					PWR_EN | PHASE2_EN);
+	else
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_POWER_CUT,
+					PWR_EN);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_MISC_0, PCUT_STATUS);
+
+out:
+	return ret;
+}
+
+static int r8157_power_cut_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_POWER_CUT,
+					PWR_EN | PHASE2_EN);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_MISC_2, BIT(1));
+		if (ret < 0)
+			goto out;
+	} else {
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_POWER_CUT,
+					PWR_EN);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_MISC_0,
+					PCUT_STATUS);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_MISC_2, BIT(1));
+	}
+
+out:
+	return ret;
+}
+
+static int r8153_queue_wake(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable)
+		ret = ocp_byte_set_bits(tp, MCU_TYPE_PLA, PLA_INDICATE_FALG,
+					UPCOMING_RUNTIME_D3);
+	else
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_INDICATE_FALG,
+					UPCOMING_RUNTIME_D3);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_SUSPEND_FLAG,
+				LINK_CHG_EVENT);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+				LINK_CHANGE_FLAG);
+
+out:
+	return ret;
+}
+
+static bool rtl_can_wakeup(struct r8152 *tp)
+{
+	struct usb_device *udev = tp->udev;
+
+	return (udev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_WAKEUP);
+}
+
+static int rtl_runtime_suspend_enable(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = __rtl_set_wol(tp, WAKE_ANY);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR,
+				     CRWECR_CONFIG);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_CONFIG34,
+					LINK_OFF_WAKE_EN);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR,
+				     CRWECR_NORAML);
+	} else {
+		ret = __rtl_set_wol(tp, tp->saved_wolopts);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR,
+				     CRWECR_CONFIG);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_CONFIG34,
+				  LINK_OFF_WAKE_EN);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR,
+				     CRWECR_NORAML);
+	}
+
+out:
+	return ret;
+}
+
+static int rtl8153_runtime_enable(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		if (tp->version == RTL_VER_06) {
+			ret = r8153_queue_wake(tp, true);
+			if (ret < 0)
+				goto out;
+		}
+		ret = r8153_u1u2en(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = r8153_u2p3en(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = rtl_runtime_suspend_enable(tp, true);
+	} else {
+		if (tp->version == RTL_VER_06) {
+			ret = r8153_queue_wake(tp, false);
+			if (ret < 0)
+				goto out;
+		}
+		ret = rtl_runtime_suspend_enable(tp, false);
+		if (ret < 0)
+			goto out;
+
+		switch (tp->version) {
+		case RTL_VER_03:
+		case RTL_VER_04:
+			break;
+		case RTL_VER_05:
+		case RTL_VER_06:
+		default:
+			ret = r8153_u2p3en(tp, true);
+			if (ret < 0)
+				goto out;
+			break;
+		}
+
+		ret = r8153_u1u2en(tp, true);
+	}
+
+out:
+	return ret;
+}
+
+static int rtl8153b_runtime_enable(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = r8153_queue_wake(tp, true);
+		if (ret < 0)
+			goto out;
+		ret = r8153b_u1u2en(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = r8153_u2p3en(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = rtl_runtime_suspend_enable(tp, true);
+		if (ret < 0)
+			goto out;
+
+		ret = r8153b_ups_en(tp, true);
+	} else {
+		ret = r8153b_ups_en(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = r8153_queue_wake(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = rtl_runtime_suspend_enable(tp, false);
+		if (ret < 0)
+			goto out;
+
+//		ret = r8153_u2p3en(tp, true);
+//		if (ret < 0)
+//			goto out;
+
+		if (tp->udev->speed >= USB_SPEED_SUPER)
+			ret = r8153b_u1u2en(tp, true);
+	}
+
+out:
+	return ret;
+}
+
+static int rtl8153c_runtime_enable(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = r8153_queue_wake(tp, true);
+		if (ret < 0)
+			goto out;
+
+		ret = r8153b_u1u2en(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = r8153_u2p3en(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = rtl_runtime_suspend_enable(tp, true);
+		if (ret < 0)
+			goto out;
+
+		ret = r8153c_ups_en(tp, true);
+	} else {
+		ret = r8153c_ups_en(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = r8153_queue_wake(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = rtl_runtime_suspend_enable(tp, false);
+		if (ret < 0)
+			goto out;
+
+//		ret = r8153_u2p3en(tp, true);
+//		if (ret < 0)
+//			goto out;
+
+		ret = r8153b_u1u2en(tp, true);
+	}
+
+out:
+	return ret;
+}
+
+static int rtl8156_runtime_enable(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = r8153_queue_wake(tp, true);
+		if (ret < 0)
+			goto out;
+
+		ret = r8153b_u1u2en(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = r8153_u2p3en(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = rtl_runtime_suspend_enable(tp, true);
+//		if (tp->version != RTL_VER_10 ||
+//		    tp->udev->speed == USB_SPEED_HIGH)
+//			ret = r8156_ups_en(tp, true);
+	} else {
+//		r8156_ups_en(tp, false);
+//		if (ret < 0)
+//			goto out;
+
+		ret = r8153_queue_wake(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = rtl_runtime_suspend_enable(tp, false);
+		if (ret < 0)
+			goto out;
+
+		ret = r8153_u2p3en(tp, true);
+		if (ret < 0)
+			goto out;
+
+		if (tp->udev->speed >= USB_SPEED_SUPER)
+			ret = r8153b_u1u2en(tp, true);
+	}
+
+out:
+	return ret;
+}
+
+static int rtl8157_runtime_enable(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	ret = r8153_queue_wake(tp, enable);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8157_u2p3en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_runtime_suspend_enable(tp, enable);
+
+out:
+	return ret;
+}
+
+static int rtl_nway_restart(struct r8152 *tp)
+{
+	int r;
+
+	/* if autoneg is off, it's an error */
+	r = r8152_mdio_read(tp, MII_BMCR);
+	if (r < 0)
+		goto out;
+
+	if (r & BMCR_ANENABLE)
+		r = r8152_mdio_write(tp, MII_BMCR, r | BMCR_ANRESTART);
+
+out:
+	if (r < 0)
+		return r;
+	else
+		return 0;
+}
+
+static int r8153_teredo_off(struct r8152 *tp)
+{
+	int ret;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_07:
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG,
+					TEREDO_SEL | TEREDO_RS_EVENT_MASK |
+					OOB_TEREDO_EN);
+		if (ret < 0)
+			goto out;
+		break;
+
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_TEST_01:
+	case RTL_VER_10:
+	case RTL_VER_11:
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_14:
+	case RTL_VER_15:
+	case RTL_VER_16:
+	case RTL_VER_17:
+	default:
+		/* The bit 0 ~ 7 are relative with teredo settings. They are
+		 * W1C (write 1 to clear), so set all 1 to disable it.
+		 */
+		ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG, 0xff);
+		if (ret < 0)
+			goto out;
+		break;
+	}
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_WDT6_CTRL, WDT6_SET_MODE);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_REALWOW_TIMER, 0);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_TEREDO_TIMER, 0);
+
+out:
+	return ret;
+}
+
+static int rtl_reset_bmu(struct r8152 *tp)
+{
+	int ret;
+
+	switch (tp->version) {
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_TEST_01:
+	case RTL_VER_10:
+	case RTL_VER_11:
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_14:
+	case RTL_VER_15:
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_BMU_RESET,
+					BMU_RESET_EP_IN | BMU_RESET_EP_OUT);
+		if (ret < 0)
+			goto out;
+		ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_BMU_RESET,
+					BMU_RESET_EP_IN | BMU_RESET_EP_OUT);
+		break;
+	case RTL_VER_16:
+	case RTL_VER_17:
+		ret = rtl_bmu_set_bits(tp, 0x2350, BIT(1));
+		if (ret < 0)
+			goto out;
+		ret = rtl_bmu_set_bits(tp, 0x2360, BIT(0));
+		if (ret < 0)
+			goto out;
+		ret = rtl_bmu_set_bits(tp, 0x2350, BIT(0));
+		if (ret < 0)
+			goto out;
+		ret = rtl_bmu_set_bits(tp, 0x2450, BIT(1));
+		if (ret < 0)
+			goto out;
+		ret = rtl_bmu_set_bits(tp, 0x2460, BIT(0));
+		if (ret < 0)
+			goto out;
+		ret = rtl_bmu_set_bits(tp, 0x2450, BIT(0));
+		if (ret < 0)
+			goto out;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+out:
+	return ret;
+}
+
+/* Clear the bp to stop the firmware before loading a new one */
+static int rtl_clear_bp(struct r8152 *tp, u16 type)
+{
+	u16 bp[16] = {0};
+	u16 bp_num;
+	int ret;
+
+	switch (tp->version) {
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_VER_10:
+	case RTL_VER_11:
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_15:
+		if (type == MCU_TYPE_USB) {
+			ret = ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0);
+			if (ret < 0)
+				goto out;
+			bp_num = 16;
+			break;
+		}
+		fallthrough;
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+		ret = ocp_write_byte(tp, type, PLA_BP_EN, 0);
+		if (ret < 0)
+			goto out;
+		fallthrough;
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+		bp_num = 8;
+		break;
+	case RTL_VER_14:
+	case RTL_VER_16:
+	case RTL_VER_17:
+	default:
+		ret = ocp_write_word(tp, type, USB_BP2_EN, 0);
+		if (ret < 0)
+			goto out;
+		bp_num = 16;
+		break;
+	}
+
+	ret = generic_ocp_write(tp, PLA_BP_0, BYTE_EN_DWORD, bp_num << 1, bp,
+				type);
+	if (ret < 0)
+		goto out;
+
+	/* wait 3 ms to make sure the firmware is stopped */
+	usleep_range(3000, 6000);
+	ret = ocp_write_word(tp, type, PLA_BP_BA, 0);
+
+out:
+	return ret;
+}
+
+static bool rtl_check_fw_ver_ok(struct r8152 *tp, u16 index, u8 new_ver)
+{
+	u32 ocp_data;
+
+	if (!index || ocp_read_byte(tp, MCU_TYPE_USB, index, &ocp_data) < 0)
+		return true;
+	if (new_ver > ocp_data)
+		return true;
+	else
+		return false;
+}
+
+static inline void rtl_reset_ocp_base(struct r8152 *tp)
+{
+	tp->ocp_base = -1;
+}
+
+static int rtl_phy_patch_request(struct r8152 *tp, bool request, bool wait)
+{
+	int i, ret;
+	u16 check;
+
+	if (request) {
+		ret = ocp_reg_set_bits(tp, OCP_PHY_PATCH_CMD, PATCH_REQUEST);
+		check = 0;
+	} else {
+		ret = ocp_reg_clr_bits(tp, OCP_PHY_PATCH_CMD, PATCH_REQUEST);
+		check = PATCH_READY;
+	}
+
+	if (ret < 0)
+		goto out;
+
+	for (i = 0; wait && i < 5000; i++) {
+		u16 data;
+
+		usleep_range(1000, 2000);
+		ret = ocp_reg_read(tp, OCP_PHY_PATCH_STAT, &data);
+		if (ret < 0 || (data & PATCH_READY) ^ check)
+			break;
+	}
+
+	if (request && wait && i == 5000) {
+		dev_err(&tp->intf->dev, "PHY patch request fail\n");
+		ocp_reg_clr_bits(tp, OCP_PHY_PATCH_CMD, PATCH_REQUEST);
+		return -ETIME;
+	}
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static void rtl_patch_key_set(struct r8152 *tp, u16 key_addr, u16 patch_key)
+{
+	if (patch_key && key_addr) {
+		sram_write(tp, key_addr, patch_key);
+		sram_write(tp, SRAM_PHY_LOCK, PHY_PATCH_LOCK);
+	} else if (key_addr) {
+		sram_write(tp, 0x0000, 0x0000);
+
+		ocp_reg_clr_bits(tp, OCP_PHY_LOCK, PATCH_LOCK);
+
+		sram_write(tp, key_addr, 0x0000);
+	} else {
+		WARN_ON_ONCE(1);
+	}
+}
+
+static int
+rtl_pre_ram_code(struct r8152 *tp, u16 key_addr, u16 patch_key, bool wait)
+{
+	if (rtl_phy_patch_request(tp, true, wait))
+		return -ETIME;
+
+	rtl_patch_key_set(tp, key_addr, patch_key);
+
+	return 0;
+}
+
+static int rtl_post_ram_code(struct r8152 *tp, u16 key_addr, bool wait)
+{
+	rtl_patch_key_set(tp, key_addr, 0);
+
+	rtl_phy_patch_request(tp, false, wait);
+
+	return 0;
+}
+
+static void patch4(struct r8152 *tp)
+{
+	ocp_word_set_bits(tp, MCU_TYPE_USB, USB_USB_TIMER, BIT(15));
+	ocp_write_word(tp, MCU_TYPE_USB, 0xc0ce, 0x0210);
+	ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_USB_TIMER, BIT(15));
+}
+
+static void r8152b_firmware(struct r8152 *tp)
+{
+	if (tp->version == RTL_VER_01) {
+		int i;
+		static u8 pla_patch_a[] = {
+			0x08, 0xe0, 0x40, 0xe0,
+			0x78, 0xe0, 0x85, 0xe0,
+			0x5d, 0xe1, 0xa1, 0xe1,
+			0xa3, 0xe1, 0xab, 0xe1,
+			0x31, 0xc3, 0x60, 0x72,
+			0xa0, 0x49, 0x10, 0xf0,
+			0xa4, 0x49, 0x0e, 0xf0,
+			0x2c, 0xc3, 0x62, 0x72,
+			0x26, 0x70, 0x80, 0x49,
+			0x05, 0xf0, 0x2f, 0x48,
+			0x62, 0x9a, 0x24, 0x70,
+			0x60, 0x98, 0x24, 0xc3,
+			0x60, 0x99, 0x23, 0xc3,
+			0x00, 0xbb, 0x2c, 0x75,
+			0xdc, 0x21, 0xbc, 0x25,
+			0x04, 0x13, 0x0a, 0xf0,
+			0x03, 0x13, 0x08, 0xf0,
+			0x02, 0x13, 0x06, 0xf0,
+			0x01, 0x13, 0x04, 0xf0,
+			0x08, 0x13, 0x02, 0xf0,
+			0x03, 0xe0, 0xd4, 0x49,
+			0x04, 0xf1, 0x14, 0xc2,
+			0x12, 0xc3, 0x00, 0xbb,
+			0x12, 0xc3, 0x60, 0x75,
+			0xd0, 0x49, 0x05, 0xf1,
+			0x50, 0x48, 0x60, 0x9d,
+			0x09, 0xc6, 0x00, 0xbe,
+			0xd0, 0x48, 0x60, 0x9d,
+			0xf3, 0xe7, 0xc2, 0xc0,
+			0x38, 0xd2, 0xc6, 0xd2,
+			0x84, 0x17, 0xa2, 0x13,
+			0x0c, 0x17, 0xbc, 0xc0,
+			0xa2, 0xd1, 0x33, 0xc5,
+			0xa0, 0x74, 0xc0, 0x49,
+			0x1f, 0xf0, 0x30, 0xc5,
+			0xa0, 0x73, 0x00, 0x13,
+			0x04, 0xf1, 0xa2, 0x73,
+			0x00, 0x13, 0x14, 0xf0,
+			0x28, 0xc5, 0xa0, 0x74,
+			0xc8, 0x49, 0x1b, 0xf1,
+			0x26, 0xc5, 0xa0, 0x76,
+			0xa2, 0x74, 0x01, 0x06,
+			0x20, 0x37, 0xa0, 0x9e,
+			0xa2, 0x9c, 0x1e, 0xc5,
+			0xa2, 0x73, 0x23, 0x40,
+			0x10, 0xf8, 0x04, 0xf3,
+			0xa0, 0x73, 0x33, 0x40,
+			0x0c, 0xf8, 0x15, 0xc5,
+			0xa0, 0x74, 0x41, 0x48,
+			0xa0, 0x9c, 0x14, 0xc5,
+			0xa0, 0x76, 0x62, 0x48,
+			0xe0, 0x48, 0xa0, 0x9e,
+			0x10, 0xc6, 0x00, 0xbe,
+			0x0a, 0xc5, 0xa0, 0x74,
+			0x48, 0x48, 0xa0, 0x9c,
+			0x0b, 0xc5, 0x20, 0x1e,
+			0xa0, 0x9e, 0xe5, 0x48,
+			0xa0, 0x9e, 0xf0, 0xe7,
+			0xbc, 0xc0, 0xc8, 0xd2,
+			0xcc, 0xd2, 0x28, 0xe4,
+			0x22, 0x02, 0xf0, 0xc0,
+			0x0b, 0xc0, 0x00, 0x71,
+			0x0a, 0xc0, 0x00, 0x72,
+			0xa0, 0x49, 0x04, 0xf0,
+			0xa4, 0x49, 0x02, 0xf0,
+			0x93, 0x48, 0x04, 0xc0,
+			0x00, 0xb8, 0x00, 0xe4,
+			0xc2, 0xc0, 0x8c, 0x09,
+			0x14, 0xc2, 0x40, 0x73,
+			0xba, 0x48, 0x40, 0x9b,
+			0x11, 0xc2, 0x40, 0x73,
+			0xb0, 0x49, 0x17, 0xf0,
+			0xbf, 0x49, 0x03, 0xf1,
+			0x09, 0xc5, 0x00, 0xbd,
+			0xb1, 0x49, 0x11, 0xf0,
+			0xb1, 0x48, 0x40, 0x9b,
+			0x02, 0xc2, 0x00, 0xba,
+			0x82, 0x18, 0x00, 0xa0,
+			0x1e, 0xfc, 0xbc, 0xc0,
+			0xf0, 0xc0, 0xde, 0xe8,
+			0x00, 0x80, 0x00, 0x60,
+			0x2c, 0x75, 0xd4, 0x49,
+			0x12, 0xf1, 0x29, 0xe0,
+			0xf8, 0xc2, 0x46, 0x71,
+			0xf7, 0xc2, 0x40, 0x73,
+			0xbe, 0x49, 0x03, 0xf1,
+			0xf5, 0xc7, 0x02, 0xe0,
+			0xf2, 0xc7, 0x4f, 0x30,
+			0x26, 0x62, 0xa1, 0x49,
+			0xf0, 0xf1, 0x22, 0x72,
+			0xa0, 0x49, 0xed, 0xf1,
+			0x25, 0x25, 0x18, 0x1f,
+			0x97, 0x30, 0x91, 0x30,
+			0x36, 0x9a, 0x2c, 0x75,
+			0x32, 0xc3, 0x60, 0x73,
+			0xb1, 0x49, 0x0d, 0xf1,
+			0xdc, 0x21, 0xbc, 0x25,
+			0x27, 0xc6, 0xc0, 0x77,
+			0x04, 0x13, 0x18, 0xf0,
+			0x03, 0x13, 0x19, 0xf0,
+			0x02, 0x13, 0x1a, 0xf0,
+			0x01, 0x13, 0x1b, 0xf0,
+			0xd4, 0x49, 0x03, 0xf1,
+			0x1c, 0xc5, 0x00, 0xbd,
+			0xcd, 0xc6, 0xc6, 0x67,
+			0x2e, 0x75, 0xd7, 0x22,
+			0xdd, 0x26, 0x05, 0x15,
+			0x1a, 0xf0, 0x14, 0xc6,
+			0x00, 0xbe, 0x13, 0xc5,
+			0x00, 0xbd, 0x12, 0xc5,
+			0x00, 0xbd, 0xf1, 0x49,
+			0xfb, 0xf1, 0xef, 0xe7,
+			0xf4, 0x49, 0xfa, 0xf1,
+			0xec, 0xe7, 0xf3, 0x49,
+			0xf7, 0xf1, 0xe9, 0xe7,
+			0xf2, 0x49, 0xf4, 0xf1,
+			0xe6, 0xe7, 0xb6, 0xc0,
+			0x6a, 0x14, 0xac, 0x13,
+			0xd6, 0x13, 0xfa, 0x14,
+			0xa0, 0xd1, 0x00, 0x00,
+			0xc0, 0x75, 0xd0, 0x49,
+			0x46, 0xf0, 0x26, 0x72,
+			0xa7, 0x49, 0x43, 0xf0,
+			0x22, 0x72, 0x25, 0x25,
+			0x20, 0x1f, 0x97, 0x30,
+			0x91, 0x30, 0x40, 0x73,
+			0xf3, 0xc4, 0x1c, 0x40,
+			0x04, 0xf0, 0xd7, 0x49,
+			0x05, 0xf1, 0x37, 0xe0,
+			0x53, 0x48, 0xc0, 0x9d,
+			0x08, 0x02, 0x40, 0x66,
+			0x64, 0x27, 0x06, 0x16,
+			0x30, 0xf1, 0x46, 0x63,
+			0x3b, 0x13, 0x2d, 0xf1,
+			0x34, 0x9b, 0x18, 0x1b,
+			0x93, 0x30, 0x2b, 0xc3,
+			0x10, 0x1c, 0x2b, 0xe8,
+			0x01, 0x14, 0x25, 0xf1,
+			0x00, 0x1d, 0x26, 0x1a,
+			0x8a, 0x30, 0x22, 0x73,
+			0xb5, 0x25, 0x0e, 0x0b,
+			0x00, 0x1c, 0x2c, 0xe8,
+			0x1f, 0xc7, 0x27, 0x40,
+			0x1a, 0xf1, 0x38, 0xe8,
+			0x32, 0x1f, 0x8f, 0x30,
+			0x08, 0x1b, 0x24, 0xe8,
+			0x36, 0x72, 0x46, 0x77,
+			0x00, 0x17, 0x0d, 0xf0,
+			0x13, 0xc3, 0x1f, 0x40,
+			0x03, 0xf1, 0x00, 0x1f,
+			0x46, 0x9f, 0x44, 0x77,
+			0x9f, 0x44, 0x5f, 0x44,
+			0x17, 0xe8, 0x0a, 0xc7,
+			0x27, 0x40, 0x05, 0xf1,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x50, 0x1a, 0x06, 0x1a,
+			0xff, 0xc7, 0x00, 0xbf,
+			0xb8, 0xcd, 0xff, 0xff,
+			0x02, 0x0c, 0x54, 0xa5,
+			0xdc, 0xa5, 0x2f, 0x40,
+			0x05, 0xf1, 0x00, 0x14,
+			0xfa, 0xf1, 0x01, 0x1c,
+			0x02, 0xe0, 0x00, 0x1c,
+			0x80, 0xff, 0xb0, 0x49,
+			0x04, 0xf0, 0x01, 0x0b,
+			0xd3, 0xa1, 0x03, 0xe0,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x00, 0x13, 0xfb, 0xf1,
+			0x80, 0xff, 0x22, 0x73,
+			0xb5, 0x25, 0x18, 0x1e,
+			0xde, 0x30, 0xd9, 0x30,
+			0x64, 0x72, 0x11, 0x1e,
+			0x68, 0x23, 0x16, 0x31,
+			0x80, 0xff, 0xd4, 0x49,
+			0x28, 0xf0, 0x02, 0xb4,
+			0x2a, 0xc4, 0x00, 0x1d,
+			0x2e, 0xe8, 0xe0, 0x73,
+			0xb9, 0x21, 0xbd, 0x25,
+			0x04, 0x13, 0x02, 0xf0,
+			0x1a, 0xe0, 0x22, 0xc4,
+			0x23, 0xc3, 0x2f, 0xe8,
+			0x23, 0xc3, 0x2d, 0xe8,
+			0x00, 0x1d, 0x21, 0xe8,
+			0xe2, 0x73, 0xbb, 0x49,
+			0xfc, 0xf0, 0xe0, 0x73,
+			0xb7, 0x48, 0x03, 0xb4,
+			0x81, 0x1d, 0x19, 0xe8,
+			0x40, 0x1a, 0x84, 0x1d,
+			0x16, 0xe8, 0x12, 0xc3,
+			0x1e, 0xe8, 0x03, 0xb0,
+			0x81, 0x1d, 0x11, 0xe8,
+			0x0e, 0xc3, 0x19, 0xe8,
+			0x02, 0xb0, 0x06, 0xc7,
+			0x04, 0x1e, 0xe0, 0x9e,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x22, 0x02, 0x20, 0xe4,
+			0x04, 0xb8, 0x34, 0xb0,
+			0x00, 0x02, 0x00, 0x03,
+			0x00, 0x0e, 0x00, 0x0c,
+			0x09, 0xc7, 0xe0, 0x9b,
+			0xe2, 0x9a, 0xe4, 0x9c,
+			0xe6, 0x8d, 0xe6, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0x80, 0xff, 0x08, 0xea,
+			0x82, 0x1d, 0xf5, 0xef,
+			0x00, 0x1a, 0x88, 0x1d,
+			0xf2, 0xef, 0xed, 0xc2,
+			0xf0, 0xef, 0x80, 0xff,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x46, 0x06, 0x08, 0xc2,
+			0x40, 0x73, 0x3a, 0x48,
+			0x40, 0x9b, 0x06, 0xff,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x86, 0x17, 0x1e, 0xfc,
+			0x36, 0xf0, 0x08, 0x1c,
+			0xea, 0x8c, 0xe3, 0x64,
+			0xc7, 0x49, 0x25, 0xf1,
+			0xe0, 0x75, 0xff, 0x1b,
+			0xeb, 0x47, 0xff, 0x1b,
+			0x6b, 0x47, 0xe0, 0x9d,
+			0x15, 0xc3, 0x60, 0x75,
+			0xd8, 0x49, 0x04, 0xf0,
+			0x81, 0x1d, 0xe2, 0x8d,
+			0x05, 0xe0, 0xe2, 0x63,
+			0x81, 0x1d, 0xdd, 0x47,
+			0xe2, 0x8b, 0x0b, 0xc3,
+			0x00, 0x1d, 0x61, 0x8d,
+			0x3c, 0x03, 0x60, 0x75,
+			0xd8, 0x49, 0x06, 0xf1,
+			0xdf, 0x48, 0x61, 0x95,
+			0x16, 0xe0, 0x4e, 0xe8,
+			0x12, 0xe8, 0x21, 0xc5,
+			0xa0, 0x73, 0xb0, 0x49,
+			0x03, 0xf0, 0x31, 0x48,
+			0xa0, 0x9b, 0x0d, 0xe0,
+			0xc0, 0x49, 0x0b, 0xf1,
+			0xe2, 0x63, 0x7e, 0x1d,
+			0xdd, 0x46, 0xe2, 0x8b,
+			0xe0, 0x75, 0x83, 0x1b,
+			0xeb, 0x46, 0xfe, 0x1b,
+			0x6b, 0x46, 0xe0, 0x9d,
+			0xe4, 0x49, 0x11, 0xf0,
+			0x10, 0x1d, 0xea, 0x8d,
+			0xe3, 0x64, 0xc6, 0x49,
+			0x09, 0xf1, 0x07, 0xc5,
+			0xa0, 0x73, 0xb1, 0x48,
+			0xa0, 0x9b, 0x02, 0xc5,
+			0x00, 0xbd, 0xe6, 0x04,
+			0xa0, 0xd1, 0x02, 0xc5,
+			0x00, 0xbd, 0xfe, 0x04,
+			0x02, 0xc5, 0x00, 0xbd,
+			0x30, 0x05, 0x00, 0x00 };
+		static u16 ram_code1[] = {
+			0x9700, 0x7fe0, 0x4c00, 0x4007,
+			0x4400, 0x4800, 0x7c1f, 0x4c00,
+			0x5310, 0x6000, 0x7c07, 0x6800,
+			0x673e, 0x0000, 0x0000, 0x571f,
+			0x5ffb, 0xaa05, 0x5b58, 0x7d80,
+			0x6100, 0x3019, 0x5b64, 0x7d80,
+			0x6080, 0xa6f8, 0xdcdb, 0x0015,
+			0xb915, 0xb511, 0xd16b, 0x000f,
+			0xb40f, 0xd06b, 0x000d, 0xb206,
+			0x7c01, 0x5800, 0x7c04, 0x5c00,
+			0x3011, 0x7c01, 0x5801, 0x7c04,
+			0x5c04, 0x3019, 0x30a5, 0x3127,
+			0x31d5, 0x7fe0, 0x4c60, 0x7c07,
+			0x6803, 0x7d00, 0x6900, 0x65a0,
+			0x0000, 0x0000, 0xaf03, 0x6015,
+			0x303e, 0x6017, 0x57e0, 0x580c,
+			0x588c, 0x7fdd, 0x5fa2, 0x4827,
+			0x7c1f, 0x4c00, 0x7c1f, 0x4c10,
+			0x8400, 0x7c30, 0x6020, 0x48bf,
+			0x7c1f, 0x4c00, 0x7c1f, 0x4c01,
+			0x7c07, 0x6803, 0xb806, 0x7c08,
+			0x6800, 0x0000, 0x0000, 0x305c,
+			0x7c08, 0x6808, 0x0000, 0x0000,
+			0xae06, 0x7c02, 0x5c02, 0x0000,
+			0x0000, 0x3067, 0x8e05, 0x7c02,
+			0x5c00, 0x0000, 0x0000, 0xad06,
+			0x7c20, 0x5c20, 0x0000, 0x0000,
+			0x3072, 0x8d05, 0x7c20, 0x5c00,
+			0x0000, 0x0000, 0xa008, 0x7c07,
+			0x6800, 0xb8db, 0x7c07, 0x6803,
+			0xd9b3, 0x00d7, 0x7fe0, 0x4c80,
+			0x7c08, 0x6800, 0x0000, 0x0000,
+			0x7c23, 0x5c23, 0x481d, 0x7c1f,
+			0x4c00, 0x7c1f, 0x4c02, 0x5310,
+			0x81ff, 0x30f5, 0x7fe0, 0x4d00,
+			0x4832, 0x7c1f, 0x4c00, 0x7c1f,
+			0x4c10, 0x7c08, 0x6000, 0xa49e,
+			0x7c07, 0x6800, 0xb89b, 0x7c07,
+			0x6803, 0xd9b3, 0x00f9, 0x7fe0,
+			0x4d20, 0x7e00, 0x6200, 0x3001,
+			0x7fe0, 0x4dc0, 0xd09d, 0x0002,
+			0xb4fe, 0x7fe0, 0x4d80, 0x7c04,
+			0x6004, 0x7c07, 0x6802, 0x6728,
+			0x0000, 0x0000, 0x7c08, 0x6000,
+			0x486c, 0x7c1f, 0x4c00, 0x7c1f,
+			0x4c01, 0x9503, 0x7e00, 0x6200,
+			0x571f, 0x5fbb, 0xaa05, 0x5b58,
+			0x7d80, 0x6100, 0x30c2, 0x5b64,
+			0x7d80, 0x6080, 0xcdab, 0x0063,
+			0xcd8d, 0x0061, 0xd96b, 0x005f,
+			0xd0a0, 0x00d7, 0xcba0, 0x0003,
+			0x80ec, 0x30cf, 0x30dc, 0x7fe0,
+			0x4ce0, 0x4832, 0x7c1f, 0x4c00,
+			0x7c1f, 0x4c08, 0x7c08, 0x6008,
+			0x8300, 0xb902, 0x30a5, 0x308a,
+			0x7fe0, 0x4da0, 0x65a8, 0x0000,
+			0x0000, 0x56a0, 0x590c, 0x7ffd,
+			0x5fa2, 0xae06, 0x7c02, 0x5c02,
+			0x0000, 0x0000, 0x30f0, 0x8e05,
+			0x7c02, 0x5c00, 0x0000, 0x0000,
+			0xcba4, 0x0004, 0xcd8d, 0x0002,
+			0x80f1, 0x7fe0, 0x4ca0, 0x7c08,
+			0x6408, 0x0000, 0x0000, 0x7d00,
+			0x6800, 0xb603, 0x7c10, 0x6010,
+			0x7d1f, 0x551f, 0x5fb3, 0xaa07,
+			0x7c80, 0x5800, 0x5b58, 0x7d80,
+			0x6100, 0x310f, 0x7c80, 0x5800,
+			0x5b64, 0x7d80, 0x6080, 0x4827,
+			0x7c1f, 0x4c00, 0x7c1f, 0x4c10,
+			0x8400, 0x7c10, 0x6000, 0x7fe0,
+			0x4cc0, 0x5fbb, 0x4824, 0x7c1f,
+			0x4c00, 0x7c1f, 0x4c04, 0x8200,
+			0x7ce0, 0x5400, 0x6728, 0x0000,
+			0x0000, 0x30cf, 0x3001, 0x7fe0,
+			0x4e00, 0x4007, 0x4400, 0x5310,
+			0x7c07, 0x6800, 0x673e, 0x0000,
+			0x0000, 0x570f, 0x5fff, 0xaa05,
+			0x585b, 0x7d80, 0x6100, 0x313b,
+			0x5867, 0x7d80, 0x6080, 0x9403,
+			0x7e00, 0x6200, 0xcda3, 0x00e7,
+			0xcd85, 0x00e5, 0xd96b, 0x00e3,
+			0x96e3, 0x7c07, 0x6800, 0x673e,
+			0x0000, 0x0000, 0x7fe0, 0x4e20,
+			0x96db, 0x8b04, 0x7c08, 0x5008,
+			0xab03, 0x7c08, 0x5000, 0x7c07,
+			0x6801, 0x677e, 0x0000, 0x0000,
+			0xdb7c, 0x00ec, 0x0000, 0x7fe1,
+			0x4f40, 0x4837, 0x4418, 0x41c7,
+			0x7fe0, 0x4e40, 0x7c40, 0x5400,
+			0x7c1f, 0x4c01, 0x7c1f, 0x4c01,
+			0x8fbf, 0xd2a0, 0x004b, 0x9204,
+			0xa042, 0x3168, 0x3127, 0x7fe1,
+			0x4f60, 0x489c, 0x4628, 0x7fe0,
+			0x4e60, 0x7e28, 0x4628, 0x7c40,
+			0x5400, 0x7c01, 0x5800, 0x7c04,
+			0x5c00, 0x41e8, 0x7c1f, 0x4c01,
+			0x7c1f, 0x4c01, 0x8fa5, 0xb241,
+			0xa02a, 0x3182, 0x7fe0, 0x4ea0,
+			0x7c02, 0x4402, 0x4448, 0x4894,
+			0x7c1f, 0x4c01, 0x7c1f, 0x4c03,
+			0x4824, 0x7c1f, 0x4c07, 0x41ef,
+			0x41ff, 0x4891, 0x7c1f, 0x4c07,
+			0x7c1f, 0x4c17, 0x8400, 0x8ef8,
+			0x41c7, 0x8f8a, 0x92d5, 0xa10f,
+			0xd480, 0x0008, 0xd580, 0x00b8,
+			0xa202, 0x319d, 0x7c04, 0x4404,
+			0x319d, 0xd484, 0x00f3, 0xd484,
+			0x00f1, 0x3127, 0x7fe0, 0x4ee0,
+			0x7c40, 0x5400, 0x4488, 0x41cf,
+			0x3127, 0x7fe0, 0x4ec0, 0x48f3,
+			0x7c1f, 0x4c01, 0x7c1f, 0x4c09,
+			0x4508, 0x41c7, 0x8fb0, 0xd218,
+			0x00ae, 0xd2a4, 0x009e, 0x31be,
+			0x7fe0, 0x4e80, 0x4832, 0x7c1f,
+			0x4c01, 0x7c1f, 0x4c11, 0x4428,
+			0x7c40, 0x5440, 0x7c01, 0x5801,
+			0x7c04, 0x5c04, 0x41e8, 0xa4b3,
+			0x31d3, 0x7fe0, 0x4f20, 0x7c07,
+			0x6800, 0x673e, 0x0000, 0x0000,
+			0x570f, 0x5fff, 0xaa04, 0x585b,
+			0x6100, 0x31e4, 0x5867, 0x6080,
+			0xbcf1, 0x3001 };
+
+		patch4(tp);
+		rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+		generic_ocp_write(tp, 0xf800, 0x3f, sizeof(pla_patch_a),
+				  pla_patch_a, MCU_TYPE_PLA);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x170b);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x01e1);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x0989);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x1349);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc30, 0x01b7);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc32, 0x061d);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xe422, 0x0020);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xe420, 0x0018);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc34, 0x1785);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc36, 0x047b);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, 0x2000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb092, 0x7070);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb098, 0x0600);
+		for (i = 0; i < ARRAY_SIZE(ram_code1); i++)
+			ocp_write_word(tp, MCU_TYPE_PLA, 0xb09a, ram_code1[i]);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb098, 0x0200);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb092, 0x7030);
+
+		rtl_reset_ocp_base(tp);
+	} else if (tp->version == RTL_VER_02) {
+		static u8 pla_patch_a2[] = {
+			0x08, 0xe0, 0x1a, 0xe0,
+			0xf2, 0xe0, 0xfa, 0xe0,
+			0x32, 0xe1, 0x34, 0xe1,
+			0x36, 0xe1, 0x38, 0xe1,
+			0x2c, 0x75, 0xdc, 0x21,
+			0xbc, 0x25, 0x04, 0x13,
+			0x0b, 0xf0, 0x03, 0x13,
+			0x09, 0xf0, 0x02, 0x13,
+			0x07, 0xf0, 0x01, 0x13,
+			0x05, 0xf0, 0x08, 0x13,
+			0x03, 0xf0, 0x04, 0xc3,
+			0x00, 0xbb, 0x03, 0xc3,
+			0x00, 0xbb, 0xd2, 0x17,
+			0xbc, 0x17, 0x14, 0xc2,
+			0x40, 0x73, 0xba, 0x48,
+			0x40, 0x9b, 0x11, 0xc2,
+			0x40, 0x73, 0xb0, 0x49,
+			0x17, 0xf0, 0xbf, 0x49,
+			0x03, 0xf1, 0x09, 0xc5,
+			0x00, 0xbd, 0xb1, 0x49,
+			0x11, 0xf0, 0xb1, 0x48,
+			0x40, 0x9b, 0x02, 0xc2,
+			0x00, 0xba, 0x4e, 0x19,
+			0x00, 0xa0, 0x1e, 0xfc,
+			0xbc, 0xc0, 0xf0, 0xc0,
+			0xde, 0xe8, 0x00, 0x80,
+			0x00, 0x60, 0x2c, 0x75,
+			0xd4, 0x49, 0x12, 0xf1,
+			0x29, 0xe0, 0xf8, 0xc2,
+			0x46, 0x71, 0xf7, 0xc2,
+			0x40, 0x73, 0xbe, 0x49,
+			0x03, 0xf1, 0xf5, 0xc7,
+			0x02, 0xe0, 0xf2, 0xc7,
+			0x4f, 0x30, 0x26, 0x62,
+			0xa1, 0x49, 0xf0, 0xf1,
+			0x22, 0x72, 0xa0, 0x49,
+			0xed, 0xf1, 0x25, 0x25,
+			0x18, 0x1f, 0x97, 0x30,
+			0x91, 0x30, 0x36, 0x9a,
+			0x2c, 0x75, 0x32, 0xc3,
+			0x60, 0x73, 0xb1, 0x49,
+			0x0d, 0xf1, 0xdc, 0x21,
+			0xbc, 0x25, 0x27, 0xc6,
+			0xc0, 0x77, 0x04, 0x13,
+			0x18, 0xf0, 0x03, 0x13,
+			0x19, 0xf0, 0x02, 0x13,
+			0x1a, 0xf0, 0x01, 0x13,
+			0x1b, 0xf0, 0xd4, 0x49,
+			0x03, 0xf1, 0x1c, 0xc5,
+			0x00, 0xbd, 0xcd, 0xc6,
+			0xc6, 0x67, 0x2e, 0x75,
+			0xd7, 0x22, 0xdd, 0x26,
+			0x05, 0x15, 0x1a, 0xf0,
+			0x14, 0xc6, 0x00, 0xbe,
+			0x13, 0xc5, 0x00, 0xbd,
+			0x12, 0xc5, 0x00, 0xbd,
+			0xf1, 0x49, 0xfb, 0xf1,
+			0xef, 0xe7, 0xf4, 0x49,
+			0xfa, 0xf1, 0xec, 0xe7,
+			0xf3, 0x49, 0xf7, 0xf1,
+			0xe9, 0xe7, 0xf2, 0x49,
+			0xf4, 0xf1, 0xe6, 0xe7,
+			0xb6, 0xc0, 0xf6, 0x14,
+			0x36, 0x14, 0x62, 0x14,
+			0x86, 0x15, 0xa0, 0xd1,
+			0x00, 0x00, 0xc0, 0x75,
+			0xd0, 0x49, 0x46, 0xf0,
+			0x26, 0x72, 0xa7, 0x49,
+			0x43, 0xf0, 0x22, 0x72,
+			0x25, 0x25, 0x20, 0x1f,
+			0x97, 0x30, 0x91, 0x30,
+			0x40, 0x73, 0xf3, 0xc4,
+			0x1c, 0x40, 0x04, 0xf0,
+			0xd7, 0x49, 0x05, 0xf1,
+			0x37, 0xe0, 0x53, 0x48,
+			0xc0, 0x9d, 0x08, 0x02,
+			0x40, 0x66, 0x64, 0x27,
+			0x06, 0x16, 0x30, 0xf1,
+			0x46, 0x63, 0x3b, 0x13,
+			0x2d, 0xf1, 0x34, 0x9b,
+			0x18, 0x1b, 0x93, 0x30,
+			0x2b, 0xc3, 0x10, 0x1c,
+			0x2b, 0xe8, 0x01, 0x14,
+			0x25, 0xf1, 0x00, 0x1d,
+			0x26, 0x1a, 0x8a, 0x30,
+			0x22, 0x73, 0xb5, 0x25,
+			0x0e, 0x0b, 0x00, 0x1c,
+			0x2c, 0xe8, 0x1f, 0xc7,
+			0x27, 0x40, 0x1a, 0xf1,
+			0x38, 0xe8, 0x32, 0x1f,
+			0x8f, 0x30, 0x08, 0x1b,
+			0x24, 0xe8, 0x36, 0x72,
+			0x46, 0x77, 0x00, 0x17,
+			0x0d, 0xf0, 0x13, 0xc3,
+			0x1f, 0x40, 0x03, 0xf1,
+			0x00, 0x1f, 0x46, 0x9f,
+			0x44, 0x77, 0x9f, 0x44,
+			0x5f, 0x44, 0x17, 0xe8,
+			0x0a, 0xc7, 0x27, 0x40,
+			0x05, 0xf1, 0x02, 0xc3,
+			0x00, 0xbb, 0x1c, 0x1b,
+			0xd2, 0x1a, 0xff, 0xc7,
+			0x00, 0xbf, 0xb8, 0xcd,
+			0xff, 0xff, 0x02, 0x0c,
+			0x54, 0xa5, 0xdc, 0xa5,
+			0x2f, 0x40, 0x05, 0xf1,
+			0x00, 0x14, 0xfa, 0xf1,
+			0x01, 0x1c, 0x02, 0xe0,
+			0x00, 0x1c, 0x80, 0xff,
+			0xb0, 0x49, 0x04, 0xf0,
+			0x01, 0x0b, 0xd3, 0xa1,
+			0x03, 0xe0, 0x02, 0x0b,
+			0xd3, 0xa5, 0x27, 0x31,
+			0x20, 0x37, 0x02, 0x0b,
+			0xd3, 0xa5, 0x27, 0x31,
+			0x20, 0x37, 0x00, 0x13,
+			0xfb, 0xf1, 0x80, 0xff,
+			0x22, 0x73, 0xb5, 0x25,
+			0x18, 0x1e, 0xde, 0x30,
+			0xd9, 0x30, 0x64, 0x72,
+			0x11, 0x1e, 0x68, 0x23,
+			0x16, 0x31, 0x80, 0xff,
+			0x08, 0xc2, 0x40, 0x73,
+			0x3a, 0x48, 0x40, 0x9b,
+			0x06, 0xff, 0x02, 0xc6,
+			0x00, 0xbe, 0x4e, 0x18,
+			0x1e, 0xfc, 0x33, 0xc5,
+			0xa0, 0x74, 0xc0, 0x49,
+			0x1f, 0xf0, 0x30, 0xc5,
+			0xa0, 0x73, 0x00, 0x13,
+			0x04, 0xf1, 0xa2, 0x73,
+			0x00, 0x13, 0x14, 0xf0,
+			0x28, 0xc5, 0xa0, 0x74,
+			0xc8, 0x49, 0x1b, 0xf1,
+			0x26, 0xc5, 0xa0, 0x76,
+			0xa2, 0x74, 0x01, 0x06,
+			0x20, 0x37, 0xa0, 0x9e,
+			0xa2, 0x9c, 0x1e, 0xc5,
+			0xa2, 0x73, 0x23, 0x40,
+			0x10, 0xf8, 0x04, 0xf3,
+			0xa0, 0x73, 0x33, 0x40,
+			0x0c, 0xf8, 0x15, 0xc5,
+			0xa0, 0x74, 0x41, 0x48,
+			0xa0, 0x9c, 0x14, 0xc5,
+			0xa0, 0x76, 0x62, 0x48,
+			0xe0, 0x48, 0xa0, 0x9e,
+			0x10, 0xc6, 0x00, 0xbe,
+			0x0a, 0xc5, 0xa0, 0x74,
+			0x48, 0x48, 0xa0, 0x9c,
+			0x0b, 0xc5, 0x20, 0x1e,
+			0xa0, 0x9e, 0xe5, 0x48,
+			0xa0, 0x9e, 0xf0, 0xe7,
+			0xbc, 0xc0, 0xc8, 0xd2,
+			0xcc, 0xd2, 0x28, 0xe4,
+			0x22, 0x02, 0xf0, 0xc0,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x00, 0x00, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x00, 0x00, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00 };
+		static u8 usb_patch_a2[] = {
+			0x08, 0xe0, 0x25, 0xe0,
+			0x8e, 0xe0, 0xb8, 0xe0,
+			0xba, 0xe0, 0xbc, 0xe0,
+			0xbe, 0xe0, 0xc0, 0xe0,
+			0x1c, 0xc2, 0x40, 0x71,
+			0x9f, 0x48, 0x40, 0x99,
+			0x1f, 0x48, 0x40, 0x99,
+			0x15, 0xc2, 0x40, 0x61,
+			0x90, 0x49, 0x0a, 0xf0,
+			0x42, 0x70, 0x80, 0x49,
+			0x07, 0xf0, 0x80, 0x48,
+			0x42, 0x98, 0x0b, 0xc2,
+			0x40, 0x60, 0x03, 0x48,
+			0x40, 0x88, 0x0a, 0xc2,
+			0x08, 0x18, 0x55, 0x60,
+			0x55, 0x88, 0x02, 0xc0,
+			0x00, 0xb8, 0xc2, 0x09,
+			0x28, 0xd4, 0xd4, 0xc4,
+			0x06, 0xd4, 0x00, 0xb0,
+			0x69, 0xc7, 0x62, 0xc6,
+			0xe4, 0x9e, 0x0f, 0x1e,
+			0xe6, 0x8e, 0xe6, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xe0, 0x73, 0xe2, 0x74,
+			0xb8, 0x26, 0xb8, 0x21,
+			0xb8, 0x25, 0x48, 0x23,
+			0x68, 0x27, 0x04, 0xb4,
+			0x05, 0xb4, 0x06, 0xb4,
+			0x52, 0xc6, 0xe3, 0x23,
+			0xfe, 0x39, 0x00, 0x1c,
+			0x00, 0x1d, 0x00, 0x13,
+			0x0c, 0xf0, 0xb0, 0x49,
+			0x04, 0xf1, 0x01, 0x05,
+			0xb1, 0x25, 0xfa, 0xe7,
+			0xb8, 0x33, 0x35, 0x43,
+			0x26, 0x31, 0x01, 0x05,
+			0xb1, 0x25, 0xf4, 0xe7,
+			0x06, 0xb0, 0x05, 0xb0,
+			0xae, 0x41, 0x25, 0x31,
+			0x3d, 0xc5, 0x6c, 0x41,
+			0x04, 0xb0, 0x48, 0x26,
+			0x05, 0xb4, 0x3c, 0xc7,
+			0x35, 0xc6, 0x04, 0x06,
+			0xe4, 0x9e, 0x0f, 0x1e,
+			0xe6, 0x8e, 0xe6, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xe0, 0x76, 0xe8, 0x25,
+			0xe8, 0x23, 0xf8, 0x27,
+			0x2a, 0xc5, 0x6c, 0x41,
+			0x33, 0x22, 0x23, 0x39,
+			0x7c, 0x41, 0xfd, 0x31,
+			0x25, 0xc6, 0x7e, 0x41,
+			0xf2, 0x21, 0xdf, 0x30,
+			0xdf, 0x30, 0x05, 0xb0,
+			0x53, 0x22, 0x25, 0x31,
+			0xa3, 0x31, 0x1b, 0xc7,
+			0xb7, 0x31, 0x1b, 0xc7,
+			0x77, 0x41, 0x1b, 0xc7,
+			0x1b, 0xc4, 0x84, 0x9f,
+			0x80, 0x9e, 0x16, 0xc3,
+			0xde, 0x30, 0x60, 0x65,
+			0x82, 0x9d, 0x8f, 0x1e,
+			0x8f, 0x1e, 0x8f, 0x1e,
+			0x86, 0x8e, 0x86, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0x06, 0xc7, 0x04, 0x1e,
+			0xe0, 0x8e, 0x02, 0xc4,
+			0x00, 0xbc, 0xb6, 0x02,
+			0x34, 0xe4, 0x00, 0xc0,
+			0x25, 0x00, 0xff, 0x00,
+			0x7f, 0x00, 0x00, 0xf8,
+			0x88, 0xd3, 0x08, 0xdc,
+			0x1f, 0xc0, 0x1f, 0xc1,
+			0x00, 0x1c, 0x00, 0x99,
+			0x1d, 0xc1, 0x02, 0x99,
+			0x1c, 0xc1, 0x04, 0x99,
+			0x06, 0x9c, 0x1a, 0xc1,
+			0x08, 0x99, 0x0a, 0x9c,
+			0x18, 0xc1, 0x0c, 0x99,
+			0x17, 0xc1, 0x0e, 0x99,
+			0x10, 0x9c, 0x15, 0xc1,
+			0x12, 0x99, 0x14, 0xc1,
+			0x14, 0x99, 0x13, 0xc1,
+			0x16, 0x99, 0x12, 0xc1,
+			0x18, 0x99, 0x08, 0xc1,
+			0x1a, 0x9c, 0x0f, 0xc4,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x04, 0x33, 0x10, 0xc3,
+			0x02, 0x00, 0x08, 0x00,
+			0x38, 0x00, 0x48, 0x00,
+			0x08, 0x00, 0x40, 0x00,
+			0x00, 0x03, 0x80, 0x01,
+			0x12, 0x7a, 0x01, 0x01,
+			0xe0, 0xcb, 0x02, 0xc0,
+			0x00, 0xb8, 0x3a, 0x4e,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x3a, 0x4e,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x3a, 0x4e };
+
+		rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(pla_patch_a2),
+				  pla_patch_a2, MCU_TYPE_PLA);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x17a5);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x13ad);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x184d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x01e1);
+
+		rtl_clear_bp(tp, MCU_TYPE_USB);
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(usb_patch_a2),
+				  usb_patch_a2, MCU_TYPE_USB);
+
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc26, 0xA000);
+
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc28, 0x0c87);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2a, 0x024f);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2c, 0x3303);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2e, 0x0000);
+
+		ocp_word_set_bits(tp, MCU_TYPE_USB, USB_USB_TIMER, BIT(15));
+
+		ocp_word_set_bits(tp, MCU_TYPE_USB, 0xc4d4, BIT(0));
+		ocp_word_clr_bits(tp, MCU_TYPE_USB, 0xc4d6, BIT(0));
+		ocp_word_set_bits(tp, MCU_TYPE_USB, 0xc5d4, BIT(2) | BIT(5));
+
+		ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_USB_TIMER, BIT(15));
+
+		rtl_reset_ocp_base(tp);
+	}
+
+	rtl_reset_ocp_base(tp);
+}
+
+static int r8152_aldps_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = ocp_reg_write(tp, OCP_ALDPS_CONFIG, ENPWRSAVE | ENPDNPS |
+							  LINKENA | DIS_SDSAVE);
+	} else {
+		ret = ocp_reg_write(tp, OCP_ALDPS_CONFIG, ENPDNPS | LINKENA |
+							  DIS_SDSAVE);
+		msleep(20);
+	}
+	return ret;
+}
+
+static int r8152_mmd_indirect(struct r8152 *tp, u16 dev, u16 reg)
+{
+	int ret;
+
+	ret = ocp_reg_write(tp, OCP_EEE_AR, FUN_ADDR | dev);
+	if (ret < 0)
+		goto out;
+	ret = ocp_reg_write(tp, OCP_EEE_DATA, reg);
+	if (ret < 0)
+		goto out;
+	ret = ocp_reg_write(tp, OCP_EEE_AR, FUN_DATA | dev);
+
+out:
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+static int r8152_mmd_read(struct r8152 *tp, u16 dev, u16 reg, u16 *data)
+{
+	int ret;
+
+	ret = r8152_mmd_indirect(tp, dev, reg);
+	if (ret < 0)
+		goto out;
+	ret = ocp_reg_read(tp, OCP_EEE_DATA, data);
+	if (ret < 0)
+		goto out;
+	ret = ocp_reg_write(tp, OCP_EEE_AR, 0x0000);
+
+out:
+	return ret;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+
+static int r8152_mmd_write(struct r8152 *tp, u16 dev, u16 reg, u16 data)
+{
+	int ret;
+
+	ret = r8152_mmd_indirect(tp, dev, reg);
+	if (ret < 0)
+		goto out;
+	ret = ocp_reg_write(tp, OCP_EEE_DATA, data);
+	if (ret < 0)
+		goto out;
+	ret = ocp_reg_write(tp, OCP_EEE_AR, 0x0000);
+
+out:
+	return ret;
+}
+
+static int r8152_eee_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_EEE_CR,
+					EEE_RX_EN | EEE_TX_EN);
+		if (ret < 0)
+			goto out;
+		ret = ocp_reg_w0w1(tp, OCP_EEE_CONFIG1, sd_rise_time_mask,
+				   EEE_10_CAP | EEE_NWAY_EN | TX_QUIET_EN |
+				   RX_QUIET_EN | sd_rise_time(1));
+		if (ret < 0)
+			goto out;
+		ret = ocp_reg_set_bits(tp, OCP_EEE_CONFIG2,
+				       RG_DACQUIET_EN | RG_LDVQUIET_EN);
+		if (ret < 0)
+			goto out;
+		ret = ocp_reg_w0w1(tp, OCP_EEE_CONFIG3, fast_snr_mask,
+				   fast_snr(42));
+	} else {
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_EEE_CR,
+					EEE_RX_EN | EEE_TX_EN);
+		if (ret < 0)
+			goto out;
+		ret = ocp_reg_w0w1(tp, OCP_EEE_CONFIG1, sd_rise_time_mask |
+				   EEE_10_CAP | EEE_NWAY_EN | TX_QUIET_EN |
+				   RX_QUIET_EN, sd_rise_time(7));
+		if (ret < 0)
+			goto out;
+		ret = ocp_reg_clr_bits(tp, OCP_EEE_CONFIG2,
+				       RG_DACQUIET_EN | RG_LDVQUIET_EN);
+		if (ret < 0)
+			goto out;
+		ret = ocp_reg_w0w1(tp, OCP_EEE_CONFIG3, fast_snr_mask,
+				   fast_snr(511));
+	}
+
+out:
+	return ret;
+}
+
+static int r8153_eee_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_EEE_CR,
+					EEE_RX_EN | EEE_TX_EN);
+		if (ret < 0)
+			goto out;
+		ret = ocp_reg_set_bits(tp, OCP_EEE_CFG, EEE10_EN);
+		if (ret < 0)
+			goto out;
+		ret = ocp_reg_write(tp, OCP_EEE_ADV, tp->eee_adv);
+	} else {
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_EEE_CR,
+					EEE_RX_EN | EEE_TX_EN);
+		if (ret < 0)
+			goto out;
+		ret = ocp_reg_clr_bits(tp, OCP_EEE_CFG, EEE10_EN);
+		if (ret < 0)
+			goto out;
+		ret = ocp_reg_write(tp, OCP_EEE_ADV, 0);
+	}
+
+	if (ret < 0)
+		goto out;
+
+	tp->ups_info.eee = enable;
+
+out:
+	return ret;
+}
+
+static int r8156_eee_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = r8153_eee_en(tp, true);
+		if (ret < 0)
+			goto out;
+		ret = ocp_reg_write(tp, OCP_EEE_ADV2, tp->eee_adv2);
+		if (ret < 0)
+			goto out;
+
+		clear_bit(DISABLE_EEE_BOTTOM, &tp->flags);
+	} else {
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_EEE_CR,
+					EEE_TX_EN);
+		if (ret < 0)
+			goto out;
+		ret = ocp_reg_write(tp, OCP_EEE_ADV, 0);
+		if (ret < 0)
+			goto out;
+		ret = ocp_reg_write(tp, OCP_EEE_ADV2, 0);
+		if (ret < 0)
+			goto out;
+
+		set_bit(DISABLE_EEE_BOTTOM, &tp->flags);
+
+		tp->ups_info.eee = false;
+	}
+
+out:
+	return ret;
+}
+
+static int r8157_eee_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_EEE_CR,
+					EEE_RX_EN | EEE_TX_EN);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_reg_write(tp, OCP_EEE_ADV, tp->eee_adv);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_reg_write(tp, OCP_EEE_ADV2, tp->eee_adv2);
+	} else {
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_EEE_CR,
+					EEE_RX_EN | EEE_TX_EN);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_reg_write(tp, OCP_EEE_ADV, 0);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_reg_write(tp, OCP_EEE_ADV2, 0);
+	}
+
+	if (ret < 0)
+		goto out;
+
+	tp->ups_info.eee = enable;
+
+out:
+	return ret;
+}
+
+static int rtl_eee_enable(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+		if (enable) {
+			ret = r8152_eee_en(tp, true);
+			if (ret < 0)
+				goto out;
+			ret = r8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV,
+					      tp->eee_adv);
+		} else {
+			ret = r8152_eee_en(tp, false);
+			if (ret < 0)
+				goto out;
+			ret = r8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV,
+					      0);
+		}
+		break;
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_VER_14:
+		ret = r8153_eee_en(tp, enable);
+		break;
+	case RTL_VER_10:
+	case RTL_VER_11:
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_15:
+		ret = r8156_eee_en(tp, enable);
+		break;
+	case RTL_VER_16:
+	case RTL_VER_17:
+		ret = r8157_eee_en(tp, enable);
+		break;
+	default:
+		ret = 0;
+		WARN_ON_ONCE(1);
+		break;
+	}
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static int rtl_disable_eee_bottom(struct r8152 *tp)
+{
+	int i, ret = -EINVAL;
+
+	for (i = 0; i < 50; i++) {
+		if (!(rtl8152_get_speed(tp) & LINK_STATUS)) {
+			ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_EEE_CR,
+						EEE_RX_EN);
+			break;
+		}
+		msleep(20);
+	}
+
+	return (ret < 0) ? ret : 0;
+}
+
+static int r8152b_enable_fc(struct r8152 *tp)
+{
+	int ret;
+
+	ret = r8152_mdio_set_bit(tp, MII_ADVERTISE,
+				 ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+
+	tp->ups_info.flow_control = true;
+
+	return ret;
+}
+
+static int rtl8152_disable(struct r8152 *tp)
+{
+	int ret, err = 0;
+
+	ret = r8152_aldps_en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = rtl_disable(tp);
+	if (ret < 0)
+		err = ret;
+	ret = r8152_aldps_en(tp, true);
+
+	if (err < 0)
+		return err;
+	else
+		return ret;
+}
+
+static void r8152b_hw_phy_cfg(struct r8152 *tp)
+{
+	r8152b_firmware(tp);
+
+	rtl_eee_enable(tp, tp->eee_en);
+	r8152_aldps_en(tp, true);
+	r8152b_enable_fc(tp);
+
+	set_bit(PHY_RESET, &tp->flags);
+}
+
+static void wait_oob_link_list_ready(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i, ret;
+
+	for (i = 0; i < 1000; i++) {
+		ret = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, &ocp_data);
+		if (ret < 0 || (ocp_data & LINK_LIST_READY))
+			break;
+		usleep_range(1000, 2000);
+	}
+}
+
+static int r8156b_wait_loading_flash(struct r8152 *tp)
+{
+	int ret = 0;
+
+	if (r8156b_flash_used(tp)) {
+		int i;
+
+		for (i = 0; i < 100; i++) {
+			u32 ocp_data;
+
+			ret = ocp_read_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL,
+					    &ocp_data);
+			if (ret < 0 || (ocp_data & GPHY_PATCH_DONE))
+				break;
+			usleep_range(1000, 2000);
+		}
+	}
+
+	return ret;
+}
+
+static int r8152b_exit_oob(struct r8152 *tp)
+{
+	int ret;
+
+	ret = ocp_dword_clr_bits(tp, MCU_TYPE_PLA, PLA_RCR, RCR_ACPT_ALL);
+	if (ret < 0)
+		goto out;
+
+	ret = rxdy_gated_en(tp, true);
+	if (ret < 0)
+		goto out;
+	ret = r8153_teredo_off(tp);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, 0x00);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, NOW_IS_OOB);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, MCU_BORW_EN);
+	if (ret < 0)
+		goto out;
+
+	wait_oob_link_list_ready(tp);
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, RE_INIT_LL);
+	if (ret < 0)
+		goto out;
+
+	wait_oob_link_list_ready(tp);
+
+	ret = rtl8152_nic_reset(tp);
+	if (ret < 0)
+		goto out;
+
+	/* rx share fifo credit full threshold */
+	ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_NORMAL);
+	if (ret < 0)
+		goto out;
+
+	if (tp->udev->speed == USB_SPEED_FULL ||
+	    tp->udev->speed == USB_SPEED_LOW) {
+		/* rx share fifo credit near full threshold */
+		ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1,
+				      RXFIFO_THR2_FULL);
+		if (ret < 0)
+			goto out;
+		ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2,
+				      RXFIFO_THR3_FULL);
+		if (ret < 0)
+			goto out;
+	} else {
+		/* rx share fifo credit near full threshold */
+		ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1,
+				      RXFIFO_THR2_HIGH);
+		if (ret < 0)
+			goto out;
+		ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2,
+				      RXFIFO_THR3_HIGH);
+		if (ret < 0)
+			goto out;
+	}
+
+	/* TX share fifo free credit full threshold */
+	ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, TXFIFO_THR_NORMAL2);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_byte(tp, MCU_TYPE_USB, USB_TX_AGG, TX_AGG_MAX_THRESHOLD);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_HIGH);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_dword(tp, MCU_TYPE_USB, USB_TX_DMA,
+			TEST_MODE_DISABLE | TX_SIZE_ADJUST1);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8152_RMS);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_TCR0, TCR0_AUTO_FIFO);
+	if (ret < 0)
+		goto out;
+
+out:
+	return ret;
+}
+
+static int r8152b_enter_oob(struct r8152 *tp)
+{
+	int ret, err = 0;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, NOW_IS_OOB);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0,
+			      RXFIFO_THR1_OOB);
+	if (ret < 0)
+		err = ret;
+	ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1,
+			      RXFIFO_THR2_OOB);
+	if (ret < 0)
+		err = ret;
+	ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2,
+			      RXFIFO_THR3_OOB);
+	if (ret < 0)
+		err = ret;
+
+	ret = rtl_disable(tp);
+	if (ret < 0)
+		err = ret;
+
+	wait_oob_link_list_ready(tp);
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, RE_INIT_LL);
+	if (ret < 0)
+		err = ret;
+
+	wait_oob_link_list_ready(tp);
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8152_RMS);
+	if (ret < 0)
+		err = ret;
+
+	ret = rtl_rx_vlan_en(tp, true);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_BDC_CR, ALDPS_PROXY_MODE);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_PLA, PLA_OOB_CTRL,
+				NOW_IS_OOB | DIS_MCU_CLROOB);
+	if (ret < 0)
+		err = ret;
+
+	ret = rxdy_gated_en(tp, false);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_dword_set_bits(tp, MCU_TYPE_PLA, PLA_RCR,
+				 RCR_APM | RCR_AM | RCR_AB);
+
+	if (err < 0)
+		return err;
+	else
+		return ret;
+}
+
+static int r8156_lock_main(struct r8152 *tp, bool lock)
+{
+	int i, ret;
+	u16 data;
+
+	if (lock)
+		ret = ocp_reg_set_bits(tp, 0xa46a, BIT(1));
+	else
+		ret = ocp_reg_clr_bits(tp, 0xa46a, BIT(1));
+	if (ret < 0)
+		goto out;
+
+	if (lock) {
+		for (i = 0; i < 100; i++) {
+			usleep_range(1000, 2000);
+			ret = ocp_reg_read(tp, 0xa730, &data);
+			if (ret < 0)
+				goto out;
+			data &= 0xff;
+			if (data == 1)
+				break;
+		}
+	} else {
+		for (i = 0; i < 100; i++) {
+			usleep_range(1000, 2000);
+			ret = ocp_reg_read(tp, 0xa730, &data);
+			if (ret < 0)
+				goto out;
+			data &= 0xff;
+			if (data != 1)
+				break;
+		}
+	}
+
+	if (i == 100)
+		ret = -ETIME;
+	else
+		ret = 0;
+
+out:
+	return ret;
+}
+
+static void r8153_wdt1_end(struct r8152 *tp)
+{
+	int i, ret;
+
+	/* Wait till the WTD timer is ready. It would take at most 104 ms. */
+	for (i = 0; i < 104; i++) {
+		u32 ocp_data;
+
+		ret = ocp_read_byte(tp, MCU_TYPE_USB, USB_WDT1_CTRL, &ocp_data);
+		if (ret < 0 || !(ocp_data & WTD1_EN))
+			break;
+		usleep_range(1000, 2000);
+	}
+}
+
+#define DBG_COUNTER_MASK		0x1f
+#define DBG_DRV_RUNNING			(1 << 5)
+#define DGB_DRV_STATE_MASK		(3 << 14)
+#define DGB_DRV_STATE_LOAD		(2 << 14)
+#define DGB_DRV_STATE_UNLOAD		(1 << 14)
+
+static void rtl_set_dbg_info_init(struct r8152 *tp, u16 drv_version)
+{
+	u32 counter;
+
+	if (ocp_read_byte(tp, MCU_TYPE_USB, 0xcfcf, &counter) < 0)
+		return;
+	counter++;
+	counter &= DBG_COUNTER_MASK;
+	ocp_write_byte(tp, MCU_TYPE_USB, 0xcfcf, counter | DBG_DRV_RUNNING);
+	counter = (counter << 5) | drv_version;
+	ocp_write_word(tp, MCU_TYPE_USB, 0xcfd0, counter);
+}
+
+static void rtl_set_dbg_info_state(struct r8152 *tp, u16 state)
+{
+	u32 ocp_data;
+
+	if (ocp_read_word(tp, MCU_TYPE_USB, 0xcfd0, &ocp_data) < 0)
+		return;
+	ocp_data &= ~DGB_DRV_STATE_MASK;
+	ocp_write_word(tp, MCU_TYPE_USB, 0xcfd0, state | ocp_data);
+}
+
+static void rtl_fw_ver_erase(struct r8152 *tp)
+{
+	u16 outer_ver;
+	u32 ocp_data;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_07:
+	case RTL_TEST_01:
+		return;
+	case RTL_VER_10:
+	case RTL_VER_11:
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_15:
+		outer_ver = USB_OUTSIDE_FW_VER;
+		break;
+	default:
+		outer_ver = USB_OUTER_FW_VER;
+		break;
+	}
+
+	if (ocp_read_word(tp, MCU_TYPE_USB, outer_ver, &ocp_data) < 0)
+		return;
+
+	if (ocp_data) {
+		ocp_write_word(tp, MCU_TYPE_USB, outer_ver, 0);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_FW_PLA_VER, 0);
+	}
+}
+
+static void r8153_firmware(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int ret;
+
+	if (tp->version == RTL_VER_03) {
+		rtl_reset_ocp_base(tp);
+
+		rtl_pre_ram_code(tp, 0x8146, 0x7000, true);
+		sram_write(tp, 0xb820, 0x0290);
+		sram_write(tp, 0xa012, 0x0000);
+		sram_write(tp, 0xa014, 0x2c04);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c18);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c45);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c45);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd501);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xe018);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x0308);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x60f2);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x607d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc117);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c16);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc116);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c16);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x607d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc117);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x0800);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd501);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x62d2);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x615d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc115);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc307);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c42);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc114);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc317);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd701);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x435d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c42);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x613d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc115);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc307);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c42);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc114);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc317);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd701);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x40dd);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd702);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x0800);
+		sram_write(tp, 0xa01a, 0x0000);
+		sram_write(tp, 0xa006, 0x0fff);
+		sram_write(tp, 0xa004, 0x0fff);
+		sram_write(tp, 0xa002, 0x05a3);
+		sram_write(tp, 0xa000, 0x3591);
+		sram_write(tp, 0xb820, 0x0210);
+		rtl_post_ram_code(tp, 0x8146, true);
+	} else if (tp->version == RTL_VER_04) {
+		static u8 usb_patch_b[] = {
+			0x08, 0xe0, 0x0f, 0xe0,
+			0x18, 0xe0, 0x24, 0xe0,
+			0x26, 0xe0, 0x3a, 0xe0,
+			0x84, 0xe0, 0x9c, 0xe0,
+			0xc2, 0x49, 0x04, 0xf0,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x14, 0x18, 0x02, 0xc0,
+			0x00, 0xb8, 0x2e, 0x18,
+			0x06, 0x89, 0x08, 0xc0,
+			0x0c, 0x61, 0x92, 0x48,
+			0x93, 0x48, 0x0c, 0x89,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x08, 0x05, 0x40, 0xb4,
+			0x16, 0x89, 0x6d, 0xc0,
+			0x00, 0x61, 0x95, 0x49,
+			0x06, 0xf0, 0xfa, 0xc0,
+			0x0c, 0x61, 0x92, 0x48,
+			0x93, 0x48, 0x0c, 0x89,
+			0x02, 0xc0, 0x00, 0xb8,
+			0xe2, 0x04, 0x02, 0xc2,
+			0x00, 0xba, 0xec, 0x11,
+			0x60, 0x60, 0x85, 0x49,
+			0x0d, 0xf1, 0x11, 0xc6,
+			0xd2, 0x61, 0x91, 0x49,
+			0xfd, 0xf0, 0x74, 0x60,
+			0x04, 0x48, 0x74, 0x88,
+			0x08, 0xc6, 0x08, 0xc0,
+			0xc4, 0x98, 0x01, 0x18,
+			0xc0, 0x88, 0x02, 0xc0,
+			0x00, 0xb8, 0x6e, 0x12,
+			0x04, 0xe4, 0x0d, 0x00,
+			0x00, 0xd4, 0xd1, 0x49,
+			0x3c, 0xf1, 0xd2, 0x49,
+			0x16, 0xf1, 0xd3, 0x49,
+			0x18, 0xf1, 0xd4, 0x49,
+			0x19, 0xf1, 0xd5, 0x49,
+			0x1a, 0xf1, 0xd6, 0x49,
+			0x1b, 0xf1, 0xd7, 0x49,
+			0x1c, 0xf1, 0xd8, 0x49,
+			0x1d, 0xf1, 0xd9, 0x49,
+			0x20, 0xf1, 0xda, 0x49,
+			0x23, 0xf1, 0xdb, 0x49,
+			0x24, 0xf1, 0x02, 0xc4,
+			0x00, 0xbc, 0x20, 0x04,
+			0xe5, 0x8e, 0x02, 0xc4,
+			0x00, 0xbc, 0x14, 0x02,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x16, 0x02, 0x02, 0xc4,
+			0x00, 0xbc, 0x18, 0x02,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x1a, 0x02, 0x02, 0xc4,
+			0x00, 0xbc, 0x1c, 0x02,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x94, 0x02, 0x10, 0xc7,
+			0xe0, 0x8e, 0x02, 0xc4,
+			0x00, 0xbc, 0x8a, 0x02,
+			0x0b, 0xc7, 0xe4, 0x8e,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x88, 0x02, 0x02, 0xc4,
+			0x00, 0xbc, 0x6e, 0x02,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x5a, 0x02, 0x30, 0xe4,
+			0x0c, 0xc3, 0x60, 0x64,
+			0xc5, 0x49, 0x04, 0xf1,
+			0x74, 0x64, 0xc4, 0x48,
+			0x74, 0x8c, 0x06, 0xc3,
+			0x64, 0x8e, 0x02, 0xc4,
+			0x00, 0xbc, 0x20, 0x04,
+			0x00, 0xd8, 0x00, 0xe4,
+			0xb2, 0xc0, 0x00, 0x61,
+			0x90, 0x49, 0x09, 0xf1,
+			0x8b, 0xc6, 0xca, 0x61,
+			0x94, 0x49, 0x0e, 0xf1,
+			0xf6, 0xc6, 0xda, 0x60,
+			0x81, 0x49, 0x0a, 0xf0,
+			0x65, 0x60, 0x03, 0x48,
+			0x65, 0x88, 0xef, 0xc6,
+			0xdc, 0x60, 0x80, 0x48,
+			0xdc, 0x88, 0x05, 0xc6,
+			0x00, 0xbe, 0x02, 0xc6,
+			0x00, 0xbe, 0x36, 0x13,
+			0x4c, 0x17, 0x99, 0xc4,
+			0x80, 0x65, 0xd0, 0x49,
+			0x04, 0xf1, 0xfa, 0x75,
+			0x04, 0xc4, 0x00, 0xbc,
+			0x03, 0xc4, 0x00, 0xbc,
+			0x9a, 0x00, 0xee, 0x01 };
+		static u8 pla_patch_b[] = {
+			0x08, 0xe0, 0xea, 0xe0,
+			0xf2, 0xe0, 0x04, 0xe1,
+			0x09, 0xe1, 0x0e, 0xe1,
+			0x46, 0xe1, 0xf7, 0xe1,
+			0x14, 0xc2, 0x40, 0x73,
+			0xba, 0x48, 0x40, 0x9b,
+			0x11, 0xc2, 0x40, 0x73,
+			0xb0, 0x49, 0x17, 0xf0,
+			0xbf, 0x49, 0x03, 0xf1,
+			0x09, 0xc5, 0x00, 0xbd,
+			0xb1, 0x49, 0x11, 0xf0,
+			0xb1, 0x48, 0x40, 0x9b,
+			0x02, 0xc2, 0x00, 0xba,
+			0x1a, 0x17, 0x00, 0xe0,
+			0x1e, 0xfc, 0xbc, 0xc0,
+			0xf0, 0xc0, 0xde, 0xe8,
+			0x00, 0x80, 0x00, 0x20,
+			0x2c, 0x75, 0xd4, 0x49,
+			0x12, 0xf1, 0x32, 0xe0,
+			0xf8, 0xc2, 0x46, 0x71,
+			0xf7, 0xc2, 0x40, 0x73,
+			0xbe, 0x49, 0x03, 0xf1,
+			0xf5, 0xc7, 0x02, 0xe0,
+			0xf2, 0xc7, 0x4f, 0x30,
+			0x26, 0x62, 0xa1, 0x49,
+			0xf0, 0xf1, 0x22, 0x72,
+			0xa0, 0x49, 0xed, 0xf1,
+			0x25, 0x25, 0x18, 0x1f,
+			0x97, 0x30, 0x91, 0x30,
+			0x36, 0x9a, 0x2c, 0x75,
+			0x3c, 0xc3, 0x60, 0x73,
+			0xb1, 0x49, 0x0d, 0xf1,
+			0xdc, 0x21, 0xbc, 0x25,
+			0x30, 0xc6, 0xc0, 0x77,
+			0x04, 0x13, 0x21, 0xf0,
+			0x03, 0x13, 0x22, 0xf0,
+			0x02, 0x13, 0x23, 0xf0,
+			0x01, 0x13, 0x24, 0xf0,
+			0x08, 0x13, 0x08, 0xf1,
+			0x2e, 0x73, 0xba, 0x21,
+			0xbd, 0x25, 0x05, 0x13,
+			0x03, 0xf1, 0x24, 0xc5,
+			0x00, 0xbd, 0xd4, 0x49,
+			0x03, 0xf1, 0x1c, 0xc5,
+			0x00, 0xbd, 0xc4, 0xc6,
+			0xc6, 0x67, 0x2e, 0x75,
+			0xd7, 0x22, 0xdd, 0x26,
+			0x05, 0x15, 0x1b, 0xf0,
+			0x14, 0xc6, 0x00, 0xbe,
+			0x13, 0xc5, 0x00, 0xbd,
+			0x12, 0xc5, 0x00, 0xbd,
+			0xf1, 0x49, 0xfb, 0xf1,
+			0xef, 0xe7, 0xf4, 0x49,
+			0xfa, 0xf1, 0xec, 0xe7,
+			0xf3, 0x49, 0xf7, 0xf1,
+			0xe9, 0xe7, 0xf2, 0x49,
+			0xf4, 0xf1, 0xe6, 0xe7,
+			0xb6, 0xc0, 0x9e, 0x12,
+			0xde, 0x11, 0x0a, 0x12,
+			0x3c, 0x13, 0x00, 0xa0,
+			0xa0, 0xd1, 0x00, 0x00,
+			0xc0, 0x75, 0xd0, 0x49,
+			0x46, 0xf0, 0x26, 0x72,
+			0xa7, 0x49, 0x43, 0xf0,
+			0x22, 0x72, 0x25, 0x25,
+			0x20, 0x1f, 0x97, 0x30,
+			0x91, 0x30, 0x40, 0x73,
+			0xf3, 0xc4, 0x1c, 0x40,
+			0x04, 0xf0, 0xd7, 0x49,
+			0x05, 0xf1, 0x37, 0xe0,
+			0x53, 0x48, 0xc0, 0x9d,
+			0x08, 0x02, 0x40, 0x66,
+			0x64, 0x27, 0x06, 0x16,
+			0x30, 0xf1, 0x46, 0x63,
+			0x3b, 0x13, 0x2d, 0xf1,
+			0x34, 0x9b, 0x18, 0x1b,
+			0x93, 0x30, 0x2b, 0xc3,
+			0x10, 0x1c, 0x2b, 0xe8,
+			0x01, 0x14, 0x25, 0xf1,
+			0x00, 0x1d, 0x26, 0x1a,
+			0x8a, 0x30, 0x22, 0x73,
+			0xb5, 0x25, 0x0e, 0x0b,
+			0x00, 0x1c, 0x2c, 0xe8,
+			0x1f, 0xc7, 0x27, 0x40,
+			0x1a, 0xf1, 0x38, 0xe8,
+			0x32, 0x1f, 0x8f, 0x30,
+			0x08, 0x1b, 0x24, 0xe8,
+			0x36, 0x72, 0x46, 0x77,
+			0x00, 0x17, 0x0d, 0xf0,
+			0x13, 0xc3, 0x1f, 0x40,
+			0x03, 0xf1, 0x00, 0x1f,
+			0x46, 0x9f, 0x44, 0x77,
+			0x9f, 0x44, 0x5f, 0x44,
+			0x17, 0xe8, 0x0a, 0xc7,
+			0x27, 0x40, 0x05, 0xf1,
+			0x02, 0xc3, 0x00, 0xbb,
+			0xfa, 0x18, 0xb0, 0x18,
+			0xff, 0xc7, 0x00, 0xbf,
+			0xb8, 0xcd, 0xff, 0xff,
+			0x02, 0x0c, 0x54, 0xa5,
+			0xdc, 0xa5, 0x2f, 0x40,
+			0x05, 0xf1, 0x00, 0x14,
+			0xfa, 0xf1, 0x01, 0x1c,
+			0x02, 0xe0, 0x00, 0x1c,
+			0x80, 0xff, 0xb0, 0x49,
+			0x04, 0xf0, 0x01, 0x0b,
+			0xd3, 0xa1, 0x03, 0xe0,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x00, 0x13, 0xfb, 0xf1,
+			0x80, 0xff, 0x22, 0x73,
+			0xb5, 0x25, 0x18, 0x1e,
+			0xde, 0x30, 0xd9, 0x30,
+			0x64, 0x72, 0x11, 0x1e,
+			0x68, 0x23, 0x16, 0x31,
+			0x80, 0xff, 0x08, 0xc2,
+			0x40, 0x73, 0x3a, 0x48,
+			0x40, 0x9b, 0x06, 0xff,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x08, 0x16, 0x1e, 0xfc,
+			0x2c, 0x75, 0xdc, 0x21,
+			0xbc, 0x25, 0x04, 0x13,
+			0x0b, 0xf0, 0x03, 0x13,
+			0x09, 0xf0, 0x02, 0x13,
+			0x07, 0xf0, 0x01, 0x13,
+			0x05, 0xf0, 0x08, 0x13,
+			0x03, 0xf0, 0x04, 0xc3,
+			0x00, 0xbb, 0x03, 0xc3,
+			0x00, 0xbb, 0x8c, 0x15,
+			0x76, 0x15, 0xa0, 0x64,
+			0x40, 0x48, 0xa0, 0x8c,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x82, 0x00, 0xa0, 0x62,
+			0x21, 0x48, 0xa0, 0x8a,
+			0x02, 0xc2, 0x00, 0xba,
+			0x40, 0x03, 0x33, 0xc5,
+			0xa0, 0x74, 0xc0, 0x49,
+			0x1f, 0xf0, 0x30, 0xc5,
+			0xa0, 0x73, 0x00, 0x13,
+			0x04, 0xf1, 0xa2, 0x73,
+			0x00, 0x13, 0x14, 0xf0,
+			0x28, 0xc5, 0xa0, 0x74,
+			0xc8, 0x49, 0x1b, 0xf1,
+			0x26, 0xc5, 0xa0, 0x76,
+			0xa2, 0x74, 0x01, 0x06,
+			0x20, 0x37, 0xa0, 0x9e,
+			0xa2, 0x9c, 0x1e, 0xc5,
+			0xa2, 0x73, 0x23, 0x40,
+			0x10, 0xf8, 0x04, 0xf3,
+			0xa0, 0x73, 0x33, 0x40,
+			0x0c, 0xf8, 0x15, 0xc5,
+			0xa0, 0x74, 0x41, 0x48,
+			0xa0, 0x9c, 0x14, 0xc5,
+			0xa0, 0x76, 0x62, 0x48,
+			0xe0, 0x48, 0xa0, 0x9e,
+			0x10, 0xc6, 0x00, 0xbe,
+			0x0a, 0xc5, 0xa0, 0x74,
+			0x48, 0x48, 0xa0, 0x9c,
+			0x0b, 0xc5, 0x20, 0x1e,
+			0xa0, 0x9e, 0xe5, 0x48,
+			0xa0, 0x9e, 0xf0, 0xe7,
+			0xbc, 0xc0, 0xc8, 0xd2,
+			0xcc, 0xd2, 0x28, 0xe4,
+			0xe6, 0x01, 0xf0, 0xc0,
+			0x18, 0x89, 0x00, 0x1d,
+			0x3c, 0xc3, 0x64, 0x71,
+			0x3c, 0xc0, 0x02, 0x99,
+			0x00, 0x61, 0x67, 0x11,
+			0x3c, 0xf1, 0x69, 0x33,
+			0x35, 0xc0, 0x28, 0x40,
+			0xf6, 0xf1, 0x34, 0xc0,
+			0x00, 0x19, 0x81, 0x1b,
+			0x91, 0xe8, 0x31, 0xc0,
+			0x04, 0x1a, 0x84, 0x1b,
+			0x8d, 0xe8, 0x82, 0xe8,
+			0xa3, 0x49, 0xfe, 0xf0,
+			0x2b, 0xc0, 0x7e, 0xe8,
+			0xa1, 0x48, 0x28, 0xc0,
+			0x84, 0x1b, 0x84, 0xe8,
+			0x00, 0x1d, 0x69, 0x33,
+			0x00, 0x1e, 0x01, 0x06,
+			0xff, 0x18, 0x30, 0x40,
+			0xfd, 0xf1, 0x19, 0xc0,
+			0x00, 0x76, 0x2e, 0x40,
+			0xf7, 0xf1, 0x21, 0x48,
+			0x19, 0xc0, 0x84, 0x1b,
+			0x75, 0xe8, 0x10, 0xc0,
+			0x69, 0xe8, 0xa1, 0x49,
+			0xfd, 0xf0, 0x11, 0xc0,
+			0x00, 0x1a, 0x84, 0x1b,
+			0x6d, 0xe8, 0x62, 0xe8,
+			0xa5, 0x49, 0xfe, 0xf0,
+			0x09, 0xc0, 0x01, 0x19,
+			0x81, 0x1b, 0x66, 0xe8,
+			0x54, 0xe0, 0x10, 0xd4,
+			0x88, 0xd3, 0xb8, 0x0b,
+			0x50, 0xe8, 0x20, 0xb4,
+			0x10, 0xd8, 0x84, 0xd4,
+			0xfd, 0xc0, 0x52, 0xe8,
+			0x48, 0x33, 0xf9, 0xc0,
+			0x00, 0x61, 0x9c, 0x20,
+			0x9c, 0x24, 0xd0, 0x49,
+			0x04, 0xf0, 0x04, 0x11,
+			0x02, 0xf1, 0x03, 0xe0,
+			0x00, 0x11, 0x06, 0xf1,
+			0x5c, 0xc0, 0x00, 0x61,
+			0x92, 0x48, 0x00, 0x89,
+			0x3a, 0xe0, 0x06, 0x11,
+			0x06, 0xf1, 0x55, 0xc0,
+			0x00, 0x61, 0x11, 0x48,
+			0x00, 0x89, 0x33, 0xe0,
+			0x05, 0x11, 0x08, 0xf1,
+			0x4e, 0xc0, 0x00, 0x61,
+			0x91, 0x49, 0x04, 0xf0,
+			0x91, 0x48, 0x00, 0x89,
+			0x11, 0xe0, 0xd9, 0xc0,
+			0x00, 0x61, 0x98, 0x20,
+			0x98, 0x24, 0x25, 0x11,
+			0x24, 0xf1, 0x44, 0xc0,
+			0x29, 0xe8, 0x95, 0x49,
+			0x20, 0xf0, 0xcf, 0xc0,
+			0x00, 0x61, 0x98, 0x20,
+			0x98, 0x24, 0x25, 0x11,
+			0x1a, 0xf1, 0x37, 0xc0,
+			0x00, 0x61, 0x92, 0x49,
+			0x16, 0xf1, 0x12, 0x48,
+			0x00, 0x89, 0x2f, 0xc0,
+			0x00, 0x19, 0x00, 0x89,
+			0x2d, 0xc0, 0x01, 0x89,
+			0x2d, 0xc0, 0x04, 0x19,
+			0x81, 0x1b, 0x1c, 0xe8,
+			0x2a, 0xc0, 0x14, 0x19,
+			0x81, 0x1b, 0x18, 0xe8,
+			0x21, 0xc0, 0x0c, 0xe8,
+			0x1f, 0xc0, 0x12, 0x48,
+			0x81, 0x1b, 0x12, 0xe8,
+			0xae, 0xc3, 0x66, 0x71,
+			0xae, 0xc0, 0x02, 0x99,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x96, 0x07, 0x13, 0xc4,
+			0x84, 0x98, 0x00, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x80, 0x71, 0x82, 0x72,
+			0x80, 0xff, 0x09, 0xc4,
+			0x84, 0x98, 0x80, 0x99,
+			0x82, 0x9a, 0x86, 0x8b,
+			0x86, 0x73, 0xbf, 0x49,
+			0xfe, 0xf1, 0x80, 0xff,
+			0x08, 0xea, 0x30, 0xd4,
+			0x10, 0xc0, 0x12, 0xe8,
+			0x8a, 0xd3, 0x28, 0xe4,
+			0x2c, 0xe4, 0x00, 0xd8,
+			0x00, 0x00, 0x00, 0x00 };
+
+		rtl_pre_ram_code(tp, 0x8146, 0x7001, true);
+		sram_write(tp, 0xb820, 0x0290);
+		sram_write(tp, 0xa012, 0x0000);
+		sram_write(tp, 0xa014, 0x2c04);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c0a);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c0d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa240);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa104);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x292d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8620);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa480);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2a2c);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8480);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa101);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2a36);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd056);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2223);
+		sram_write(tp, 0xa01a, 0x0000);
+		sram_write(tp, 0xa006, 0x0222);
+		sram_write(tp, 0xa004, 0x0a35);
+		sram_write(tp, 0xa002, 0x0a2b);
+		sram_write(tp, 0xa000, 0xf92c);
+		sram_write(tp, 0xb820, 0x0210);
+		rtl_post_ram_code(tp, 0x8146, true);
+
+		r8153_wdt1_end(tp);
+
+		rtl_clear_bp(tp, MCU_TYPE_USB);
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(usb_patch_b),
+				  usb_patch_b, MCU_TYPE_USB);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc26, 0xa000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc28, 0x180c);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2a, 0x0506);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2c, 0x04E0);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2e, 0x11E4);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc30, 0x125C);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc32, 0x0232);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc34, 0x131E);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc36, 0x0098);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x00FF);
+
+		rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+		/* Enable backup/restore of MACDBG. This is required after
+		 * clearing PLA break points and before applying the PLA
+		 * firmware.
+		 */
+		ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MACDBG_POST,
+				    &ocp_data);
+		if (!(ocp_data & DEBUG_OE)) {
+			ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_MACDBG_PRE,
+					     DEBUG_LTSSM);
+			ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_MACDBG_POST,
+					     DEBUG_LTSSM);
+		}
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(pla_patch_b),
+				  pla_patch_b, MCU_TYPE_PLA);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x1154);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x1606);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x155a);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x0080);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc30, 0x033c);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc32, 0x01a0);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc34, 0x0794);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc36, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x007f);
+
+		/* reset UPHY timer to 36 ms */
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_UPHY_TIMER, 36000 / 16);
+
+		rtl_reset_ocp_base(tp);
+	} else if (tp->version == RTL_VER_05) {
+		static u8 usb_patch_c[] = {
+			0x08, 0xe0, 0x0a, 0xe0,
+			0x14, 0xe0, 0x58, 0xe0,
+			0x64, 0xe0, 0x79, 0xe0,
+			0xab, 0xe0, 0xb6, 0xe0,
+			0x02, 0xc5, 0x00, 0xbd,
+			0x38, 0x3b, 0xdb, 0x49,
+			0x04, 0xf1, 0x06, 0xc3,
+			0x00, 0xbb, 0x5a, 0x02,
+			0x05, 0xc4, 0x03, 0xc3,
+			0x00, 0xbb, 0xa4, 0x04,
+			0x7e, 0x02, 0x30, 0xd4,
+			0x65, 0xc6, 0x66, 0x61,
+			0x92, 0x49, 0x12, 0xf1,
+			0x3e, 0xc0, 0x02, 0x61,
+			0x97, 0x49, 0x05, 0xf0,
+			0x3c, 0xc0, 0x00, 0x61,
+			0x90, 0x49, 0x0a, 0xf1,
+			0xca, 0x63, 0xb0, 0x49,
+			0x09, 0xf1, 0xb1, 0x49,
+			0x05, 0xf0, 0x32, 0xc0,
+			0x00, 0x71, 0x9e, 0x49,
+			0x03, 0xf1, 0xb0, 0x48,
+			0x05, 0xe0, 0x30, 0x48,
+			0xda, 0x61, 0x10, 0x48,
+			0xda, 0x89, 0x4a, 0xc6,
+			0xc0, 0x60, 0x85, 0x49,
+			0x03, 0xf0, 0x31, 0x48,
+			0x04, 0xe0, 0xb1, 0x48,
+			0xb2, 0x48, 0x0f, 0xe0,
+			0x30, 0x18, 0x1b, 0xc1,
+			0x0f, 0xe8, 0x1a, 0xc6,
+			0xc7, 0x65, 0xd0, 0x49,
+			0x05, 0xf0, 0x32, 0x48,
+			0x02, 0xc2, 0x00, 0xba,
+			0x3e, 0x16, 0x02, 0xc2,
+			0x00, 0xba, 0x48, 0x16,
+			0x02, 0xc2, 0x00, 0xba,
+			0x4a, 0x16, 0x02, 0xb4,
+			0x09, 0xc2, 0x40, 0x99,
+			0x0e, 0x48, 0x42, 0x98,
+			0x42, 0x70, 0x8e, 0x49,
+			0xfe, 0xf1, 0x02, 0xb0,
+			0x80, 0xff, 0xc0, 0xd4,
+			0xe4, 0x40, 0x20, 0xd4,
+			0xca, 0xcf, 0x00, 0xcf,
+			0x3c, 0xe4, 0x0c, 0xc0,
+			0x00, 0x63, 0xb5, 0x49,
+			0x09, 0xc0, 0x30, 0x18,
+			0x06, 0xc1, 0xea, 0xef,
+			0xf5, 0xc7, 0x02, 0xc0,
+			0x00, 0xb8, 0xd0, 0x10,
+			0xe4, 0x4b, 0x00, 0xd8,
+			0x14, 0xc3, 0x60, 0x61,
+			0x90, 0x49, 0x06, 0xf0,
+			0x11, 0xc3, 0x70, 0x61,
+			0x12, 0x48, 0x70, 0x89,
+			0x08, 0xe0, 0x0a, 0xc6,
+			0xd4, 0x61, 0x93, 0x48,
+			0xd4, 0x89, 0x02, 0xc1,
+			0x00, 0xb9, 0x72, 0x17,
+			0x02, 0xc1, 0x00, 0xb9,
+			0x9c, 0x15, 0x00, 0xd8,
+			0xef, 0xcf, 0x20, 0xd4,
+			0x30, 0x18, 0xe7, 0xc1,
+			0xcb, 0xef, 0x2b, 0xc5,
+			0xa0, 0x77, 0x00, 0x1c,
+			0xa0, 0x9c, 0x28, 0xc5,
+			0xa0, 0x64, 0xc0, 0x48,
+			0xc1, 0x48, 0xc2, 0x48,
+			0xa0, 0x8c, 0xb1, 0x64,
+			0xc0, 0x48, 0xb1, 0x8c,
+			0x20, 0xc5, 0xa0, 0x64,
+			0x40, 0x48, 0x41, 0x48,
+			0xc2, 0x48, 0xa0, 0x8c,
+			0x19, 0xc5, 0xa4, 0x64,
+			0x44, 0x48, 0xa4, 0x8c,
+			0xb1, 0x64, 0x40, 0x48,
+			0xb1, 0x8c, 0x14, 0xc4,
+			0x80, 0x73, 0x13, 0xc4,
+			0x82, 0x9b, 0x11, 0x1b,
+			0x80, 0x9b, 0x0c, 0xc5,
+			0xa0, 0x64, 0x40, 0x48,
+			0x41, 0x48, 0x42, 0x48,
+			0xa0, 0x8c, 0x05, 0xc5,
+			0xa0, 0x9f, 0x02, 0xc5,
+			0x00, 0xbd, 0x6c, 0x3a,
+			0x1e, 0xfc, 0x10, 0xd8,
+			0x86, 0xd4, 0xf8, 0xcb,
+			0x20, 0xe4, 0x0a, 0xc0,
+			0x16, 0x61, 0x91, 0x48,
+			0x16, 0x89, 0x07, 0xc0,
+			0x11, 0x19, 0x0c, 0x89,
+			0x02, 0xc1, 0x00, 0xb9,
+			0x02, 0x06, 0x00, 0xd4,
+			0x40, 0xb4, 0xfe, 0xc0,
+			0x16, 0x61, 0x91, 0x48,
+			0x16, 0x89, 0xfb, 0xc0,
+			0x11, 0x19, 0x0c, 0x89,
+			0x02, 0xc1, 0x00, 0xb9,
+			0xd2, 0x05, 0x00, 0x00 };
+		static u8 pla_patch_c[] = {
+			0x5d, 0xe0, 0x07, 0xe0,
+			0x0f, 0xe0, 0x5a, 0xe0,
+			0x59, 0xe0, 0x1f, 0xe0,
+			0x57, 0xe0, 0x3e, 0xe1,
+			0x08, 0xc2, 0x40, 0x73,
+			0x3a, 0x48, 0x40, 0x9b,
+			0x06, 0xff, 0x02, 0xc6,
+			0x00, 0xbe, 0xcc, 0x17,
+			0x1e, 0xfc, 0x2c, 0x75,
+			0xdc, 0x21, 0xbc, 0x25,
+			0x04, 0x13, 0x0b, 0xf0,
+			0x03, 0x13, 0x09, 0xf0,
+			0x02, 0x13, 0x07, 0xf0,
+			0x01, 0x13, 0x05, 0xf0,
+			0x08, 0x13, 0x03, 0xf0,
+			0x04, 0xc3, 0x00, 0xbb,
+			0x03, 0xc3, 0x00, 0xbb,
+			0x50, 0x17, 0x3a, 0x17,
+			0x33, 0xc5, 0xa0, 0x74,
+			0xc0, 0x49, 0x1f, 0xf0,
+			0x30, 0xc5, 0xa0, 0x73,
+			0x00, 0x13, 0x04, 0xf1,
+			0xa2, 0x73, 0x00, 0x13,
+			0x14, 0xf0, 0x28, 0xc5,
+			0xa0, 0x74, 0xc8, 0x49,
+			0x1b, 0xf1, 0x26, 0xc5,
+			0xa0, 0x76, 0xa2, 0x74,
+			0x01, 0x06, 0x20, 0x37,
+			0xa0, 0x9e, 0xa2, 0x9c,
+			0x1e, 0xc5, 0xa2, 0x73,
+			0x23, 0x40, 0x10, 0xf8,
+			0x04, 0xf3, 0xa0, 0x73,
+			0x33, 0x40, 0x0c, 0xf8,
+			0x15, 0xc5, 0xa0, 0x74,
+			0x41, 0x48, 0xa0, 0x9c,
+			0x14, 0xc5, 0xa0, 0x76,
+			0x62, 0x48, 0xe0, 0x48,
+			0xa0, 0x9e, 0x10, 0xc6,
+			0x00, 0xbe, 0x0a, 0xc5,
+			0xa0, 0x74, 0x48, 0x48,
+			0xa0, 0x9c, 0x0b, 0xc5,
+			0x20, 0x1e, 0xa0, 0x9e,
+			0xe5, 0x48, 0xa0, 0x9e,
+			0xf0, 0xe7, 0xbc, 0xc0,
+			0xc8, 0xd2, 0xcc, 0xd2,
+			0x28, 0xe4, 0xfa, 0x01,
+			0xf0, 0xc0, 0x18, 0x89,
+			0x74, 0xc0, 0xcd, 0xe8,
+			0x80, 0x76, 0x00, 0x1d,
+			0x6e, 0xc3, 0x66, 0x62,
+			0xa0, 0x49, 0x06, 0xf0,
+			0x64, 0xc0, 0x02, 0x71,
+			0x60, 0x99, 0x62, 0xc1,
+			0x03, 0xe0, 0x5f, 0xc0,
+			0x60, 0xc1, 0x02, 0x99,
+			0x00, 0x61, 0x0f, 0x1b,
+			0x59, 0x41, 0x03, 0x13,
+			0x18, 0xf1, 0xe4, 0x49,
+			0x20, 0xf1, 0xe5, 0x49,
+			0x1e, 0xf0, 0x59, 0xc6,
+			0xd0, 0x73, 0xb7, 0x49,
+			0x08, 0xf0, 0x01, 0x0b,
+			0x80, 0x13, 0x03, 0xf0,
+			0xd0, 0x8b, 0x03, 0xe0,
+			0x3f, 0x48, 0xd0, 0x9b,
+			0x51, 0xc0, 0x10, 0x1a,
+			0x84, 0x1b, 0xb1, 0xe8,
+			0x4b, 0xc2, 0x40, 0x63,
+			0x30, 0x48, 0x0a, 0xe0,
+			0xe5, 0x49, 0x09, 0xf0,
+			0x47, 0xc0, 0x00, 0x1a,
+			0x84, 0x1b, 0xa7, 0xe8,
+			0x41, 0xc2, 0x40, 0x63,
+			0xb0, 0x48, 0x40, 0x8b,
+			0x67, 0x11, 0x3f, 0xf1,
+			0x69, 0x33, 0x32, 0xc0,
+			0x28, 0x40, 0xd2, 0xf1,
+			0x33, 0xc0, 0x00, 0x19,
+			0x81, 0x1b, 0x99, 0xe8,
+			0x30, 0xc0, 0x04, 0x1a,
+			0x84, 0x1b, 0x95, 0xe8,
+			0x8a, 0xe8, 0xa3, 0x49,
+			0xfe, 0xf0, 0x2a, 0xc0,
+			0x86, 0xe8, 0xa1, 0x48,
+			0x84, 0x1b, 0x8d, 0xe8,
+			0x00, 0x1d, 0x69, 0x33,
+			0x00, 0x1e, 0x01, 0x06,
+			0xff, 0x18, 0x30, 0x40,
+			0xfd, 0xf1, 0x1f, 0xc0,
+			0x00, 0x76, 0x2e, 0x40,
+			0xf7, 0xf1, 0x21, 0x48,
+			0x19, 0xc0, 0x84, 0x1b,
+			0x7e, 0xe8, 0x74, 0x08,
+			0x72, 0xe8, 0xa1, 0x49,
+			0xfd, 0xf0, 0x11, 0xc0,
+			0x00, 0x1a, 0x84, 0x1b,
+			0x76, 0xe8, 0x6b, 0xe8,
+			0xa5, 0x49, 0xfe, 0xf0,
+			0x09, 0xc0, 0x01, 0x19,
+			0x81, 0x1b, 0x6f, 0xe8,
+			0x5a, 0xe0, 0xb8, 0x0b,
+			0x50, 0xe8, 0x83, 0x00,
+			0x82, 0x00, 0x20, 0xb4,
+			0x10, 0xd8, 0x84, 0xd4,
+			0x88, 0xd3, 0x10, 0xe0,
+			0x00, 0xd8, 0x24, 0xd4,
+			0xf9, 0xc0, 0x57, 0xe8,
+			0x48, 0x33, 0xf3, 0xc0,
+			0x00, 0x61, 0x6a, 0xc0,
+			0x47, 0x11, 0x03, 0xf0,
+			0x57, 0x11, 0x05, 0xf1,
+			0x00, 0x61, 0x17, 0x48,
+			0x00, 0x89, 0x41, 0xe0,
+			0x9c, 0x20, 0x9c, 0x24,
+			0xd0, 0x49, 0x09, 0xf0,
+			0x04, 0x11, 0x07, 0xf1,
+			0x00, 0x61, 0x97, 0x49,
+			0x38, 0xf0, 0x97, 0x48,
+			0x00, 0x89, 0x2b, 0xe0,
+			0x00, 0x11, 0x05, 0xf1,
+			0x00, 0x61, 0x92, 0x48,
+			0x00, 0x89, 0x2f, 0xe0,
+			0x06, 0x11, 0x05, 0xf1,
+			0x00, 0x61, 0x11, 0x48,
+			0x00, 0x89, 0x29, 0xe0,
+			0x05, 0x11, 0x0f, 0xf1,
+			0x00, 0x61, 0x93, 0x49,
+			0x1a, 0xf1, 0x91, 0x49,
+			0x0a, 0xf0, 0x91, 0x48,
+			0x00, 0x89, 0x0f, 0xe0,
+			0xc6, 0xc0, 0x00, 0x61,
+			0x98, 0x20, 0x98, 0x24,
+			0x25, 0x11, 0x80, 0xff,
+			0xfa, 0xef, 0x17, 0xf1,
+			0x38, 0xc0, 0x1f, 0xe8,
+			0x95, 0x49, 0x13, 0xf0,
+			0xf4, 0xef, 0x11, 0xf1,
+			0x31, 0xc0, 0x00, 0x61,
+			0x92, 0x49, 0x0d, 0xf1,
+			0x12, 0x48, 0x00, 0x89,
+			0x29, 0xc0, 0x00, 0x19,
+			0x00, 0x89, 0x27, 0xc0,
+			0x01, 0x89, 0x23, 0xc0,
+			0x0e, 0xe8, 0x12, 0x48,
+			0x81, 0x1b, 0x15, 0xe8,
+			0xae, 0xc3, 0x66, 0x62,
+			0xa0, 0x49, 0x04, 0xf0,
+			0x64, 0x71, 0xa3, 0xc0,
+			0x02, 0x99, 0x02, 0xc0,
+			0x00, 0xb8, 0xd6, 0x07,
+			0x13, 0xc4, 0x84, 0x98,
+			0x00, 0x1b, 0x86, 0x8b,
+			0x86, 0x73, 0xbf, 0x49,
+			0xfe, 0xf1, 0x80, 0x71,
+			0x82, 0x72, 0x80, 0xff,
+			0x09, 0xc4, 0x84, 0x98,
+			0x80, 0x99, 0x82, 0x9a,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x80, 0xff, 0x08, 0xea,
+			0x30, 0xd4, 0x10, 0xc0,
+			0x12, 0xe8, 0x8a, 0xd3,
+			0x00, 0xd8, 0x02, 0xc6,
+			0x00, 0xbe, 0xe0, 0x08 };
+
+		rtl_pre_ram_code(tp, 0x8146, 0x7001, true);
+		sram_write(tp, 0xb820, 0x0290);
+		sram_write(tp, 0xa012, 0x0000);
+		sram_write(tp, 0xa014, 0x2c04);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c0a);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c0d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa240);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa104);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x292d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8620);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa480);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2a2c);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8480);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa101);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2a36);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd056);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2223);
+		sram_write(tp, 0xa01a, 0x0000);
+		sram_write(tp, 0xa006, 0x0222);
+		sram_write(tp, 0xa004, 0x0a35);
+		sram_write(tp, 0xa002, 0x0a2b);
+		sram_write(tp, 0xa000, 0xf92c);
+		sram_write(tp, 0xb820, 0x0210);
+		rtl_post_ram_code(tp, 0x8146, true);
+
+		r8153_wdt1_end(tp);
+
+		ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_FW_FIX_EN0,
+				  FW_FIX_SUSPEND);
+
+		rtl_clear_bp(tp, MCU_TYPE_USB);
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(usb_patch_c),
+				  usb_patch_c, MCU_TYPE_USB);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc26, 0xa000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc28, 0x3b34);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2a, 0x027c);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2c, 0x15de);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2e, 0x10ce);
+		ret = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSTMR, &ocp_data);
+		if (ocp_data & FORCE_SUPER)
+			ocp_write_word(tp, MCU_TYPE_USB, 0xfc30, 0x1578);
+		else
+			ocp_write_word(tp, MCU_TYPE_USB, 0xfc30, 0x1adc);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc32, 0x3a28);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc34, 0x05f8);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc36, 0x05c8);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x00ff);
+
+		rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(pla_patch_c),
+				  pla_patch_c, MCU_TYPE_PLA);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x1306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x17ca);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x171e);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc30, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc32, 0x01b4);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc34, 0x07d4);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc36, 0x0894);
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x00e6);
+
+		/* reset UPHY timer to 36 ms */
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_UPHY_TIMER, 36000 / 16);
+
+		/* enable U3P3 check, set the counter to 4 */
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+			       U3P3_CHECK_EN | 4);
+
+		ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_FIX_EN0,
+				  FW_FIX_SUSPEND);
+
+		ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_USB2PHY,
+				  USB2PHY_L1 | USB2PHY_SUSPEND);
+
+		rtl_reset_ocp_base(tp);
+	} else if (tp->version == RTL_VER_06) {
+		static u8 usb_patch_d[] = {
+			0x08, 0xe0, 0x0e, 0xe0,
+			0x11, 0xe0, 0x24, 0xe0,
+			0x2b, 0xe0, 0x33, 0xe0,
+			0x3a, 0xe0, 0x3c, 0xe0,
+			0x1e, 0xc3, 0x70, 0x61,
+			0x12, 0x48, 0x70, 0x89,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x02, 0x17, 0x32, 0x19,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x44, 0x14, 0x30, 0x18,
+			0x11, 0xc1, 0x05, 0xe8,
+			0x10, 0xc6, 0x02, 0xc2,
+			0x00, 0xba, 0x94, 0x17,
+			0x02, 0xb4, 0x09, 0xc2,
+			0x40, 0x99, 0x0e, 0x48,
+			0x42, 0x98, 0x42, 0x70,
+			0x8e, 0x49, 0xfe, 0xf1,
+			0x02, 0xb0, 0x80, 0xff,
+			0xc0, 0xd4, 0xe4, 0x40,
+			0x20, 0xd4, 0x30, 0x18,
+			0x06, 0xc1, 0xf1, 0xef,
+			0xfc, 0xc7, 0x02, 0xc0,
+			0x00, 0xb8, 0x38, 0x12,
+			0xe4, 0x4b, 0x0c, 0x61,
+			0x92, 0x48, 0x93, 0x48,
+			0x95, 0x48, 0x96, 0x48,
+			0x0c, 0x89, 0x02, 0xc0,
+			0x00, 0xb8, 0x0e, 0x06,
+			0x30, 0x18, 0xf5, 0xc1,
+			0xe0, 0xef, 0x04, 0xc5,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x76, 0x3c, 0x1e, 0xfc,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x00, 0x00, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00 };
+		static u8 pla_patch_d[] = {
+			0x03, 0xe0, 0x16, 0xe0,
+			0x30, 0xe0, 0x12, 0xc2,
+			0x40, 0x73, 0xb0, 0x49,
+			0x08, 0xf0, 0xb8, 0x49,
+			0x06, 0xf0, 0xb8, 0x48,
+			0x40, 0x9b, 0x0b, 0xc2,
+			0x40, 0x76, 0x05, 0xe0,
+			0x02, 0x61, 0x02, 0xc3,
+			0x00, 0xbb, 0x54, 0x08,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x64, 0x08, 0x98, 0xd3,
+			0x1e, 0xfc, 0xfe, 0xc0,
+			0x02, 0x62, 0xa0, 0x48,
+			0x02, 0x8a, 0x00, 0x72,
+			0xa0, 0x49, 0x11, 0xf0,
+			0x13, 0xc1, 0x20, 0x62,
+			0x2e, 0x21, 0x2f, 0x25,
+			0x00, 0x71, 0x9f, 0x24,
+			0x0a, 0x40, 0x09, 0xf0,
+			0x00, 0x71, 0x18, 0x48,
+			0xa0, 0x49, 0x03, 0xf1,
+			0x9f, 0x48, 0x02, 0xe0,
+			0x1f, 0x48, 0x00, 0x99,
+			0x02, 0xc2, 0x00, 0xba,
+			0xac, 0x0c, 0x08, 0xe9,
+			0x36, 0xc0, 0x00, 0x61,
+			0x9c, 0x20, 0x9c, 0x24,
+			0x33, 0xc0, 0x07, 0x11,
+			0x05, 0xf1, 0x00, 0x61,
+			0x17, 0x48, 0x00, 0x89,
+			0x0d, 0xe0, 0x04, 0x11,
+			0x0b, 0xf1, 0x00, 0x61,
+			0x97, 0x49, 0x08, 0xf0,
+			0x97, 0x48, 0x00, 0x89,
+			0x23, 0xc0, 0x0e, 0xe8,
+			0x12, 0x48, 0x81, 0x1b,
+			0x15, 0xe8, 0x1f, 0xc0,
+			0x00, 0x61, 0x67, 0x11,
+			0x04, 0xf0, 0x02, 0xc0,
+			0x00, 0xb8, 0x42, 0x09,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x90, 0x08, 0x13, 0xc4,
+			0x84, 0x98, 0x00, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x80, 0x71, 0x82, 0x72,
+			0x80, 0xff, 0x09, 0xc4,
+			0x84, 0x98, 0x80, 0x99,
+			0x82, 0x9a, 0x86, 0x8b,
+			0x86, 0x73, 0xbf, 0x49,
+			0xfe, 0xf1, 0x80, 0xff,
+			0x08, 0xea, 0x30, 0xd4,
+			0x50, 0xe8, 0x8a, 0xd3 };
+
+		rtl_pre_ram_code(tp, 0x8146, 0x7003, true);
+		sram_write(tp, 0xb820, 0x0290);
+		sram_write(tp, 0xa012, 0x0000);
+		sram_write(tp, 0xa014, 0x2c04);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa240);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa104);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2944);
+		sram_write(tp, 0xa01a, 0x0000);
+		sram_write(tp, 0xa006, 0x0fff);
+		sram_write(tp, 0xa004, 0x0fff);
+		sram_write(tp, 0xa002, 0x0fff);
+		sram_write(tp, 0xa000, 0x1943);
+		sram_write(tp, 0xb820, 0x0210);
+		rtl_post_ram_code(tp, 0x8146, true);
+
+		rtl_clear_bp(tp, MCU_TYPE_USB);
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(usb_patch_d),
+				  usb_patch_d, MCU_TYPE_USB);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc26, 0xa000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc28, 0x16de);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2a, 0x1442);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2c, 0x1792);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2e, 0x1236);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc30, 0x0606);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc32, 0x3C74);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc34, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc36, 0x0000);
+		ret = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSTMR, &ocp_data);
+		if (ocp_data & FORCE_SUPER)
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x003f);
+		else
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x003e);
+
+		rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(pla_patch_d),
+				  pla_patch_d, MCU_TYPE_PLA);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x0852);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x0c92);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x088c);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc30, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc32, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc34, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc36, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x0007);
+
+		ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_USB2PHY,
+				  USB2PHY_L1 | USB2PHY_SUSPEND);
+
+		ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_FIX_EN1,
+				  FW_IP_RESET_EN);
+
+		rtl_reset_ocp_base(tp);
+	}
+
+	rtl_reset_ocp_base(tp);
+}
+
+static void r8153b_firmware(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int ret;
+
+	if (tp->version == RTL_VER_09) {
+		static u8 usb_patch2_b[] = {
+			0x10, 0xe0, 0x5b, 0xe0,
+			0x7c, 0xe0, 0x9c, 0xe0,
+			0xb0, 0xe0, 0xc9, 0xe0,
+			0xea, 0xe0, 0x46, 0xe1,
+			0x62, 0xe1, 0x65, 0xe1,
+			0x7d, 0xe1, 0x8f, 0xe1,
+			0x97, 0xe1, 0xf5, 0xe1,
+			0x11, 0xe2, 0x22, 0xe2,
+			0x43, 0xc4, 0x80, 0x63,
+			0xb2, 0x49, 0x05, 0xf0,
+			0x41, 0xc4, 0x02, 0xc3,
+			0x00, 0xbb, 0x88, 0x3d,
+			0x64, 0xc4, 0x3b, 0xc3,
+			0x84, 0x9b, 0x00, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x80, 0x73, 0x35, 0xc2,
+			0x40, 0x9b, 0x34, 0xc3,
+			0x80, 0x9b, 0x83, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x2e, 0xc3, 0x84, 0x9b,
+			0x00, 0x1b, 0x86, 0x8b,
+			0x86, 0x73, 0xbf, 0x49,
+			0xfe, 0xf1, 0x80, 0x73,
+			0xba, 0x48, 0xbb, 0x48,
+			0x80, 0x9b, 0x83, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x20, 0xc3, 0x84, 0x9b,
+			0x1f, 0xc3, 0x80, 0x9b,
+			0x83, 0x1b, 0x86, 0x8b,
+			0x86, 0x73, 0xbf, 0x49,
+			0xfe, 0xf1, 0x11, 0xc3,
+			0x84, 0x9b, 0x40, 0x73,
+			0x80, 0x9b, 0x83, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x0d, 0xc4, 0x80, 0x73,
+			0xbb, 0x48, 0x80, 0x9b,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x06, 0x3e, 0xee, 0xcf,
+			0x6c, 0xe8, 0xe0, 0xcb,
+			0x2e, 0xc3, 0x00, 0xa0,
+			0x08, 0xb4, 0x4a, 0xd8,
+			0x00, 0xb4, 0x00, 0x92,
+			0x1c, 0xc6, 0xc0, 0x61,
+			0x04, 0x11, 0x15, 0xf1,
+			0x19, 0xc6, 0xc0, 0x61,
+			0x9c, 0x20, 0x9c, 0x24,
+			0x09, 0x11, 0x0f, 0xf1,
+			0x14, 0xc6, 0x01, 0x19,
+			0xc0, 0x89, 0x13, 0xc1,
+			0x13, 0xc6, 0x24, 0x9e,
+			0x00, 0x1e, 0x26, 0x8e,
+			0x26, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0x22, 0x76,
+			0x08, 0xc1, 0x22, 0x9e,
+			0x07, 0xc6, 0x02, 0xc1,
+			0x00, 0xb9, 0x8c, 0x08,
+			0x18, 0xb4, 0x4a, 0xb4,
+			0x90, 0xcc, 0x80, 0xd4,
+			0x08, 0xdc, 0x10, 0xe8,
+			0x1f, 0xc0, 0x00, 0x75,
+			0xd1, 0x49, 0x15, 0xf0,
+			0x19, 0xc7, 0x17, 0xc2,
+			0xec, 0x9a, 0x00, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0xea, 0x71, 0x9f, 0x49,
+			0x0a, 0xf0, 0x11, 0xc2,
+			0xec, 0x9a, 0x00, 0x19,
+			0xe8, 0x99, 0x81, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x06, 0xc3, 0x02, 0xc2,
+			0x00, 0xba, 0xf0, 0x1d,
+			0x4c, 0xe8, 0x00, 0xdc,
+			0x00, 0xd4, 0x34, 0xd3,
+			0x24, 0xe4, 0x7b, 0xc0,
+			0x00, 0x75, 0xd1, 0x49,
+			0x0d, 0xf0, 0x74, 0xc0,
+			0x74, 0xc5, 0x00, 0x1e,
+			0x08, 0x9e, 0x72, 0xc6,
+			0x0a, 0x9e, 0x0c, 0x9d,
+			0x8f, 0x1c, 0x0e, 0x8c,
+			0x0e, 0x74, 0xcf, 0x49,
+			0xfe, 0xf1, 0x04, 0xc0,
+			0x02, 0xc1, 0x00, 0xb9,
+			0xc4, 0x16, 0x20, 0xd4,
+			0x66, 0xc0, 0x00, 0x75,
+			0xd1, 0x48, 0x00, 0x9d,
+			0xe3, 0xc7, 0x5f, 0xc2,
+			0xec, 0x9a, 0x00, 0x19,
+			0xe8, 0x9a, 0x81, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x2c, 0xc1, 0xec, 0x99,
+			0x81, 0x19, 0xee, 0x89,
+			0xee, 0x71, 0x9f, 0x49,
+			0xfe, 0xf1, 0x04, 0xc3,
+			0x02, 0xc2, 0x00, 0xba,
+			0x96, 0x1c, 0xc0, 0xd4,
+			0xc0, 0x88, 0x1e, 0xc6,
+			0xc0, 0x70, 0x8f, 0x49,
+			0x0e, 0xf0, 0x8f, 0x48,
+			0x1b, 0xc6, 0xca, 0x98,
+			0x11, 0x18, 0xc8, 0x98,
+			0x16, 0xc0, 0xcc, 0x98,
+			0x8f, 0x18, 0xce, 0x88,
+			0xce, 0x70, 0x8f, 0x49,
+			0xfe, 0xf1, 0x0b, 0xe0,
+			0x36, 0xc6, 0x00, 0x18,
+			0xc8, 0x98, 0x0b, 0xc0,
+			0xcc, 0x98, 0x81, 0x18,
+			0xce, 0x88, 0xce, 0x70,
+			0x8f, 0x49, 0xfe, 0xf1,
+			0x02, 0xc0, 0x00, 0xb8,
+			0xf2, 0x19, 0x40, 0xd3,
+			0x20, 0xe4, 0x00, 0xdc,
+			0x90, 0x49, 0x1f, 0xf0,
+			0x29, 0xc0, 0x01, 0x66,
+			0x05, 0x16, 0x3f, 0xf0,
+			0x25, 0x16, 0x45, 0xf0,
+			0x09, 0x16, 0x23, 0xf0,
+			0x16, 0xe0, 0x1a, 0xc2,
+			0x40, 0x76, 0xe1, 0x48,
+			0x40, 0x9e, 0x17, 0xc2,
+			0x00, 0x1e, 0x48, 0x9e,
+			0xec, 0xc6, 0x4c, 0x9e,
+			0x81, 0x1e, 0x4e, 0x8e,
+			0x4e, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0x0b, 0xc6,
+			0x4c, 0x9e, 0x81, 0x1e,
+			0x4e, 0x8e, 0x4e, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0x90, 0x49, 0x02, 0xc7,
+			0x00, 0xbf, 0xe2, 0x27,
+			0x24, 0xe4, 0x34, 0xd3,
+			0x00, 0xdc, 0x00, 0xdc,
+			0x24, 0xe4, 0x80, 0x02,
+			0x34, 0xd3, 0xf8, 0xc7,
+			0xf9, 0xc2, 0x40, 0x76,
+			0xe1, 0x48, 0x40, 0x9e,
+			0xf6, 0xc2, 0x00, 0x1e,
+			0x48, 0x9e, 0xcb, 0xc6,
+			0x4c, 0x9e, 0x81, 0x1e,
+			0x4e, 0x8e, 0x4e, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xea, 0xc6, 0x4c, 0x9e,
+			0x81, 0x1e, 0x4e, 0x8e,
+			0x4e, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xdf, 0xe7,
+			0x40, 0xd4, 0x00, 0x00,
+			0xfe, 0xc2, 0x4c, 0x73,
+			0xbf, 0x49, 0xc4, 0xf0,
+			0x06, 0x76, 0xfa, 0xc2,
+			0x32, 0x40, 0xc0, 0xf0,
+			0xde, 0xc6, 0xc0, 0x75,
+			0xd1, 0x49, 0xd1, 0xf0,
+			0xd7, 0xc0, 0xd7, 0xc6,
+			0x0c, 0x9e, 0x00, 0x1e,
+			0x08, 0x9e, 0xd4, 0xc6,
+			0x0a, 0x9e, 0x8f, 0x1e,
+			0x0e, 0x8e, 0x0e, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xc4, 0xe7, 0x1a, 0xc6,
+			0xc0, 0x67, 0xf0, 0x49,
+			0x13, 0xf0, 0xf0, 0x48,
+			0xc0, 0x8f, 0xc2, 0x77,
+			0x14, 0xc1, 0x14, 0xc6,
+			0x24, 0x9e, 0x22, 0x9f,
+			0x8c, 0x1e, 0x26, 0x8e,
+			0x26, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xfb, 0x49,
+			0x05, 0xf0, 0x07, 0xc6,
+			0xc0, 0x61, 0x10, 0x48,
+			0xc0, 0x89, 0x02, 0xc6,
+			0x00, 0xbe, 0x7e, 0x36,
+			0x6c, 0xb4, 0x90, 0xcc,
+			0x08, 0xdc, 0x10, 0xe8,
+			0x1e, 0x89, 0x02, 0xc0,
+			0x00, 0xb8, 0xfa, 0x12,
+			0x18, 0xc0, 0x00, 0x65,
+			0xd1, 0x49, 0x0d, 0xf0,
+			0x11, 0xc0, 0x11, 0xc5,
+			0x00, 0x1e, 0x08, 0x9e,
+			0x0c, 0x9d, 0x0e, 0xc6,
+			0x0a, 0x9e, 0x8f, 0x1c,
+			0x0e, 0x8c, 0x0e, 0x74,
+			0xcf, 0x49, 0xfe, 0xf1,
+			0x04, 0xc0, 0x02, 0xc2,
+			0x00, 0xba, 0xa0, 0x41,
+			0x06, 0xd4, 0x00, 0xdc,
+			0x24, 0xe4, 0x80, 0x02,
+			0x34, 0xd3, 0x9e, 0x49,
+			0x0a, 0xf0, 0x0f, 0xc2,
+			0x40, 0x71, 0x9f, 0x49,
+			0x02, 0xf1, 0x08, 0xe0,
+			0x0b, 0xc2, 0x40, 0x61,
+			0x91, 0x48, 0x40, 0x89,
+			0x02, 0xc5, 0x00, 0xbd,
+			0x82, 0x24, 0x02, 0xc5,
+			0x00, 0xbd, 0xf8, 0x23,
+			0xfe, 0xcf, 0x1e, 0xd4,
+			0xfe, 0xc7, 0xe0, 0x75,
+			0x5f, 0x48, 0xe0, 0x9d,
+			0x04, 0xc7, 0x02, 0xc5,
+			0x00, 0xbd, 0x82, 0x18,
+			0x14, 0xd8, 0xc0, 0x88,
+			0x5d, 0xc7, 0x56, 0xc6,
+			0xe4, 0x9e, 0x0f, 0x1e,
+			0xe6, 0x8e, 0xe6, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xe2, 0x75, 0xe0, 0x74,
+			0xd8, 0x25, 0xd8, 0x22,
+			0xd8, 0x26, 0x48, 0x23,
+			0x68, 0x27, 0x48, 0x26,
+			0x04, 0xb4, 0x05, 0xb4,
+			0x06, 0xb4, 0x45, 0xc6,
+			0xe2, 0x23, 0xfe, 0x39,
+			0x00, 0x1c, 0x00, 0x1d,
+			0x00, 0x13, 0x0c, 0xf0,
+			0xb0, 0x49, 0x04, 0xf1,
+			0x01, 0x05, 0xb1, 0x25,
+			0xfa, 0xe7, 0xb8, 0x33,
+			0x35, 0x43, 0x26, 0x31,
+			0x01, 0x05, 0xb1, 0x25,
+			0xf4, 0xe7, 0x06, 0xb0,
+			0x05, 0xb0, 0xae, 0x41,
+			0x25, 0x31, 0x30, 0xc5,
+			0x6c, 0x41, 0x04, 0xb0,
+			0x05, 0xb4, 0x30, 0xc7,
+			0x29, 0xc6, 0x04, 0x06,
+			0xe4, 0x9e, 0x0f, 0x1e,
+			0xe6, 0x8e, 0xe6, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xe0, 0x76, 0xe8, 0x25,
+			0xe8, 0x23, 0xf8, 0x27,
+			0x1e, 0xc5, 0x6f, 0x41,
+			0x33, 0x23, 0xb3, 0x31,
+			0x74, 0x41, 0xf5, 0x31,
+			0x19, 0xc6, 0x7e, 0x41,
+			0x1a, 0xc6, 0xc4, 0x9f,
+			0xf1, 0x21, 0xdf, 0x30,
+			0x05, 0xb0, 0xc2, 0x9d,
+			0x52, 0x22, 0xa3, 0x31,
+			0x0e, 0xc7, 0xb7, 0x31,
+			0x0e, 0xc7, 0x77, 0x41,
+			0x0e, 0xc7, 0xe6, 0x9e,
+			0x0b, 0xc3, 0xde, 0x30,
+			0x60, 0x64, 0xe8, 0x8c,
+			0x02, 0xc4, 0x00, 0xbc,
+			0xe8, 0x19, 0x00, 0xc0,
+			0x41, 0x00, 0xff, 0x00,
+			0x7f, 0x00, 0x00, 0xe6,
+			0x60, 0xd3, 0x08, 0xdc,
+			0x1b, 0xc4, 0x80, 0x75,
+			0x08, 0x15, 0x04, 0xf0,
+			0x01, 0x05, 0x80, 0x9d,
+			0x0f, 0xe0, 0x00, 0x1d,
+			0x80, 0x9d, 0x25, 0xc4,
+			0x80, 0x75, 0xd8, 0x22,
+			0xdc, 0x26, 0x01, 0x15,
+			0x04, 0xf1, 0x0d, 0xc4,
+			0x11, 0x1d, 0x80, 0x8d,
+			0x14, 0x1e, 0xe5, 0x8e,
+			0x04, 0xe0, 0xe5, 0x66,
+			0x62, 0x48, 0xe5, 0x8e,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x8c, 0x06, 0x50, 0xd3,
+			0x4c, 0xb4, 0x11, 0xc0,
+			0x00, 0x71, 0x98, 0x20,
+			0x9c, 0x24, 0x01, 0x11,
+			0x06, 0xf1, 0x0a, 0xc6,
+			0x01, 0x1d, 0xc6, 0x8d,
+			0x19, 0x1d, 0xc1, 0x8d,
+			0x04, 0xc0, 0x02, 0xc1,
+			0x00, 0xb9, 0xa2, 0x12,
+			0xc0, 0xd4, 0x04, 0xe4,
+			0xb4, 0xbb, 0xec, 0xc6,
+			0x00, 0x1d, 0xc0, 0x8d,
+			0xfb, 0xc6, 0x14, 0x1d,
+			0xc5, 0x8d, 0x04, 0xc6,
+			0x02, 0xc5, 0x00, 0xbd,
+			0xd2, 0x03, 0x40, 0xb4 };
+		static u8 pla_patch2_b[] = {
+			0x10, 0xe0, 0x26, 0xe0,
+			0x37, 0xe0, 0x6b, 0xe0,
+			0x7e, 0xe0, 0xcb, 0xe0,
+			0xcd, 0xe0, 0xcf, 0xe0,
+			0xd1, 0xe0, 0xd3, 0xe0,
+			0xd5, 0xe0, 0xd7, 0xe0,
+			0xd9, 0xe0, 0xdb, 0xe0,
+			0xdd, 0xe0, 0xdf, 0xe0,
+			0x15, 0xc6, 0xc2, 0x64,
+			0xd2, 0x49, 0x06, 0xf1,
+			0xc4, 0x48, 0xc5, 0x48,
+			0xc6, 0x48, 0xc7, 0x48,
+			0x05, 0xe0, 0x44, 0x48,
+			0x45, 0x48, 0x46, 0x48,
+			0x47, 0x48, 0xc2, 0x8c,
+			0xc0, 0x64, 0x46, 0x48,
+			0xc0, 0x8c, 0x05, 0xc5,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x18, 0x02, 0x06, 0xdc,
+			0xb0, 0xc0, 0x10, 0xc5,
+			0xa0, 0x77, 0xa0, 0x74,
+			0x46, 0x48, 0x47, 0x48,
+			0xa0, 0x9c, 0x0b, 0xc5,
+			0xa0, 0x74, 0x44, 0x48,
+			0x43, 0x48, 0xa0, 0x9c,
+			0x05, 0xc5, 0xa0, 0x9f,
+			0x02, 0xc5, 0x00, 0xbd,
+			0x3c, 0x03, 0x1c, 0xe8,
+			0x20, 0xe8, 0xd4, 0x49,
+			0x04, 0xf1, 0xd5, 0x49,
+			0x20, 0xf1, 0x28, 0xe0,
+			0x2a, 0xc7, 0xe0, 0x75,
+			0xda, 0x49, 0x14, 0xf0,
+			0x27, 0xc7, 0xe0, 0x75,
+			0xdc, 0x49, 0x10, 0xf1,
+			0x24, 0xc7, 0xe0, 0x75,
+			0x25, 0xc7, 0xe0, 0x74,
+			0x2c, 0x40, 0x0a, 0xfa,
+			0x1f, 0xc7, 0xe4, 0x75,
+			0xd0, 0x49, 0x09, 0xf1,
+			0x1c, 0xc5, 0xe6, 0x9d,
+			0x11, 0x1d, 0xe4, 0x8d,
+			0x04, 0xe0, 0x16, 0xc7,
+			0x00, 0x1d, 0xe4, 0x8d,
+			0xe0, 0x8e, 0x11, 0x1d,
+			0xe0, 0x8d, 0x07, 0xe0,
+			0x0c, 0xc7, 0xe0, 0x75,
+			0xda, 0x48, 0xe0, 0x9d,
+			0x0b, 0xc7, 0xe4, 0x8e,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x28, 0x03, 0x02, 0xc4,
+			0x00, 0xbc, 0x14, 0x03,
+			0x12, 0xe8, 0x4e, 0xe8,
+			0x1c, 0xe6, 0x20, 0xe4,
+			0x80, 0x02, 0xa4, 0xc0,
+			0x12, 0xc2, 0x40, 0x73,
+			0xb0, 0x49, 0x08, 0xf0,
+			0xb8, 0x49, 0x06, 0xf0,
+			0xb8, 0x48, 0x40, 0x9b,
+			0x0b, 0xc2, 0x40, 0x76,
+			0x05, 0xe0, 0x02, 0x61,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x0a, 0x0a, 0x02, 0xc3,
+			0x00, 0xbb, 0x1a, 0x0a,
+			0x98, 0xd3, 0x1e, 0xfc,
+			0x1f, 0xe8, 0xfd, 0xc0,
+			0x02, 0x62, 0xa0, 0x48,
+			0x02, 0x8a, 0x00, 0x72,
+			0xa0, 0x49, 0x11, 0xf0,
+			0x13, 0xc1, 0x20, 0x62,
+			0x2e, 0x21, 0x2f, 0x25,
+			0x00, 0x71, 0x9f, 0x24,
+			0x0a, 0x40, 0x09, 0xf0,
+			0x00, 0x71, 0x18, 0x48,
+			0xa0, 0x49, 0x03, 0xf1,
+			0x9f, 0x48, 0x02, 0xe0,
+			0x1f, 0x48, 0x00, 0x99,
+			0x02, 0xc2, 0x00, 0xba,
+			0xda, 0x0e, 0x08, 0xe9,
+			0x08, 0xea, 0x34, 0xd3,
+			0xe8, 0xd4, 0x00, 0xb4,
+			0x01, 0xb4, 0x02, 0xb4,
+			0xf9, 0xc1, 0x20, 0x62,
+			0x2e, 0x21, 0x2f, 0x25,
+			0xa0, 0x49, 0x23, 0xf0,
+			0xf4, 0xc0, 0xf4, 0xc2,
+			0x04, 0x9a, 0x00, 0x1a,
+			0x06, 0x8a, 0x06, 0x72,
+			0xaf, 0x49, 0xfe, 0xf1,
+			0x00, 0x72, 0xa1, 0x49,
+			0x18, 0xf0, 0xeb, 0xc2,
+			0x04, 0x9a, 0x00, 0x1a,
+			0x06, 0x8a, 0x06, 0x72,
+			0xaf, 0x49, 0xfe, 0xf1,
+			0x00, 0x72, 0xa1, 0x48,
+			0x00, 0x9a, 0x81, 0x1a,
+			0x06, 0x8a, 0x06, 0x72,
+			0xaf, 0x49, 0xfe, 0xf1,
+			0x00, 0x72, 0x21, 0x48,
+			0x00, 0x9a, 0x81, 0x1a,
+			0x06, 0x8a, 0x06, 0x72,
+			0xaf, 0x49, 0xfe, 0xf1,
+			0x02, 0xb0, 0x01, 0xb0,
+			0x00, 0xb0, 0x80, 0xff,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x3a, 0x4e,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x00, 0x00 };
+		u8 new_ver;
+
+		rtl_fw_ver_erase(tp);
+
+		new_ver = 7;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_USB_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_USB);
+
+			/* enable fc timer and set timer to 1 second. */
+			ocp_write_word(tp, MCU_TYPE_USB, USB_FC_TIMER,
+				       CTRL_TIMER_EN | (1000 / 8));
+
+			generic_ocp_write(tp, 0xe600, 0xff,
+					  sizeof(usb_patch2_b), usb_patch2_b,
+					  MCU_TYPE_USB);
+
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xa000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x3d86);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x088a);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x1dee);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x16c2);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x1c94);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x19f0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x27e0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x35a8);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x12f8);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x419e);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x23f4);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x186e);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x19e6);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x0674);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x12a0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x03d0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0xffff);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_USB_VER,
+				       new_ver);
+		}
+
+		new_ver = 3;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_PLA_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+			generic_ocp_write(tp, 0xf800, 0xff,
+					  sizeof(pla_patch2_b), pla_patch2_b,
+					  MCU_TYPE_PLA);
+
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_BA, 0x8000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_0, 0x0216);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_1, 0x0332);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_2, 0x030c);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_3, 0x0a08);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_4, 0x0ec0);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_5, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_6, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_7, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x001e);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_PLA_VER,
+				       new_ver);
+
+			ret = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_1,
+					    &ocp_data);
+			if (ocp_data & BND_MASK)
+				ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_BP_EN,
+						  BIT(0));
+		}
+
+		ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_CTRL,
+				  FLOW_CTRL_PATCH_OPT);
+
+		ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_TASK, FC_PATCH_TASK);
+
+		ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_FIX_EN1,
+				  FW_IP_RESET_EN);
+
+		rtl_reset_ocp_base(tp);
+	} else if (tp->version == RTL_VER_14) {
+		static u8 usb_patch3_a[] = {
+			0x10, 0xe0, 0x79, 0xe0,
+			0x97, 0xe0, 0x99, 0xe0,
+			0xa0, 0xe0, 0xa2, 0xe0,
+			0xc3, 0xe0, 0xe9, 0xe0,
+			0xeb, 0xe0, 0xed, 0xe0,
+			0xef, 0xe0, 0xf1, 0xe0,
+			0xf3, 0xe0, 0xf5, 0xe0,
+			0xf7, 0xe0, 0xf9, 0xe0,
+			0x01, 0xb4, 0x03, 0xb4,
+			0x04, 0xb4, 0x05, 0xb4,
+			0x07, 0xb4, 0x64, 0xc6,
+			0xc0, 0x60, 0x82, 0x48,
+			0xc0, 0x88, 0x5f, 0xc7,
+			0x58, 0xc6, 0xe4, 0x9e,
+			0x0f, 0x1e, 0xe6, 0x8e,
+			0xe6, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xe2, 0x73,
+			0xe0, 0x74, 0xb8, 0x22,
+			0xd8, 0x26, 0xb8, 0x25,
+			0x48, 0x23, 0x68, 0x27,
+			0x48, 0x26, 0x04, 0xb4,
+			0x05, 0xb4, 0x06, 0xb4,
+			0x47, 0xc6, 0xe2, 0x23,
+			0xfe, 0x39, 0x00, 0x1c,
+			0x00, 0x1d, 0x00, 0x13,
+			0x0c, 0xf0, 0xb0, 0x49,
+			0x04, 0xf1, 0x01, 0x05,
+			0xb1, 0x25, 0xfa, 0xe7,
+			0xb8, 0x33, 0x35, 0x43,
+			0x26, 0x31, 0x01, 0x05,
+			0xb1, 0x25, 0xf4, 0xe7,
+			0x06, 0xb0, 0x05, 0xb0,
+			0xae, 0x41, 0x25, 0x31,
+			0x32, 0xc5, 0x6c, 0x41,
+			0x04, 0xb0, 0x05, 0xb4,
+			0x32, 0xc7, 0x2b, 0xc6,
+			0x04, 0x06, 0xe4, 0x9e,
+			0x0f, 0x1e, 0xe6, 0x8e,
+			0xe6, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xe0, 0x76,
+			0xe8, 0x25, 0xe8, 0x23,
+			0xf8, 0x27, 0x20, 0xc5,
+			0x6f, 0x41, 0xb3, 0x20,
+			0x4b, 0x30, 0x4c, 0x41,
+			0x4d, 0x30, 0x1b, 0xc6,
+			0x4e, 0x41, 0x91, 0x21,
+			0xd9, 0x30, 0x05, 0xb0,
+			0x52, 0x22, 0xa3, 0x31,
+			0x13, 0xc7, 0xb7, 0x31,
+			0x13, 0xc7, 0x77, 0x41,
+			0x12, 0xc3, 0xde, 0x30,
+			0x60, 0x65, 0x10, 0xc7,
+			0xe0, 0x8d, 0xe2, 0x9e,
+			0x07, 0xb0, 0x05, 0xb0,
+			0x04, 0xb0, 0x03, 0xb0,
+			0x01, 0xb0, 0x02, 0xc0,
+			0x00, 0xb8, 0xd6, 0x20,
+			0x00, 0xc0, 0x41, 0x00,
+			0xff, 0x00, 0x7f, 0x00,
+			0x00, 0xe6, 0x7a, 0xd3,
+			0x08, 0xdc, 0xe8, 0xd4,
+			0x04, 0xb4, 0x05, 0xb4,
+			0x06, 0xb4, 0x1b, 0xc0,
+			0x00, 0x75, 0xd8, 0x49,
+			0x0d, 0xf0, 0x14, 0xc0,
+			0x14, 0xc5, 0x00, 0x1e,
+			0x08, 0x9e, 0x0c, 0x9d,
+			0x11, 0xc6, 0x0a, 0x9e,
+			0x8f, 0x1c, 0x0e, 0x8c,
+			0x0e, 0x74, 0xcf, 0x49,
+			0xfe, 0xf1, 0x07, 0xc1,
+			0x06, 0xb0, 0x05, 0xb0,
+			0x04, 0xb0, 0x02, 0xc0,
+			0x00, 0xb8, 0xdc, 0x5c,
+			0xe0, 0xcb, 0x00, 0xdc,
+			0x24, 0xe4, 0x80, 0x02,
+			0x34, 0xd3, 0x02, 0xc2,
+			0x00, 0xba, 0x42, 0x08,
+			0x40, 0x60, 0x80, 0x48,
+			0x81, 0x48, 0x82, 0x48,
+			0x40, 0x88, 0x02, 0xc2,
+			0x00, 0xba, 0xf0, 0x1b,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x20, 0x24, 0x1c, 0xc6,
+			0xc0, 0x61, 0x04, 0x11,
+			0x15, 0xf1, 0x19, 0xc6,
+			0xc0, 0x61, 0x9c, 0x20,
+			0x9c, 0x24, 0x09, 0x11,
+			0x0f, 0xf1, 0x14, 0xc6,
+			0x01, 0x19, 0xc0, 0x89,
+			0x13, 0xc1, 0x13, 0xc6,
+			0x24, 0x9e, 0x00, 0x1e,
+			0x26, 0x8e, 0x26, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0x22, 0x76, 0x08, 0xc1,
+			0x22, 0x9e, 0x07, 0xc6,
+			0x02, 0xc1, 0x00, 0xb9,
+			0x64, 0x09, 0x18, 0xb4,
+			0x4a, 0xb4, 0xe0, 0xcc,
+			0x80, 0xd4, 0x08, 0xdc,
+			0x10, 0xe8, 0xfc, 0xc6,
+			0xc0, 0x67, 0xf0, 0x49,
+			0x1d, 0xf0, 0xf0, 0x48,
+			0xc0, 0x8f, 0xc2, 0x77,
+			0xf7, 0xc1, 0xf7, 0xc6,
+			0x24, 0x9e, 0x22, 0x9f,
+			0x8c, 0x1e, 0x26, 0x8e,
+			0x26, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xfb, 0x49,
+			0x05, 0xf0, 0x11, 0xc6,
+			0xc0, 0x61, 0x10, 0x48,
+			0xc0, 0x89, 0x0e, 0xc6,
+			0xc0, 0x71, 0x18, 0x48,
+			0xc0, 0x99, 0x0b, 0xc1,
+			0xcc, 0x99, 0x0a, 0xc6,
+			0xc0, 0x61, 0x11, 0x48,
+			0xc0, 0x89, 0x02, 0xc6,
+			0x00, 0xbe, 0x46, 0x50,
+			0x6c, 0xb4, 0x34, 0xd3,
+			0x4b, 0x80, 0xe8, 0xd4,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x00, 0x00 };
+		static u8 pla_patch3_a[] = {
+			0x10, 0xe0, 0x12, 0xe0,
+			0x15, 0xe0, 0x1a, 0xe0,
+			0x25, 0xe0, 0x31, 0xe0,
+			0x33, 0xe0, 0x35, 0xe0,
+			0x37, 0xe0, 0x39, 0xe0,
+			0x3b, 0xe0, 0x3d, 0xe0,
+			0x3f, 0xe0, 0x41, 0xe0,
+			0x43, 0xe0, 0x45, 0xe0,
+			0x02, 0xc6, 0x00, 0xbe,
+			0xec, 0x2c, 0x94, 0x49,
+			0x02, 0xc6, 0x00, 0xbe,
+			0xae, 0x2b, 0x05, 0xc0,
+			0x00, 0x72, 0x02, 0xc6,
+			0x00, 0xbe, 0xd6, 0x2b,
+			0x20, 0xe8, 0x08, 0xc3,
+			0x60, 0x65, 0xd0, 0x49,
+			0x06, 0xf1, 0xe0, 0x75,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x3e, 0x08, 0xb4, 0xd3,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x5e, 0x08, 0x6c, 0x74,
+			0xc4, 0x75, 0xe5, 0x41,
+			0xc2, 0x49, 0x05, 0xf0,
+			0x07, 0xc6, 0x01, 0x1c,
+			0xc0, 0x8c, 0xc1, 0x8c,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x16, 0x02, 0x99, 0xd3,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x3a, 0x4e,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x00, 0x00 };
+		u8 new_ver;
+
+		rtl_fw_ver_erase(tp);
+
+		new_ver = 2;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_PLA_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+			generic_ocp_write(tp, 0xf800, 0xff,
+					  sizeof(pla_patch3_a), pla_patch3_a,
+					  MCU_TYPE_PLA);
+
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_BA, 0x8000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_0, 0x2be6);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_1, 0x2bac);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_2, 0x2bd4);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_3, 0x083c);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_4, 0x0214);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_5, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_6, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_7, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_8, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_9, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_10, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_11, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_12, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_13, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_14, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_15, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP2_EN, 0x001f);
+
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_PLA_VER,
+				       new_ver);
+		}
+
+		new_ver = 5;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_USB_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_USB);
+
+			/* enable fc timer and set timer to 1 second. */
+			ocp_write_word(tp, MCU_TYPE_USB, USB_FC_TIMER,
+				       CTRL_TIMER_EN | (1000 / 8));
+
+			generic_ocp_write(tp, 0xe600, 0xff,
+					  sizeof(usb_patch3_a), usb_patch3_a,
+					  MCU_TYPE_USB);
+
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xa000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x20ce);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x5cda);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x0834);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x1bec);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x241e);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x0962);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x4f54);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0x007f);
+
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_USB_VER,
+				       new_ver);
+		}
+
+		ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_CTRL,
+				  FLOW_CTRL_PATCH_2);
+
+		ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_TASK, FC_PATCH_TASK);
+
+		rtl_reset_ocp_base(tp);
+	}
+
+	rtl_reset_ocp_base(tp);
+}
+
+static void r8156_firmware(struct r8152 *tp)
+{
+	if (tp->version == RTL_TEST_01) {
+		static u8 usb3_patch_t[] = {
+			0x01, 0xe0, 0x05, 0xc7,
+			0xf6, 0x65, 0x02, 0xc0,
+			0x00, 0xb8, 0x40, 0x03,
+			0x00, 0xd4, 0x00, 0x00 };
+
+		rtl_reset_ocp_base(tp);
+
+		sram2_write(tp, 0x8099, 0x2a50);
+		sram2_write(tp, 0x80a1, 0x2a50);
+		sram2_write(tp, 0x809a, 0x5010);
+		sram2_write(tp, 0x80a2, 0x500f);
+		sram2_write(tp, 0x8087, 0xc0cf);
+		sram2_write(tp, 0x8080, 0x0f16);
+		sram2_write(tp, 0x8089, 0x161b);
+		sram2_write(tp, 0x808a, 0x1b1f);
+
+		ocp_reg_write(tp, 0xac36, 0x0080);
+		ocp_reg_write(tp, 0xac4a, 0xff00);
+		ocp_reg_w0w1(tp, 0xac34, BIT(4), BIT(2) | BIT(3));
+
+		ocp_reg_clr_bits(tp, 0xac54, BIT(9) | BIT(10));
+		sram2_write(tp, 0x8099, 0x2050);
+		sram2_write(tp, 0x80a1, 0x2050);
+		sram2_write(tp, 0x809a, 0x5010);
+		sram2_write(tp, 0x80a2, 0x500f);
+		ocp_reg_w0w1(tp, 0xac34, BIT(5), BIT(6) | BIT(7));
+
+		if (rtl_phy_patch_request(tp, true, true)) {
+			netif_err(tp, drv, tp->netdev,
+				  "patch request error\n");
+			return;
+		}
+
+		ocp_reg_clr_bits(tp, 0xb896, BIT(0));
+		ocp_reg_write(tp, 0xb892, 0x0000);
+		ocp_reg_write(tp, 0xb88e, 0xc089);
+		ocp_reg_write(tp, 0xb890, 0xc1d0);
+		ocp_reg_write(tp, 0xb88e, 0xc08a);
+		ocp_reg_write(tp, 0xb890, 0xe0f0);
+		ocp_reg_write(tp, 0xb88e, 0xc08b);
+		ocp_reg_write(tp, 0xb890, 0xe0f0);
+		ocp_reg_write(tp, 0xb88e, 0xc08c);
+		ocp_reg_write(tp, 0xb890, 0xffff);
+		ocp_reg_write(tp, 0xb88e, 0xc08d);
+		ocp_reg_write(tp, 0xb890, 0xffff);
+		ocp_reg_write(tp, 0xb88e, 0xc08e);
+		ocp_reg_write(tp, 0xb890, 0xffff);
+		ocp_reg_write(tp, 0xb88e, 0xc08f);
+		ocp_reg_write(tp, 0xb890, 0xffff);
+		ocp_reg_write(tp, 0xb88e, 0xc090);
+		ocp_reg_write(tp, 0xb890, 0xff12);
+
+		ocp_reg_write(tp, 0xb88e, 0xc09a);
+		ocp_reg_write(tp, 0xb890, 0x191a);
+		ocp_reg_write(tp, 0xb88e, 0xc09b);
+		ocp_reg_write(tp, 0xb890, 0x191a);
+		ocp_reg_write(tp, 0xb88e, 0xc09e);
+		ocp_reg_write(tp, 0xb890, 0x1d1e);
+		ocp_reg_write(tp, 0xb88e, 0xc09f);
+		ocp_reg_write(tp, 0xb890, 0x1d1e);
+		ocp_reg_write(tp, 0xb88e, 0xc0a0);
+		ocp_reg_write(tp, 0xb890, 0x1f20);
+		ocp_reg_write(tp, 0xb88e, 0xc0a1);
+		ocp_reg_write(tp, 0xb890, 0x1f20);
+		ocp_reg_write(tp, 0xb88e, 0xc0a2);
+		ocp_reg_write(tp, 0xb890, 0x2122);
+		ocp_reg_write(tp, 0xb88e, 0xc0a3);
+		ocp_reg_write(tp, 0xb890, 0x2122);
+		ocp_reg_write(tp, 0xb88e, 0xc0a4);
+		ocp_reg_write(tp, 0xb890, 0x2324);
+		ocp_reg_write(tp, 0xb88e, 0xc0a5);
+		ocp_reg_write(tp, 0xb890, 0x2324);
+
+		ocp_reg_write(tp, 0xb88e, 0xc029);
+		ocp_reg_write(tp, 0xb890, 0xdff3);
+		ocp_reg_write(tp, 0xb88e, 0xc02a);
+		ocp_reg_write(tp, 0xb890, 0xf3f3);
+		ocp_reg_write(tp, 0xb88e, 0xc02b);
+		ocp_reg_write(tp, 0xb890, 0xf3f3);
+		ocp_reg_write(tp, 0xb88e, 0xc02c);
+		ocp_reg_write(tp, 0xb890, 0xf3ef);
+		ocp_reg_write(tp, 0xb88e, 0xc02d);
+		ocp_reg_write(tp, 0xb890, 0xf3ef);
+		ocp_reg_write(tp, 0xb88e, 0xc02e);
+		ocp_reg_write(tp, 0xb890, 0xebe7);
+		ocp_reg_write(tp, 0xb88e, 0xc02f);
+		ocp_reg_write(tp, 0xb890, 0xebe7);
+		ocp_reg_write(tp, 0xb88e, 0xc030);
+		ocp_reg_write(tp, 0xb890, 0xe4e2);
+		ocp_reg_write(tp, 0xb88e, 0xc031);
+		ocp_reg_write(tp, 0xb890, 0xe4e2);
+		ocp_reg_write(tp, 0xb88e, 0xc032);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc033);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc034);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc035);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc036);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc037);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc038);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc039);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc03a);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc03b);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc03c);
+		ocp_reg_write(tp, 0xb890, 0xdf00);
+
+		ocp_reg_set_bits(tp, 0xb896, BIT(0));
+
+		rtl_patch_key_set(tp, 0x8024, 0x0000);
+		sram_write(tp, SRAM_PHY_LOCK, PHY_PATCH_LOCK);
+
+		ocp_reg_set_bits(tp, OCP_PHY_PATCH_CMD, BIT(7));
+
+		/* nc0_patch_171220_loop_test_USB */
+		sram_write(tp, 0xA016, 0x0000);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8027);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x802e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8035);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x806d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8077);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8091);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3709);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8017);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3bdd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x38c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1034);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4061);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x37b8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1034);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1044);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3b0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1032);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12ed);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2109);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1032);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa130);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd020);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa8c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd020);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd093);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa63f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa73f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd09e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd0dc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd03b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1c4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x617d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcdc7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4013);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f7a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f7a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8208);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcc08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x08ba);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x08c6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ee6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x068b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0e9d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x34a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0da2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f1c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd75e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ffd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0dca);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd707);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5e67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2f79);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0dc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd75e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2a51);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0db6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffec);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa540);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1308);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x159e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc445);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdb02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0608);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c47);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0542);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x408d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd075);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6045);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd05d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd07a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1b5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0771);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3b4d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x809f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2635);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0241);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2745);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0241);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x27d0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80aa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ec8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc446);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdb04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd064);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd018);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x068b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0753);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x407b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0771);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2745);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0241);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x608a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6306);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80c5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5e28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2730);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80c5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0771);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc447);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdb08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x406d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c07);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd056);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1c2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ce1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2734);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80c5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c07);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1b2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd0a8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdb08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc447);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x26d7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x648a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fbb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ca0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0320);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa208);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc317);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2c51);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdb10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc448);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa620);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x41dd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa306);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x415f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa210);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa330);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc575);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8210);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8320);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2c59);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3a33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd098);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd191);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x609f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8306);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa320);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa210);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd006);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1e3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc30f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4093);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc033);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02fb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa0f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8208);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02fb);
+		sram_write(tp, 0xA026, 0x0279);
+		sram_write(tp, 0xA024, 0x159c);
+		sram_write(tp, 0xA022, 0x0d94);
+		sram_write(tp, 0xA020, 0x0ee1);
+		sram_write(tp, 0xA006, 0x0f46);
+		sram_write(tp, 0xA004, 0x12e2);
+		sram_write(tp, 0xA002, 0x12ea);
+		sram_write(tp, 0xA000, 0x1034);
+		sram_write(tp, 0xA008, 0xff00);
+
+		/* nc2_patch_171109_USB */
+		sram_write(tp, 0xA016, 0x0020);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8018);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8024);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8056);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8062);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8069);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8080);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0390);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd37a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd21a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0508);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd164);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0441);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcf0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0437);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x010c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb60);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x210c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x001a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f57);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbb80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x605f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9b80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1c3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd074);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfff1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb62);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb910);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9930);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8406);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa780);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd141);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0441);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa70c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6041);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0441);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ed);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd164);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0441);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0450);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0236);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbb80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1c3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd074);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03f3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb17);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0441);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ec0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0e80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaec0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x34a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x012c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5d8e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0134);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb23);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0441);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ec0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0e80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaec0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5dee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0249);
+		sram_write(tp, 0xA10E, 0x0239);
+		sram_write(tp, 0xA10C, 0x0119);
+		sram_write(tp, 0xA10A, 0x03f2);
+		sram_write(tp, 0xA108, 0x0231);
+		sram_write(tp, 0xA106, 0x0413);
+		sram_write(tp, 0xA104, 0x0108);
+		sram_write(tp, 0xA102, 0x0506);
+		sram_write(tp, 0xA100, 0x038e);
+		sram_write(tp, 0xA110, 0x00ff);
+
+		/* uc2_patch_171006_calc_txcrc_reg_write_seq_USB */
+		sram_write(tp, 0xb87c, 0x82c1);
+		sram_write(tp, 0xb87e, 0xaf82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcdaf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82d6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd9af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82dc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0282);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdc02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x830c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd7af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0eea);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe4f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8169);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac23);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x815d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad23);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1bf7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfa02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b99);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0283);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3cf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d70);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8169);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac24);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x815d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad24);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1bf7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfa02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8349);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0283);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3cf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x861d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf70f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcfad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x27fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf60f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8375);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae16);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x83aa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae0e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x848f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae06);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x857e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad2b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x16ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ee1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x815d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf62c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe581);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5dbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8663);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe281);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa6e3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3905);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac2f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1da2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0417);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0285);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x815d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf62c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe581);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5dbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8663);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4412);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x20e6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe781);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa75d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0303);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe281);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa4e3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5d03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x030c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x260c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x341e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x121e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8666);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8d1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x09bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8669);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8675);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa201);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0abf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x867b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x64ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x22a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x020a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7e02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3f2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae15);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa203);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0abf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8681);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x64ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x08bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8684);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6483);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a63);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa81a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x961f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x66ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x563d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1fd9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef79);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef16);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x290a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x435c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef97);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1916);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaed9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8678);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2879);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6f02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3f2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa094);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe381);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa7d1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8672);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x100d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x121f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1259);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0043);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5903);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x851c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe681);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa4e7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5d03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x120c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x121e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x130c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x121e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x120c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x121e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8666);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8d1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x09bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8669);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8675);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x06bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8675);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f66);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8283);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3c00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2741);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2c00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8672);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x868a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x868d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8690);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x868a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1311);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x435c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2b02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x16ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3f2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ee2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe381);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa7d1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8672);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1259);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5903);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0da0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x900a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13e7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae2f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa094);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x26d1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8672);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x100d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x161f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1259);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x000d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5903);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcdbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8675);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd209);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3b0e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad3f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8669);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5c12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad2b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x44e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8169);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf62c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe581);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x815d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf62c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe581);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5def);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa400);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa601);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa300);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x44a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe070);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb468);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdab4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x68ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb468);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0b6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3a20);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb638);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeb6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x38ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb638);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10b5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0032);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54b5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0076);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4e70);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb450);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x52b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4e66);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb44e);
+		sram_write(tp, 0xb85e, 0x03d1);
+		sram_write(tp, 0xb860, 0x0ee4);
+		sram_write(tp, 0xb862, 0x0fde);
+		sram_write(tp, 0xb864, 0xffff);
+		sram_write(tp, 0xb878, 0x0001);
+
+		ocp_reg_clr_bits(tp, OCP_PHY_PATCH_CMD, BIT(7));
+
+		/* uc_patch_171212_customer_USB */
+		sram_write(tp, 0x8586, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x92af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8598);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa1af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0285);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa1af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0414);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7e02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1cf8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9e3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x83ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa601);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x580f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa008);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4659);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f9e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4239);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0aab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ead);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2729);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf60e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe283);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xab1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x239f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x28e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb714);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe1b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x155c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9fee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0285);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0af7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0fe0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0fe2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x83ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f23);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9f03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa6fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfb02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f77);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2ee1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb72f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ce0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb72c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe1b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x864c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2ae1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb72b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ce0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb728);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe1b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x864c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x26e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb727);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x47d2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb8e6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb468);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe5b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69d2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbce6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb468);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe4b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfffd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfad2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x675e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d71);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f7f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2803);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x010d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4112);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa210);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb463);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6901);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe4b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb463);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8016);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad2d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3bbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x08ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2832);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3f08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x29d2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x080d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11f6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2fef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x31e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf627);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf627);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86ca);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbfa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf4e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fed);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c21);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a92);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe08f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeee1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe08f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0217);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x70fc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xff04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2087);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0620);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8709);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0087);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cbb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa880);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeea8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8070);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa880);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60a8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x18e8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa818);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60a8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a00);
+		sram_write(tp, 0xb818, 0x040e);
+		sram_write(tp, 0xb81a, 0x1019);
+		sram_write(tp, 0xb81c, 0xffff);
+		sram_write(tp, 0xb81e, 0xffff);
+		sram_write(tp, 0xb832, 0x0003);
+
+		rtl_patch_key_set(tp, 0x8024, 0x0000);
+		ocp_reg_write(tp, 0xc414, 0x0200);
+
+		rtl_phy_patch_request(tp, false, true);
+
+		r8156_lock_main(tp, true);
+
+		sram_write(tp, 0x80c9, 0x3478);
+		sram_write(tp, 0x80d0, 0xfe8f);
+		sram_write(tp, 0x80ca, 0x7843);
+		sram_write(tp, 0x80cb, 0x43b0);
+		sram_write(tp, 0x80cb, 0x4380);
+		sram_write(tp, 0x80cc, 0xb00b);
+		sram_write(tp, 0x80cd, 0x0ba1);
+		sram_write(tp, 0x80d8, 0x1078);
+		sram_write(tp, 0x8016, 0x3f00);
+		sram_write(tp, 0x8fed, 0x0386);
+		sram_write(tp, 0x8fee, 0x86f4);
+		sram_write(tp, 0x8fef, 0xf486);
+		sram_write(tp, 0x8ff0, 0x86fd);
+		sram_write(tp, 0x8ff1, 0xfd28);
+		sram_write(tp, 0x8ff2, 0x285a);
+		sram_write(tp, 0x8ff3, 0x5a70);
+		sram_write(tp, 0x8ff4, 0x7000);
+		sram_write(tp, 0x8ff5, 0x005d);
+		sram_write(tp, 0x8ff6, 0x5d77);
+		sram_write(tp, 0x8ff7, 0x7778);
+		sram_write(tp, 0x8ff8, 0x785f);
+		sram_write(tp, 0x8ff9, 0x5f74);
+		sram_write(tp, 0x8ffa, 0x7478);
+		sram_write(tp, 0x8ffb, 0x7858);
+		sram_write(tp, 0x8ffc, 0x5870);
+		sram_write(tp, 0x8ffd, 0x7078);
+		sram_write(tp, 0x8ffe, 0x7850);
+		sram_write(tp, 0x8fff, 0x5000);
+		sram_write(tp, 0x80dd, 0x34a4);
+		sram_write(tp, 0x80e4, 0xfe7f);
+		sram_write(tp, 0x80e6, 0x4a19);
+		sram_write(tp, 0x80de, 0xa443);
+		sram_write(tp, 0x80df, 0x43a0);
+		sram_write(tp, 0x80df, 0x43a0);
+		sram_write(tp, 0x80e0, 0xa00a);
+		sram_write(tp, 0x80e1, 0x0a00);
+		sram_write(tp, 0x80e8, 0x700c);
+		sram_write(tp, 0x80e2, 0x0007);
+		sram_write(tp, 0x80e3, 0x07fe);
+		sram_write(tp, 0x80ec, 0x0e78);
+		sram_write(tp, 0x80b5, 0x42f7);
+		sram_write(tp, 0x80bc, 0xfaa4);
+		sram_write(tp, 0x80bf, 0x1f80);
+		sram_write(tp, 0x80be, 0xff1f);
+		sram_write(tp, 0x80b7, 0x4280);
+		sram_write(tp, 0x80b6, 0xf742);
+		sram_write(tp, 0x80b8, 0x800f);
+		sram_write(tp, 0x80b9, 0x0fab);
+		sram_write(tp, 0x80c1, 0x1e0a);
+		sram_write(tp, 0x80c0, 0x801e);
+		sram_write(tp, 0x80bd, 0xa4ff);
+		sram_write(tp, 0x80bb, 0x0bfa);
+		sram_write(tp, 0x80ba, 0xab0b);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0x818d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x003d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x009b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00cb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00f2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00c2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0065);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0034);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x001b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x000e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0007);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		sram_write(tp, 0x8163, 0xdb06);
+		sram_write(tp, 0x816a, 0xdb06);
+		sram_write(tp, 0x8171, 0xdb06);
+
+		r8156_lock_main(tp, false);
+
+		rtl_clear_bp(tp, MCU_TYPE_USB);
+
+		generic_ocp_write(tp, 0xe600, 0xff, sizeof(usb3_patch_t),
+				  usb3_patch_t, MCU_TYPE_USB);
+
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xa000);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x033e);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0x0001);
+	}
+
+	rtl_reset_ocp_base(tp);
+}
+
+static int r8153_aldps_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		ret = ocp_reg_set_bits(tp, OCP_POWER_CFG, EN_ALDPS);
+	} else {
+		int i;
+
+		ret = ocp_reg_clr_bits(tp, OCP_POWER_CFG, EN_ALDPS);
+		if (ret < 0)
+			goto out;
+		for (i = 0; i < 20; i++) {
+			u32 ocp_data;
+
+			usleep_range(1000, 2000);
+			ret = ocp_read_word(tp, MCU_TYPE_PLA, 0xe000,
+					    &ocp_data);
+			if (ret < 0 || (ocp_data & 0x0100))
+				break;
+		}
+	}
+
+	tp->ups_info.aldps = enable;
+
+out:
+	return ret;
+}
+
+static int r8153b_mcu_spdown_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable)
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3,
+					PLA_MCU_SPDWN_EN);
+	else
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3,
+					PLA_MCU_SPDWN_EN);
+
+	return ret;
+}
+
+static void r8153_hw_phy_cfg(struct r8152 *tp)
+{
+	/* disable ALDPS before updating the PHY parameters */
+	r8153_aldps_en(tp, false);
+
+	/* disable EEE before updating the PHY parameters */
+	rtl_eee_enable(tp, false);
+
+	r8153_firmware(tp);
+
+	if (tp->version == RTL_VER_03)
+		ocp_reg_clr_bits(tp, OCP_EEE_CFG, CTAP_SHORT_EN);
+
+	ocp_reg_set_bits(tp, OCP_POWER_CFG, EEE_CLKDIV_EN);
+
+	ocp_reg_set_bits(tp, OCP_DOWN_SPEED, EN_10M_BGOFF);
+	ocp_reg_set_bits(tp, OCP_POWER_CFG, EN_10M_PLLOFF);
+	sram_write(tp, SRAM_IMPEDANCE, 0x0b13);
+
+	ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_PHY_PWR, PFM_PWM_SWITCH);
+
+	/* Enable LPF corner auto tune */
+	sram_write(tp, SRAM_LPF_CFG, 0xf70f);
+
+	/* Adjust 10M Amplitude */
+	sram_write(tp, SRAM_10M_AMP1, 0x00af);
+	sram_write(tp, SRAM_10M_AMP2, 0x0208);
+
+	if (tp->eee_en)
+		rtl_eee_enable(tp, true);
+
+	r8153_aldps_en(tp, true);
+	r8152b_enable_fc(tp);
+
+	switch (tp->version) {
+	case RTL_VER_03:
+	case RTL_VER_04:
+		break;
+	case RTL_VER_05:
+	case RTL_VER_06:
+	default:
+		r8153_u2p3en(tp, true);
+		break;
+	}
+
+	set_bit(PHY_RESET, &tp->flags);
+}
+
+static u32 r8152_efuse_read(struct r8152 *tp, u8 addr)
+{
+	u32 ocp_data, d2;
+	int ret;
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_EFUSE_CMD,
+			     EFUSE_READ_CMD | addr);
+	if (ret < 0)
+		return 0xffffffff;
+	ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EFUSE_CMD, &ocp_data);
+	if (ret < 0)
+		return 0xffffffff;
+	ocp_data = (ocp_data & EFUSE_DATA_BIT16) << 9;	/* data of bit16 */
+	ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EFUSE_DATA, &d2);
+	if (ret < 0)
+		return 0xffffffff;
+	ocp_data |= d2;
+
+	return ocp_data;
+}
+
+static void r8153b_hw_phy_cfg(struct r8152 *tp)
+{
+	u32 ocp_data;
+	u16 data;
+	int ret;
+
+	ocp_word_test_and_clr_bits(tp, MCU_TYPE_USB, USB_MISC_0, PCUT_STATUS);
+
+	/* disable ALDPS before updating the PHY parameters */
+	r8153_aldps_en(tp, false);
+
+	/* disable EEE before updating the PHY parameters */
+	rtl_eee_enable(tp, false);
+
+	/* U1/U2/L1 idle timer. 500 us */
+	ocp_write_word(tp, MCU_TYPE_USB, USB_U1U2_TIMER, 500);
+
+	ret = r8153_phy_status(tp, 0);
+	if (ret < 0)
+		return;
+
+	switch (ret) {
+	case PHY_STAT_PWRDN:
+	case PHY_STAT_EXT_INIT:
+		r8153b_firmware(tp);
+		r8152_mdio_clr_bit(tp, MII_BMCR, BMCR_PDOWN);
+		break;
+	case PHY_STAT_LAN_ON:
+	default:
+		r8153b_firmware(tp);
+		break;
+	}
+
+	r8153b_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));
+
+	sram_set_bits(tp, SRAM_GREEN_CFG, R_TUNE_EN);
+	ocp_reg_set_bits(tp, OCP_NCTL_CFG, PGA_RETURN_EN);
+
+	/* ADC Bias Calibration:
+	 * read efuse offset 0x7d to get a 17-bit data. Remove the dummy/fake
+	 * bit (bit3) to rebuild the real 16-bit data. Write the data to the
+	 * ADC ioffset.
+	 */
+	ocp_data = r8152_efuse_read(tp, 0x7d);
+	data = (u16)(((ocp_data & 0x1fff0) >> 1) | (ocp_data & 0x7));
+	if (data != 0xffff)
+		ocp_reg_write(tp, OCP_ADC_IOFFSET, data);
+
+	/* ups mode tx-link-pulse timing adjustment:
+	 * rg_saw_cnt = OCP reg 0xC426 Bit[13:0]
+	 * swr_cnt_1ms_ini = 16000000 / rg_saw_cnt
+	 */
+	ret = ocp_reg_read(tp, 0xc426, &data);
+	if (ret < 0)
+		return;
+
+	ocp_data = data & 0x3fff;
+	if (ocp_data) {
+		u32 swr_cnt_1ms_ini;
+
+		swr_cnt_1ms_ini = (16000000 / ocp_data) & SAW_CNT_1MS_MASK;
+		ret = ocp_word_w0w1(tp, MCU_TYPE_USB, USB_UPS_CFG, SAW_CNT_1MS_MASK,
+				    swr_cnt_1ms_ini);
+		if (ret < 0)
+			return;
+	}
+
+	ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_PHY_PWR, PFM_PWM_SWITCH);
+
+#ifdef CONFIG_CTAP_SHORT_OFF
+	ocp_reg_clr_bits(tp, OCP_EEE_CFG, CTAP_SHORT_EN);
+
+	tp->ups_info.ctap_short_off = true;
+#endif
+	/* Advnace EEE */
+	if (!rtl_phy_patch_request(tp, true, true)) {
+		ocp_reg_set_bits(tp, OCP_POWER_CFG, EEE_CLKDIV_EN);
+		tp->ups_info.eee_ckdiv = true;
+
+		ocp_reg_set_bits(tp, OCP_DOWN_SPEED,
+				 EN_EEE_CMODE | EN_EEE_1000 | EN_10M_CLKDIV);
+		tp->ups_info.eee_cmod_lv = true;
+		tp->ups_info._10m_ckdiv = true;
+		tp->ups_info.eee_plloff_giga = true;
+
+		ocp_reg_write(tp, OCP_SYSCLK_CFG, 0);
+		ocp_reg_write(tp, OCP_SYSCLK_CFG, clk_div_expo(5));
+		tp->ups_info._250m_ckdiv = true;
+
+		rtl_phy_patch_request(tp, false, true);
+	}
+
+	if (tp->eee_en)
+		rtl_eee_enable(tp, true);
+
+	r8153_aldps_en(tp, true);
+	r8152b_enable_fc(tp);
+//	r8153_u2p3en(tp, true);
+
+	set_bit(PHY_RESET, &tp->flags);
+	rtl_set_dbg_info_state(tp, DGB_DRV_STATE_LOAD);
+}
+
+static void r8153c_hw_phy_cfg(struct r8152 *tp)
+{
+	r8153b_hw_phy_cfg(tp);
+
+	tp->ups_info.r_tune = true;
+}
+
+static int rtl8153_change_mtu(struct r8152 *tp)
+{
+	int ret;
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS,
+			     mtu_to_size(tp->netdev->mtu));
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_JUMBO);
+
+out:
+	return ret;
+}
+
+static int r8153_lanwake_clr_en(struct r8152 *tp, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		/* Enable the feature that the MCU could clear the lanwake */
+		ret = ocp_byte_set_bits(tp, MCU_TYPE_PLA, PLA_CONFIG6,
+					LANWAKE_CLR_EN);
+		if (ret < 0)
+			goto out;
+
+		/* Clear lanwake */
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_LWAKE_CTRL_REG,
+					LANWAKE_PIN);
+	} else {
+		/* Disable the feature that the MCU could clear the lanwake */
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_CONFIG6,
+					LANWAKE_CLR_EN);
+	}
+
+out:
+	return ret;
+}
+
+static int r8153_first_init(struct r8152 *tp)
+{
+	int ret;
+
+	ret = rxdy_gated_en(tp, true);
+	if (ret < 0)
+		goto out;
+	ret = r8153_teredo_off(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_dword_clr_bits(tp, MCU_TYPE_PLA, PLA_RCR, RCR_ACPT_ALL);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl8152_nic_reset(tp);
+	if (ret < 0)
+		goto out;
+	ret = rtl_reset_bmu(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, NOW_IS_OOB);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, MCU_BORW_EN);
+	if (ret < 0)
+		goto out;
+
+	wait_oob_link_list_ready(tp);
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, RE_INIT_LL);
+	if (ret < 0)
+		goto out;
+
+	wait_oob_link_list_ready(tp);
+
+	ret = rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl8153_change_mtu(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_TCR0, TCR0_AUTO_FIFO);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl8152_nic_reset(tp);
+	if (ret < 0)
+		goto out;
+
+	/* rx share fifo credit full threshold */
+	ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_NORMAL);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_NORMAL);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_NORMAL);
+	if (ret < 0)
+		goto out;
+	/* TX share fifo free credit full threshold */
+	ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, TXFIFO_THR_NORMAL2);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_lanwake_clr_en(tp, true);
+
+out:
+	return ret;
+}
+
+static int r8153_enter_oob(struct r8152 *tp)
+{
+	int ret, err = 0;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, NOW_IS_OOB);
+	if (ret < 0)
+		err = ret;
+
+	/* RX FIFO settings for OOB */
+	ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_OOB);
+	if (ret < 0)
+		err = ret;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_OOB);
+	if (ret < 0)
+		err = ret;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_OOB);
+	if (ret < 0)
+		err = ret;
+
+	ret = rtl_disable(tp);
+	if (ret < 0)
+		err = ret;
+	ret = rtl_reset_bmu(tp);
+	if (ret < 0)
+		err = ret;
+
+	wait_oob_link_list_ready(tp);
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, RE_INIT_LL);
+	if (ret < 0)
+		err = ret;
+
+	wait_oob_link_list_ready(tp);
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, 1522);
+	if (ret < 0)
+		err = ret;
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_DEFAULT);
+	if (ret < 0)
+		err = ret;
+
+	switch (tp->version) {
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG,
+					TEREDO_WAKE_MASK);
+		if (ret < 0)
+			err = ret;
+		break;
+
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_VER_14:
+		/* Clear teredo wake event. bit[15:8] is the teredo wakeup
+		 * type. Set it to zero. bits[7:0] are the W1C bits about
+		 * the events. Set them to all 1 to clear them.
+		 */
+		ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_WAKE_BASE,
+				     0x00ff);
+		if (ret < 0)
+			err = ret;
+		break;
+
+	default:
+		break;
+	}
+
+	ret = rtl_rx_vlan_en(tp, true);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_BDC_CR, ALDPS_PROXY_MODE);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_PLA, PLA_OOB_CTRL,
+				NOW_IS_OOB | DIS_MCU_CLROOB);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, MCU_BORW_EN);
+	if (ret < 0)
+		err = ret;
+
+	ret = rxdy_gated_en(tp, false);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_dword_set_bits(tp, MCU_TYPE_PLA, PLA_RCR,
+				 RCR_APM | RCR_AM | RCR_AB);
+	if (ret < 0)
+		err = ret;
+
+	ret = r8153_lanwake_clr_en(tp, false);
+
+	if (err < 0)
+		return err;
+	else
+		return ret;
+}
+
+static int rtl8153_disable(struct r8152 *tp)
+{
+	int ret, err = 0;
+
+	ret = r8153_aldps_en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = rtl_disable(tp);
+	if (ret < 0)
+		err = ret;
+	ret = rtl_reset_bmu(tp);
+	if (ret < 0)
+		err = ret;
+	ret = r8153_aldps_en(tp, true);
+
+	if (err < 0)
+		return err;
+	else
+		return ret;
+}
+
+static u32 fc_pause_on_auto(struct r8152 *tp)
+{
+	return (ALIGN(mtu_to_size(tp->netdev->mtu), 1024) + 6 * 1024);
+}
+
+static u32 fc_pause_off_auto(struct r8152 *tp)
+{
+	return (ALIGN(mtu_to_size(tp->netdev->mtu), 1024) + 14 * 1024);
+}
+
+static int r8156_fc_parameter(struct r8152 *tp)
+{
+	int ret;
+
+	u32 pause_on = tp->fc_pause_on ? tp->fc_pause_on : fc_pause_on_auto(tp);
+	u32 pause_off = tp->fc_pause_off ? tp->fc_pause_off : fc_pause_off_auto(tp);
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, pause_on / 16);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY,
+			     pause_off / 16);
+
+out:
+	return ret;
+}
+
+static int rtl8156_enable(struct r8152 *tp)
+{
+	u16 speed;
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = r8156_fc_parameter(tp);
+	if (ret < 0)
+		goto out;
+	set_tx_qlen(tp);
+	ret = rtl_set_eee_plus(tp);
+	if (ret < 0)
+		goto out;
+	ret = r8153_set_rx_early_timeout(tp);
+	if (ret < 0)
+		goto out;
+	ret = r8153_set_rx_early_size(tp);
+	if (ret < 0)
+		goto out;
+
+	switch (tp->version) {
+	case RTL_TEST_01:
+		ret = ocp_byte_w0w1(tp, MCU_TYPE_PLA, 0xe95a, 0xf, 5);
+		if (ret < 0)
+			goto out;
+		ret = ocp_byte_w0w1(tp, MCU_TYPE_PLA, 0xe940, 0x1f, 4);
+		if (ret < 0)
+			goto out;
+		break;
+	default:
+		break;
+	}
+
+	speed = rtl8152_get_speed(tp);
+	ret = rtl_set_ifg(tp, speed);
+	if (ret < 0)
+		goto out;
+
+	if (speed & _2500bps)
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4,
+					IDLE_SPDWN_EN);
+	else
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4,
+					IDLE_SPDWN_EN);
+	if (ret < 0)
+		goto out;
+
+	if (speed & _1000bps)
+		ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_TXTWSYS, 0x11);
+	else if (speed & _500bps)
+		ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_TXTWSYS, 0x3d);
+	if (ret < 0)
+		goto out;
+
+	if (tp->udev->speed == USB_SPEED_HIGH) {
+		/* USB 0xb45e[3:0] l1_nyet_hird */
+		if (is_flow_control(speed))
+			ret = ocp_word_w0w1(tp, MCU_TYPE_USB, USB_L1_CTRL,
+					    0xf, 0xf);
+		else
+			ret = ocp_word_w0w1(tp, MCU_TYPE_USB, USB_L1_CTRL,
+					    0xf, 0x1);
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_FW_TASK, FC_PATCH_TASK);
+	if (ret < 0)
+		goto out;
+	usleep_range(1000, 2000);
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_TASK, FC_PATCH_TASK);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_enable(tp);
+
+out:
+	return ret;
+}
+
+static int rtl8156_disable(struct r8152 *tp)
+{
+	int ret, err = 0;
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, 0);
+	if (ret < 0)
+		err = ret;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, 0);
+	if (ret < 0)
+		err = ret;
+
+	ret = rtl8153_disable(tp);
+
+	if (err < 0)
+		return err;
+	else
+		return ret;
+}
+
+static int rtl8156b_enable(struct r8152 *tp)
+{
+	u16 speed;
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	set_tx_qlen(tp);
+	ret = rtl_set_eee_plus(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_RX_AGGR_NUM,
+				RX_AGGR_NUM_MASK);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_set_rx_early_timeout(tp);
+	if (ret < 0)
+		goto out;
+	ret = r8153_set_rx_early_size(tp);
+	if (ret < 0)
+		goto out;
+
+	speed = rtl8152_get_speed(tp);
+	ret = rtl_set_ifg(tp, speed);
+	if (ret < 0)
+		goto out;
+
+	if (speed & _2500bps)
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4,
+					IDLE_SPDWN_EN);
+	else
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4,
+					IDLE_SPDWN_EN);
+	if (ret < 0)
+		goto out;
+
+	if (tp->udev->speed == USB_SPEED_HIGH) {
+		if (is_flow_control(speed))
+			ret = ocp_word_w0w1(tp, MCU_TYPE_USB, USB_L1_CTRL,
+					    0xf, 0xf);
+		else
+			ret = ocp_word_w0w1(tp, MCU_TYPE_USB, USB_L1_CTRL,
+					    0xf, 0x1);
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_FW_TASK, FC_PATCH_TASK);
+	if (ret < 0)
+		goto out;
+	usleep_range(1000, 2000);
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_TASK, FC_PATCH_TASK);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_enable(tp);
+
+out:
+	return ret;
+}
+
+static int rtl8157_enable(struct r8152 *tp)
+{
+	u16 speed;
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	set_tx_qlen(tp);
+	ret = rtl_set_eee_plus(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_RX_AGGR_NUM,
+				RX_AGGR_NUM_MASK);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_set_rx_early_timeout(tp);
+	if (ret < 0)
+		goto out;
+	ret = r8153_set_rx_early_size(tp);
+	if (ret < 0)
+		goto out;
+
+	speed = rtl8152_get_speed(tp);
+	ret = rtl_set_ifg(tp, speed);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_enable(tp);
+
+out:
+	return ret;
+}
+
+static int rtl8152_set_speed(struct r8152 *tp, u8 autoneg, u32 speed, u8 duplex,
+			     u32 advertising)
+{
+	u16 bmcr;
+	int ret = 0;
+
+	if (autoneg == AUTONEG_DISABLE) {
+		if (duplex != DUPLEX_HALF && duplex != DUPLEX_FULL)
+			return -EINVAL;
+
+		switch (speed) {
+		case SPEED_10:
+			bmcr = BMCR_SPEED10;
+			if (duplex == DUPLEX_FULL) {
+				bmcr |= BMCR_FULLDPLX;
+				tp->ups_info.speed_duplex = FORCE_10M_FULL;
+			} else {
+				tp->ups_info.speed_duplex = FORCE_10M_HALF;
+			}
+			break;
+		case SPEED_100:
+			bmcr = BMCR_SPEED100;
+			if (duplex == DUPLEX_FULL) {
+				bmcr |= BMCR_FULLDPLX;
+				tp->ups_info.speed_duplex = FORCE_100M_FULL;
+			} else {
+				tp->ups_info.speed_duplex = FORCE_100M_HALF;
+			}
+			break;
+		case SPEED_1000:
+			if (tp->mii.supports_gmii) {
+				bmcr = BMCR_SPEED1000 | BMCR_FULLDPLX;
+				tp->ups_info.speed_duplex = NWAY_1000M_FULL;
+				break;
+			}
+			fallthrough;
+		default:
+			ret = -EINVAL;
+			goto out;
+		}
+
+		if (duplex == DUPLEX_FULL)
+			tp->mii.full_duplex = 1;
+		else
+			tp->mii.full_duplex = 0;
+
+		tp->mii.force_media = 1;
+	} else {
+		u16 orig, new1;
+		u32 support;
+
+		support = RTL_ADVERTISED_10_HALF | RTL_ADVERTISED_10_FULL |
+			  RTL_ADVERTISED_100_HALF | RTL_ADVERTISED_100_FULL;
+
+		if (tp->mii.supports_gmii)
+			support |= RTL_ADVERTISED_1000_FULL;
+
+		if (tp->support_2500full)
+			support |= RTL_ADVERTISED_2500_FULL;
+
+		if (tp->support_5000full)
+			support |= RTL_ADVERTISED_5000_FULL;
+
+		if (tp->support_10gfull)
+			support |= RTL_ADVERTISED_10GT_FULL;
+
+		if (!(advertising & support))
+			return -EINVAL;
+
+		ret = r8152_mdio_read(tp, MII_ADVERTISE);
+		if (ret < 0)
+			goto out;
+
+		orig = ret;
+		new1 = orig & ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
+				ADVERTISE_100HALF | ADVERTISE_100FULL);
+		if (advertising & RTL_ADVERTISED_10_HALF) {
+			new1 |= ADVERTISE_10HALF;
+			tp->ups_info.speed_duplex = NWAY_10M_HALF;
+		}
+		if (advertising & RTL_ADVERTISED_10_FULL) {
+			new1 |= ADVERTISE_10FULL;
+			tp->ups_info.speed_duplex = NWAY_10M_FULL;
+		}
+
+		if (advertising & RTL_ADVERTISED_100_HALF) {
+			new1 |= ADVERTISE_100HALF;
+			tp->ups_info.speed_duplex = NWAY_100M_HALF;
+		}
+		if (advertising & RTL_ADVERTISED_100_FULL) {
+			new1 |= ADVERTISE_100FULL;
+			tp->ups_info.speed_duplex = NWAY_100M_FULL;
+		}
+
+		if (orig != new1) {
+			ret = r8152_mdio_write(tp, MII_ADVERTISE, new1);
+			if (ret < 0)
+				goto out;
+			tp->mii.advertising = new1;
+		}
+
+		if (tp->mii.supports_gmii) {
+			ret = r8152_mdio_read(tp, MII_CTRL1000);
+			if (ret < 0)
+				goto out;
+
+			orig = ret;
+			new1 = orig & ~(ADVERTISE_1000FULL |
+					ADVERTISE_1000HALF);
+
+			if (advertising & RTL_ADVERTISED_1000_FULL) {
+				new1 |= ADVERTISE_1000FULL;
+				tp->ups_info.speed_duplex = NWAY_1000M_FULL;
+			}
+
+			if (orig != new1) {
+				ret = r8152_mdio_write(tp, MII_CTRL1000, new1);
+				if (ret < 0)
+					goto out;
+			}
+		}
+
+		if (tp->support_2500full || tp->support_5000full ||
+		    tp->support_10gfull) {
+			ret = ocp_reg_read(tp, OCP_10GBT_CTRL, &orig);
+			if (ret < 0)
+				goto out;
+
+			new1 = orig;
+			new1 &= ~(MDIO_AN_10GBT_CTRL_ADV2_5G |
+				  MDIO_AN_10GBT_CTRL_ADV5G |
+				  MDIO_AN_10GBT_CTRL_ADV10G);
+
+			if (advertising & RTL_ADVERTISED_2500_FULL) {
+				new1 |= MDIO_AN_10GBT_CTRL_ADV2_5G;
+				tp->ups_info.speed_duplex = NWAY_2500M_FULL;
+			}
+
+			if (advertising & RTL_ADVERTISED_5000_FULL) {
+				new1 |= MDIO_AN_10GBT_CTRL_ADV5G;
+				tp->ups_info.speed_duplex = NWAY_5000M_FULL;
+			}
+
+			if (advertising & RTL_ADVERTISED_10GT_FULL) {
+				new1 |= MDIO_AN_10GBT_CTRL_ADV10G;
+				tp->ups_info.speed_duplex = NWAY_10G_FULL;
+			}
+
+			if (orig != new1) {
+				ret = ocp_reg_write(tp, OCP_10GBT_CTRL, new1);
+				if (ret < 0)
+					goto out;
+			}
+		}
+
+		bmcr = BMCR_ANENABLE | BMCR_ANRESTART;
+
+		tp->mii.force_media = 0;
+	}
+
+	if (test_and_clear_bit(PHY_RESET, &tp->flags))
+		bmcr |= BMCR_RESET;
+
+	ret = r8152_mdio_write(tp, MII_BMCR, bmcr);
+	if (ret < 0)
+		goto out;
+
+	if (bmcr & BMCR_RESET) {
+		int i;
+
+		for (i = 0; i < 50; i++) {
+			msleep(20);
+			ret = r8152_mdio_read(tp, MII_BMCR);
+			if (ret < 0)
+				goto out;
+			if ((ret & BMCR_RESET) == 0)
+				break;
+		}
+	}
+
+	if (test_and_clear_bit(DISABLE_EEE_BOTTOM, &tp->flags)) {
+		ret = rtl_disable_eee_bottom(tp);
+		if (ret < 0)
+			goto out;
+	}
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static bool rtl_speed_down(struct r8152 *tp)
+{
+	bool ret = false;
+	int r;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return ret;
+
+	if (!(tp->saved_wolopts & WAKE_ANY)) {
+		switch (tp->version) {
+		case RTL_VER_01:
+		case RTL_VER_02:
+			set_bit(RECOVER_SPEED, &tp->flags);
+			ret = true;
+			r = r8152_mdio_set_bit(tp, MII_BMCR, BMCR_PDOWN);
+			if (r < 0)
+				goto out1;
+			goto out1;
+		default:
+			break;
+		}
+	}
+
+	if (!(tp->saved_wolopts & WAKE_PHY)) {
+		u16 bmcr;
+
+		r = r8152_mdio_read(tp, MII_BMCR);
+		if (r < 0)
+			goto out1;
+
+		bmcr = r;
+		r = r8152_mdio_read(tp, MII_EXPANSION);
+		if (r < 0)
+			goto out1;
+
+		if (netif_carrier_ok(tp->netdev) && (bmcr & BMCR_ANENABLE) &&
+		    (r & EXPANSION_NWAY)) {
+			u16 anar, gbcr = 0, lpa, gbcr2 = 0, lpa2, lpa3;
+
+			r = r8152_mdio_read(tp, MII_ADVERTISE);
+			if (r < 0)
+				goto out1;
+
+			anar = r;
+			anar &= ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
+				  ADVERTISE_100HALF | ADVERTISE_100FULL);
+
+			if (tp->mii.supports_gmii) {
+				r = r8152_mdio_read(tp, MII_CTRL1000);
+				if (r < 0)
+					goto out1;
+
+				gbcr = r;
+				gbcr &= ~(ADVERTISE_1000FULL |
+					  ADVERTISE_1000HALF);
+			}
+
+			if (tp->support_2500full || tp->support_5000full ||
+			    tp->support_10gfull) {
+				r = ocp_reg_read(tp, OCP_10GBT_CTRL, &gbcr2);
+				if (r < 0)
+					goto out1;
+				gbcr2 &= ~(MDIO_AN_10GBT_CTRL_ADV2_5G |
+					   MDIO_AN_10GBT_CTRL_ADV5G |
+					   MDIO_AN_10GBT_CTRL_ADV10G);
+			}
+
+			r = r8152_mdio_read(tp, MII_LPA);
+			if (r < 0)
+				goto out1;
+			lpa = r;
+			r = r8152_mdio_read(tp, MII_STAT1000);
+			if (r < 0)
+				goto out1;
+			lpa2 = r;
+			r = r8152_mdio_read(tp, OCP_10GBT_STAT);
+			if (r < 0)
+				goto out1;
+			lpa3 = r;
+			if (lpa & (LPA_10HALF | LPA_10FULL)) {
+				anar |= ADVERTISE_10HALF | ADVERTISE_10FULL;
+				rtl_eee_plus_en(tp, true);
+			} else if (lpa & (LPA_100HALF | LPA_100FULL)) {
+				anar |= ADVERTISE_10HALF | ADVERTISE_10FULL |
+					ADVERTISE_100HALF | ADVERTISE_100FULL;
+			} else if (lpa2 & (LPA_1000HALF | LPA_1000FULL)) {
+				gbcr |= ADVERTISE_1000FULL | ADVERTISE_1000HALF;
+			} else if (lpa3 & MDIO_AN_10GBT_STAT_LP2_5G)  {
+				gbcr2 |= MDIO_AN_10GBT_CTRL_ADV2_5G;
+			} else if (lpa3 & MDIO_AN_10GBT_STAT_LP5G)  {
+				gbcr2 |= MDIO_AN_10GBT_CTRL_ADV5G;
+			} else {
+				goto out1;
+			}
+
+			set_bit(RECOVER_SPEED, &tp->flags);
+			ret = true;
+
+			if (tp->mii.supports_gmii) {
+				r = r8152_mdio_write(tp, MII_CTRL1000, gbcr);
+				if (r < 0)
+					goto out1;
+			}
+
+			if (tp->support_2500full || tp->support_5000full ||
+			    tp->support_10gfull) {
+				r = ocp_reg_write(tp, OCP_10GBT_CTRL, gbcr2);
+				if (r < 0)
+					goto out1;
+			}
+
+			r = r8152_mdio_write(tp, MII_ADVERTISE, anar);
+			if (r < 0)
+				goto out1;
+			r = r8152_mdio_write(tp, MII_BMCR, bmcr | BMCR_ANRESTART);
+			if (r < 0)
+				goto out1;
+		}
+	}
+
+out1:
+	return ret;
+}
+
+static int rtl8152_up(struct r8152 *tp)
+{
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = r8152_aldps_en(tp, false);
+	if (ret < 0)
+		goto out;
+	ret = r8152b_exit_oob(tp);
+	if (ret < 0)
+		goto out;
+	ret = r8152_aldps_en(tp, true);
+
+out:
+	return ret;
+}
+
+static int rtl8152_down(struct r8152 *tp)
+{
+	int ret, err = 0;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		rtl_stop_rx(tp);
+		return -ENODEV;
+	}
+
+	ret = r8152_power_cut_en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8152_aldps_en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8152b_enter_oob(tp);
+	if (ret < 0)
+		err = ret;
+	ret = r8152_aldps_en(tp, true);
+
+
+	if (err < 0)
+		return err;
+	else
+		return ret;
+}
+
+static int rtl8153_up(struct r8152 *tp)
+{
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = r8153_u1u2en(tp, false);
+	if (ret < 0)
+		goto out;
+	ret = r8153_u2p3en(tp, false);
+	if (ret < 0)
+		goto out;
+	ret = r8153_aldps_en(tp, false);
+	if (ret < 0)
+		goto out;
+	ret = r8153_first_init(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_SSPHYLINK1,
+				DELAY_PHY_PWR_CHG);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_aldps_en(tp, true);
+	if (ret < 0)
+		goto out;
+
+	switch (tp->version) {
+	case RTL_VER_03:
+	case RTL_VER_04:
+		break;
+	case RTL_VER_05:
+	case RTL_VER_06:
+	default:
+		ret = r8153_u2p3en(tp, true);
+		if (ret < 0)
+			goto out;
+		break;
+	}
+
+	ret = r8153_u1u2en(tp, true);
+
+out:
+	return ret;
+}
+
+static int rtl8153_down(struct r8152 *tp)
+{
+	int ret, err = 0;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		rtl_stop_rx(tp);
+		return -ENODEV;
+	}
+
+	ret = r8153_u1u2en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8153_u2p3en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8153_power_cut_en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8153_aldps_en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8153_enter_oob(tp);
+	if (ret < 0)
+		err = ret;
+	ret = r8153_aldps_en(tp, true);
+
+	if (err < 0)
+		return err;
+	else
+		return ret;
+}
+
+static int rtl8153b_up(struct r8152 *tp)
+{
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		goto out;
+	ret = r8153_u2p3en(tp, false);
+	if (ret < 0)
+		goto out;
+	ret = r8153_aldps_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_first_init(tp);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_B);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_mcu_spdown_en(tp, false);
+	if (ret < 0)
+		goto out;
+	ret = r8153_aldps_en(tp, true);
+	if (ret < 0)
+		goto out;
+//	ret = r8153_u2p3en(tp, true);
+//	if (ret < 0)
+//		goto out;
+	if (tp->udev->speed >= USB_SPEED_SUPER)
+		ret = r8153b_u1u2en(tp, true);
+
+out:
+	return ret;
+}
+
+static int rtl8153b_down(struct r8152 *tp)
+{
+	int ret, err = 0;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		rtl_stop_rx(tp);
+		return -ENODEV;
+	}
+
+	ret = r8153b_mcu_spdown_en(tp, true);
+	if (ret < 0)
+		err = ret;
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8153_u2p3en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8153b_power_cut_en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8153_aldps_en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8153_enter_oob(tp);
+	if (ret < 0)
+		err = ret;
+	ret = r8153_aldps_en(tp, true);
+
+	if (err < 0)
+		return err;
+	else
+		return ret;
+}
+
+static int rtl8153c_change_mtu(struct r8152 *tp)
+{
+	int ret;
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS,
+			     mtu_to_size(tp->netdev->mtu));
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, 0xe048,
+			     mtu_to_size(tp->netdev->mtu));
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, 10 * 1024 / 64);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, 512 / 64);
+	if (ret < 0)
+		goto out;
+
+	/* Adjust the tx fifo free credit full threshold, otherwise
+	 * the fifo would be too small to send a jumbo frame packet.
+	 */
+	if (tp->netdev->mtu < 8000)
+		ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL,
+				     2048 / 8);
+	else
+		ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL,
+				     900 / 8);
+
+out:
+	return ret;
+}
+
+static int rtl8153c_up(struct r8152 *tp)
+{
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		goto out;
+	ret = r8153_u2p3en(tp, false);
+	if (ret < 0)
+		goto out;
+	ret = r8153_aldps_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rxdy_gated_en(tp, true);
+	if (ret < 0)
+		goto out;
+	ret = r8153_teredo_off(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_dword_clr_bits(tp, MCU_TYPE_PLA, PLA_RCR, RCR_ACPT_ALL);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl8152_nic_reset(tp);
+	if (ret < 0)
+		goto out;
+	ret = rtl_reset_bmu(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, NOW_IS_OOB);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, MCU_BORW_EN);
+	if (ret < 0)
+		goto out;
+
+	wait_oob_link_list_ready(tp);
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, RE_INIT_LL);
+	if (ret < 0)
+		goto out;
+
+	wait_oob_link_list_ready(tp);
+
+	ret = rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl8153c_change_mtu(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl8152_nic_reset(tp);
+	if (ret < 0)
+		goto out;
+
+	/* rx share fifo credit full threshold */
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, 0x02);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, 0x08);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_NORMAL);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_NORMAL);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_B);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_CONFIG34, BIT(8));
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_mcu_spdown_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_aldps_en(tp, true);
+	if (ret < 0)
+		goto out;
+//	ret = r8153_u2p3en(tp, true);
+//	if (ret < 0)
+//		goto out;
+	ret = r8153b_u1u2en(tp, true);
+
+out:
+	return ret;
+}
+
+static int rtl8156_change_mtu(struct r8152 *tp)
+{
+	u32 max_pkt_size = mtu_to_size(tp->netdev->mtu);
+	int ret;
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, max_pkt_size);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_JUMBO);
+	if (ret < 0)
+		goto out;
+	ret = r8156_fc_parameter(tp);
+	if (ret < 0)
+		goto out;
+
+	/* TX share fifo free credit full threshold */
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, 512 / 64);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL,
+			     ALIGN(max_pkt_size + tp->tx_desc.size, 1024) / 16);
+
+out:
+	return ret;
+}
+
+static int rtl8156_up(struct r8152 *tp)
+{
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		goto out;
+	ret = r8153_u2p3en(tp, false);
+	if (ret < 0)
+		goto out;
+	ret = r8153_aldps_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rxdy_gated_en(tp, true);
+	if (ret < 0)
+		goto out;
+	ret = r8153_teredo_off(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_dword_clr_bits(tp, MCU_TYPE_PLA, PLA_RCR, RCR_ACPT_ALL);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl8152_nic_reset(tp);
+	if (ret < 0)
+		goto out;
+	ret = rtl_reset_bmu(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, NOW_IS_OOB);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, MCU_BORW_EN);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_rx_vlan_en(tp,
+			     tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl8156_change_mtu(tp);
+	if (ret < 0)
+		goto out;
+
+	switch (tp->version) {
+	case RTL_TEST_01:
+	case RTL_VER_10:
+	case RTL_VER_11:
+		ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_BMU_CONFIG,
+					ACT_ODMA);
+		if (ret < 0)
+			goto out;
+		break;
+	default:
+		break;
+	}
+
+	/* share FIFO settings */
+	ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, RXFIFO_FULL_MASK,
+			    0x08);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_mcu_spdown_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_SPEED_OPTION,
+				RG_PWRDN_EN | ALL_SPEED_OFF);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, 0x00600400);
+	if (ret < 0)
+		goto out;
+
+	if (tp->saved_wolopts != __rtl_get_wol(tp)) {
+		netif_warn(tp, ifup, tp->netdev, "wol setting is changed\n");
+		ret = __rtl_set_wol(tp, tp->saved_wolopts);
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = r8153_aldps_en(tp, true);
+	if (ret < 0)
+		goto out;
+	ret = r8153_u2p3en(tp, true);
+	if (ret < 0)
+		goto out;
+
+	/* Enable Clear_SDR */
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, 0xd3ca, BIT(15));
+	if (ret < 0)
+		goto out;
+
+	if (tp->udev->speed >= USB_SPEED_SUPER)
+		ret = r8153b_u1u2en(tp, true);
+
+out:
+	return ret;
+}
+
+static int rtl8156_down(struct r8152 *tp)
+{
+	int ret, err = 0;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		rtl_stop_rx(tp);
+		return -ENODEV;
+	}
+
+	ret = r8153b_mcu_spdown_en(tp, true);
+	if (ret < 0)
+		err = ret;
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8153_u2p3en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8153b_power_cut_en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8153_aldps_en(tp, false);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, NOW_IS_OOB);
+	if (ret < 0)
+		err = ret;
+
+	/* RX FIFO settings for OOB */
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, 64 / 16);
+	if (ret < 0)
+		err = ret;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, 1024 / 16);
+	if (ret < 0)
+		err = ret;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, 4096 / 16);
+	if (ret < 0)
+		err = ret;
+
+	ret = rtl_disable(tp);
+	if (ret < 0)
+		err = ret;
+	ret = rtl_reset_bmu(tp);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, 1522);
+	if (ret < 0)
+		err = ret;
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_DEFAULT);
+	if (ret < 0)
+		err = ret;
+
+	/* Clear teredo wake event. bit[15:8] is the teredo wakeup
+	 * type. Set it to zero. bits[7:0] are the W1C bits about
+	 * the events. Set them to all 1 to clear them.
+	 */
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_WAKE_BASE, 0x00ff);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_BDC_CR, ALDPS_PROXY_MODE);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_PLA, PLA_OOB_CTRL,
+				NOW_IS_OOB | DIS_MCU_CLROOB);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, MCU_BORW_EN);
+	if (ret < 0)
+		err = ret;
+
+	ret = rtl_rx_vlan_en(tp, true);
+	if (ret < 0)
+		err = ret;
+	ret = rxdy_gated_en(tp, false);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_dword_set_bits(tp, MCU_TYPE_PLA, PLA_RCR,
+				 RCR_APM | RCR_AM | RCR_AB);
+	if (ret < 0)
+		err = ret;
+
+	ret = r8153_aldps_en(tp, true);
+
+	if (err < 0)
+		return err;
+	else
+		return ret;
+}
+
+static int rtl8157_change_mtu(struct r8152 *tp)
+{
+	u32 max_pkt_size = mtu_to_size(tp->netdev->mtu);
+	u32 ocp_data;
+	int ret;
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, max_pkt_size);
+	if (ret < 0)
+		goto out;
+
+	/* Use at least 10K for MTPS */
+	ocp_data = max_t(u32, max_pkt_size, 10 * 1024) / 64;
+
+	/* 16 * 1024 / 64 = 0x100, so the max is 0xff for 8 bits data */
+	ocp_data = min_t(u32, ocp_data, 0xff);
+
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, ocp_data);
+	if (ret < 0)
+		goto out;
+
+	ret = r8156_fc_parameter(tp);
+	if (ret < 0)
+		goto out;
+
+	/* TX share fifo free credit full threshold */
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, 512 / 64);
+	if (ret < 0)
+		goto out;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL,
+			     ALIGN(max_pkt_size + tp->tx_desc.size, 1024) / 16);
+
+out:
+	return ret;
+}
+
+static int rtl8157_up(struct r8152 *tp)
+{
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		goto out;
+	ret = r8153_aldps_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rxdy_gated_en(tp, true);
+	if (ret < 0)
+		goto out;
+	ret = r8153_teredo_off(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_dword_clr_bits(tp, MCU_TYPE_PLA, PLA_RCR, RCR_ACPT_ALL);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl8152_nic_reset(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, NOW_IS_OOB);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_RCR1, BIT(3));
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, MCU_BORW_EN);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_rx_vlan_en(tp,
+			     tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl8157_change_mtu(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_reset_bmu(tp);
+	if (ret < 0)
+		goto out;
+
+	/* share FIFO settings */
+	ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, RXFIFO_FULL_MASK,
+			    0x08);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, 0x00600400);
+	if (ret < 0)
+		goto out;
+
+	if (tp->saved_wolopts != __rtl_get_wol(tp)) {
+		netif_warn(tp, ifup, tp->netdev, "wol setting is changed\n");
+		ret = __rtl_set_wol(tp, tp->saved_wolopts);
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = r8153_aldps_en(tp, true);
+	if (ret < 0)
+		goto out;
+
+	/* Clear_SDR */
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, 0xd378, BIT(7));
+	if (ret < 0)
+		goto out;
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, 0xcd06, BIT(15));
+	if (ret < 0)
+		goto out;
+
+//	if (tp->udev->speed >= USB_SPEED_SUPER)
+//		ret = r8153b_u1u2en(tp, true);
+
+out:
+	return ret;
+}
+
+static int rtl8157_down(struct r8152 *tp)
+{
+	int ret, err = 0;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		rtl_stop_rx(tp);
+		return -ENODEV;
+	}
+
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		err = ret;
+	ret = r8153_aldps_en(tp, false);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, NOW_IS_OOB);
+	if (ret < 0)
+		err = ret;
+
+	/* RX FIFO settings for OOB */
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, 64 / 16);
+	if (ret < 0)
+		err = ret;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, 1024 / 16);
+	if (ret < 0)
+		err = ret;
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, 4096 / 16);
+	if (ret < 0)
+		err = ret;
+
+	ret = rtl_disable(tp);
+	if (ret < 0)
+		err = ret;
+	ret = rtl_reset_bmu(tp);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, 1526);
+	if (ret < 0)
+		err = ret;
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, 10 * 1024 / 64);
+	if (ret < 0)
+		err = ret;
+
+	/* Clear teredo wake event. bit[15:8] is the teredo wakeup
+	 * type. Set it to zero. bits[7:0] are the W1C bits about
+	 * the events. Set them to all 1 to clear them.
+	 */
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_WAKE_BASE, 0x00ff);
+	if (ret < 0)
+		err = ret;
+
+	ret = rtl_rx_vlan_en(tp, true);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_BDC_CR, ALDPS_PROXY_MODE);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_PLA, PLA_OOB_CTRL,
+				NOW_IS_OOB | DIS_MCU_CLROOB);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, MCU_BORW_EN);
+	if (ret < 0)
+		err = ret;
+
+	ret = rxdy_gated_en(tp, false);
+	if (ret < 0)
+		err = ret;
+
+	ret = ocp_dword_set_bits(tp, MCU_TYPE_PLA, PLA_RCR,
+				 RCR_APM | RCR_AM | RCR_AB);
+	if (ret < 0)
+		err = ret;
+
+	ret = r8153_aldps_en(tp, true);
+
+	if (err < 0)
+		return err;
+	else
+		return ret;
+}
+
+static bool rtl8152_in_nway(struct r8152 *tp)
+{
+	u32 nway_state;
+
+	if (ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, 0x2000) < 0) {
+		rtl_reset_ocp_base(tp);
+		return false;
+	}
+	tp->ocp_base = 0x2000;
+
+	/* phy state */
+	if (ocp_write_byte(tp, MCU_TYPE_PLA, 0xb014, 0x4c) < 0)
+		return false;
+	if (ocp_read_word(tp, MCU_TYPE_PLA, 0xb01a, &nway_state) < 0)
+		return false;
+
+	/* bit 15: TXDIS_STATE, bit 14: ABD_STATE */
+	if (nway_state & 0xc000)
+		return false;
+	else
+		return true;
+}
+
+static bool rtl8153_in_nway(struct r8152 *tp)
+{
+	u16 phy_state;
+
+	if (ocp_reg_read(tp, OCP_PHY_STATE, &phy_state) < 0)
+		return false;
+
+	phy_state &= 0xff;
+
+	if (phy_state == TXDIS_STATE || phy_state == ABD_STATE)
+		return false;
+	else
+		return true;
+}
+
+static int r8156_mdio_force_mode(struct r8152 *tp)
+{
+	/* Select force mode through 0xa5b4 bit 15
+	 * 0: MDIO force mode
+	 * 1: MMD force mode
+	 */
+	return ocp_reg_clr_bits(tp, 0xa5b4, BIT(15));
+}
+
+static void set_carrier(struct r8152 *tp)
+{
+	struct net_device *netdev = tp->netdev;
+	struct napi_struct *napi = &tp->napi;
+	u16 speed;
+
+	speed = rtl8152_get_speed(tp);
+
+	if (speed & LINK_STATUS) {
+		if (!netif_carrier_ok(netdev)) {
+			tp->rtl_ops.enable(tp);
+			netif_stop_queue(netdev);
+			napi_disable(napi);
+			netif_carrier_on(netdev);
+			rtl_start_rx(tp);
+			rtl8152_set_rx_mode(netdev);
+			napi_enable(napi);
+			netif_wake_queue(netdev);
+			netif_info(tp, link, netdev, "carrier on\n");
+		} else if (netif_queue_stopped(netdev) &&
+			   skb_queue_len(&tp->tx_queue) < tp->tx_qlen) {
+			netif_wake_queue(netdev);
+		}
+	} else {
+		if (netif_carrier_ok(netdev)) {
+			netif_carrier_off(netdev);
+			tasklet_disable(&tp->tx_tl);
+			napi_disable(napi);
+			tp->rtl_ops.disable(tp);
+			napi_enable(napi);
+			tasklet_enable(&tp->tx_tl);
+			netif_info(tp, link, netdev, "carrier off\n");
+		}
+	}
+}
+
+static inline void __rtl_work_func(struct r8152 *tp)
+{
+	/* If the device is unplugged or !netif_running(), the workqueue
+	 * doesn't need to wake the device, and could return directly.
+	 */
+	if (test_bit(RTL8152_UNPLUG, &tp->flags) || !netif_running(tp->netdev))
+		return;
+
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
+
+	if (!test_bit(WORK_ENABLE, &tp->flags))
+		goto out1;
+
+	if (!mutex_trylock(&tp->control)) {
+		if (tp->rtk_enable_diag)
+			goto link_chg_only;
+
+		schedule_delayed_work(&tp->schedule, 0);
+		goto out1;
+	}
+
+	if (test_and_clear_bit(RTL8152_LINK_CHG, &tp->flags))
+		set_carrier(tp);
+
+	if (test_bit(RTL8152_SET_RX_MODE, &tp->flags))
+		rtl8152_set_rx_mode(tp->netdev);
+
+	/* don't schedule tasket before linking */
+	if (test_and_clear_bit(SCHEDULE_TASKLET, &tp->flags) &&
+	    netif_carrier_ok(tp->netdev))
+		tasklet_schedule(&tp->tx_tl);
+
+	if (test_and_clear_bit(RX_EPROTO, &tp->flags) &&
+	    !list_empty(&tp->rx_done))
+		napi_schedule(&tp->napi);
+
+	mutex_unlock(&tp->control);
+
+out1:
+	usb_autopm_put_interface(tp->intf);
+
+link_chg_only:
+	if (test_and_clear_bit(RTL8152_LINK_CHG, &tp->flags)) {
+		int lock;
+
+		rtnl_lock();
+		lock = mutex_trylock(&tp->control);
+		set_carrier(tp);
+		if (lock)
+			mutex_unlock(&tp->control);
+		rtnl_unlock();
+		goto out1;
+	}
+}
+
+static inline void __rtl_hw_phy_work_func(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
+
+	mutex_lock(&tp->control);
+
+	tp->rtl_ops.hw_phy_cfg(tp);
+
+	rtl8152_set_speed(tp, tp->autoneg, tp->speed, tp->duplex,
+			  tp->advertising);
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+
+static void rtl_work_func_t(void *data)
+{
+	struct r8152 *tp = (struct r8152 *)data;
+
+	__rtl_work_func(tp);
+}
+
+static void rtl_hw_phy_work_func_t(void *data)
+{
+	struct r8152 *tp = (struct r8152 *)data;
+
+	__rtl_hw_phy_work_func(tp);
+}
+
+#else
+
+static void rtl_work_func_t(struct work_struct *work)
+{
+	struct r8152 *tp = container_of(work, struct r8152, schedule.work);
+
+	__rtl_work_func(tp);
+}
+
+static void rtl_hw_phy_work_func_t(struct work_struct *work)
+{
+	struct r8152 *tp = container_of(work, struct r8152, hw_phy_work.work);
+
+	__rtl_hw_phy_work_func(tp);
+}
+
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP)
+static int rtl_notifier(struct notifier_block *nb, unsigned long action,
+			void *data)
+{
+	struct r8152 *tp = container_of(nb, struct r8152, pm_notifier);
+
+	switch (action) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		if (usb_autopm_get_interface(tp->intf) < 0)
+			netif_info(tp, drv, tp->netdev, "Auto-wake fail\n");
+		break;
+
+	case PM_POST_HIBERNATION:
+	case PM_POST_SUSPEND:
+		usb_autopm_put_interface(tp->intf);
+		break;
+
+	case PM_POST_RESTORE:
+	case PM_RESTORE_PREPARE:
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP) */
+
+#if defined(RTL8152_S5_WOL) && defined(CONFIG_PM)
+static int rtl_s5_wol(struct r8152 *tp)
+{
+	struct usb_device *udev = tp->udev;
+	u32 ocp_data;
+	int ret;
+
+	if (!tp->saved_wolopts)
+		return -EOPNOTSUPP;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+		return -EOPNOTSUPP;
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+		goto remote_wake;
+	default:
+		break;
+	}
+
+	ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG5, &ocp_data);
+	if (ret < 0)
+		goto out;
+	if (!(ocp_data & LAN_WAKE_EN))
+		return -EOPNOTSUPP;
+
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_PLA, PLA_INDICATE_FALG, BIT(1));
+	if (ret < 0)
+		goto out;
+
+remote_wake:
+	/* usb_enable_remote_wakeup */
+	if (udev->speed < USB_SPEED_SUPER)
+		ret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				      USB_REQ_SET_FEATURE, USB_RECIP_DEVICE,
+				      USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
+				      USB_CTRL_SET_TIMEOUT);
+	else
+		ret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				      USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
+				      USB_INTRF_FUNC_SUSPEND,
+				      USB_INTRF_FUNC_SUSPEND_RW |
+				      USB_INTRF_FUNC_SUSPEND_LP,
+				      NULL, 0, USB_CTRL_SET_TIMEOUT);
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static
+int rtl_reboot_notifier(struct notifier_block *nb, unsigned long action,
+			void *data)
+{
+	struct r8152 *tp = container_of(nb, struct r8152, reboot_notifier);
+
+	switch (action) {
+	case SYS_POWER_OFF:
+		if (test_and_clear_bit(WORK_ENABLE, &tp->flags)) {
+			int ret;
+
+			if (usb_autopm_get_interface(tp->intf) < 0)
+				break;
+
+			mutex_lock(&tp->control);
+			tp->rtl_ops.down(tp);
+			ret = rtl_s5_wol(tp);
+			if (ret < 0)
+				netif_info(tp, drv, tp->netdev,
+					   "S5 WOL is not enabled, %d\n", ret);
+			else
+				netif_info(tp, drv, tp->netdev, "Enable S5 WOL\n");
+
+			mutex_unlock(&tp->control);
+			usb_autopm_put_interface(tp->intf);
+		}
+		break;
+
+	case SYS_RESTART:
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+#endif /* defined(RTL8152_S5_WOL) && defined(CONFIG_PM) */
+
+static int rtk_disable_diag(struct r8152 *tp)
+{
+	tp->rtk_enable_diag--;
+	rtl_reset_ocp_base(tp);
+
+	if (tp->support_2500full || tp->support_5000full || tp->support_10gfull)
+		r8156_mdio_force_mode(tp);
+
+	netif_info(tp, drv, tp->netdev, "disable rtk diag %d\n",
+		   tp->rtk_enable_diag);
+	mutex_unlock(&tp->control);
+	if (test_bit(WORK_ENABLE, &tp->flags))
+		schedule_delayed_work(&tp->schedule, 0);
+	usb_autopm_put_interface(tp->intf);
+
+	return 0;
+}
+
+static int rtl8152_open(struct net_device *netdev)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	int res = 0;
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	if (work_busy(&tp->hw_phy_work.work) & WORK_BUSY_PENDING) {
+		cancel_delayed_work_sync(&tp->hw_phy_work);
+		__rtl_hw_phy_work_func(tp);
+	}
+
+	res = alloc_all_mem(tp);
+	if (res)
+		goto out;
+
+	res = usb_autopm_get_interface(tp->intf);
+	if (res < 0)
+		goto out_free;
+
+	mutex_lock(&tp->control);
+
+	res = tp->rtl_ops.up(tp);
+	if (res < 0)
+		goto out_unlock;
+
+	netif_carrier_off(netdev);
+	netif_start_queue(netdev);
+	smp_mb__before_atomic();
+	set_bit(WORK_ENABLE, &tp->flags);
+	smp_mb__after_atomic();
+
+	if (test_and_clear_bit(RECOVER_SPEED, &tp->flags))
+		rtl8152_set_speed(tp, tp->autoneg, tp->speed, tp->duplex,
+				  tp->advertising);
+
+	res = usb_submit_urb(tp->intr_urb, GFP_KERNEL);
+	if (res) {
+		if (res == -ENODEV)
+			netif_device_detach(tp->netdev);
+		netif_warn(tp, ifup, netdev, "intr_urb submit failed: %d\n",
+			   res);
+		goto out_unwork;
+	}
+	napi_enable(&tp->napi);
+	tasklet_enable(&tp->tx_tl);
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP)
+	tp->pm_notifier.notifier_call = rtl_notifier;
+	register_pm_notifier(&tp->pm_notifier);
+#endif
+#if defined(RTL8152_S5_WOL) && defined(CONFIG_PM)
+	tp->reboot_notifier.notifier_call = rtl_reboot_notifier;
+	register_reboot_notifier(&tp->reboot_notifier);
+#endif /* defined(RTL8152_S5_WOL) && defined(CONFIG_PM) */
+	return 0;
+
+out_unwork:
+	clear_bit(WORK_ENABLE, &tp->flags);
+out_unlock:
+	mutex_unlock(&tp->control);
+	usb_autopm_put_interface(tp->intf);
+out_free:
+	free_all_mem(tp);
+out:
+	return res;
+}
+
+static int rtl8152_close(struct net_device *netdev)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	int res = 0;
+
+#if defined(RTL8152_S5_WOL) && defined(CONFIG_PM)
+	unregister_reboot_notifier(&tp->reboot_notifier);
+#endif /* defined(RTL8152_S5_WOL) && defined(CONFIG_PM) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP)
+	unregister_pm_notifier(&tp->pm_notifier);
+#endif
+	tasklet_disable(&tp->tx_tl);
+	smp_mb__before_atomic();
+	clear_bit(WORK_ENABLE, &tp->flags);
+	smp_mb__after_atomic();
+	usb_kill_urb(tp->intr_urb);
+	cancel_delayed_work_sync(&tp->schedule);
+	napi_disable(&tp->napi);
+	netif_stop_queue(netdev);
+
+	if (unlikely(tp->rtk_enable_diag)) {
+		netif_err(tp, drv, tp->netdev, "rtk diag isn't disabled\n");
+		rtk_disable_diag(tp);
+	}
+
+	res = usb_autopm_get_interface(tp->intf);
+	if (res < 0 || test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		rtl_stop_rx(tp);
+	} else {
+		mutex_lock(&tp->control);
+
+		tp->rtl_ops.down(tp);
+
+#if defined(RTL8152_S5_WOL) && defined(CONFIG_PM)
+		if (rtl_s5_wol(tp) < 0)
+			netif_info(tp, drv, tp->netdev,
+				   "S5 WOL is not enabled\n");
+		else
+			netif_info(tp, drv, tp->netdev, "Enable S5 WOL\n");
+#endif /* defined(RTL8152_S5_WOL) && defined(CONFIG_PM) */
+
+		if (tp->version == RTL_VER_01)
+			rtl8152_set_speed(tp, AUTONEG_ENABLE, 0, 0, 3);
+		else
+			rtl_speed_down(tp);
+
+		mutex_unlock(&tp->control);
+	}
+
+	if (!res)
+		usb_autopm_put_interface(tp->intf);
+
+	free_all_mem(tp);
+
+	return res;
+}
+
+static int rtl_tally_reset(struct r8152 *tp)
+{
+	return ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_RSTTALLY, TALLY_RESET);
+}
+
+static int test_io_en(struct r8152 *tp, bool enable)
+{
+	if (enable)
+	    return ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_PHY_PWR,
+				     TEST_IO_OFF);
+	else
+	    return ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_PHY_PWR,
+				     TEST_IO_OFF);
+}
+
+static int rtl_disable_spi(struct r8152 *tp)
+{
+	int ret;
+
+	ret = ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
+	if (ret < 0)
+		goto out;
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_CONFIG5, SPI_EN);
+	if (ret < 0)
+		goto out;
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, 0xcbf0, BIT(1));
+
+out:
+	return ret;
+}
+
+static int r8152b_init(struct r8152 *tp)
+{
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+#if 0
+	/* Clear EP3 Fifo before using interrupt transfer */
+	ret = ocp_read_byte(tp, MCU_TYPE_USB, 0xb963, &ocp_data);
+	if (ret < 0)
+		goto out;
+	if (ocp_data & 0x80) {
+		ret = ocp_write_byte(tp, MCU_TYPE_USB, 0xb963, 0x08);
+		if (ret < 0)
+			goto out;
+		ret = ocp_write_byte(tp, MCU_TYPE_USB, 0xb963, 0x40);
+		if (ret < 0)
+			goto out;
+		ret = ocp_write_byte(tp, MCU_TYPE_USB, 0xb963, 0x00);
+		if (ret < 0)
+			goto out;
+		ret = ocp_write_byte(tp, MCU_TYPE_USB, 0xb968, 0x00);
+		if (ret < 0)
+			goto out;
+		ret = ocp_write_word(tp, MCU_TYPE_USB, 0xb010, 0x00e0);
+		if (ret < 0)
+			goto out;
+		ret = ocp_write_byte(tp, MCU_TYPE_USB, 0xb963, 0x04);
+		if (ret < 0)
+			goto out;
+	}
+#endif
+
+	ret = r8153_phy_status(tp, 0);
+	if (ret < 0)
+		goto out;
+
+	ret = r8152_mdio_test_and_clr_bit(tp, MII_BMCR, BMCR_PDOWN);
+	if (ret < 0)
+		goto out;
+
+	ret = r8152_aldps_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	if (tp->version == RTL_VER_01) {
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_LED_FEATURE,
+					LED_MODE_MASK);
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = r8152_power_cut_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_runtime_suspend_enable(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_PHY_PWR,
+				TX_10M_IDLE_EN | PFM_PWM_SWITCH);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_dword_w0w1(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL,
+			     MCU_CLK_RATIO_MASK, MCU_CLK_RATIO |
+			     D3_CLK_GATED_EN);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_word(tp, MCU_TYPE_PLA, PLA_GPHY_INTR_IMR,
+			     GPHY_STS_MSK | SPEED_DOWN_MSK | SPDWN_RXDV_MSK |
+			     SPDWN_LINKCHG_MSK);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_USB_TIMER, BIT(15));
+	if (ret < 0)
+		goto out;
+
+	/* MSC timer = 8s */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 8000 / 8);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_USB_TIMER, BIT(15));
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_tally_reset(tp);
+	if (ret < 0)
+		goto out;
+
+	/* enable rx aggregation */
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_USB_CTRL,
+				RX_AGG_DISABLE | RX_ZERO_EN);
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static int r8153_init(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i, ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = r8153_u1u2en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	for (i = 0; i < 500; i++) {
+		ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL, &ocp_data);
+		if (ret < 0)
+			goto out;
+		if (ocp_data & AUTOLOAD_DONE)
+			break;
+
+		msleep(20);
+	}
+
+	ret = r8153_phy_status(tp, 0);
+	if (ret < 0)
+		goto out;
+
+	if (tp->version == RTL_VER_03 || tp->version == RTL_VER_04 ||
+	    tp->version == RTL_VER_05) {
+		ret = ocp_reg_write(tp, OCP_ADC_CFG, CKADSEL_L | ADC_EN |
+				    EN_EMI_L);
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = r8152_mdio_test_and_clr_bit(tp, MII_BMCR, BMCR_PDOWN);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_u2p3en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	if (tp->version == RTL_VER_04) {
+		ret = ocp_word_w0w1(tp, MCU_TYPE_USB, USB_SSPHYLINK2,
+				    pwd_dn_scale_mask, pwd_dn_scale(96));
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_USB2PHY,
+					USB2PHY_L1 | USB2PHY_SUSPEND);
+		if (ret < 0)
+			goto out;
+	} else if (tp->version == RTL_VER_05) {
+		ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, PLA_DMY_REG0, ECM_ALDPS);
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE, &ocp_data);
+		if (ret < 0)
+			goto out;
+
+		if (ocp_data == 0)
+			ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_CSR_DUMMY1,
+						DYNAMIC_BURST);
+		else
+			ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_CSR_DUMMY1,
+						DYNAMIC_BURST);
+		if (ret < 0)
+			goto out;
+	} else if (tp->version == RTL_VER_06) {
+		ret = ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE, &ocp_data);
+		if (ret < 0)
+			goto out;
+
+		if (ocp_data == 0)
+			ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB,
+						USB_CSR_DUMMY1,
+						DYNAMIC_BURST);
+		else
+			ret = ocp_byte_set_bits(tp, MCU_TYPE_USB,
+						USB_CSR_DUMMY1,
+						DYNAMIC_BURST);
+		if (ret < 0)
+			goto out;
+
+		ret = r8153_queue_wake(tp, false);
+		if (ret < 0)
+			goto out;
+
+		if (rtl8152_get_speed(tp) & LINK_STATUS)
+			ret = ocp_word_set_bits(tp, MCU_TYPE_PLA,
+						PLA_EXTRA_STATUS,
+						CUR_LINK_OK | POLL_LINK_CHG);
+		else
+			ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+					    CUR_LINK_OK, POLL_LINK_CHG);
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_CSR_DUMMY2, EP4_FULL_FC);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_WDT11_CTRL, TIMER11_EN);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_LED_FEATURE,
+				LED_MODE_MASK);
+	if (ret < 0)
+		goto out;
+
+	if (tp->version == RTL_VER_04 && tp->udev->speed < USB_SPEED_SUPER)
+		ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_LPM_CTRL,
+					FIFO_EMPTY_1FB | ROK_EXIT_LPM |
+					LPM_TIMER_500MS);
+	else
+		ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_LPM_CTRL,
+					FIFO_EMPTY_1FB | ROK_EXIT_LPM |
+					LPM_TIMER_500US);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_w0w1(tp, MCU_TYPE_USB, USB_AFE_CTRL2, SEN_VAL_MASK,
+			    SEN_VAL_NORMAL | SEL_RXIDLE);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_CONNECT_TIMER, 0x0001);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_power_cut_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_runtime_suspend_enable(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_mac_clk_speed_down(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_u1u2en(tp, true);
+	if (ret < 0)
+		goto out;
+
+	usb_enable_lpm(tp->udev);
+
+	ret = r8153_lanwake_clr_en(tp, true);
+	if (ret < 0)
+		goto out;
+
+	/* rx aggregation */
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_USB_CTRL,
+				RX_AGG_DISABLE | RX_ZERO_EN);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_tally_reset(tp);
+	if (ret < 0)
+		goto out;
+
+	switch (tp->udev->speed) {
+	case USB_SPEED_SUPER:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+	case USB_SPEED_SUPER_PLUS:
+#endif
+		tp->coalesce = COALESCE_SUPER;
+		break;
+	case USB_SPEED_HIGH:
+		tp->coalesce = COALESCE_HIGH;
+		break;
+	default:
+		tp->coalesce = COALESCE_SLOW;
+		break;
+	}
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static int r8153b_init(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i, ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	rtl_set_dbg_info_init(tp, 0xb);
+
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_disable_spi(tp);
+	if (ret < 0)
+		goto out;
+
+	for (i = 0; i < 500; i++) {
+		ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL, &ocp_data);
+
+		if (ret < 0)
+			goto out;
+		if (ocp_data & AUTOLOAD_DONE)
+			break;
+
+		msleep(20);
+	}
+
+	ret = r8153_phy_status(tp, 0);
+	if (ret < 0)
+		goto out;
+
+	ret = r8152_mdio_test_and_clr_bit(tp, MII_BMCR, BMCR_PDOWN);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_u2p3en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	/* MSC timer = 0xfff * 8ms = 32760 ms */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_power_cut_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_ups_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_queue_wake(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_runtime_suspend_enable(tp, false);
+	if (ret < 0)
+		goto out;
+
+	if (rtl8152_get_speed(tp) & LINK_STATUS)
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+					CUR_LINK_OK | POLL_LINK_CHG);
+	else
+		ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+				    CUR_LINK_OK, POLL_LINK_CHG);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_lanwake_clr_en(tp, true);
+	if (ret < 0)
+		goto out;
+
+	if (tp->udev->descriptor.idVendor == VENDOR_ID_LENOVO &&
+	    tp->udev->descriptor.idProduct == 0x3069)
+		ocp_write_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2, 0x0c8c);
+
+//	if (tp->udev->speed >= USB_SPEED_SUPER) {
+//		ret = r8153b_u1u2en(tp, true);
+//		if (ret < 0)
+//			goto out;
+//	}
+
+	usb_enable_lpm(tp->udev);
+
+	/* MAC clock speed down */
+	ret = r8153_mac_clk_speed_down(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_mcu_spdown_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	if (tp->version == RTL_VER_09) {
+		/* Disable Test IO for 32QFN */
+		ret = ocp_read_byte(tp, MCU_TYPE_PLA, 0xdc00, &ocp_data);
+		if (ret < 0)
+			goto out;
+		if (ocp_data & BIT(5)) {
+			ret = test_io_en(tp, false);
+			if (ret < 0)
+				goto out;
+		}
+	}
+
+	set_bit(GREEN_ETHERNET, &tp->flags);
+
+	/* rx aggregation */
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_USB_CTRL,
+				RX_AGG_DISABLE | RX_ZERO_EN);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_tally_reset(tp);
+	if (ret < 0)
+		goto out;
+
+	tp->coalesce = 15000;	/* 15 us */
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static int r8153c_init(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i, ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	rtl_set_dbg_info_init(tp, 0xc);
+
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_disable_spi(tp);
+	if (ret < 0)
+		goto out;
+
+	for (i = 0; i < 500; i++) {
+		ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL, &ocp_data);
+		if (ret < 0)
+			goto out;
+		if (ocp_data & AUTOLOAD_DONE)
+			break;
+
+		msleep(20);
+	}
+
+	ret = r8153_phy_status(tp, 0);
+	if (ret < 0)
+		goto out;
+
+	ret = r8152_mdio_test_and_clr_bit(tp, MII_BMCR, BMCR_PDOWN);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_u2p3en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	/* MSC timer = 0xfff * 8ms = 32760 ms */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_power_cut_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153c_ups_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_queue_wake(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_runtime_suspend_enable(tp, false);
+	if (ret < 0)
+		goto out;
+
+	if (rtl8152_get_speed(tp) & LINK_STATUS)
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+					CUR_LINK_OK | POLL_LINK_CHG);
+	else
+		ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+				    CUR_LINK_OK, POLL_LINK_CHG);
+	if (ret < 0)
+		goto out;
+
+	if (tp->udev->speed < USB_SPEED_SUPER)
+		ret = r8153b_u1u2en(tp, false);
+	else
+		ret = r8153b_u1u2en(tp, true);
+	if (ret < 0)
+		goto out;
+
+	usb_enable_lpm(tp->udev);
+
+	/* MAC clock speed down */
+	ret = r8153_mac_clk_speed_down(tp, true);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_MISC_2, BIT(7));
+	if (ret < 0)
+		goto out;
+
+	ret = test_io_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	set_bit(GREEN_ETHERNET, &tp->flags);
+
+	/* rx aggregation */
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_USB_CTRL,
+				RX_AGG_DISABLE | RX_ZERO_EN);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_tally_reset(tp);
+	if (ret < 0)
+		goto out;
+
+	tp->coalesce = 15000;	/* 15 us */
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static void r8156_patch_code(struct r8152 *tp)
+{
+	if (tp->version == RTL_TEST_01) {
+		static u8 usb3_patch_t[] = {
+			0x01, 0xe0, 0x05, 0xc7,
+			0xf6, 0x65, 0x02, 0xc0,
+			0x00, 0xb8, 0x40, 0x03,
+			0x00, 0xd4, 0x00, 0x00 };
+
+		rtl_clear_bp(tp, MCU_TYPE_USB);
+
+		generic_ocp_write(tp, 0xe600, 0xff, sizeof(usb3_patch_t),
+				  usb3_patch_t, MCU_TYPE_USB);
+
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xa000);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x033e);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0x0001);
+	} else if (tp->version == RTL_VER_11) {
+		static u8 usb_patch3_b[] = {
+			0x10, 0xe0, 0x12, 0xe0,
+			0x33, 0xe0, 0x7d, 0xe0,
+			0x92, 0xe0, 0xae, 0xe0,
+			0xce, 0xe0, 0x23, 0xe1,
+			0x3f, 0xe1, 0x58, 0xe1,
+			0x84, 0xe1, 0xca, 0xe1,
+			0xd9, 0xe1, 0xeb, 0xe1,
+			0x02, 0xe2, 0xe0, 0xe2,
+			0x02, 0xc0, 0x00, 0xb8,
+			0xf0, 0x4b, 0x1c, 0xc6,
+			0xc0, 0x61, 0x04, 0x11,
+			0x15, 0xf1, 0x19, 0xc6,
+			0xc0, 0x61, 0x9c, 0x20,
+			0x9c, 0x24, 0x09, 0x11,
+			0x0f, 0xf1, 0x14, 0xc6,
+			0x01, 0x19, 0xc0, 0x89,
+			0x13, 0xc1, 0x13, 0xc6,
+			0x24, 0x9e, 0x00, 0x1e,
+			0x26, 0x8e, 0x26, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0x22, 0x76, 0x08, 0xc1,
+			0x22, 0x9e, 0x07, 0xc6,
+			0x02, 0xc1, 0x00, 0xb9,
+			0x9e, 0x09, 0x18, 0xb4,
+			0x4a, 0xb4, 0x90, 0xcc,
+			0x80, 0xd4, 0x08, 0xdc,
+			0x10, 0xe8, 0x28, 0xe8,
+			0x23, 0xc7, 0x21, 0xc2,
+			0xec, 0x9a, 0x00, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0xea, 0x71, 0x9f, 0x49,
+			0x14, 0xf0, 0x1a, 0xc2,
+			0xec, 0x9a, 0x00, 0x19,
+			0xe8, 0x99, 0x81, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x12, 0xc2, 0xec, 0x9a,
+			0x00, 0x19, 0x98, 0x20,
+			0xe8, 0x99, 0x82, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x06, 0xc3, 0x02, 0xc2,
+			0x00, 0xba, 0x3e, 0x29,
+			0x4c, 0xe8, 0x00, 0xdc,
+			0x00, 0xd4, 0x24, 0xe4,
+			0x04, 0xe4, 0x00, 0xb4,
+			0x04, 0xb4, 0x05, 0xb4,
+			0x06, 0xb4, 0x51, 0xc0,
+			0x00, 0x75, 0xd9, 0x49,
+			0x17, 0xf0, 0x30, 0xc0,
+			0xf6, 0xc5, 0x00, 0x1e,
+			0x68, 0x23, 0x08, 0x9e,
+			0x0c, 0x9d, 0x82, 0x1c,
+			0x0e, 0x8c, 0x0e, 0x74,
+			0xcf, 0x49, 0xfe, 0xf1,
+			0x25, 0xc0, 0xeb, 0xc5,
+			0x11, 0x1e, 0x68, 0x23,
+			0x08, 0x9e, 0x0c, 0x9d,
+			0x82, 0x1c, 0x0e, 0x8c,
+			0x0e, 0x74, 0xcf, 0x49,
+			0xfe, 0xf1, 0x06, 0xb0,
+			0x05, 0xb0, 0x04, 0xb0,
+			0x00, 0xb0, 0x80, 0xff,
+			0x32, 0xc0, 0x00, 0x75,
+			0xd8, 0x49, 0x0d, 0xf0,
+			0x11, 0xc0, 0xd6, 0xc5,
+			0x00, 0x1e, 0x08, 0x9e,
+			0x73, 0xc6, 0x0a, 0x9e,
+			0x0c, 0x9d, 0x8f, 0x1c,
+			0x0e, 0x8c, 0x0e, 0x74,
+			0xcf, 0x49, 0xfe, 0xf1,
+			0x04, 0xc0, 0x02, 0xc1,
+			0x00, 0xb9, 0x00, 0x1d,
+			0x20, 0xd4, 0x00, 0xdc,
+			0xc7, 0xef, 0x1b, 0xc0,
+			0x00, 0x75, 0xd8, 0x48,
+			0x00, 0x9d, 0xbe, 0xc7,
+			0x15, 0xc2, 0xec, 0x9a,
+			0x00, 0x19, 0xe8, 0x9a,
+			0x81, 0x19, 0xee, 0x89,
+			0xee, 0x71, 0x9f, 0x49,
+			0xfe, 0xf1, 0x2e, 0xc1,
+			0xec, 0x99, 0x81, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x04, 0xc3, 0x02, 0xc2,
+			0x00, 0xba, 0x3a, 0x27,
+			0xc0, 0xd4, 0x24, 0xe4,
+			0x34, 0xd3, 0xc0, 0x88,
+			0x1e, 0xc6, 0xc0, 0x70,
+			0x8f, 0x49, 0x0e, 0xf0,
+			0x8f, 0x48, 0x3f, 0xc6,
+			0xca, 0x98, 0x11, 0x18,
+			0xc8, 0x98, 0x16, 0xc0,
+			0xcc, 0x98, 0x8f, 0x18,
+			0xce, 0x88, 0xce, 0x70,
+			0x8f, 0x49, 0xfe, 0xf1,
+			0x0b, 0xe0, 0x33, 0xc6,
+			0x00, 0x18, 0xc8, 0x98,
+			0x0b, 0xc0, 0xcc, 0x98,
+			0x81, 0x18, 0xce, 0x88,
+			0xce, 0x70, 0x8f, 0x49,
+			0xfe, 0xf1, 0x02, 0xc0,
+			0x00, 0xb8, 0xbc, 0x21,
+			0x40, 0xd3, 0x20, 0xe4,
+			0x29, 0xc0, 0x01, 0x66,
+			0x05, 0x16, 0x3e, 0xf0,
+			0x25, 0x16, 0x40, 0xf0,
+			0x09, 0x16, 0x23, 0xf0,
+			0x16, 0xe0, 0x1a, 0xc2,
+			0x40, 0x76, 0xe1, 0x48,
+			0x40, 0x9e, 0x17, 0xc2,
+			0x00, 0x1e, 0x48, 0x9e,
+			0xef, 0xc6, 0x4c, 0x9e,
+			0x81, 0x1e, 0x4e, 0x8e,
+			0x4e, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0x0b, 0xc6,
+			0x4c, 0x9e, 0x81, 0x1e,
+			0x4e, 0x8e, 0x4e, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0x90, 0x49, 0x02, 0xc7,
+			0x00, 0xbf, 0x64, 0x39,
+			0x24, 0xe4, 0x34, 0xd3,
+			0x00, 0xdc, 0x00, 0xdc,
+			0x24, 0xe4, 0x80, 0x02,
+			0x34, 0xd3, 0x80, 0xc3,
+			0xf9, 0xc2, 0x40, 0x76,
+			0xe1, 0x48, 0x40, 0x9e,
+			0xf6, 0xc2, 0x00, 0x1e,
+			0x48, 0x9e, 0xce, 0xc6,
+			0x4c, 0x9e, 0x81, 0x1e,
+			0x4e, 0x8e, 0x4e, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xea, 0xc6, 0x4c, 0x9e,
+			0x81, 0x1e, 0x4e, 0x8e,
+			0x4e, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xdf, 0xe7,
+			0x40, 0xd4, 0xff, 0xc2,
+			0x4c, 0x73, 0xbf, 0x49,
+			0xc5, 0xf0, 0xe3, 0xc6,
+			0xc0, 0x75, 0xd1, 0x49,
+			0xd6, 0xf0, 0xdc, 0xc0,
+			0xdc, 0xc6, 0x0c, 0x9e,
+			0x00, 0x1e, 0x08, 0x9e,
+			0xd9, 0xc6, 0x0a, 0x9e,
+			0x8f, 0x1e, 0x0e, 0x8e,
+			0x0e, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xc9, 0xe7,
+			0x1a, 0xc6, 0xc0, 0x67,
+			0xf0, 0x49, 0x13, 0xf0,
+			0xf0, 0x48, 0xc0, 0x8f,
+			0xc2, 0x77, 0x14, 0xc1,
+			0x14, 0xc6, 0x24, 0x9e,
+			0x22, 0x9f, 0x8c, 0x1e,
+			0x26, 0x8e, 0x26, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xfb, 0x49, 0x05, 0xf0,
+			0x07, 0xc6, 0xc0, 0x61,
+			0x10, 0x48, 0xc0, 0x89,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x96, 0x52, 0x6c, 0xb4,
+			0x90, 0xcc, 0x08, 0xdc,
+			0x10, 0xe8, 0x16, 0xef,
+			0x18, 0xc0, 0x00, 0x72,
+			0xa8, 0x49, 0x0d, 0xf0,
+			0x11, 0xc0, 0x11, 0xc2,
+			0x00, 0x19, 0x08, 0x99,
+			0x0c, 0x9a, 0x0e, 0xc1,
+			0x0a, 0x99, 0x8f, 0x1b,
+			0x0e, 0x8b, 0x0e, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x04, 0xc0, 0x02, 0xc2,
+			0x00, 0xba, 0x64, 0x62,
+			0x02, 0xcf, 0x00, 0xdc,
+			0x24, 0xe4, 0x80, 0x02,
+			0x34, 0xd3, 0x2c, 0xc3,
+			0x60, 0x70, 0x80, 0x49,
+			0xfd, 0xf0, 0x27, 0xc3,
+			0x66, 0x60, 0x80, 0x48,
+			0x02, 0x48, 0x66, 0x88,
+			0x00, 0x48, 0x82, 0x48,
+			0x66, 0x88, 0x1b, 0xc3,
+			0x60, 0x70, 0x17, 0xc4,
+			0x88, 0x98, 0x14, 0xc0,
+			0x8c, 0x98, 0x83, 0x18,
+			0x8e, 0x88, 0x8e, 0x70,
+			0x8f, 0x49, 0xfe, 0xf1,
+			0x62, 0x70, 0x8a, 0x98,
+			0x0d, 0xc0, 0x8c, 0x98,
+			0x84, 0x18, 0x8e, 0x88,
+			0x8e, 0x70, 0x8f, 0x49,
+			0xfe, 0xf1, 0x08, 0xc3,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x68, 0x0f, 0x6c, 0xe9,
+			0x00, 0xdc, 0x50, 0xe8,
+			0x30, 0xc1, 0x36, 0xd3,
+			0x80, 0x10, 0x00, 0x00,
+			0x80, 0xd4, 0x26, 0xd8,
+			0x44, 0xc2, 0x4a, 0x41,
+			0x94, 0x20, 0x42, 0xc0,
+			0x16, 0x00, 0x00, 0x73,
+			0x40, 0xc4, 0x5c, 0x41,
+			0x8b, 0x41, 0x0b, 0x18,
+			0x38, 0xc6, 0xc0, 0x88,
+			0xc1, 0x99, 0x21, 0xe8,
+			0x35, 0xc0, 0x00, 0x73,
+			0xbd, 0x48, 0x0d, 0x18,
+			0x30, 0xc6, 0xc0, 0x88,
+			0xc1, 0x9b, 0x19, 0xe8,
+			0x2d, 0xc0, 0x02, 0x73,
+			0x35, 0x48, 0x0e, 0x18,
+			0x28, 0xc6, 0xc0, 0x88,
+			0xc1, 0x9b, 0x11, 0xe8,
+			0xdf, 0xc3, 0xdd, 0xc6,
+			0x01, 0x03, 0x1e, 0x40,
+			0xfe, 0xf1, 0x20, 0xc0,
+			0x02, 0x73, 0xb5, 0x48,
+			0x0e, 0x18, 0x1b, 0xc6,
+			0xc0, 0x88, 0xc1, 0x9b,
+			0x04, 0xe8, 0x02, 0xc6,
+			0x00, 0xbe, 0xb6, 0x10,
+			0x00, 0xb4, 0x01, 0xb4,
+			0x02, 0xb4, 0x03, 0xb4,
+			0x10, 0xc3, 0x0e, 0xc2,
+			0x61, 0x71, 0x40, 0x99,
+			0x60, 0x60, 0x0e, 0x48,
+			0x42, 0x98, 0x42, 0x70,
+			0x8e, 0x49, 0xfe, 0xf1,
+			0x03, 0xb0, 0x02, 0xb0,
+			0x01, 0xb0, 0x00, 0xb0,
+			0x80, 0xff, 0xc0, 0xd4,
+			0x8f, 0xcb, 0xaa, 0xc7,
+			0x1e, 0x00, 0x90, 0xc7,
+			0x1f, 0xfe, 0x0a, 0x10,
+			0x0c, 0xf0, 0x0b, 0x10,
+			0x0a, 0xf0, 0x0d, 0x10,
+			0x08, 0xf0, 0x0e, 0x10,
+			0x06, 0xf0, 0x24, 0x10,
+			0x04, 0xf0, 0x02, 0xc7,
+			0x00, 0xbf, 0x58, 0x11,
+			0x02, 0xc7, 0x00, 0xbf,
+			0x62, 0x11, 0xec, 0xc0,
+			0x02, 0x75, 0xd5, 0x48,
+			0x0e, 0x18, 0xe7, 0xc6,
+			0xc0, 0x88, 0xc1, 0x9d,
+			0xd0, 0xef, 0xe4, 0xc0,
+			0x02, 0x75, 0x55, 0x48,
+			0x0e, 0x18, 0xdf, 0xc6,
+			0xc0, 0x88, 0xc1, 0x9d,
+			0xc8, 0xef, 0x02, 0xc7,
+			0x00, 0xbf, 0x8e, 0x11,
+			0x16, 0xc0, 0xbb, 0x21,
+			0xb9, 0x25, 0x00, 0x71,
+			0x13, 0xc2, 0x4a, 0x41,
+			0x8b, 0x41, 0x24, 0x18,
+			0xd0, 0xc6, 0xc0, 0x88,
+			0xc1, 0x99, 0xb9, 0xef,
+			0x0a, 0xc0, 0x08, 0x71,
+			0x28, 0x18, 0xc9, 0xc6,
+			0xc0, 0x88, 0xc1, 0x99,
+			0xb2, 0xef, 0x02, 0xc0,
+			0x00, 0xb8, 0x3c, 0x11,
+			0xd8, 0xc7, 0x83, 0xff,
+			0x01, 0xb4, 0x02, 0xb4,
+			0x03, 0xb4, 0x04, 0xb4,
+			0x05, 0xb4, 0x44, 0xc4,
+			0x45, 0xc0, 0x48, 0xc1,
+			0x81, 0x1b, 0xce, 0xe8,
+			0x46, 0xc0, 0x44, 0xc2,
+			0x84, 0x1b, 0xca, 0xe8,
+			0x59, 0xc0, 0x00, 0x1b,
+			0xc7, 0xe8, 0x80, 0x65,
+			0xdb, 0x22, 0xdd, 0x26,
+			0x03, 0x15, 0x12, 0xf1,
+			0x4e, 0xc0, 0x37, 0xc1,
+			0x81, 0x1b, 0xbe, 0xe8,
+			0x4b, 0xc0, 0x32, 0xc1,
+			0x88, 0x1b, 0xba, 0xe8,
+			0x48, 0xc0, 0x49, 0xc1,
+			0x81, 0x1b, 0xb6, 0xe8,
+			0x04, 0x00, 0x46, 0xc1,
+			0x46, 0xc2, 0x8f, 0x1b,
+			0xb1, 0xe8, 0x25, 0xc0,
+			0x29, 0xc1, 0x2b, 0xc2,
+			0x8f, 0x1b, 0xac, 0xe8,
+			0x04, 0x00, 0x3e, 0xc1,
+			0x27, 0xc2, 0xa8, 0xe8,
+			0x04, 0x00, 0x2b, 0xc1,
+			0x2b, 0xc2, 0xa4, 0xe8,
+			0x04, 0x00, 0x29, 0xc1,
+			0x2b, 0xc2, 0xa0, 0xe8,
+			0x04, 0x00, 0x26, 0xc1,
+			0x26, 0xc2, 0x9c, 0xe8,
+			0x04, 0x00, 0x24, 0xc1,
+			0x21, 0xc2, 0x98, 0xe8,
+			0x04, 0x00, 0x21, 0xc1,
+			0x1f, 0xc2, 0x94, 0xe8,
+			0x04, 0x00, 0x1a, 0xc1,
+			0x1d, 0xc2, 0x90, 0xe8,
+			0x3d, 0xe0, 0x08, 0xdc,
+			0x3c, 0xe8, 0x14, 0xe8,
+			0x00, 0xf8, 0x00, 0x40,
+			0x00, 0x00, 0x01, 0x00,
+			0x9a, 0xd3, 0x04, 0xe0,
+			0x02, 0xe0, 0x0b, 0xe0,
+			0x0c, 0xe0, 0x25, 0xe0,
+			0xef, 0x1f, 0xa8, 0x8f,
+			0x02, 0xc7, 0x00, 0xbf,
+			0x76, 0x15, 0x66, 0x15,
+			0xa0, 0x49, 0x05, 0xf1,
+			0xa4, 0x49, 0x00, 0xbe,
+			0xca, 0x1a, 0x02, 0xc6,
+			0xe0, 0x1a, 0xce, 0x13,
+			0x80, 0xe0, 0xcb, 0xe0,
+			0xe0, 0xe8, 0x28, 0xdc,
+			0x13, 0x00, 0x08, 0x11,
+			0x42, 0x80, 0x0e, 0xe0,
+			0x06, 0xb4, 0x84, 0x76,
+			0x31, 0x40, 0x82, 0x71,
+			0x0c, 0xe8, 0x81, 0x24,
+			0x1f, 0x48, 0x84, 0x99,
+			0x08, 0xe8, 0x80, 0x49,
+			0x03, 0xf1, 0x80, 0x71,
+			0x80, 0xff, 0x85, 0x61,
+			0x96, 0x24, 0xfd, 0xf1,
+			0x06, 0xb0, 0x00, 0x11,
+			0x6c, 0x0f, 0x34, 0x1c,
+			0x28, 0xfc, 0x38, 0xfc,
+			0x0f, 0x00, 0xc8, 0x1a,
+			0xbe, 0x13, 0x04, 0x00,
+			0xe6, 0xc1, 0xea, 0xc2,
+			0x4f, 0xe8, 0x04, 0x00,
+			0xe3, 0xc1, 0xe3, 0xc2,
+			0x4b, 0xe8, 0x04, 0x00,
+			0xe8, 0xc1, 0xe0, 0xc2,
+			0x47, 0xe8, 0x04, 0x00,
+			0xc1, 0xc1, 0xdd, 0xc2,
+			0x43, 0xe8, 0x04, 0x00,
+			0xdb, 0xc1, 0xdb, 0xc2,
+			0x3f, 0xe8, 0x04, 0x00,
+			0xd9, 0xc1, 0xd9, 0xc2,
+			0x3b, 0xe8, 0x04, 0x00,
+			0xd7, 0xc1, 0xd7, 0xc2,
+			0x37, 0xe8, 0x04, 0x00,
+			0xd5, 0xc1, 0xaf, 0xc2,
+			0x33, 0xe8, 0x04, 0x00,
+			0xc9, 0xc1, 0xd5, 0xc2,
+			0x2f, 0xe8, 0x04, 0x00,
+			0xce, 0xc1, 0xce, 0xc2,
+			0x2b, 0xe8, 0x04, 0x00,
+			0xcc, 0xc1, 0xce, 0xc2,
+			0x27, 0xe8, 0x04, 0x00,
+			0xc9, 0xc1, 0xc5, 0xc2,
+			0x23, 0xe8, 0x04, 0x00,
+			0xa0, 0xc1, 0xa0, 0xc2,
+			0x1f, 0xe8, 0x04, 0x00,
+			0x9e, 0xc1, 0x9e, 0xc2,
+			0x1b, 0xe8, 0x04, 0x00,
+			0x9c, 0xc1, 0x83, 0x1b,
+			0x17, 0xe8, 0xbf, 0xc0,
+			0xc1, 0xc1, 0xc1, 0xc2,
+			0x8f, 0x1b, 0x12, 0xe8,
+			0x04, 0x00, 0xb8, 0xc1,
+			0x93, 0xc2, 0x8f, 0x1b,
+			0x0d, 0xe8, 0xb6, 0xc0,
+			0xb6, 0xc1, 0x81, 0x1b,
+			0x09, 0xe8, 0x05, 0xb0,
+			0x04, 0xb0, 0x03, 0xb0,
+			0x02, 0xb0, 0x01, 0xb0,
+			0x60, 0x70, 0xa9, 0xc3,
+			0x00, 0xbb, 0x84, 0x98,
+			0x80, 0x99, 0x82, 0x9a,
+			0x86, 0x8b, 0x86, 0x75,
+			0xdf, 0x49, 0xfe, 0xf1,
+			0x80, 0xff, 0x3b, 0xc0,
+			0x3b, 0xc1, 0x00, 0x70,
+			0x08, 0x40, 0x34, 0xf1,
+			0x38, 0xc0, 0x38, 0xc1,
+			0x0c, 0x99, 0x00, 0x19,
+			0x0e, 0x89, 0x0e, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x0a, 0x71, 0x9a, 0x48,
+			0x0a, 0x99, 0x8f, 0x19,
+			0x0e, 0x89, 0x0e, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x2a, 0xc0, 0x00, 0x71,
+			0x90, 0x48, 0x00, 0x99,
+			0x27, 0xc0, 0x00, 0x71,
+			0x13, 0x48, 0x00, 0x99,
+			0x20, 0xc0, 0x20, 0xc1,
+			0x0c, 0x99, 0x00, 0x19,
+			0x0e, 0x89, 0x0e, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x0a, 0x71, 0x9b, 0x48,
+			0x0a, 0x99, 0x8f, 0x19,
+			0x0e, 0x89, 0x0e, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x12, 0xc0, 0x00, 0x71,
+			0x10, 0x48, 0x00, 0x99,
+			0x0f, 0xc0, 0x00, 0x71,
+			0x93, 0x48, 0x00, 0x99,
+			0x06, 0xc0, 0x00, 0x19,
+			0x00, 0x99, 0x09, 0xc7,
+			0x09, 0xc5, 0x00, 0xbd,
+			0x80, 0xd2, 0x86, 0x64,
+			0x00, 0xdc, 0x10, 0xe8,
+			0xb0, 0xd4, 0x06, 0xd4,
+			0xc0, 0xd4, 0x72, 0x14};
+		static u8 pla_patch11[] = {
+			0x05, 0xe0, 0x0a, 0xe0,
+			0x38, 0xe0, 0x3a, 0xe0,
+			0x57, 0xe0, 0x05, 0xc2,
+			0x40, 0x76, 0x02, 0xc4,
+			0x00, 0xbc, 0xd6, 0x0b,
+			0x1e, 0xfc, 0x29, 0xc5,
+			0xa0, 0x77, 0x2b, 0xc4,
+			0xa0, 0x9c, 0x26, 0xc5,
+			0xa0, 0x64, 0x01, 0x14,
+			0x0b, 0xf0, 0x02, 0x14,
+			0x09, 0xf0, 0x01, 0x07,
+			0xf1, 0x49, 0x06, 0xf0,
+			0x21, 0xc7, 0xe0, 0x8e,
+			0x11, 0x1e, 0xe0, 0x8e,
+			0x14, 0xe0, 0x17, 0xc5,
+			0x00, 0x1f, 0xa0, 0x9f,
+			0x13, 0xc5, 0xa0, 0x77,
+			0xa0, 0x74, 0x46, 0x48,
+			0x47, 0x48, 0xa0, 0x9c,
+			0x11, 0xc5, 0xa0, 0x74,
+			0x44, 0x48, 0x43, 0x48,
+			0xa0, 0x9c, 0x08, 0xc5,
+			0xa0, 0x9f, 0x02, 0xc5,
+			0x00, 0xbd, 0xea, 0x03,
+			0x02, 0xc5, 0x00, 0xbd,
+			0xf6, 0x03, 0x1c, 0xe8,
+			0xaa, 0xd3, 0x08, 0xb7,
+			0x6c, 0xe8, 0x20, 0xe8,
+			0x00, 0xa0, 0x38, 0xe4,
+			0x02, 0xc5, 0x00, 0xbd,
+			0xcc, 0x06, 0xd4, 0x49,
+			0x17, 0xf0, 0x19, 0xc5,
+			0xa4, 0x64, 0xc1, 0x49,
+			0x07, 0xf1, 0x16, 0xc5,
+			0xa0, 0x64, 0xc7, 0x48,
+			0x46, 0x48, 0xa0, 0x8c,
+			0x06, 0xe0, 0x10, 0xc5,
+			0xa0, 0x64, 0x47, 0x48,
+			0xc6, 0x48, 0xa0, 0x8c,
+			0x0c, 0xc7, 0xe0, 0x8e,
+			0x11, 0x1e, 0xe0, 0x8e,
+			0x02, 0xc7, 0x00, 0xbf,
+			0x88, 0x04, 0x02, 0xc7,
+			0x00, 0xbf, 0xbe, 0x03,
+			0x5c, 0xdc, 0xf0, 0xd3,
+			0x20, 0xe4, 0xd2, 0x49,
+			0x08, 0xf1, 0xd3, 0x49,
+			0x55, 0xf1, 0xd4, 0x49,
+			0x1e, 0xf1, 0xd5, 0x49,
+			0x45, 0xf1, 0x4d, 0xe0,
+			0x5a, 0xc7, 0xe0, 0x72,
+			0xa0, 0x49, 0x05, 0xf0,
+			0x54, 0xc7, 0xe0, 0x72,
+			0xaf, 0x49, 0x0e, 0xf1,
+			0x53, 0xc7, 0xff, 0x1a,
+			0xe0, 0x9a, 0x51, 0xc2,
+			0xe4, 0x9a, 0x50, 0xc2,
+			0xe6, 0x9a, 0x01, 0x1a,
+			0xe0, 0x9a, 0x4d, 0xc2,
+			0xe4, 0x9a, 0x4a, 0xc2,
+			0xe6, 0x9a, 0x44, 0xc7,
+			0xe5, 0x8e, 0x00, 0x1d,
+			0xe5, 0x8d, 0x30, 0xe0,
+			0x38, 0xc7, 0xe0, 0x75,
+			0xda, 0x49, 0x1f, 0xf0,
+			0x35, 0xc7, 0xe0, 0x75,
+			0xdc, 0x49, 0x1b, 0xf1,
+			0x32, 0xc7, 0xe0, 0x75,
+			0xd5, 0x49, 0x17, 0xf0,
+			0x39, 0xc7, 0xe0, 0x75,
+			0xd8, 0x48, 0xd9, 0x48,
+			0xda, 0x48, 0xdb, 0x48,
+			0xe0, 0x9d, 0x2a, 0xc7,
+			0xe0, 0x75, 0xdb, 0x49,
+			0x03, 0xf1, 0xde, 0x49,
+			0x0d, 0xf0, 0x22, 0xc7,
+			0xe4, 0x75, 0xd0, 0x49,
+			0x09, 0xf1, 0x1f, 0xc5,
+			0xe6, 0x9d, 0x11, 0x1d,
+			0xe4, 0x8d, 0x04, 0xe0,
+			0x19, 0xc7, 0x00, 0x1d,
+			0xe4, 0x8d, 0xe0, 0x8e,
+			0x11, 0x1d, 0xe0, 0x8d,
+			0x07, 0xe0, 0x0f, 0xc7,
+			0xe0, 0x75, 0xda, 0x48,
+			0xe0, 0x9d, 0x0e, 0xc7,
+			0xe4, 0x8e, 0x02, 0xc4,
+			0x00, 0xbc, 0xd6, 0x03,
+			0x02, 0xc4, 0x00, 0xbc,
+			0xc2, 0x03, 0x02, 0xc4,
+			0x00, 0xbc, 0x5a, 0x04,
+			0x12, 0xe8, 0x4e, 0xe8,
+			0x08, 0xe9, 0x20, 0xe4,
+			0x80, 0x02, 0x9a, 0xc0,
+			0x4e, 0xe8, 0x00, 0xe4,
+			0x10, 0xe0, 0xe0, 0xe8,
+			0x80, 0x11, 0x02, 0x80,
+			0x30, 0x10, 0xb4, 0xc0};
+		u8 new_ver;
+
+		rtl_fw_ver_erase(tp);
+
+		new_ver = 7;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_USB_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_USB);
+
+			generic_ocp_write(tp, 0xe600, 0xff,
+					  sizeof(usb_patch3_b), usb_patch3_b,
+					  MCU_TYPE_USB);
+
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xa000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x39d4);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x099c);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x293c);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x1cfe);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x2738);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x21ba);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x3962);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x51ba);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x6262);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x0f66);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x1098);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x1148);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x116c);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x10e0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x0f6a);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0x7fff);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_USB_VER,
+				       new_ver);
+		}
+
+		ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_FIX_EN1,
+				  FW_IP_RESET_EN);
+
+		ocp_write_dword(tp, MCU_TYPE_USB, USB_UPHY3_MDCMDIO, 0x4026840e);
+		ocp_write_dword(tp, MCU_TYPE_USB, USB_UPHY3_MDCMDIO, 0x4001acc9);
+
+		new_ver = 6;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_PLA_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+			generic_ocp_write(tp, 0xf800, 0xff, sizeof(pla_patch11),
+					  pla_patch11, MCU_TYPE_PLA);
+
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_BA, 0x8000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_0, 0x0bc2);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_1, 0x03e0);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_2, 0x06b8);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_3, 0x03ba);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_4, 0x03b2);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_5, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_6, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_7, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x0017);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_PLA_VER,
+				       new_ver);
+		}
+	} else if (tp->version == RTL_VER_12) {
+		static u8 usb_patch4_a[] = {
+			0x10, 0xe0, 0x38, 0xe0,
+			0x4e, 0xe0, 0x8b, 0xe0,
+			0xc1, 0xe0, 0xcd, 0xe0,
+			0xd5, 0xe0, 0xed, 0xe0,
+			0xf9, 0xe0, 0xfb, 0xe0,
+			0xfd, 0xe0, 0xff, 0xe0,
+			0x01, 0xe1, 0x03, 0xe1,
+			0x05, 0xe1, 0x07, 0xe1,
+			0x22, 0xc2, 0x4a, 0x41,
+			0x91, 0x20, 0x20, 0xc0,
+			0x16, 0x00, 0x00, 0x73,
+			0x1e, 0xc4, 0x5c, 0x41,
+			0x8b, 0x41, 0x1a, 0xc0,
+			0x1a, 0x00, 0x00, 0x73,
+			0xbd, 0x48, 0x0d, 0x18,
+			0x17, 0xc6, 0xc0, 0x88,
+			0xc1, 0x9b, 0x15, 0xe8,
+			0x0b, 0x18, 0x12, 0xc6,
+			0xc0, 0x88, 0xc1, 0x99,
+			0x10, 0xe8, 0x0c, 0xc0,
+			0x1c, 0x00, 0x00, 0x73,
+			0x0e, 0x18, 0x0a, 0xc6,
+			0xc0, 0x88, 0xc1, 0x9b,
+			0x08, 0xe8, 0x02, 0xc6,
+			0x00, 0xbe, 0x10, 0x12,
+			0xf0, 0x00, 0x90, 0xc7,
+			0x1f, 0xfe, 0x8f, 0xcb,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x66, 0x3f, 0x11, 0x21,
+			0x2b, 0x25, 0x13, 0xc4,
+			0xa2, 0x41, 0x80, 0x63,
+			0xf5, 0xc0, 0x48, 0x00,
+			0xbb, 0x21, 0xb9, 0x25,
+			0x00, 0x71, 0x0c, 0xc2,
+			0x4a, 0x41, 0x8b, 0x41,
+			0x24, 0x18, 0xee, 0xc6,
+			0xc0, 0x88, 0xc1, 0x99,
+			0xec, 0xef, 0x02, 0xc6,
+			0x00, 0xbe, 0x8a, 0x12,
+			0xa0, 0xf9, 0x83, 0xff,
+			0xd4, 0x18, 0x20, 0x88,
+			0x36, 0xe8, 0x22, 0x60,
+			0x85, 0x48, 0x06, 0x48,
+			0x21, 0x88, 0xf4, 0x18,
+			0x20, 0x88, 0x32, 0xe8,
+			0x2d, 0xc3, 0xc0, 0x18,
+			0x20, 0x88, 0x2b, 0xe8,
+			0x22, 0x60, 0x60, 0x88,
+			0xc1, 0x18, 0x20, 0x88,
+			0x26, 0xe8, 0x22, 0x60,
+			0x61, 0x88, 0xc2, 0x18,
+			0x20, 0x88, 0x21, 0xe8,
+			0x22, 0x60, 0x62, 0x88,
+			0xc3, 0x18, 0x20, 0x88,
+			0x1c, 0xe8, 0x22, 0x60,
+			0x63, 0x88, 0xc4, 0x18,
+			0x20, 0x88, 0x17, 0xe8,
+			0x22, 0x60, 0x64, 0x88,
+			0xc5, 0x18, 0x20, 0x88,
+			0x12, 0xe8, 0x22, 0x60,
+			0x65, 0x88, 0xc6, 0x18,
+			0x20, 0x88, 0x0d, 0xe8,
+			0x22, 0x60, 0x66, 0x88,
+			0xc7, 0x18, 0x20, 0x88,
+			0x08, 0xe8, 0x22, 0x60,
+			0x67, 0x88, 0xd4, 0x18,
+			0x02, 0xc5, 0x00, 0xbd,
+			0xc2, 0x35, 0xc0, 0xd3,
+			0x02, 0xc5, 0x00, 0xbd,
+			0xb2, 0x3e, 0x02, 0xc5,
+			0x00, 0xbd, 0x08, 0x3f,
+			0xd4, 0x18, 0xc0, 0x88,
+			0xf8, 0xef, 0xc2, 0x60,
+			0x85, 0x48, 0x06, 0x48,
+			0xc1, 0x88, 0xf4, 0x18,
+			0xc0, 0x88, 0xf4, 0xef,
+			0xef, 0xc3, 0x60, 0x60,
+			0xc1, 0x88, 0xe0, 0x18,
+			0xc0, 0x88, 0xee, 0xef,
+			0x61, 0x60, 0xc1, 0x88,
+			0xe1, 0x18, 0xc0, 0x88,
+			0xe9, 0xef, 0x62, 0x60,
+			0xc1, 0x88, 0xe2, 0x18,
+			0xc0, 0x88, 0xe4, 0xef,
+			0x63, 0x60, 0xc1, 0x88,
+			0xe3, 0x18, 0xc0, 0x88,
+			0xdf, 0xef, 0x64, 0x60,
+			0xc1, 0x88, 0xe4, 0x18,
+			0xc0, 0x88, 0xda, 0xef,
+			0x65, 0x60, 0xc1, 0x88,
+			0xe5, 0x18, 0xc0, 0x88,
+			0xd5, 0xef, 0x66, 0x60,
+			0xc1, 0x88, 0xe6, 0x18,
+			0xc0, 0x88, 0xd0, 0xef,
+			0x67, 0x60, 0xc1, 0x88,
+			0xe7, 0x18, 0xc0, 0x88,
+			0xcb, 0xef, 0xd4, 0x18,
+			0x02, 0xc2, 0x00, 0xba,
+			0x3a, 0x15, 0x0b, 0xc6,
+			0xc7, 0x65, 0xd0, 0x49,
+			0x05, 0xf1, 0x08, 0xc0,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x50, 0x2f, 0x02, 0xc7,
+			0x00, 0xbf, 0x56, 0x2f,
+			0x20, 0xd4, 0x00, 0xd4,
+			0x08, 0xc3, 0x60, 0x60,
+			0x03, 0x48, 0x60, 0x88,
+			0x00, 0x1b, 0x02, 0xc6,
+			0x00, 0xbe, 0xda, 0x2c,
+			0x60, 0xb4, 0x17, 0xc1,
+			0x17, 0xc2, 0x4c, 0x99,
+			0x00, 0x19, 0x4e, 0x89,
+			0x4f, 0x61, 0x97, 0x49,
+			0xfe, 0xf1, 0x48, 0x61,
+			0x01, 0xb4, 0x16, 0x48,
+			0x17, 0x48, 0x48, 0x89,
+			0x0a, 0xc1, 0x4c, 0x99,
+			0x81, 0x19, 0x4e, 0x89,
+			0x4f, 0x61, 0x97, 0x49,
+			0xfe, 0xf1, 0x02, 0xc0,
+			0x00, 0xb8, 0x32, 0x7c,
+			0x1c, 0xe8, 0x00, 0xdc,
+			0x01, 0xb0, 0xfe, 0xc2,
+			0x48, 0x89, 0xfb, 0xc1,
+			0x4c, 0x99, 0x81, 0x19,
+			0x4e, 0x89, 0x4f, 0x61,
+			0x97, 0x49, 0xfe, 0xf1,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x96, 0x7c, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x00, 0x00};
+		static u8 pla_patch4_a[] = {
+			0x08, 0xe0, 0x0c, 0xe0,
+			0x10, 0xe0, 0x3e, 0xe0,
+			0x40, 0xe0, 0x42, 0xe0,
+			0x44, 0xe0, 0x46, 0xe0,
+			0x03, 0xb4, 0x02, 0xb4,
+			0x02, 0xc7, 0x00, 0xbf,
+			0xb4, 0x03, 0x02, 0xb0,
+			0x03, 0xb0, 0x02, 0xc6,
+			0x00, 0xbe, 0x8c, 0x05,
+			0xaf, 0x49, 0x17, 0xf1,
+			0x20, 0xc6, 0x00, 0x1a,
+			0x23, 0xe8, 0x21, 0xc6,
+			0xc0, 0x61, 0x91, 0x49,
+			0x0c, 0xf0, 0x95, 0x49,
+			0x0a, 0xf1, 0x14, 0x48,
+			0x16, 0xc6, 0x81, 0x1a,
+			0x19, 0xe8, 0x14, 0xc6,
+			0xc0, 0x62, 0x24, 0x48,
+			0xc0, 0x8a, 0x0c, 0xe0,
+			0x10, 0xc6, 0xc0, 0x62,
+			0xa5, 0x49, 0x08, 0xf1,
+			0x0d, 0xc6, 0xc0, 0x62,
+			0xa0, 0x48, 0xc0, 0x8a,
+			0xc2, 0x62, 0xa3, 0x48,
+			0xc2, 0x8a, 0x02, 0xc6,
+			0x00, 0xbe, 0xd2, 0x16,
+			0x84, 0xd2, 0x6a, 0xdc,
+			0x90, 0xd3, 0x66, 0xb4,
+			0x08, 0xea, 0xff, 0xc0,
+			0x04, 0x9e, 0x00, 0x99,
+			0x06, 0x8a, 0x06, 0x72,
+			0xaf, 0x49, 0xfe, 0xf1,
+			0x80, 0xff, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x00, 0x00, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x00, 0x00, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00};
+		u8 new_ver;
+
+		rtl_fw_ver_erase(tp);
+
+		new_ver = 2;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_USB_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_USB);
+
+			generic_ocp_write(tp, 0xe600, 0xff,
+					  sizeof(usb_patch4_a), usb_patch4_a,
+					  MCU_TYPE_USB);
+
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xc000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x11e2);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x1268);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x35c0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x1538);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x2f4e);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x2cd8);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x7c26);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x7c90);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x0000);
+//			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0x00df);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_USB_VER,
+				       new_ver);
+		}
+
+//		ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_FIX_EN1,
+//				  FW_IP_RESET_EN);
+
+//		ocp_write_dword(tp, MCU_TYPE_USB, 0xd480, 0x4026840e);
+//		ocp_write_dword(tp, MCU_TYPE_USB, 0xd480, 0x4001acc9);
+
+		new_ver = 2;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_PLA_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+			generic_ocp_write(tp, 0xf800, 0xff,
+					  sizeof(pla_patch4_a), pla_patch4_a,
+					  MCU_TYPE_PLA);
+
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_BA, 0x8000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_0, 0x03b2);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_1, 0x058a);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_2, 0x16c0);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_3, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_4, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_5, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_6, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_7, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x0007);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_PLA_VER,
+				       new_ver);
+		}
+	} else if (tp->version == RTL_VER_13 || tp->version == RTL_VER_15) {
+		static u8 usb_patch_13[] = {
+			0x10, 0xe0, 0x25, 0xe0,
+			0x29, 0xe0, 0x2d, 0xe0,
+			0x52, 0xe0, 0xff, 0xe0,
+			0x02, 0xe1, 0x06, 0xe1,
+			0x16, 0xe1, 0x18, 0xe1,
+			0x48, 0xe1, 0x72, 0xe1,
+			0x80, 0xe1, 0x8f, 0xe1,
+			0x96, 0xe1, 0x98, 0xe1,
+			0x13, 0xc3, 0x60, 0x70,
+			0x8b, 0x49, 0x0d, 0xf1,
+			0x10, 0xc3, 0x60, 0x60,
+			0x85, 0x49, 0x09, 0xf1,
+			0x40, 0x03, 0x64, 0x60,
+			0x82, 0x49, 0x05, 0xf1,
+			0x09, 0xc3, 0x60, 0x60,
+			0x80, 0x48, 0x60, 0x88,
+			0x02, 0xc0, 0x00, 0xb8,
+			0xde, 0x0f, 0xca, 0xcf,
+			0x00, 0xd8, 0x1e, 0xb4,
+			0x04, 0xc3, 0x02, 0xc0,
+			0x00, 0xb8, 0x62, 0x36,
+			0xce, 0xd3, 0x04, 0xc3,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x7a, 0x14, 0xce, 0xd3,
+			0x00, 0xb4, 0x01, 0xb4,
+			0x02, 0xb4, 0x03, 0xb4,
+			0x1f, 0xc1, 0x02, 0x1b,
+			0x2c, 0x8b, 0x0c, 0x62,
+			0xa7, 0x49, 0x0a, 0xf1,
+			0x00, 0x1b, 0x08, 0x72,
+			0x13, 0x40, 0x04, 0xf1,
+			0x0a, 0x72, 0x13, 0x40,
+			0x03, 0xf0, 0x01, 0x1b,
+			0x2c, 0x8b, 0x12, 0xc0,
+			0x01, 0x1a, 0x08, 0x8a,
+			0x0a, 0x8a, 0x0d, 0xc0,
+			0x12, 0x71, 0x19, 0x48,
+			0x1a, 0x48, 0x12, 0x99,
+			0x03, 0xb0, 0x02, 0xb0,
+			0x01, 0xb0, 0x00, 0xb0,
+			0x02, 0xc0, 0x00, 0xb8,
+			0xb0, 0x77, 0x20, 0xc3,
+			0x18, 0xb4, 0x80, 0xcb,
+			0x00, 0xb4, 0x01, 0xb4,
+			0x02, 0xb4, 0x03, 0xb4,
+			0x07, 0xb4, 0x23, 0xc0,
+			0x24, 0xc1, 0x08, 0x1a,
+			0x2a, 0x8a, 0x24, 0x01,
+			0x0d, 0x1a, 0x20, 0x9a,
+			0x24, 0x09, 0x00, 0x1a,
+			0x22, 0x9a, 0x04, 0x72,
+			0x06, 0x73, 0x18, 0xc7,
+			0xe4, 0x9a, 0xe6, 0x9b,
+			0x17, 0xc2, 0x17, 0xc3,
+			0xe0, 0x9a, 0xe2, 0x9b,
+			0x80, 0x1b, 0x32, 0x8b,
+			0x00, 0x1a, 0x24, 0x9f,
+			0x26, 0x9a, 0x01, 0x1a,
+			0x28, 0x8a, 0x0f, 0xe8,
+			0x07, 0xb0, 0x03, 0xb0,
+			0x02, 0xb0, 0x01, 0xb0,
+			0x00, 0xb0, 0x02, 0xc6,
+			0x00, 0xbe, 0xe6, 0x60,
+			0x00, 0xc3, 0x20, 0xc3,
+			0x80, 0xcb, 0x55, 0x53,
+			0x42, 0x53, 0x80, 0xcb,
+			0x03, 0xb4, 0x06, 0xb4,
+			0x07, 0xb4, 0xfc, 0xc7,
+			0x79, 0xc7, 0xe0, 0x73,
+			0xba, 0x49, 0x0d, 0xf0,
+			0xf7, 0xc6, 0x24, 0x06,
+			0xc0, 0x77, 0xfa, 0x25,
+			0x76, 0x23, 0x66, 0x27,
+			0x70, 0xc7, 0xe1, 0x9e,
+			0x00, 0x16, 0x10, 0xf0,
+			0x01, 0x03, 0x0e, 0xe0,
+			0xb9, 0x49, 0x10, 0xf0,
+			0xe9, 0xc6, 0x24, 0x06,
+			0xc0, 0x77, 0xf9, 0x25,
+			0x77, 0x23, 0x67, 0x27,
+			0x62, 0xc7, 0xe1, 0x9e,
+			0x00, 0x16, 0x02, 0xf0,
+			0x01, 0x03, 0x5e, 0xc7,
+			0xe0, 0x8b, 0x12, 0xe8,
+			0x0d, 0xe0, 0xda, 0xc6,
+			0x24, 0x06, 0xc0, 0x77,
+			0xf6, 0x25, 0x7a, 0x23,
+			0x6a, 0x27, 0x53, 0xc7,
+			0xe1, 0x9e, 0x00, 0x16,
+			0xf3, 0xf0, 0x01, 0x03,
+			0xf1, 0xe7, 0x07, 0xb0,
+			0x06, 0xb0, 0x03, 0xb0,
+			0x80, 0xff, 0x03, 0xb4,
+			0x06, 0xb4, 0x07, 0xb4,
+			0xc7, 0xc6, 0xc4, 0x77,
+			0x40, 0xc3, 0x7c, 0x9f,
+			0x41, 0xc6, 0xc0, 0x73,
+			0xba, 0x49, 0x05, 0xf1,
+			0x00, 0x13, 0x05, 0xf1,
+			0x39, 0xc3, 0x04, 0xe0,
+			0x38, 0xc3, 0x02, 0xe0,
+			0x40, 0x1b, 0xb8, 0xc6,
+			0xfb, 0x31, 0xc4, 0x9f,
+			0x35, 0xc6, 0xc0, 0x67,
+			0x01, 0x17, 0x07, 0xfc,
+			0x30, 0xc6, 0xc1, 0x77,
+			0x01, 0x1b, 0xc0, 0x8b,
+			0x00, 0x17, 0x0c, 0xf1,
+			0x29, 0xc6, 0xc0, 0x73,
+			0xba, 0x49, 0x05, 0xf1,
+			0xb9, 0x49, 0x05, 0xf0,
+			0x21, 0xc7, 0x04, 0xe0,
+			0x20, 0xc7, 0x02, 0xe0,
+			0x40, 0x1f, 0x1a, 0xc6,
+			0x7e, 0x41, 0x1d, 0xc6,
+			0xc0, 0x63, 0xbb, 0x21,
+			0xbb, 0x41, 0x15, 0xc3,
+			0x66, 0x9f, 0x18, 0xc6,
+			0xc0, 0x67, 0xf9, 0x3b,
+			0xc0, 0x8f, 0x01, 0x17,
+			0x03, 0xfd, 0x00, 0x1f,
+			0x02, 0xe0, 0x01, 0x1f,
+			0x0e, 0xc6, 0xc0, 0x8f,
+			0x08, 0xc3, 0x04, 0x1e,
+			0x60, 0x8e, 0x07, 0xb0,
+			0x06, 0xb0, 0x03, 0xb0,
+			0x80, 0xff, 0xff, 0x07,
+			0x40, 0xd4, 0x00, 0x02,
+			0x00, 0x04, 0x80, 0xb9,
+			0xfd, 0xcb, 0xa2, 0xcb,
+			0xe8, 0x74, 0x02, 0xc5,
+			0x00, 0xbd, 0x96, 0x6d,
+			0x04, 0xc4, 0x02, 0xc3,
+			0x00, 0xbb, 0x50, 0x28,
+			0x7f, 0x00, 0x00, 0x1e,
+			0x00, 0x11, 0x0c, 0xf0,
+			0x90, 0x49, 0x04, 0xf1,
+			0x01, 0x06, 0x91, 0x24,
+			0xfa, 0xe7, 0x28, 0x32,
+			0x06, 0x43, 0xf8, 0x31,
+			0x01, 0x06, 0x91, 0x24,
+			0xf4, 0xe7, 0x02, 0xc0,
+			0x00, 0xb8, 0x0e, 0x28,
+			0x02, 0xc7, 0x00, 0xbf,
+			0x48, 0x31, 0x57, 0xc6,
+			0xc0, 0x71, 0x9f, 0x49,
+			0x08, 0xf0, 0x52, 0xc6,
+			0x00, 0x19, 0x98, 0x20,
+			0xc0, 0x99, 0xc2, 0x99,
+			0xc4, 0x99, 0xc6, 0x99,
+			0x20, 0xc6, 0xc0, 0x61,
+			0x04, 0x11, 0x05, 0xf0,
+			0x1e, 0xc6, 0x02, 0x19,
+			0xc0, 0x89, 0x15, 0xe0,
+			0x19, 0xc6, 0xc0, 0x61,
+			0x9c, 0x20, 0x9c, 0x24,
+			0x09, 0x11, 0xf7, 0xf1,
+			0x14, 0xc6, 0x01, 0x19,
+			0xc0, 0x89, 0x13, 0xc1,
+			0x13, 0xc6, 0x24, 0x9e,
+			0x00, 0x1e, 0x26, 0x8e,
+			0x26, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0x22, 0x76,
+			0x08, 0xc1, 0x22, 0x9e,
+			0x07, 0xc6, 0x02, 0xc1,
+			0x00, 0xb9, 0xae, 0x09,
+			0x18, 0xb4, 0x4a, 0xb4,
+			0xe0, 0xcc, 0x80, 0xd4,
+			0x08, 0xdc, 0x10, 0xe8,
+			0xfc, 0xc6, 0xc0, 0x67,
+			0xf0, 0x49, 0x1e, 0xf0,
+			0xf0, 0x48, 0xc0, 0x8f,
+			0xc2, 0x77, 0xf7, 0xc1,
+			0xf7, 0xc6, 0x24, 0x9e,
+			0x22, 0x9f, 0x8c, 0x1e,
+			0x26, 0x8e, 0x26, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xfb, 0x49, 0x10, 0xf0,
+			0x12, 0xc6, 0xc0, 0x61,
+			0x10, 0x48, 0xc0, 0x89,
+			0x11, 0xc6, 0x11, 0xc1,
+			0xc0, 0x99, 0x10, 0xc6,
+			0xc0, 0x71, 0x18, 0x48,
+			0xc0, 0x99, 0x0d, 0xc6,
+			0xc0, 0x71, 0x11, 0x48,
+			0xc0, 0x99, 0x02, 0xc6,
+			0x00, 0xbe, 0x06, 0x5f,
+			0x6c, 0xb4, 0xf8, 0xc6,
+			0xca, 0xd3, 0x40, 0xd3,
+			0x4b, 0x80, 0x34, 0xd3,
+			0xe8, 0xd4, 0xfb, 0xc2,
+			0x40, 0x71, 0x9f, 0x49,
+			0x08, 0xf0, 0xf6, 0xc2,
+			0x00, 0x19, 0x98, 0x20,
+			0x40, 0x99, 0x42, 0x99,
+			0x44, 0x99, 0x46, 0x99,
+			0x13, 0xc2, 0x02, 0xc1,
+			0x00, 0xb9, 0x04, 0x5a,
+			0xec, 0xc1, 0x20, 0x72,
+			0xaf, 0x49, 0x08, 0xf0,
+			0xe7, 0xc1, 0x00, 0x1a,
+			0x28, 0x21, 0x20, 0x9a,
+			0x22, 0x9a, 0x24, 0x9a,
+			0x26, 0x9a, 0x04, 0xc1,
+			0x02, 0xc2, 0x00, 0xba,
+			0xc2, 0x5b, 0xca, 0xcf,
+			0x40, 0x71, 0x90, 0x48,
+			0x91, 0x48, 0x92, 0x48,
+			0x40, 0x99, 0x02, 0xc0,
+			0x00, 0xb8, 0x8e, 0x20,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00};
+		static u8 pla_patch_13[] = {
+			0x10, 0xe0, 0x1c, 0xe0,
+			0x20, 0xe0, 0x3a, 0xe0,
+			0xd0, 0xe0, 0xdc, 0xe0,
+			0x58, 0xe1, 0x09, 0xe0,
+			0x08, 0xe0, 0x07, 0xe0,
+			0x06, 0xe0, 0x05, 0xe0,
+			0x04, 0xe0, 0x03, 0xe0,
+			0x02, 0xe0, 0x01, 0xe0,
+			0x0c, 0xc4, 0x04, 0x40,
+			0x05, 0xf0, 0x8c, 0x26,
+			0x0b, 0x15, 0x02, 0xf0,
+			0x03, 0xe0, 0x00, 0x9a,
+			0x01, 0xe0, 0x02, 0xc4,
+			0x00, 0xbc, 0x36, 0x37,
+			0x6c, 0xe8, 0x3a, 0x73,
+			0xbb, 0x49, 0x02, 0xc6,
+			0x00, 0xbe, 0xde, 0x27,
+			0x3a, 0x73, 0xb5, 0x21,
+			0xbc, 0x25, 0x04, 0x13,
+			0x11, 0xf1, 0x12, 0x1b,
+			0x2a, 0x1d, 0x68, 0x31,
+			0xda, 0x3a, 0xab, 0x31,
+			0x00, 0x1a, 0xc0, 0x9a,
+			0x00, 0x13, 0xfb, 0xf1,
+			0x20, 0x76, 0x6e, 0x23,
+			0x6f, 0x27, 0x3c, 0x1a,
+			0xa1, 0x22, 0xb5, 0x41,
+			0xe2, 0x9e, 0xe4, 0x76,
+			0x6f, 0x48, 0xe4, 0x9e,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x62, 0x2a, 0x87, 0x49,
+			0x62, 0xf0, 0x03, 0x1b,
+			0x58, 0x41, 0x33, 0xf0,
+			0x20, 0x73, 0x0b, 0xc5,
+			0xa4, 0x74, 0xc0, 0x49,
+			0x1b, 0xf1, 0x08, 0xc4,
+			0x14, 0x40, 0x07, 0xf1,
+			0x01, 0x1c, 0xa6, 0x9c,
+			0xa0, 0x9b, 0x27, 0xe0,
+			0xb8, 0xd3, 0x6c, 0xe8,
+			0x2c, 0x26, 0x0b, 0x14,
+			0x0f, 0xf1, 0x70, 0xc4,
+			0xa6, 0x73, 0xb0, 0x49,
+			0x08, 0xf0, 0xb0, 0x48,
+			0xa6, 0x9b, 0xa0, 0x73,
+			0x80, 0x9b, 0x20, 0x73,
+			0x40, 0x83, 0x17, 0xe0,
+			0x20, 0x73, 0x40, 0x83,
+			0x14, 0xe0, 0x70, 0xc4,
+			0x22, 0x40, 0x0a, 0xf1,
+			0x38, 0x22, 0x48, 0x26,
+			0xe8, 0x14, 0x06, 0xfb,
+			0x6b, 0xc4, 0x80, 0x74,
+			0xca, 0x49, 0x02, 0xf1,
+			0xbe, 0x48, 0x40, 0x83,
+			0x56, 0xc4, 0x22, 0x40,
+			0x57, 0xf0, 0x54, 0xc4,
+			0x22, 0x40, 0x57, 0xf0,
+			0x0c, 0x1b, 0x58, 0x41,
+			0x57, 0xf0, 0x02, 0x24,
+			0x03, 0x1b, 0x58, 0x41,
+			0x53, 0xf0, 0x47, 0xc5,
+			0xa4, 0x74, 0xc0, 0x49,
+			0x0e, 0xf1, 0x2c, 0x26,
+			0x0b, 0x14, 0x0b, 0xf1,
+			0x41, 0xc4, 0x80, 0x73,
+			0xa2, 0x9b, 0xa0, 0x73,
+			0x80, 0x9b, 0x22, 0x73,
+			0x42, 0x83, 0xa2, 0x73,
+			0x80, 0x9b, 0x42, 0xe0,
+			0x22, 0x73, 0x45, 0xc4,
+			0x22, 0x40, 0x0a, 0xf1,
+			0x39, 0x22, 0x4e, 0x26,
+			0x03, 0x14, 0x06, 0xf1,
+			0x3f, 0xc4, 0x80, 0x74,
+			0xca, 0x49, 0x02, 0xf1,
+			0xbe, 0x48, 0x42, 0x83,
+			0x2a, 0xc4, 0x22, 0x40,
+			0x31, 0xf1, 0x29, 0xc4,
+			0x82, 0x83, 0x2e, 0xe0,
+			0x22, 0xc5, 0xa4, 0x74,
+			0xc0, 0x49, 0x12, 0xf1,
+			0x2c, 0x26, 0x0b, 0x14,
+			0x0f, 0xf1, 0x1b, 0xc5,
+			0x1b, 0xc4, 0xa6, 0x73,
+			0xb0, 0x49, 0x05, 0xf0,
+			0xb0, 0x48, 0xa6, 0x9b,
+			0xa0, 0x73, 0x80, 0x9b,
+			0x40, 0x73, 0x20, 0x9b,
+			0x42, 0x73, 0x22, 0x9b,
+			0x19, 0xe0, 0x86, 0x49,
+			0x03, 0xf0, 0x84, 0x49,
+			0x03, 0xf0, 0x40, 0x73,
+			0x20, 0x9b, 0x86, 0x49,
+			0x03, 0xf0, 0x85, 0x49,
+			0x0f, 0xf0, 0x42, 0x73,
+			0x22, 0x9b, 0x0c, 0xe0,
+			0xb8, 0xd3, 0x6c, 0xe8,
+			0x00, 0xc0, 0x04, 0xc0,
+			0x82, 0xcc, 0xff, 0xc4,
+			0x80, 0x83, 0xab, 0xe7,
+			0xfc, 0xc4, 0x84, 0x83,
+			0xa8, 0xe7, 0x02, 0xc5,
+			0x00, 0xbd, 0x66, 0x0a,
+			0x00, 0xea, 0x04, 0xdd,
+			0x02, 0xdd, 0x5a, 0xe8,
+			0x04, 0xe8, 0x02, 0xc1,
+			0x00, 0xb9, 0xac, 0x35,
+			0x08, 0xc1, 0x20, 0x70,
+			0x87, 0x48, 0x20, 0x98,
+			0x36, 0x70, 0x80, 0x48,
+			0x36, 0x98, 0x80, 0xff,
+			0xd4, 0xb5, 0x04, 0x10,
+			0x07, 0xf1, 0x64, 0xc1,
+			0x32, 0x70, 0x89, 0x48,
+			0x32, 0x98, 0xf1, 0xef,
+			0x18, 0xe0, 0x05, 0x10,
+			0x07, 0xf1, 0x5c, 0xc1,
+			0x32, 0x70, 0x89, 0x48,
+			0x32, 0x98, 0x5f, 0xe8,
+			0x10, 0xe0, 0x06, 0x10,
+			0x07, 0xf1, 0x54, 0xc1,
+			0x32, 0x70, 0x09, 0x48,
+			0x32, 0x98, 0x57, 0xe8,
+			0x08, 0xe0, 0x07, 0x10,
+			0x0d, 0xf1, 0x4c, 0xc1,
+			0x32, 0x70, 0x09, 0x48,
+			0x32, 0x98, 0x57, 0xe8,
+			0x47, 0xc1, 0x28, 0x70,
+			0x05, 0x48, 0x06, 0x48,
+			0x07, 0x48, 0x08, 0x48,
+			0x28, 0x98, 0xa4, 0x49,
+			0x07, 0xf0, 0x40, 0xc1,
+			0x20, 0x70, 0x00, 0x48,
+			0x01, 0x48, 0x20, 0x98,
+			0x05, 0xe0, 0x3a, 0xc1,
+			0x20, 0x70, 0x81, 0x48,
+			0x20, 0x98, 0xa5, 0x49,
+			0x07, 0xf0, 0x34, 0xc1,
+			0x40, 0x01, 0x20, 0x60,
+			0x01, 0x48, 0x20, 0x88,
+			0x06, 0xe0, 0x2e, 0xc1,
+			0x40, 0x01, 0x20, 0x60,
+			0x81, 0x48, 0x20, 0x88,
+			0xa6, 0x49, 0x06, 0xf0,
+			0x26, 0xc1, 0x30, 0x70,
+			0x02, 0x48, 0x30, 0x98,
+			0x05, 0xe0, 0x21, 0xc1,
+			0x30, 0x70, 0x82, 0x48,
+			0x30, 0x98, 0xa7, 0x49,
+			0x07, 0xf0, 0x1a, 0xc1,
+			0x28, 0x70, 0x0a, 0x48,
+			0x0b, 0x48, 0x28, 0x98,
+			0x06, 0xe0, 0x14, 0xc1,
+			0x28, 0x70, 0x8a, 0x48,
+			0x8b, 0x48, 0x28, 0x98,
+			0x12, 0xc1, 0x12, 0xc2,
+			0x24, 0x9a, 0x0c, 0xc1,
+			0x10, 0xc2, 0x20, 0x9a,
+			0x0c, 0xc1, 0x24, 0x9b,
+			0x0d, 0xc2, 0x40, 0x73,
+			0x3f, 0x48, 0x40, 0x9b,
+			0x02, 0xc1, 0x00, 0xb9,
+			0xc6, 0x36, 0x00, 0xb4,
+			0x20, 0xb4, 0x40, 0xe0,
+			0x68, 0xe8, 0x00, 0xa0,
+			0x00, 0x12, 0x58, 0xe8,
+			0x92, 0xc1, 0x20, 0x70,
+			0x87, 0x48, 0x20, 0x98,
+			0x36, 0x70, 0x00, 0x48,
+			0x36, 0x98, 0x80, 0xff,
+			0x8a, 0xc1, 0x20, 0x70,
+			0x07, 0x48, 0x20, 0x98,
+			0x36, 0x70, 0x00, 0x48,
+			0x36, 0x98, 0x80, 0xff,
+			0xa9, 0xe7, 0x02, 0xc1,
+			0x00, 0xb9, 0xc6, 0x36};
+		u8 new_ver;
+
+		rtl_fw_ver_erase(tp);
+
+		new_ver = 6;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_USB_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_USB);
+
+			generic_ocp_write(tp, 0xe600, 0xff,
+					  sizeof(usb_patch_13), usb_patch_13,
+					  MCU_TYPE_USB);
+
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xc000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x0fba);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x3660);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x1478);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x77ae);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x60e0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x6d94);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x284e);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x27f6);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x3140);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x09ac);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x5e2a);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x5a02);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x5bc0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x208a);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0x3fff);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_USB_VER,
+				       new_ver);
+		}
+
+		new_ver = 8;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_PLA_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+			generic_ocp_write(tp, 0xf800, 0xff,
+					  sizeof(pla_patch_13), pla_patch_13,
+					  MCU_TYPE_PLA);
+
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_BA, 0x8000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_0, 0x374e);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_1, 0x27dc);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_2, 0x2a5c);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_3, 0x09d0);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_4, 0x359e);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_5, 0x35b6);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_6, 0x35b4);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_7, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x007f);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_PLA_VER,
+				       new_ver);
+		}
+	}
+
+	rtl_reset_ocp_base(tp);
+}
+
+static void r8157_patch_code(struct r8152 *tp)
+{
+	if (tp->version == RTL_VER_16) {
+		static u8 usb_patch_16[] = {
+			0x10, 0xe0, 0x20, 0xe0,
+			0x22, 0xe0, 0x71, 0xe0,
+			0x75, 0xe0, 0x9b, 0xe0,
+			0xbf, 0xe0, 0xd8, 0xe0,
+			0xfb, 0xe0, 0xff, 0xe0,
+			0x08, 0xe1, 0x1c, 0xe1,
+			0x1e, 0xe1, 0x29, 0xe1,
+			0x4c, 0xe1, 0x52, 0xe1,
+			0x0d, 0xc6, 0xc0, 0x71,
+			0x91, 0x48, 0xc0, 0x99,
+			0x11, 0x48, 0xc0, 0x99,
+			0x09, 0xc6, 0x09, 0xc1,
+			0xc0, 0x99, 0x05, 0xc6,
+			0x02, 0xc1, 0x00, 0xb9,
+			0x80, 0x33, 0x86, 0xd4,
+			0x6c, 0xe4, 0x00, 0xb9,
+			0x47, 0x68, 0x02, 0xc6,
+			0x00, 0xbe, 0x32, 0x19,
+			0x27, 0xc2, 0x40, 0x71,
+			0x92, 0x49, 0x0e, 0xf1,
+			0x91, 0x49, 0x0c, 0xf1,
+			0x27, 0xc2, 0x01, 0x02,
+			0xc0, 0x9a, 0x00, 0x19,
+			0x18, 0x48, 0xc2, 0x99,
+			0x1a, 0xc1, 0xc4, 0x99,
+			0xc6, 0x9b, 0x16, 0xff,
+			0x3d, 0xe0, 0x17, 0xc2,
+			0x40, 0x73, 0xb0, 0x49,
+			0x28, 0xf0, 0x14, 0xc2,
+			0x40, 0x73, 0xbf, 0x49,
+			0x19, 0xf1, 0x11, 0xc2,
+			0x50, 0x73, 0xb0, 0x49,
+			0x15, 0xf1, 0x0e, 0xc3,
+			0x0e, 0xc2, 0x60, 0x9a,
+			0x40, 0x1a, 0x28, 0x21,
+			0x28, 0x25, 0x62, 0x9a,
+			0x17, 0xff, 0x28, 0xe0,
+			0xe0, 0x01, 0x44, 0xd8,
+			0x0c, 0xd2, 0x74, 0xd3,
+			0x00, 0xd4, 0x70, 0xd3,
+			0xe8, 0xd4, 0x04, 0xc7,
+			0xff, 0xff, 0xf2, 0xb8,
+			0x28, 0xe4, 0xfc, 0xc2,
+			0x03, 0x02, 0xc0, 0x9a,
+			0x00, 0x19, 0xc2, 0x99,
+			0x13, 0x48, 0xc4, 0x99,
+			0xf6, 0xc3, 0xc6, 0x9b,
+			0x16, 0xff, 0x12, 0xe0,
+			0xf3, 0xc2, 0x40, 0x71,
+			0x1f, 0x48, 0x40, 0x99,
+			0xf0, 0xc2, 0x01, 0x19,
+			0x42, 0x99, 0x01, 0x19,
+			0x40, 0x89, 0xe6, 0xc3,
+			0xe6, 0xc2, 0x60, 0x9a,
+			0x40, 0x1a, 0x28, 0x21,
+			0x28, 0x25, 0x62, 0x9a,
+			0x17, 0xff, 0x02, 0xc2,
+			0x00, 0xba, 0x1c, 0x2d,
+			0x00, 0x75, 0xd8, 0x49,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x36, 0xc6, 0x04, 0xf0,
+			0x02, 0xc0, 0x00, 0xb8,
+			0xb2, 0xa0, 0x1e, 0xc7,
+			0xf3, 0x66, 0xb1, 0x3b,
+			0xf3, 0x8e, 0x00, 0x16,
+			0x03, 0xf1, 0x08, 0xe8,
+			0x04, 0xe0, 0x02, 0xc6,
+			0x00, 0xbe, 0xaa, 0xa1,
+			0x02, 0xc7, 0x00, 0xbf,
+			0x82, 0xa1, 0x11, 0xc5,
+			0xa2, 0x76, 0x6a, 0x27,
+			0x6a, 0x23, 0x0e, 0xc7,
+			0x37, 0x40, 0x09, 0xf1,
+			0x0c, 0xc5, 0x0c, 0xc6,
+			0xc0, 0x9d, 0x08, 0x1d,
+			0xd8, 0x22, 0xd8, 0x26,
+			0xc2, 0x9d, 0x17, 0xff,
+			0x80, 0xff, 0x80, 0xcb,
+			0x80, 0xc3, 0x00, 0xc4,
+			0xe8, 0xd4, 0x70, 0xd3,
+			0x24, 0xc3, 0x60, 0x74,
+			0xcf, 0x49, 0x0e, 0xf1,
+			0x1c, 0xc3, 0x60, 0x74,
+			0xcf, 0x49, 0x16, 0xf0,
+			0x44, 0x22, 0x4c, 0x26,
+			0x17, 0xc3, 0x60, 0x65,
+			0xd5, 0x22, 0xd5, 0x26,
+			0x25, 0x40, 0x0e, 0xf1,
+			0x0d, 0xe0, 0xcf, 0x48,
+			0x60, 0x9c, 0x0f, 0xc3,
+			0x62, 0x74, 0x11, 0x1d,
+			0x62, 0x9d, 0x0c, 0xc3,
+			0x62, 0x75, 0xd3, 0x48,
+			0x62, 0x9d, 0x07, 0xc3,
+			0x62, 0x9c, 0x02, 0xc3,
+			0x00, 0xbb, 0x14, 0x09,
+			0x44, 0xd6, 0xf4, 0xcb,
+			0x3c, 0xd5, 0x04, 0xb7,
+			0xf2, 0xb8, 0x3a, 0xc2,
+			0x40, 0x71, 0x9f, 0x49,
+			0x06, 0xf1, 0x85, 0xc2,
+			0x50, 0x71, 0x90, 0x49,
+			0x02, 0xf1, 0x0f, 0xe0,
+			0x31, 0xc2, 0x40, 0x71,
+			0x9f, 0x48, 0x40, 0x99,
+			0x82, 0xc2, 0x00, 0x1b,
+			0x40, 0x8b, 0xef, 0xc2,
+			0x40, 0x73, 0xbf, 0x48,
+			0x40, 0x9b, 0x02, 0xc2,
+			0x00, 0xba, 0xfc, 0x5b,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x0e, 0x5c, 0x21, 0xc6,
+			0x21, 0xc1, 0xc0, 0x99,
+			0x20, 0xc0, 0xc6, 0x98,
+			0x16, 0xff, 0xc2, 0x70,
+			0x0d, 0x20, 0x0d, 0x24,
+			0x82, 0x49, 0x07, 0xf0,
+			0x13, 0xc6, 0xc0, 0x71,
+			0x9c, 0x20, 0x9c, 0x24,
+			0x03, 0x11, 0x0a, 0xf1,
+			0x0d, 0xc6, 0xc0, 0x71,
+			0x9c, 0x24, 0x06, 0x11,
+			0x05, 0xf1, 0x0a, 0xc0,
+			0x00, 0x71, 0x1f, 0x48,
+			0x00, 0x99, 0x05, 0xc0,
+			0x02, 0xc1, 0x00, 0xb9,
+			0xb4, 0x50, 0xba, 0xd4,
+			0x20, 0xd4, 0x74, 0xd3,
+			0x80, 0xcf, 0x0c, 0xc7,
+			0xff, 0xff, 0x04, 0xc6,
+			0x02, 0xc5, 0x00, 0xbd,
+			0xa4, 0x58, 0x80, 0x90,
+			0x08, 0xc5, 0x08, 0xc6,
+			0xa0, 0x77, 0xc0, 0x9f,
+			0x07, 0xb0, 0x02, 0xc6,
+			0x00, 0xbe, 0xae, 0x5a,
+			0xd8, 0xc7, 0x18, 0x90,
+			0x11, 0xc2, 0x16, 0x40,
+			0x0c, 0xf0, 0x0f, 0xc2,
+			0x16, 0x40, 0x09, 0xf0,
+			0x0d, 0xc2, 0x16, 0x40,
+			0x06, 0xf0, 0x0b, 0xc2,
+			0x16, 0x40, 0x02, 0xc2,
+			0x00, 0xba, 0x42, 0x45,
+			0x02, 0xc2, 0x00, 0xba,
+			0x46, 0x45, 0x18, 0xc0,
+			0x1a, 0xc0, 0x1c, 0xc0,
+			0x14, 0xc0, 0x02, 0xc1,
+			0x00, 0xb9, 0x1c, 0x64,
+			0x0a, 0xc0, 0x00, 0x72,
+			0xa2, 0x49, 0x03, 0xf0,
+			0x25, 0x48, 0x00, 0x9a,
+			0x05, 0xc0, 0x02, 0xc2,
+			0x00, 0xba, 0x94, 0xd0,
+			0x26, 0xd4, 0x06, 0xd4,
+			0x20, 0xc6, 0xc6, 0x75,
+			0xd5, 0x49, 0x16, 0xf0,
+			0xd5, 0x48, 0xc6, 0x9d,
+			0x1b, 0xc5, 0xa0, 0x76,
+			0x11, 0x1c, 0xa0, 0x9c,
+			0x18, 0xc4, 0x82, 0x63,
+			0xb4, 0x48, 0xb5, 0x48,
+			0xb6, 0x48, 0xb7, 0x48,
+			0x82, 0x8b, 0xa0, 0x9e,
+			0x11, 0xc4, 0x80, 0x73,
+			0xb0, 0x49, 0x04, 0xf0,
+			0xb2, 0x49, 0x02, 0xf0,
+			0x05, 0xe0, 0xf6, 0x65,
+			0x02, 0xc6, 0x00, 0xbe,
+			0xe6, 0x04, 0x02, 0xc6,
+			0x00, 0xbe, 0x5a, 0x05,
+			0x20, 0xd4, 0x3e, 0xd5,
+			0x04, 0xb7, 0x26, 0xd4,
+			0x06, 0xc1, 0x40, 0x1a,
+			0x20, 0x9a, 0x02, 0xc2,
+			0x00, 0xba, 0xb2, 0xab,
+			0x18, 0x90, 0x0e, 0xc7,
+			0xe0, 0x75, 0xd6, 0x48,
+			0xe0, 0x9d, 0x0b, 0xc7,
+			0x00, 0x1d, 0xe0, 0x8d,
+			0x09, 0xc7, 0xe0, 0x75,
+			0xdf, 0x48, 0xe0, 0x9d,
+			0x02, 0xc1, 0x00, 0xb9,
+			0xe4, 0x4f, 0xe8, 0xd4,
+			0x28, 0xe4, 0xf2, 0xb8};
+		static u8 pla_patch_16[] = {
+			0x10, 0xe0, 0x0f, 0xe0,
+			0x0e, 0xe0, 0x0d, 0xe0,
+			0x0c, 0xe0, 0x0b, 0xe0,
+			0x0a, 0xe0, 0x09, 0xe0,
+			0x08, 0xe0, 0x07, 0xe0,
+			0x06, 0xe0, 0x05, 0xe0,
+			0x04, 0xe0, 0x03, 0xe0,
+			0x02, 0xe0, 0x01, 0xe0,
+			0x08, 0xc6, 0xc0, 0x71,
+			0x90, 0x49, 0x07, 0xf0,
+			0x05, 0xc6, 0x02, 0xc1,
+			0x00, 0xb9, 0x80, 0x1e,
+			0xc8, 0xe0, 0x10, 0xd4,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x86, 0x1e, 0x00, 0x00};
+		u8 new_ver;
+
+		rtl_fw_ver_erase(tp);
+
+		new_ver = 3;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_USB_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_USB);
+
+			generic_ocp_write(tp, 0xe600, 0xff,
+					  sizeof(usb_patch_16), usb_patch_16,
+					  MCU_TYPE_USB);
+
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xf000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x337e);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x192a);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x269a);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0xc632);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0xa108);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x08f4);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x5be6);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x50b2);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x453e);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0xd092);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x04e4);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0xa93e);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x5074);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0x74ff);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_USB_VER,
+				       new_ver);
+		}
+
+		new_ver = 1;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_PLA_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+			generic_ocp_write(tp, 0xf800, 0xff,
+					  sizeof(pla_patch_16), pla_patch_16,
+					  MCU_TYPE_PLA);
+
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_BA, 0x8000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_0, 0x1e7e);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x0001);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_PLA_VER,
+				       new_ver);
+		}
+	}
+}
+
+static void r8159_patch_code(struct r8152 *tp)
+{
+}
+
+static int rtl_ram_code_speed_up(struct r8152 *tp, bool wait)
+{
+	u16 fw_version, code_ver;
+	u32 len = 0, ocp_data;
+	u8 *data = NULL;
+	int ret = 0;
+
+	rtl_reset_ocp_base(tp);
+
+	if (tp->version == RTL_VER_13 || tp->version == RTL_VER_15) {
+		static u8 ram13[] = {
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x24, 0x80,
+			0x38, 0xb4, 0x01, 0x37,
+			0x36, 0xb4, 0x2e, 0xb8,
+			0x38, 0xb4, 0x01, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0,
+			0x20, 0xb8, 0x90, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x10, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3f, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x45, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x67, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x6d, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x71, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xb1, 0x80,
+			0x38, 0xb4, 0x93, 0xd0,
+			0x38, 0xb4, 0xc4, 0xd1,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xbc, 0x5f,
+			0x38, 0xb4, 0x04, 0xd5,
+			0x38, 0xb4, 0xf1, 0xc9,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xc9, 0x0f,
+			0x38, 0xb4, 0x50, 0xbb,
+			0x38, 0xb4, 0x05, 0xd5,
+			0x38, 0xb4, 0x02, 0xa2,
+			0x38, 0xb4, 0x04, 0xd5,
+			0x38, 0xb4, 0x0f, 0x8c,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x19, 0x15,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x5e, 0xd7,
+			0x38, 0xb4, 0xae, 0x5f,
+			0x38, 0xb4, 0x50, 0x9b,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x5e, 0xd7,
+			0x38, 0xb4, 0xae, 0x7f,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x07, 0xd7,
+			0x38, 0xb4, 0xa7, 0x40,
+			0x38, 0xb4, 0x19, 0xd7,
+			0x38, 0xb4, 0x71, 0x40,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x57, 0x15,
+			0x38, 0xb4, 0x19, 0xd7,
+			0x38, 0xb4, 0x70, 0x2f,
+			0x38, 0xb4, 0x3b, 0x80,
+			0x38, 0xb4, 0x73, 0x2f,
+			0x38, 0xb4, 0x6a, 0x15,
+			0x38, 0xb4, 0x70, 0x5e,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x5d, 0x15,
+			0x38, 0xb4, 0x05, 0xd5,
+			0x38, 0xb4, 0x02, 0xa2,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0xed, 0xff,
+			0x38, 0xb4, 0x09, 0xd7,
+			0x38, 0xb4, 0x54, 0x40,
+			0x38, 0xb4, 0x88, 0xa7,
+			0x38, 0xb4, 0x0b, 0xd7,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2a, 0x17,
+			0x38, 0xb4, 0xc1, 0xc0,
+			0x38, 0xb4, 0xc0, 0xc0,
+			0x38, 0xb4, 0x5a, 0xd0,
+			0x38, 0xb4, 0xba, 0xd1,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0x29, 0x25,
+			0x38, 0xb4, 0x2a, 0x02,
+			0x38, 0xb4, 0xa7, 0xd0,
+			0x38, 0xb4, 0xb9, 0xd1,
+			0x38, 0xb4, 0x08, 0xa2,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x0e, 0x08,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0x8b, 0x40,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x65, 0x0a,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x0a,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x20, 0x09,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x15, 0x09,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x09, 0x09,
+			0x38, 0xb4, 0x8f, 0x22,
+			0x38, 0xb4, 0x4e, 0x80,
+			0x38, 0xb4, 0x01, 0x98,
+			0x38, 0xb4, 0x1e, 0xd7,
+			0x38, 0xb4, 0x61, 0x5d,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2a, 0x02,
+			0x38, 0xb4, 0x05, 0x20,
+			0x38, 0xb4, 0x1a, 0x09,
+			0x38, 0xb4, 0xd9, 0x3b,
+			0x38, 0xb4, 0x19, 0x09,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x16, 0x09,
+			0x38, 0xb4, 0x90, 0xd0,
+			0x38, 0xb4, 0xc9, 0xd1,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x64, 0x10,
+			0x38, 0xb4, 0x96, 0xd0,
+			0x38, 0xb4, 0xa9, 0xd1,
+			0x38, 0xb4, 0x03, 0xd5,
+			0x38, 0xb4, 0x04, 0xa1,
+			0x38, 0xb4, 0x07, 0x0c,
+			0x38, 0xb4, 0x02, 0x09,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x10, 0xbc,
+			0x38, 0xb4, 0x01, 0xd5,
+			0x38, 0xb4, 0x01, 0xce,
+			0x38, 0xb4, 0x01, 0xa2,
+			0x38, 0xb4, 0x01, 0x82,
+			0x38, 0xb4, 0x00, 0xce,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x84, 0xc4,
+			0x38, 0xb4, 0x03, 0xd5,
+			0x38, 0xb4, 0x02, 0xcc,
+			0x38, 0xb4, 0x0d, 0xcd,
+			0x38, 0xb4, 0x01, 0xaf,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x03, 0xd7,
+			0x38, 0xb4, 0x71, 0x43,
+			0x38, 0xb4, 0x08, 0xbd,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x5e, 0xd7,
+			0x38, 0xb4, 0xb3, 0x5f,
+			0x38, 0xb4, 0x03, 0xd5,
+			0x38, 0xb4, 0xf5, 0xd0,
+			0x38, 0xb4, 0xc6, 0xd1,
+			0x38, 0xb4, 0xf0, 0x0c,
+			0x38, 0xb4, 0x50, 0x0e,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x1c, 0x40,
+			0x38, 0xb4, 0xf5, 0xd0,
+			0x38, 0xb4, 0xc6, 0xd1,
+			0x38, 0xb4, 0xf0, 0x0c,
+			0x38, 0xb4, 0xa0, 0x0e,
+			0x38, 0xb4, 0x1c, 0x40,
+			0x38, 0xb4, 0x7b, 0xd0,
+			0x38, 0xb4, 0xc5, 0xd1,
+			0x38, 0xb4, 0xf0, 0x8e,
+			0x38, 0xb4, 0x1c, 0x40,
+			0x38, 0xb4, 0x08, 0x9d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x5e, 0xd7,
+			0x38, 0xb4, 0xb3, 0x7f,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x5e, 0xd7,
+			0x38, 0xb4, 0xad, 0x5f,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xc5, 0x14,
+			0x38, 0xb4, 0x03, 0xd7,
+			0x38, 0xb4, 0x81, 0x31,
+			0x38, 0xb4, 0xaf, 0x80,
+			0x38, 0xb4, 0xad, 0x60,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x03, 0xd7,
+			0x38, 0xb4, 0xba, 0x5f,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xc7, 0x0c,
+			0x38, 0xb4, 0x02, 0xa8,
+			0x38, 0xb4, 0x01, 0xa3,
+			0x38, 0xb4, 0x01, 0xa8,
+			0x38, 0xb4, 0x04, 0xc0,
+			0x38, 0xb4, 0x10, 0xd7,
+			0x38, 0xb4, 0x00, 0x40,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x79, 0x1e,
+			0x36, 0xb4, 0x26, 0xa0,
+			0x38, 0xb4, 0x78, 0x1e,
+			0x36, 0xb4, 0x24, 0xa0,
+			0x38, 0xb4, 0x93, 0x0c,
+			0x36, 0xb4, 0x22, 0xa0,
+			0x38, 0xb4, 0x62, 0x10,
+			0x36, 0xb4, 0x20, 0xa0,
+			0x38, 0xb4, 0x15, 0x09,
+			0x36, 0xb4, 0x06, 0xa0,
+			0x38, 0xb4, 0x0a, 0x02,
+			0x36, 0xb4, 0x04, 0xa0,
+			0x38, 0xb4, 0x26, 0x17,
+			0x36, 0xb4, 0x02, 0xa0,
+			0x38, 0xb4, 0x42, 0x15,
+			0x36, 0xb4, 0x00, 0xa0,
+			0x38, 0xb4, 0xc7, 0x0f,
+			0x36, 0xb4, 0x08, 0xa0,
+			0x38, 0xb4, 0x00, 0xff,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x10, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x10, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1d, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2c, 0x80,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x90, 0x60,
+			0x38, 0xb4, 0xd1, 0x60,
+			0x38, 0xb4, 0x5c, 0xc9,
+			0x38, 0xb4, 0x07, 0xf0,
+			0x38, 0xb4, 0xb1, 0x60,
+			0x38, 0xb4, 0x5a, 0xc9,
+			0x38, 0xb4, 0x04, 0xf0,
+			0x38, 0xb4, 0x56, 0xc9,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x4e, 0xc9,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xcd, 0x00,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x90, 0x60,
+			0x38, 0xb4, 0xd1, 0x60,
+			0x38, 0xb4, 0x5c, 0xc9,
+			0x38, 0xb4, 0x07, 0xf0,
+			0x38, 0xb4, 0xb1, 0x60,
+			0x38, 0xb4, 0x5a, 0xc9,
+			0x38, 0xb4, 0x04, 0xf0,
+			0x38, 0xb4, 0x56, 0xc9,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x4e, 0xc9,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x2a, 0x02,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x32, 0x01,
+			0x36, 0xb4, 0x8e, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x8c, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x8a, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x88, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x86, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x84, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x82, 0xa0,
+			0x38, 0xb4, 0x2f, 0x01,
+			0x36, 0xb4, 0x80, 0xa0,
+			0x38, 0xb4, 0xcc, 0x00,
+			0x36, 0xb4, 0x90, 0xa0,
+			0x38, 0xb4, 0x03, 0x01,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x20, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x10, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x20, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x35, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3c, 0x80,
+			0x38, 0xb4, 0x07, 0xd1,
+			0x38, 0xb4, 0x42, 0xd0,
+			0x38, 0xb4, 0x04, 0xa4,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xdf, 0x09,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x80, 0x82,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x65, 0x60,
+			0x38, 0xb4, 0x25, 0xd1,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x2b, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x7f, 0x07,
+			0x38, 0xb4, 0xf0, 0x0c,
+			0x38, 0xb4, 0x50, 0x0c,
+			0x38, 0xb4, 0x04, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xa8, 0x0a,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2e, 0x0a,
+			0x38, 0xb4, 0x9b, 0xcb,
+			0x38, 0xb4, 0x10, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x7b, 0x0b,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xdf, 0x09,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1b, 0x08,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xdf, 0x09,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xb8, 0x7f,
+			0x38, 0xb4, 0x18, 0xa7,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x4e, 0x07,
+			0x36, 0xb4, 0x0e, 0xa1,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x0c, 0xa1,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x0a, 0xa1,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x08, 0xa1,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x06, 0xa1,
+			0x38, 0xb4, 0x4d, 0x07,
+			0x36, 0xb4, 0x04, 0xa1,
+			0x38, 0xb4, 0x18, 0x08,
+			0x36, 0xb4, 0x02, 0xa1,
+			0x38, 0xb4, 0x2c, 0x0a,
+			0x36, 0xb4, 0x00, 0xa1,
+			0x38, 0xb4, 0x7e, 0x07,
+			0x36, 0xb4, 0x10, 0xa1,
+			0x38, 0xb4, 0x0f, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0x25, 0x86,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0x86, 0xaf,
+			0x38, 0xb4, 0xaf, 0x3d,
+			0x38, 0xb4, 0x89, 0x86,
+			0x38, 0xb4, 0x88, 0xaf,
+			0x38, 0xb4, 0xaf, 0x69,
+			0x38, 0xb4, 0x87, 0x88,
+			0x38, 0xb4, 0x88, 0xaf,
+			0x38, 0xb4, 0xaf, 0x9c,
+			0x38, 0xb4, 0x9c, 0x88,
+			0x38, 0xb4, 0x88, 0xaf,
+			0x38, 0xb4, 0xaf, 0x9c,
+			0x38, 0xb4, 0x9c, 0x88,
+			0x38, 0xb4, 0x86, 0xbf,
+			0x38, 0xb4, 0xd7, 0x49,
+			0x38, 0xb4, 0x40, 0x00,
+			0x38, 0xb4, 0x77, 0x02,
+			0x38, 0xb4, 0xaf, 0x7d,
+			0x38, 0xb4, 0x27, 0x27,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x05, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x08, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0xf3, 0x71,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0xf6, 0x71,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x29, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x2c, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x17, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x1a, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x1d, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x11, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x20, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x14, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x2f, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x23, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x32, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x26, 0x72,
+			0x38, 0xb4, 0xf9, 0xf8,
+			0x38, 0xb4, 0xe0, 0xfa,
+			0x38, 0xb4, 0xb3, 0x85,
+			0x38, 0xb4, 0x02, 0x38,
+			0x38, 0xb4, 0x27, 0xad,
+			0x38, 0xb4, 0xae, 0x02,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0x30, 0x88,
+			0x38, 0xb4, 0x66, 0x1f,
+			0x38, 0xb4, 0x65, 0xef,
+			0x38, 0xb4, 0xc2, 0xbf,
+			0x38, 0xb4, 0x1a, 0x1f,
+			0x38, 0xb4, 0xf7, 0x96,
+			0x38, 0xb4, 0xee, 0x05,
+			0x38, 0xb4, 0xd2, 0xff,
+			0x38, 0xb4, 0xda, 0x00,
+			0x38, 0xb4, 0x05, 0xf6,
+			0x38, 0xb4, 0xc2, 0xbf,
+			0x38, 0xb4, 0x1a, 0x2f,
+			0x38, 0xb4, 0xf7, 0x96,
+			0x38, 0xb4, 0xee, 0x05,
+			0x38, 0xb4, 0xd2, 0xff,
+			0x38, 0xb4, 0xdb, 0x00,
+			0x38, 0xb4, 0x05, 0xf6,
+			0x38, 0xb4, 0x02, 0xef,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x42, 0x0d,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x42,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x02, 0xef,
+			0x38, 0xb4, 0x03, 0x1b,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x42, 0x0d,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x45,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x02, 0xef,
+			0x38, 0xb4, 0x03, 0x1a,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x42, 0x0d,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x48,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0xc2, 0xbf,
+			0x38, 0xb4, 0x1a, 0x3f,
+			0x38, 0xb4, 0xf7, 0x96,
+			0x38, 0xb4, 0xee, 0x05,
+			0x38, 0xb4, 0xd2, 0xff,
+			0x38, 0xb4, 0xda, 0x00,
+			0x38, 0xb4, 0x05, 0xf6,
+			0x38, 0xb4, 0xc2, 0xbf,
+			0x38, 0xb4, 0x1a, 0x4f,
+			0x38, 0xb4, 0xf7, 0x96,
+			0x38, 0xb4, 0xee, 0x05,
+			0x38, 0xb4, 0xd2, 0xff,
+			0x38, 0xb4, 0xdb, 0x00,
+			0x38, 0xb4, 0x05, 0xf6,
+			0x38, 0xb4, 0x02, 0xef,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x42, 0x0d,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x4b,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x02, 0xef,
+			0x38, 0xb4, 0x03, 0x1b,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x42, 0x0d,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x4e,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x02, 0xef,
+			0x38, 0xb4, 0x03, 0x1a,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x42, 0x0d,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x51,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x56, 0xef,
+			0x38, 0xb4, 0x20, 0xd0,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x54,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x57,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x5a,
+			0xff, 0xff, 0xff, 0xff,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xef, 0xa0,
+			0x38, 0xb4, 0x48, 0x03,
+			0x38, 0xb4, 0x28, 0x0a,
+			0x38, 0xb4, 0xef, 0x05,
+			0x38, 0xb4, 0x1b, 0x20,
+			0x38, 0xb4, 0xad, 0x01,
+			0x38, 0xb4, 0x35, 0x27,
+			0x38, 0xb4, 0x44, 0x1f,
+			0x38, 0xb4, 0x85, 0xe0,
+			0x38, 0xb4, 0xe1, 0x88,
+			0x38, 0xb4, 0x89, 0x85,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x5d,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x85, 0xe0,
+			0x38, 0xb4, 0xe1, 0x8e,
+			0x38, 0xb4, 0x8f, 0x85,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x60,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x85, 0xe0,
+			0x38, 0xb4, 0xe1, 0x94,
+			0x38, 0xb4, 0x95, 0x85,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x63,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x85, 0xe0,
+			0x38, 0xb4, 0xe1, 0x9a,
+			0x38, 0xb4, 0x9b, 0x85,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x66,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x88, 0xaf,
+			0x38, 0xb4, 0xbf, 0x3c,
+			0x38, 0xb4, 0x3f, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xad, 0x9c,
+			0x38, 0xb4, 0x35, 0x28,
+			0x38, 0xb4, 0x44, 0x1f,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xe1, 0xf8,
+			0x38, 0xb4, 0xf9, 0x8f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x5d,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xe1, 0xfa,
+			0x38, 0xb4, 0xfb, 0x8f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x60,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xe1, 0xfc,
+			0x38, 0xb4, 0xfd, 0x8f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x63,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xe1, 0xfe,
+			0x38, 0xb4, 0xff, 0x8f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x66,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x88, 0xaf,
+			0x38, 0xb4, 0xe1, 0x3c,
+			0x38, 0xb4, 0xa1, 0x85,
+			0x38, 0xb4, 0x21, 0x1b,
+			0x38, 0xb4, 0x37, 0xad,
+			0x38, 0xb4, 0x1f, 0x34,
+			0x38, 0xb4, 0xe0, 0x44,
+			0x38, 0xb4, 0x8a, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x8b,
+			0x38, 0xb4, 0x5d, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xe0, 0x7d,
+			0x38, 0xb4, 0x90, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x91,
+			0x38, 0xb4, 0x60, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xe0, 0x7d,
+			0x38, 0xb4, 0x96, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x97,
+			0x38, 0xb4, 0x63, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xe0, 0x7d,
+			0x38, 0xb4, 0x9c, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x9d,
+			0x38, 0xb4, 0x66, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xae, 0x7d,
+			0x38, 0xb4, 0x1f, 0x40,
+			0x38, 0xb4, 0xe0, 0x44,
+			0x38, 0xb4, 0x8c, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x8d,
+			0x38, 0xb4, 0x5d, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xe0, 0x7d,
+			0x38, 0xb4, 0x92, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x93,
+			0x38, 0xb4, 0x60, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xe0, 0x7d,
+			0x38, 0xb4, 0x98, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x99,
+			0x38, 0xb4, 0x63, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xe0, 0x7d,
+			0x38, 0xb4, 0x9e, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x9f,
+			0x38, 0xb4, 0x66, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xae, 0x7d,
+			0x38, 0xb4, 0xe1, 0x0c,
+			0x38, 0xb4, 0xb3, 0x85,
+			0x38, 0xb4, 0x04, 0x39,
+			0x38, 0xb4, 0x2f, 0xac,
+			0x38, 0xb4, 0xee, 0x04,
+			0x38, 0xb4, 0xb3, 0x85,
+			0x38, 0xb4, 0xaf, 0x00,
+			0x38, 0xb4, 0xd9, 0x39,
+			0x38, 0xb4, 0xac, 0x22,
+			0x38, 0xb4, 0xf0, 0xea,
+			0x38, 0xb4, 0xf6, 0xac,
+			0x38, 0xb4, 0xac, 0xf0,
+			0x38, 0xb4, 0xf0, 0xfa,
+			0x38, 0xb4, 0xf8, 0xac,
+			0x38, 0xb4, 0xac, 0xf0,
+			0x38, 0xb4, 0xf0, 0xfc,
+			0x38, 0xb4, 0x00, 0xad,
+			0x38, 0xb4, 0xac, 0xf0,
+			0x38, 0xb4, 0xf0, 0xfe,
+			0x38, 0xb4, 0xf0, 0xac,
+			0x38, 0xb4, 0xac, 0xf0,
+			0x38, 0xb4, 0xf0, 0xf4,
+			0x38, 0xb4, 0xf2, 0xac,
+			0x38, 0xb4, 0xac, 0xf0,
+			0x38, 0xb4, 0xf0, 0xb0,
+			0x38, 0xb4, 0xae, 0xac,
+			0x38, 0xb4, 0xac, 0xf0,
+			0x38, 0xb4, 0xf0, 0xac,
+			0x38, 0xb4, 0xaa, 0xac,
+			0x38, 0xb4, 0x00, 0xa1,
+			0x38, 0xb4, 0xe1, 0x0c,
+			0x38, 0xb4, 0xf7, 0x8f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x84,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x26, 0xaf,
+			0x38, 0xb4, 0xe1, 0xe9,
+			0x38, 0xb4, 0xf6, 0x8f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x84,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x26, 0xaf,
+			0x38, 0xb4, 0x20, 0xf5,
+			0x38, 0xb4, 0x86, 0xac,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x3f,
+			0x38, 0xb4, 0x9c, 0x6e,
+			0x38, 0xb4, 0x28, 0xad,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0x24, 0x33,
+			0x38, 0xb4, 0x38, 0xad,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0xe6, 0x32,
+			0x38, 0xb4, 0x32, 0xaf,
+			0x38, 0xb4, 0x00, 0xfb,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0xf6, 0x8f,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0x05, 0x07,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0xf8, 0x8f,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0xcc, 0x19,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0xfa, 0x8f,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0xe3, 0x28,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0xfc, 0x8f,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0x47, 0x10,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0xfe, 0x8f,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0x45, 0x0a,
+			0x36, 0xb4, 0x5e, 0xb8,
+			0x38, 0xb4, 0x1e, 0x27,
+			0x36, 0xb4, 0x60, 0xb8,
+			0x38, 0xb4, 0x46, 0x38,
+			0x36, 0xb4, 0x62, 0xb8,
+			0x38, 0xb4, 0xe6, 0x26,
+			0x36, 0xb4, 0x64, 0xb8,
+			0x38, 0xb4, 0xe3, 0x32,
+			0x36, 0xb4, 0x86, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x88, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x8a, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x8c, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x38, 0xb8,
+			0x38, 0xb4, 0x0f, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0,
+			0x20, 0xb8, 0x10, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x6e, 0x84,
+			0x38, 0xb4, 0x84, 0xaf,
+			0x38, 0xb4, 0xaf, 0x86,
+			0x38, 0xb4, 0x90, 0x86,
+			0x38, 0xb4, 0x86, 0xaf,
+			0x38, 0xb4, 0xaf, 0xa4,
+			0x38, 0xb4, 0xa4, 0x86,
+			0x38, 0xb4, 0x86, 0xaf,
+			0x38, 0xb4, 0xaf, 0xa4,
+			0x38, 0xb4, 0xa4, 0x86,
+			0x38, 0xb4, 0x86, 0xaf,
+			0x38, 0xb4, 0xaf, 0xa4,
+			0x38, 0xb4, 0xa4, 0x86,
+			0x38, 0xb4, 0x82, 0xee,
+			0x38, 0xb4, 0x00, 0x5f,
+			0x38, 0xb4, 0x84, 0x02,
+			0x38, 0xb4, 0xaf, 0x90,
+			0x38, 0xb4, 0x41, 0x04,
+			0x38, 0xb4, 0xe0, 0xf8,
+			0x38, 0xb4, 0xf3, 0x8f,
+			0x38, 0xb4, 0x00, 0xa0,
+			0x38, 0xb4, 0x02, 0x05,
+			0x38, 0xb4, 0xa4, 0x84,
+			0x38, 0xb4, 0x06, 0xae,
+			0x38, 0xb4, 0x01, 0xa0,
+			0x38, 0xb4, 0x02, 0x03,
+			0x38, 0xb4, 0xc8, 0x84,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xf9, 0xf8,
+			0x38, 0xb4, 0x59, 0xef,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xad, 0x15,
+			0x38, 0xb4, 0x02, 0x27,
+			0x38, 0xb4, 0x03, 0xae,
+			0x38, 0xb4, 0x84, 0xaf,
+			0x38, 0xb4, 0xbf, 0xc3,
+			0x38, 0xb4, 0xca, 0x53,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xad, 0xc8,
+			0x38, 0xb4, 0x07, 0x28,
+			0x38, 0xb4, 0x85, 0x02,
+			0x38, 0xb4, 0xee, 0x2c,
+			0x38, 0xb4, 0xf3, 0x8f,
+			0x38, 0xb4, 0xef, 0x01,
+			0x38, 0xb4, 0xfd, 0x95,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xf9, 0xf8,
+			0x38, 0xb4, 0xef, 0xfa,
+			0x38, 0xb4, 0xbf, 0x69,
+			0x38, 0xb4, 0xca, 0x53,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xac, 0xc8,
+			0x38, 0xb4, 0x22, 0x28,
+			0x38, 0xb4, 0x80, 0xd4,
+			0x38, 0xb4, 0xbf, 0x00,
+			0x38, 0xb4, 0x84, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xbf, 0xa9,
+			0x38, 0xb4, 0x87, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xbf, 0xa9,
+			0x38, 0xb4, 0x8a, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xbf, 0xa9,
+			0x38, 0xb4, 0x8d, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xee, 0xa9,
+			0x38, 0xb4, 0xf3, 0x8f,
+			0x38, 0xb4, 0xaf, 0x00,
+			0x38, 0xb4, 0x26, 0x85,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xe1, 0xf4,
+			0x38, 0xb4, 0xf5, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe2,
+			0x38, 0xb4, 0xe3, 0xf6,
+			0x38, 0xb4, 0xf7, 0x8f,
+			0x38, 0xb4, 0x45, 0x1b,
+			0x38, 0xb4, 0x27, 0xac,
+			0x38, 0xb4, 0xee, 0x0e,
+			0x38, 0xb4, 0xf4, 0x8f,
+			0x38, 0xb4, 0xee, 0x00,
+			0x38, 0xb4, 0xf5, 0x8f,
+			0x38, 0xb4, 0x02, 0x00,
+			0x38, 0xb4, 0x2c, 0x85,
+			0x38, 0xb4, 0x85, 0xaf,
+			0x38, 0xb4, 0xe0, 0x26,
+			0x38, 0xb4, 0xf4, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0x2c, 0xf5,
+			0x38, 0xb4, 0x01, 0x00,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xf4,
+			0x38, 0xb4, 0xf5, 0x8f,
+			0x38, 0xb4, 0x96, 0xef,
+			0x38, 0xb4, 0xfd, 0xfe,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xf9, 0xf8,
+			0x38, 0xb4, 0x59, 0xef,
+			0x38, 0xb4, 0x53, 0xbf,
+			0x38, 0xb4, 0x02, 0x22,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8b, 0xa1,
+			0x38, 0xb4, 0xae, 0x02,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0xda, 0x85,
+			0x38, 0xb4, 0x57, 0xbf,
+			0x38, 0xb4, 0x02, 0x72,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xf8,
+			0x38, 0xb4, 0xf9, 0x8f,
+			0x38, 0xb4, 0x57, 0xbf,
+			0x38, 0xb4, 0x02, 0x75,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xfa,
+			0x38, 0xb4, 0xfb, 0x8f,
+			0x38, 0xb4, 0x57, 0xbf,
+			0x38, 0xb4, 0x02, 0x78,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xfc,
+			0x38, 0xb4, 0xfd, 0x8f,
+			0x38, 0xb4, 0x57, 0xbf,
+			0x38, 0xb4, 0x02, 0x7b,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xfe,
+			0x38, 0xb4, 0xff, 0x8f,
+			0x38, 0xb4, 0x57, 0xbf,
+			0x38, 0xb4, 0x02, 0x6c,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x02, 0xa1,
+			0x38, 0xb4, 0xee, 0x13,
+			0x38, 0xb4, 0xfc, 0x8f,
+			0x38, 0xb4, 0xee, 0x80,
+			0x38, 0xb4, 0xfd, 0x8f,
+			0x38, 0xb4, 0xee, 0x00,
+			0x38, 0xb4, 0xfe, 0x8f,
+			0x38, 0xb4, 0xee, 0x80,
+			0x38, 0xb4, 0xff, 0x8f,
+			0x38, 0xb4, 0xaf, 0x00,
+			0x38, 0xb4, 0x99, 0x85,
+			0x38, 0xb4, 0x01, 0xa1,
+			0x38, 0xb4, 0xbf, 0x0c,
+			0x38, 0xb4, 0x4c, 0x53,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xa1, 0xc8,
+			0x38, 0xb4, 0x03, 0x03,
+			0x38, 0xb4, 0x85, 0xaf,
+			0x38, 0xb4, 0xbf, 0x77,
+			0x38, 0xb4, 0x22, 0x53,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xa1, 0xc8,
+			0x38, 0xb4, 0x02, 0x8b,
+			0x38, 0xb4, 0x03, 0xae,
+			0x38, 0xb4, 0x86, 0xaf,
+			0x38, 0xb4, 0xe0, 0x64,
+			0x38, 0xb4, 0xf8, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xbf, 0xf9,
+			0x38, 0xb4, 0x84, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe0, 0xa9,
+			0x38, 0xb4, 0xfa, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xbf, 0xfb,
+			0x38, 0xb4, 0x87, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe0, 0xa9,
+			0x38, 0xb4, 0xfc, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xbf, 0xfd,
+			0x38, 0xb4, 0x8a, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe0, 0xa9,
+			0x38, 0xb4, 0xfe, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xbf, 0xff,
+			0x38, 0xb4, 0x8d, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xaf, 0xa9,
+			0x38, 0xb4, 0x7f, 0x86,
+			0x38, 0xb4, 0x53, 0xbf,
+			0x38, 0xb4, 0x02, 0x22,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x44, 0xa1,
+			0x38, 0xb4, 0xbf, 0x3c,
+			0x38, 0xb4, 0x7b, 0x54,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe4, 0xc8,
+			0x38, 0xb4, 0xf8, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xbf, 0xf9,
+			0x38, 0xb4, 0x7e, 0x54,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe4, 0xc8,
+			0x38, 0xb4, 0xfa, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xbf, 0xfb,
+			0x38, 0xb4, 0x81, 0x54,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe4, 0xc8,
+			0x38, 0xb4, 0xfc, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xbf, 0xfd,
+			0x38, 0xb4, 0x84, 0x54,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe4, 0xc8,
+			0x38, 0xb4, 0xfe, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xbf, 0xff,
+			0x38, 0xb4, 0x22, 0x53,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xa1, 0xc8,
+			0x38, 0xb4, 0x48, 0x44,
+			0x38, 0xb4, 0x85, 0xaf,
+			0x38, 0xb4, 0xbf, 0xa7,
+			0x38, 0xb4, 0x22, 0x53,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xa1, 0xc8,
+			0x38, 0xb4, 0x3c, 0x31,
+			0x38, 0xb4, 0x54, 0xbf,
+			0x38, 0xb4, 0x02, 0x7b,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xf8,
+			0x38, 0xb4, 0xf9, 0x8f,
+			0x38, 0xb4, 0x54, 0xbf,
+			0x38, 0xb4, 0x02, 0x7e,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xfa,
+			0x38, 0xb4, 0xfb, 0x8f,
+			0x38, 0xb4, 0x54, 0xbf,
+			0x38, 0xb4, 0x02, 0x81,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xfc,
+			0x38, 0xb4, 0xfd, 0x8f,
+			0x38, 0xb4, 0x54, 0xbf,
+			0x38, 0xb4, 0x02, 0x84,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xfe,
+			0x38, 0xb4, 0xff, 0x8f,
+			0x38, 0xb4, 0x53, 0xbf,
+			0x38, 0xb4, 0x02, 0x22,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x31, 0xa1,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0xa7, 0x85,
+			0x38, 0xb4, 0x80, 0xd4,
+			0x38, 0xb4, 0xbf, 0x00,
+			0x38, 0xb4, 0x84, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xbf, 0xa9,
+			0x38, 0xb4, 0x87, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xbf, 0xa9,
+			0x38, 0xb4, 0x8a, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xbf, 0xa9,
+			0x38, 0xb4, 0x8d, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xef, 0xa9,
+			0x38, 0xb4, 0xfd, 0x95,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xd1, 0xf0,
+			0x38, 0xb4, 0xf0, 0x2a,
+			0x38, 0xb4, 0x2c, 0xd1,
+			0x38, 0xb4, 0xd1, 0xf0,
+			0x38, 0xb4, 0xf0, 0x44,
+			0x38, 0xb4, 0x46, 0xd1,
+			0x38, 0xb4, 0x86, 0xbf,
+			0x38, 0xb4, 0x02, 0xa1,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x86, 0xbf,
+			0x38, 0xb4, 0x02, 0xa1,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x01, 0xd1,
+			0x38, 0xb4, 0x06, 0xaf,
+			0x38, 0xb4, 0x70, 0xa5,
+			0x38, 0xb4, 0x42, 0xce,
+			0x36, 0xb4, 0x18, 0xb8,
+			0x38, 0xb4, 0x3d, 0x04,
+			0x36, 0xb4, 0x1a, 0xb8,
+			0x38, 0xb4, 0xa3, 0x06,
+			0x36, 0xb4, 0x1c, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x1e, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x50, 0xb8,
+			0xff, 0xff, 0xff, 0xff,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x52, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x78, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x84, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x32, 0xb8,
+			0x38, 0xb4, 0x03, 0x00,
+			0x36, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x2e, 0xb8,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x24, 0x80,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x1e, 0x80,
+			0x38, 0xb4, 0x21, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0,
+			0x20, 0xb8, 0x00, 0x00,
+			0xff, 0xff, 0xff, 0xff};
+
+		code_ver = 0x0021;
+		ret = sram_read(tp, SRAM_GPHY_FW_VER, &fw_version);
+		if (ret < 0)
+			goto out;
+
+		if (fw_version < code_ver) {
+			data = ram13;
+			len = sizeof(ram13);
+
+			if (r8156b_flash_used(tp)) {
+				ret = ocp_word_set_bits(tp, MCU_TYPE_USB,
+							USB_GPHY_CTRL,
+							BYPASS_FLASH);
+				if (ret < 0)
+					goto out;
+			}
+		}
+	} else if (tp->version == RTL_VER_16) {
+		static u8 ram16[] = {
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x23, 0x80,
+			0x38, 0xb4, 0x01, 0x47,
+			0x36, 0xb4, 0x2e, 0xb8,
+			0x38, 0xb4, 0x01, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0,
+			0x20, 0xb8, 0x90, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x10, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x32, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3e, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x44, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x4b, 0x80,
+			0x38, 0xb4, 0x04, 0xd5,
+			0x38, 0xb4, 0xb5, 0xc9,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x07, 0xd7,
+			0x38, 0xb4, 0x70, 0x40,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x82, 0x10,
+			0x38, 0xb4, 0x04, 0xd5,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x7a, 0x10,
+			0x38, 0xb4, 0xd0, 0x61,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0xa5, 0x60,
+			0x38, 0xb4, 0x04, 0xd5,
+			0x38, 0xb4, 0xb2, 0xc9,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x04, 0xf0,
+			0x38, 0xb4, 0x04, 0xd5,
+			0x38, 0xb4, 0xb1, 0xc9,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x07, 0xd7,
+			0x38, 0xb4, 0x70, 0x60,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xb0, 0x10,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xc5, 0x10,
+			0x38, 0xb4, 0x07, 0xd7,
+			0x38, 0xb4, 0x05, 0x20,
+			0x38, 0xb4, 0x30, 0x80,
+			0x38, 0xb4, 0x5e, 0xd7,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x8c, 0x13,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xff, 0x13,
+			0x38, 0xb4, 0x04, 0xc5,
+			0x38, 0xb4, 0x20, 0xce,
+			0x38, 0xb4, 0x01, 0xcf,
+			0x38, 0xb4, 0x0a, 0xd7,
+			0x38, 0xb4, 0x05, 0x40,
+			0x38, 0xb4, 0x02, 0xcf,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x99, 0x1b,
+			0x38, 0xb4, 0x80, 0xa9,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x4d, 0x14,
+			0x38, 0xb4, 0x7f, 0x90,
+			0x38, 0xb4, 0xa3, 0x91,
+			0x38, 0xb4, 0x06, 0x93,
+			0x38, 0xb4, 0x18, 0xb1,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x47, 0x21,
+			0x38, 0xb4, 0x7f, 0x90,
+			0x38, 0xb4, 0x09, 0x92,
+			0x38, 0xb4, 0xa3, 0x91,
+			0x38, 0xb4, 0x06, 0x93,
+			0x38, 0xb4, 0x18, 0xb1,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3c, 0x20,
+			0x38, 0xb4, 0x07, 0xd7,
+			0x38, 0xb4, 0x21, 0x41,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0xfc, 0x40,
+			0x38, 0xb4, 0x0a, 0xd7,
+			0x38, 0xb4, 0xb5, 0x40,
+			0x38, 0xb4, 0x28, 0xd0,
+			0x38, 0xb4, 0xc1, 0xd1,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x57, 0x80,
+			0x38, 0xb4, 0x7b, 0xd0,
+			0x38, 0xb4, 0xc5, 0xd1,
+			0x38, 0xb4, 0x03, 0xd5,
+			0x38, 0xb4, 0x08, 0xa1,
+			0x38, 0xb4, 0x05, 0xd5,
+			0x38, 0xb4, 0x03, 0x81,
+			0x38, 0xb4, 0x04, 0xd5,
+			0x38, 0xb4, 0x02, 0xa0,
+			0x38, 0xb4, 0x02, 0xa3,
+			0x38, 0xb4, 0x07, 0xd7,
+			0x38, 0xb4, 0x61, 0x40,
+			0x38, 0xb4, 0x03, 0xd5,
+			0x38, 0xb4, 0x01, 0x8b,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x8a, 0xc4,
+			0x38, 0xb4, 0x03, 0xd5,
+			0x38, 0xb4, 0x09, 0xcc,
+			0x38, 0xb4, 0x58, 0xcd,
+			0x38, 0xb4, 0x01, 0xaf,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x10, 0xbe,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x39, 0x17,
+			0x38, 0xb4, 0x19, 0xd7,
+			0x38, 0xb4, 0x6c, 0x60,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x5c, 0x64,
+			0x38, 0xb4, 0x5e, 0xd7,
+			0x38, 0xb4, 0x4d, 0x60,
+			0x38, 0xb4, 0xf8, 0xff,
+			0x38, 0xb4, 0x10, 0x9e,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x39, 0x17,
+			0x38, 0xb4, 0x19, 0xd7,
+			0x38, 0xb4, 0x6c, 0x60,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x1c, 0x63,
+			0x38, 0xb4, 0x5e, 0xd7,
+			0x38, 0xb4, 0x4d, 0x40,
+			0x38, 0xb4, 0xf8, 0xff,
+			0x38, 0xb4, 0x04, 0xd5,
+			0x38, 0xb4, 0x18, 0xaa,
+			0x38, 0xb4, 0x01, 0xa0,
+			0x38, 0xb4, 0xe0, 0xa1,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x39, 0x17,
+			0x38, 0xb4, 0x19, 0xd7,
+			0x38, 0xb4, 0xac, 0x7f,
+			0x38, 0xb4, 0x04, 0xd5,
+			0x38, 0xb4, 0x01, 0xa0,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x39, 0x17,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x5c, 0x5f,
+			0x38, 0xb4, 0x19, 0xd7,
+			0x38, 0xb4, 0xaf, 0x3a,
+			0x38, 0xb4, 0x91, 0x80,
+			0x38, 0xb4, 0x16, 0xf0,
+			0x38, 0xb4, 0x07, 0xd7,
+			0x38, 0xb4, 0x21, 0x61,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xd8, 0x16,
+			0x38, 0xb4, 0x03, 0xd5,
+			0x38, 0xb4, 0x59, 0xcd,
+			0x38, 0xb4, 0x01, 0xaf,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xdc, 0x0d,
+			0x38, 0xb4, 0x03, 0xd5,
+			0x38, 0xb4, 0x40, 0x80,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xd8, 0x16,
+			0x38, 0xb4, 0x03, 0xd5,
+			0x38, 0xb4, 0x5a, 0xcd,
+			0x38, 0xb4, 0x01, 0xaf,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xbf, 0x0d,
+			0x38, 0xb4, 0x04, 0xd5,
+			0x38, 0xb4, 0x08, 0xa0,
+			0x38, 0xb4, 0x04, 0xa2,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x39, 0x17,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0xa0, 0x5f,
+			0x38, 0xb4, 0x03, 0xd5,
+			0x38, 0xb4, 0x82, 0xa0,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x1e, 0xd7,
+			0x38, 0xb4, 0x97, 0x40,
+			0x38, 0xb4, 0x78, 0xd0,
+			0x38, 0xb4, 0xaa, 0xd1,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x78, 0xd0,
+			0x38, 0xb4, 0xaa, 0xd1,
+			0x38, 0xb4, 0x07, 0xd7,
+			0x38, 0xb4, 0xc1, 0x40,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x9c, 0x40,
+			0x38, 0xb4, 0x0a, 0xd7,
+			0x38, 0xb4, 0x55, 0x40,
+			0x38, 0xb4, 0x10, 0xf0,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x65, 0x60,
+			0x38, 0xb4, 0x89, 0xcc,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x8b, 0xcc,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x7b, 0x0b,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0xd0, 0x2a,
+			0x38, 0xb4, 0xca, 0x80,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x81, 0x0b,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x87, 0x0b,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x53, 0x0c,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xd7, 0x12,
+			0x36, 0xb4, 0x26, 0xa0,
+			0x38, 0xb4, 0x5d, 0x12,
+			0x36, 0xb4, 0x24, 0xa0,
+			0x38, 0xb4, 0x33, 0x20,
+			0x36, 0xb4, 0x22, 0xa0,
+			0x38, 0xb4, 0x3f, 0x21,
+			0x36, 0xb4, 0x20, 0xa0,
+			0x38, 0xb4, 0x4c, 0x14,
+			0x36, 0xb4, 0x06, 0xa0,
+			0x38, 0xb4, 0x98, 0x1b,
+			0x36, 0xb4, 0x04, 0xa0,
+			0x38, 0xb4, 0x8b, 0x13,
+			0x36, 0xb4, 0x02, 0xa0,
+			0x38, 0xb4, 0xc4, 0x10,
+			0x36, 0xb4, 0x00, 0xa0,
+			0x38, 0xb4, 0x79, 0x10,
+			0x36, 0xb4, 0x08, 0xa0,
+			0x38, 0xb4, 0x00, 0xff,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0xf8, 0x0f,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x4d, 0xd0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x52, 0xa1,
+			0x38, 0xb4, 0xdc, 0x12,
+			0x36, 0xb4, 0x54, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x56, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x58, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x5a, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x5c, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x5e, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x60, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x50, 0xa1,
+			0x38, 0xb4, 0x01, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x20, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x10, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x22, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x33, 0x82,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x32, 0x83,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x5f, 0x85,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x19, 0x86,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xaf, 0x86,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0xa9, 0x60,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xa1, 0x60,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x62, 0x09,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x62, 0x09,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x82, 0x09,
+			0x38, 0xb4, 0x0a, 0x80,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x00, 0x0d,
+			0x38, 0xb4, 0xc0, 0x8d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xb5, 0x12,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x99, 0x0f,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x01, 0x62,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0xa0, 0x40,
+			0x38, 0xb4, 0x0d, 0xd7,
+			0x38, 0xb4, 0x9d, 0x41,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2c, 0x80,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0x1a, 0x61,
+			0x38, 0xb4, 0x10, 0x87,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x80, 0x82,
+			0x38, 0xb4, 0x80, 0x87,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x10, 0xa7,
+			0x38, 0xb4, 0x80, 0x95,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x04, 0xa3,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x07, 0x0d,
+			0x38, 0xb4, 0xc0, 0x8d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xb5, 0x12,
+			0x38, 0xb4, 0x81, 0xcb,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xe2, 0x48,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x7a, 0x40,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x67, 0x48,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x5a, 0x40,
+			0x38, 0xb4, 0x10, 0x89,
+			0x38, 0xb4, 0x10, 0xa2,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x1c, 0x61,
+			0x38, 0xb4, 0xc0, 0x0c,
+			0x38, 0xb4, 0x80, 0x00,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x01, 0x01,
+			0x38, 0xb4, 0xe0, 0x0c,
+			0x38, 0xb4, 0xa0, 0x03,
+			0x38, 0xb4, 0xb5, 0xcc,
+			0x38, 0xb4, 0xc0, 0x0c,
+			0x38, 0xb4, 0x80, 0x00,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x01,
+			0x38, 0xb4, 0xe0, 0x0c,
+			0x38, 0xb4, 0x40, 0x03,
+			0x38, 0xb4, 0x52, 0xcc,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0xda, 0x42,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x1c, 0x0f,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xb3, 0x5f,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x1f, 0x8f,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x33, 0x7f,
+			0x38, 0xb4, 0x90, 0x81,
+			0x38, 0xb4, 0x04, 0x82,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x87, 0x80,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x1b, 0x0f,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xb3, 0x5f,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x1f, 0x8f,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x33, 0x7f,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x67, 0x60,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x87, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x92, 0x80,
+			0x38, 0xb4, 0x03, 0xd4,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x03, 0x12,
+			0x38, 0xb4, 0x82, 0xcb,
+			0x38, 0xb4, 0x0a, 0xd4,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x03, 0x12,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x67, 0x42,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x1d, 0x13,
+			0x38, 0xb4, 0x40, 0x8a,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x0e, 0x12,
+			0x38, 0xb4, 0x04, 0xa1,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x20, 0x12,
+			0x38, 0xb4, 0x04, 0x81,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x17, 0x12,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x04, 0xa7,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x88, 0xcb,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xb7, 0x81,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x61, 0x61,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0xa0, 0x40,
+			0x38, 0xb4, 0x0d, 0xd7,
+			0x38, 0xb4, 0xfd, 0x40,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xb0, 0x80,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0x7a, 0x60,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xb0, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xa6, 0x81,
+			0x38, 0xb4, 0x10, 0xa2,
+			0x38, 0xb4, 0x10, 0x8a,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x3e, 0x64,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x04, 0x0d,
+			0x38, 0xb4, 0xc0, 0x8d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xb5, 0x12,
+			0x38, 0xb4, 0xc0, 0x0c,
+			0x38, 0xb4, 0x40, 0x00,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x01,
+			0x38, 0xb4, 0xe0, 0x0c,
+			0x38, 0xb4, 0xe0, 0x03,
+			0x38, 0xb4, 0xce, 0xcc,
+			0x38, 0xb4, 0x0a, 0xa0,
+			0x38, 0xb4, 0x80, 0xa2,
+			0x38, 0xb4, 0x10, 0xd1,
+			0x38, 0xb4, 0x4c, 0xd0,
+			0x38, 0xb4, 0xa0, 0xcb,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x10, 0x87,
+			0x38, 0xb4, 0x0f, 0xaa,
+			0x38, 0xb4, 0x30, 0xa1,
+			0x38, 0xb4, 0x2f, 0xaa,
+			0x38, 0xb4, 0xd5, 0xa2,
+			0x38, 0xb4, 0x05, 0xa4,
+			0x38, 0xb4, 0x20, 0xa7,
+			0x38, 0xb4, 0x0a, 0xa0,
+			0x38, 0xb4, 0xa1, 0xcb,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xfa, 0x80,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xf1, 0x3c,
+			0x38, 0xb4, 0xdb, 0x80,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x02, 0x0d,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xdd, 0x80,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x01, 0x0d,
+			0x38, 0xb4, 0xc0, 0x0c,
+			0x38, 0xb4, 0x40, 0x0d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xb5, 0x12,
+			0x38, 0xb4, 0x10, 0x87,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x0e, 0x12,
+			0x38, 0xb4, 0x08, 0xa1,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x20, 0x12,
+			0x38, 0xb4, 0x08, 0x81,
+			0xff, 0xff, 0xff, 0xff,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x38, 0xb4, 0x03, 0xa2,
+			0x38, 0xb4, 0x2f, 0x8a,
+			0x38, 0xb4, 0x30, 0xa1,
+			0x38, 0xb4, 0x04, 0x82,
+			0x38, 0xb4, 0x40, 0xa1,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x20, 0x12,
+			0x38, 0xb4, 0x40, 0x81,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x17, 0x12,
+			0x38, 0xb4, 0xa2, 0xcb,
+			0x38, 0xb4, 0x7a, 0xd1,
+			0x38, 0xb4, 0x4b, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x04, 0xa2,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xa7, 0x5f,
+			0x38, 0xb4, 0x20, 0xb9,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0xb4, 0x7f,
+			0x38, 0xb4, 0x20, 0x99,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0x45, 0x61,
+			0x38, 0xb4, 0x74, 0x60,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x04, 0x81,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xa7, 0x5f,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xfe, 0x80,
+			0x38, 0xb4, 0x20, 0xb8,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0xa5, 0x7f,
+			0x38, 0xb4, 0x20, 0x98,
+			0x38, 0xb4, 0x01, 0x9b,
+			0x38, 0xb4, 0x02, 0xd4,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x03, 0x12,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0xb1, 0x33,
+			0x38, 0xb4, 0x24, 0x81,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0xb5, 0x60,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x69, 0x60,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x26, 0x81,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x96, 0x81,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xab, 0x40,
+			0x38, 0xb4, 0x0a, 0x80,
+			0x38, 0xb4, 0x10, 0x81,
+			0x38, 0xb4, 0x84, 0x82,
+			0x38, 0xb4, 0x04, 0x84,
+			0x38, 0xb4, 0x10, 0xa7,
+			0x38, 0xb4, 0x20, 0x81,
+			0x38, 0xb4, 0x41, 0x82,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x0e, 0x12,
+			0x38, 0xb4, 0x04, 0xa1,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x20, 0x12,
+			0x38, 0xb4, 0x04, 0x81,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x17, 0x12,
+			0x38, 0xb4, 0x2f, 0xaa,
+			0x38, 0xb4, 0xa3, 0xcb,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x8b, 0x43,
+			0x38, 0xb4, 0x84, 0xa2,
+			0x38, 0xb4, 0x78, 0xd0,
+			0x38, 0xb4, 0x0a, 0x80,
+			0x38, 0xb4, 0x10, 0x81,
+			0x38, 0xb4, 0x84, 0xa2,
+			0x38, 0xb4, 0x04, 0x84,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x08, 0xa1,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x19, 0x0f,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xb3, 0x5f,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x1f, 0x8f,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x33, 0x7f,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x07, 0x0d,
+			0x38, 0xb4, 0xc0, 0x8d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xb5, 0x12,
+			0x38, 0xb4, 0x10, 0x81,
+			0x38, 0xb4, 0x84, 0xa2,
+			0x38, 0xb4, 0x04, 0xa4,
+			0x38, 0xb4, 0x0a, 0xa0,
+			0x38, 0xb4, 0xa4, 0xcb,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xa1, 0x40,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x10, 0xad,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x4b, 0x41,
+			0x38, 0xb4, 0xc0, 0x0c,
+			0x38, 0xb4, 0x80, 0x00,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x01,
+			0x38, 0xb4, 0xe0, 0x0c,
+			0x38, 0xb4, 0x40, 0x03,
+			0x38, 0xb4, 0x52, 0xcc,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x75, 0x81,
+			0x38, 0xb4, 0xc0, 0x80,
+			0x38, 0xb4, 0x03, 0x81,
+			0x38, 0xb4, 0xe0, 0x83,
+			0x38, 0xb4, 0xff, 0x8c,
+			0x38, 0xb4, 0xba, 0x60,
+			0x38, 0xb4, 0x10, 0xd1,
+			0x38, 0xb4, 0x41, 0xd0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x7c, 0x81,
+			0x38, 0xb4, 0x93, 0xd1,
+			0x38, 0xb4, 0x47, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x10, 0xa1,
+			0x38, 0xb4, 0xa5, 0xcb,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xaa, 0x5f,
+			0x38, 0xb4, 0x80, 0xa1,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x41, 0x60,
+			0x38, 0xb4, 0x02, 0xa4,
+			0x38, 0xb4, 0xa6, 0xcb,
+			0x38, 0xb4, 0xba, 0x60,
+			0x38, 0xb4, 0xf5, 0xd1,
+			0x38, 0xb4, 0x45, 0xd0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x92, 0x81,
+			0x38, 0xb4, 0xf5, 0xd1,
+			0x38, 0xb4, 0x49, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x10, 0x87,
+			0x38, 0xb4, 0x0a, 0xa0,
+			0x38, 0xb4, 0x90, 0xa1,
+			0x38, 0xb4, 0x04, 0xa2,
+			0x38, 0xb4, 0x80, 0xa2,
+			0x38, 0xb4, 0x04, 0xa4,
+			0x38, 0xb4, 0xa7, 0xcb,
+			0x38, 0xb4, 0x80, 0xbb,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x20, 0xb9,
+			0x38, 0xb4, 0x80, 0x9b,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xe5, 0x81,
+			0x38, 0xb4, 0x10, 0xa2,
+			0x38, 0xb4, 0x0a, 0xa0,
+			0x38, 0xb4, 0x40, 0xaa,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x0e, 0x12,
+			0x38, 0xb4, 0x04, 0xa1,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x20, 0x12,
+			0x38, 0xb4, 0x04, 0x81,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x17, 0x12,
+			0x38, 0xb4, 0x90, 0xa1,
+			0x38, 0xb4, 0x84, 0xa2,
+			0x38, 0xb4, 0x04, 0xa4,
+			0x38, 0xb4, 0x10, 0x8a,
+			0x38, 0xb4, 0x80, 0x8a,
+			0x38, 0xb4, 0x84, 0xcb,
+			0x38, 0xb4, 0x3e, 0xd1,
+			0x38, 0xb4, 0x5a, 0xd0,
+			0x38, 0xb4, 0x3e, 0xd1,
+			0x38, 0xb4, 0x6b, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x59, 0x35,
+			0x38, 0xb4, 0xc2, 0x81,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xbb, 0x81,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x4b, 0x60,
+			0x38, 0xb4, 0x8a, 0xcb,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x59, 0x36,
+			0x38, 0xb4, 0xcc, 0x81,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xc5, 0x81,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x6b, 0x60,
+			0x38, 0xb4, 0x8b, 0xcb,
+			0x38, 0xb4, 0xcb, 0x5e,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x41, 0x60,
+			0x38, 0xb4, 0x02, 0xa4,
+			0x38, 0xb4, 0x8c, 0xcb,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0xba, 0x60,
+			0x38, 0xb4, 0x79, 0xd1,
+			0x38, 0xb4, 0x49, 0xd0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xdc, 0x81,
+			0x38, 0xb4, 0x60, 0xd1,
+			0x38, 0xb4, 0x4b, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x8d, 0xcb,
+			0x38, 0xb4, 0x10, 0x87,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0xd4, 0x5f,
+			0x38, 0xb4, 0x20, 0xb9,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0xb4, 0x7f,
+			0x38, 0xb4, 0x20, 0x99,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0x45, 0x61,
+			0x38, 0xb4, 0x74, 0x60,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xea, 0x81,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xab, 0x5f,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xe4, 0x81,
+			0x38, 0xb4, 0x10, 0xa7,
+			0x38, 0xb4, 0x20, 0xb8,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0xa5, 0x7f,
+			0x38, 0xb4, 0x20, 0x98,
+			0x38, 0xb4, 0x14, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xba, 0x5f,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x76, 0x5f,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x34, 0x5f,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x81, 0x60,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x5a, 0x40,
+			0x38, 0xb4, 0x80, 0xa4,
+			0x38, 0xb4, 0x86, 0xcb,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0xfa, 0x60,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xe1, 0x60,
+			0x38, 0xb4, 0xc8, 0xd1,
+			0x38, 0xb4, 0x45, 0xd0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x18, 0x82,
+			0x38, 0xb4, 0x7a, 0xd1,
+			0x38, 0xb4, 0x4b, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0xc0, 0x0c,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x01, 0x01,
+			0x38, 0xb4, 0xe0, 0x0c,
+			0x38, 0xb4, 0x20, 0x03,
+			0x38, 0xb4, 0x29, 0xcc,
+			0x38, 0xb4, 0x08, 0xa2,
+			0x38, 0xb4, 0x04, 0x82,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xf5, 0x40,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x80, 0xa2,
+			0x38, 0xb4, 0x80, 0x87,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x04, 0x8e,
+			0x38, 0xb4, 0x14, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xf4, 0x5f,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3e, 0x0c,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x9d, 0x60,
+			0x38, 0xb4, 0x17, 0xd4,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x03, 0x12,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x89, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x7a, 0x5f,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x36, 0x5f,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x89, 0x60,
+			0x38, 0xb4, 0x0c, 0xd4,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x03, 0x12,
+			0x38, 0xb4, 0x40, 0xaa,
+			0x38, 0xb4, 0x10, 0xbb,
+			0x38, 0xb4, 0x50, 0xcb,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x10, 0xa3,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x5f, 0xcb,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x89, 0x12,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0x75, 0x5f,
+			0x38, 0xb4, 0x90, 0x81,
+			0x38, 0xb4, 0xa0, 0x82,
+			0x38, 0xb4, 0x02, 0x84,
+			0x38, 0xb4, 0x04, 0xa4,
+			0x38, 0xb4, 0x0a, 0x80,
+			0x38, 0xb4, 0x18, 0x87,
+			0x38, 0xb4, 0x10, 0x9b,
+			0x38, 0xb4, 0x20, 0x9b,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0xb5, 0x7f,
+			0x38, 0xb4, 0x51, 0xcb,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0x94, 0x5f,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0xa9, 0x61,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0xa1, 0x40,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x79, 0x40,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x9d, 0x60,
+			0x38, 0xb4, 0x41, 0xd1,
+			0x38, 0xb4, 0x43, 0xd0,
+			0x38, 0xb4, 0x06, 0xf0,
+			0x38, 0xb4, 0x01, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x41, 0xd1,
+			0x38, 0xb4, 0x44, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xe5, 0x60,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xbe, 0x60,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0xb1, 0x29,
+			0x38, 0xb4, 0x80, 0x82,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x80, 0xa8,
+			0x38, 0xb4, 0x0a, 0xa0,
+			0x38, 0xb4, 0x90, 0xa1,
+			0x38, 0xb4, 0x20, 0x82,
+			0x38, 0xb4, 0x80, 0xa2,
+			0x38, 0xb4, 0x04, 0xa4,
+			0x38, 0xb4, 0x20, 0xa6,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0xaa, 0xc5,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x61, 0x60,
+			0x38, 0xb4, 0x02, 0xa4,
+			0x38, 0xb4, 0x80, 0xa4,
+			0x38, 0xb4, 0x52, 0xcb,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xba, 0x5f,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x76, 0x5f,
+			0x38, 0xb4, 0x20, 0xb9,
+			0x38, 0xb4, 0x53, 0xcb,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0xb4, 0x7f,
+			0x38, 0xb4, 0x20, 0x99,
+			0x38, 0xb4, 0x0a, 0xa0,
+			0x38, 0xb4, 0x90, 0xa1,
+			0x38, 0xb4, 0x80, 0xa2,
+			0x38, 0xb4, 0x20, 0x82,
+			0x38, 0xb4, 0x04, 0xa4,
+			0x38, 0xb4, 0x80, 0xb5,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xa1, 0x40,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x02, 0xa6,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x10, 0xa3,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x60, 0xcb,
+			0x38, 0xb4, 0x01, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x10, 0xaa,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x33, 0x28,
+			0x38, 0xb4, 0xb9, 0x82,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x30, 0x13,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xa6, 0x40,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x40, 0xa1,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xa3, 0x40,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x20, 0xac,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x0c, 0xa9,
+			0x38, 0xb4, 0x80, 0xaa,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x07, 0x0d,
+			0x38, 0xb4, 0xc0, 0x8d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xb5, 0x12,
+			0x38, 0xb4, 0x0a, 0xa0,
+			0x38, 0xb4, 0x90, 0xa1,
+			0x38, 0xb4, 0x80, 0xa2,
+			0x38, 0xb4, 0x20, 0x82,
+			0x38, 0xb4, 0x04, 0xa4,
+			0x38, 0xb4, 0x80, 0xb5,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x00, 0xc5,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0xe0, 0x83,
+			0x38, 0xb4, 0x01, 0x8e,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xa1, 0x40,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x02, 0xa6,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x4a, 0xd1,
+			0x38, 0xb4, 0x58, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xd7, 0x12,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x63, 0x40,
+			0xff, 0xff, 0xff, 0xff,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xea, 0x12,
+			0x38, 0xb4, 0x6f, 0xcb,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x70, 0x2e,
+			0x38, 0xb4, 0x27, 0x83,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0x6e, 0x67,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x68, 0x38,
+			0x38, 0xb4, 0x02, 0x83,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0xc2, 0x61,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x18, 0x2f,
+			0x38, 0xb4, 0x08, 0x83,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x35, 0x5d,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0xaa, 0xc5,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0xe0, 0x0c,
+			0x38, 0xb4, 0x20, 0x03,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x0e, 0x83,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0xaa, 0xc5,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2e, 0x83,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0xaa, 0xc5,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x30, 0x83,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xd7, 0x12,
+			0x38, 0xb4, 0x02, 0xae,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x63, 0x40,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xea, 0x12,
+			0x38, 0xb4, 0x61, 0xcb,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x70, 0x2e,
+			0x38, 0xb4, 0x27, 0x83,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x68, 0x38,
+			0x38, 0xb4, 0x2e, 0x83,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0xe2, 0x61,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0x2e, 0x61,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x18, 0x2f,
+			0x38, 0xb4, 0x30, 0x83,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x0e, 0x83,
+			0x38, 0xb4, 0x02, 0x8e,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x99, 0x0f,
+			0x38, 0xb4, 0x04, 0xae,
+			0x38, 0xb4, 0x10, 0x83,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x31, 0x0e,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xac, 0x85,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x07, 0x0e,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xa4, 0x5f,
+			0x38, 0xb4, 0x06, 0xa7,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x4b, 0x40,
+			0x38, 0xb4, 0x80, 0xa8,
+			0x38, 0xb4, 0x01, 0x88,
+			0x38, 0xb4, 0x01, 0x8e,
+			0x38, 0xb4, 0x50, 0xca,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xd5, 0x83,
+			0x38, 0xb4, 0x51, 0xca,
+			0x38, 0xb4, 0x0e, 0xd7,
+			0x38, 0xb4, 0x10, 0x22,
+			0x38, 0xb4, 0xd3, 0x83,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x84, 0x40,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0xfd, 0x5e,
+			0x38, 0xb4, 0x07, 0xf0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xc2, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xe2, 0x5c,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x92, 0x16,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x5a, 0x60,
+			0x38, 0xb4, 0x10, 0x9a,
+			0x38, 0xb4, 0x40, 0x8e,
+			0x38, 0xb4, 0x04, 0x84,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x27, 0x18,
+			0x38, 0xb4, 0x80, 0x8e,
+			0x38, 0xb4, 0x62, 0xca,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x84, 0x30,
+			0x38, 0xb4, 0xb5, 0x83,
+			0x38, 0xb4, 0x10, 0xba,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xae, 0x84,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x00, 0x01,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x38, 0x46,
+			0x38, 0xb4, 0xc4, 0xd1,
+			0x38, 0xb4, 0x44, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x7c, 0x5f,
+			0x38, 0xb4, 0x08, 0x81,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x07, 0x09,
+			0x38, 0xb4, 0x40, 0x89,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xdb, 0x17,
+			0x38, 0xb4, 0xc4, 0xa0,
+			0x38, 0xb4, 0x10, 0x86,
+			0x38, 0xb4, 0x30, 0x80,
+			0x38, 0xb4, 0x06, 0x87,
+			0x38, 0xb4, 0x07, 0x0c,
+			0x38, 0xb4, 0x06, 0x0b,
+			0x38, 0xb4, 0x10, 0x84,
+			0x38, 0xb4, 0x80, 0xa9,
+			0x38, 0xb4, 0x02, 0xa7,
+			0x38, 0xb4, 0xc4, 0xd1,
+			0x38, 0xb4, 0x45, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x7c, 0x5f,
+			0x38, 0xb4, 0x07, 0x0c,
+			0x38, 0xb4, 0x06, 0x0b,
+			0x38, 0xb4, 0x30, 0xa0,
+			0x38, 0xb4, 0x10, 0xa6,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x41, 0x60,
+			0x38, 0xb4, 0x01, 0xa5,
+			0x38, 0xb4, 0x08, 0xa1,
+			0x38, 0xb4, 0xc4, 0xd1,
+			0x38, 0xb4, 0x45, 0xd0,
+			0x38, 0xb4, 0x63, 0xca,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x7c, 0x5f,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x78, 0x60,
+			0x38, 0xb4, 0x20, 0x99,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x20, 0xb9,
+			0x38, 0xb4, 0x80, 0xa8,
+			0x38, 0xb4, 0x10, 0x9a,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0x73, 0x5f,
+			0x38, 0xb4, 0x11, 0xf0,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x9b, 0x40,
+			0x38, 0xb4, 0x20, 0x99,
+			0x38, 0xb4, 0x10, 0x9a,
+			0x38, 0xb4, 0xf5, 0xff,
+			0x38, 0xb4, 0xfe, 0x80,
+			0x38, 0xb4, 0x10, 0x86,
+			0x38, 0xb4, 0x01, 0x85,
+			0x38, 0xb4, 0x80, 0x89,
+			0x38, 0xb4, 0x02, 0x87,
+			0x38, 0xb4, 0x10, 0xa4,
+			0x38, 0xb4, 0x40, 0xa9,
+			0x38, 0xb4, 0xc0, 0x81,
+			0x38, 0xb4, 0x80, 0xae,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x5a, 0x83,
+			0x38, 0xb4, 0x04, 0x88,
+			0x38, 0xb4, 0x04, 0xa7,
+			0x38, 0xb4, 0x88, 0x87,
+			0x38, 0xb4, 0x82, 0xff,
+			0x38, 0xb4, 0x08, 0xbb,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x07, 0x09,
+			0x38, 0xb4, 0x40, 0x89,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xdb, 0x17,
+			0x38, 0xb4, 0x01, 0x87,
+			0x38, 0xb4, 0x02, 0x85,
+			0x38, 0xb4, 0xf4, 0xa0,
+			0x38, 0xb4, 0x10, 0xa6,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x61, 0x60,
+			0x38, 0xb4, 0x02, 0xa0,
+			0x38, 0xb4, 0x01, 0xa5,
+			0x38, 0xb4, 0x06, 0x87,
+			0x38, 0xb4, 0x10, 0x84,
+			0x38, 0xb4, 0x80, 0xa9,
+			0x38, 0xb4, 0x64, 0xca,
+			0x38, 0xb4, 0x10, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x7c, 0x5f,
+			0x38, 0xb4, 0x04, 0x88,
+			0x38, 0xb4, 0x06, 0xa7,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x36, 0x83,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x7c, 0x14,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x5f, 0x40,
+			0x38, 0xb4, 0x37, 0xf0,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0x59, 0x42,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x34, 0x62,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xc6, 0x41,
+			0x38, 0xb4, 0x0d, 0xd7,
+			0x38, 0xb4, 0x9d, 0x41,
+			0x38, 0xb4, 0x0d, 0xd7,
+			0x38, 0xb4, 0x7e, 0x41,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x27, 0x61,
+			0x38, 0xb4, 0x51, 0x29,
+			0x38, 0xb4, 0xec, 0x83,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x83, 0x40,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x81, 0x2e,
+			0x38, 0xb4, 0xec, 0x83,
+			0x38, 0xb4, 0xc2, 0xf0,
+			0x38, 0xb4, 0xfe, 0x80,
+			0x38, 0xb4, 0x10, 0x86,
+			0x38, 0xb4, 0x01, 0x85,
+			0x38, 0xb4, 0x04, 0x87,
+			0x38, 0xb4, 0x30, 0x0c,
+			0x38, 0xb4, 0x10, 0x04,
+			0x38, 0xb4, 0x02, 0xac,
+			0x38, 0xb4, 0x02, 0xa5,
+			0x38, 0xb4, 0x80, 0x89,
+			0x38, 0xb4, 0x60, 0xca,
+			0x38, 0xb4, 0x04, 0xa0,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x65, 0x60,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xfc, 0x83,
+			0x38, 0xb4, 0x04, 0x80,
+			0x38, 0xb4, 0x04, 0xa8,
+			0x38, 0xb4, 0x0f, 0x0c,
+			0x38, 0xb4, 0x02, 0x06,
+			0x38, 0xb4, 0x70, 0x0c,
+			0x38, 0xb4, 0x30, 0x07,
+			0x38, 0xb4, 0x08, 0xa7,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x9c, 0x60,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x12, 0x09,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x0e, 0x09,
+			0x38, 0xb4, 0x40, 0xa9,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xdb, 0x17,
+			0x38, 0xb4, 0x80, 0xa7,
+			0x38, 0xb4, 0xa0, 0xf0,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xab, 0x63,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x71, 0x43,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x9c, 0x33,
+			0x38, 0xb4, 0xad, 0x84,
+			0x38, 0xb4, 0x88, 0x87,
+			0x38, 0xb4, 0x04, 0x87,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x07, 0x09,
+			0x38, 0xb4, 0x40, 0x89,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xdb, 0x17,
+			0x38, 0xb4, 0x10, 0x84,
+			0x38, 0xb4, 0xf4, 0xa0,
+			0x38, 0xb4, 0x10, 0xa6,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x61, 0x60,
+			0x38, 0xb4, 0x02, 0xa0,
+			0x38, 0xb4, 0x01, 0xa5,
+			0x38, 0xb4, 0x06, 0xa7,
+			0x38, 0xb4, 0x04, 0x88,
+			0x38, 0xb4, 0x80, 0xa9,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x85, 0x60,
+			0x38, 0xb4, 0x01, 0x87,
+			0x38, 0xb4, 0x02, 0x85,
+			0x38, 0xb4, 0x02, 0x8c,
+			0x38, 0xb4, 0x82, 0xf0,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xc5, 0x60,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x53, 0x60,
+			0x38, 0xb4, 0x7d, 0xf0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xaa, 0x84,
+			0x38, 0xb4, 0x0d, 0xd7,
+			0x38, 0xb4, 0x1b, 0x4d,
+			0x38, 0xb4, 0x10, 0xba,
+			0x38, 0xb4, 0x40, 0xae,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0xb4, 0x03,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0xb4, 0x05,
+			0x38, 0xb4, 0xc4, 0xd1,
+			0x38, 0xb4, 0x44, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x7c, 0x5f,
+			0x38, 0xb4, 0x06, 0x87,
+			0x38, 0xb4, 0x80, 0x82,
+			0x38, 0xb4, 0xe0, 0xac,
+			0x38, 0xb4, 0x80, 0xa6,
+			0x38, 0xb4, 0x40, 0xa2,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x79, 0x5f,
+			0x38, 0xb4, 0x40, 0x82,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x98, 0x68,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x57, 0x49,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x9c, 0x84,
+			0x38, 0xb4, 0xc0, 0xa1,
+			0x38, 0xb4, 0x3f, 0x0c,
+			0x38, 0xb4, 0x20, 0x02,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0x0c, 0x03,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0x0c, 0x05,
+			0x38, 0xb4, 0x08, 0x81,
+			0x38, 0xb4, 0x40, 0x86,
+			0x38, 0xb4, 0x20, 0xa1,
+			0x38, 0xb4, 0x40, 0xa6,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x01, 0x01,
+			0x38, 0xb4, 0x10, 0xa1,
+			0x38, 0xb4, 0xc4, 0xd1,
+			0x38, 0xb4, 0x44, 0xd0,
+			0x38, 0xb4, 0x84, 0xca,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x7c, 0x5f,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0xfc, 0x60,
+			0x38, 0xb4, 0x10, 0x82,
+			0x38, 0xb4, 0xe0, 0x0c,
+			0x38, 0xb4, 0x20, 0x03,
+			0x38, 0xb4, 0xe0, 0x0c,
+			0x38, 0xb4, 0x20, 0x05,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x10, 0xa2,
+			0x38, 0xb4, 0xc4, 0xd1,
+			0x38, 0xb4, 0x43, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x7c, 0x5f,
+			0x38, 0xb4, 0x33, 0x82,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0x6c, 0x03,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0x6c, 0x05,
+			0x38, 0xb4, 0xc4, 0xd1,
+			0x38, 0xb4, 0x44, 0xd0,
+			0x38, 0xb4, 0x85, 0xca,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x7c, 0x5f,
+			0x38, 0xb4, 0x80, 0xa6,
+			0x38, 0xb4, 0x40, 0xa2,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x79, 0x5f,
+			0x38, 0xb4, 0x40, 0x82,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0x90, 0x03,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0x90, 0x05,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x58, 0x60,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0xc8, 0xfe,
+			0x38, 0xb4, 0xc0, 0x81,
+			0x38, 0xb4, 0x80, 0x88,
+			0x38, 0xb4, 0x06, 0x87,
+			0x38, 0xb4, 0x61, 0xca,
+			0x38, 0xb4, 0xc4, 0xd1,
+			0x38, 0xb4, 0x54, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x7d, 0x5f,
+			0x38, 0xb4, 0x06, 0xa7,
+			0x38, 0xb4, 0x04, 0xf0,
+			0x38, 0xb4, 0x88, 0x87,
+			0x38, 0xb4, 0x04, 0xa4,
+			0x38, 0xb4, 0x02, 0x87,
+			0x38, 0xb4, 0x00, 0x08,
+			0x38, 0xb4, 0x43, 0x84,
+			0x38, 0xb4, 0x03, 0x83,
+			0x38, 0xb4, 0x80, 0x82,
+			0x38, 0xb4, 0x20, 0x99,
+			0x38, 0xb4, 0xe0, 0x8c,
+			0x38, 0xb4, 0x04, 0x80,
+			0x38, 0xb4, 0xc0, 0xa1,
+			0x38, 0xb4, 0x0e, 0xd7,
+			0x38, 0xb4, 0x4a, 0x40,
+			0x38, 0xb4, 0x80, 0xa2,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0xd0, 0x3b,
+			0x38, 0xb4, 0xbe, 0x84,
+			0x38, 0xb4, 0x3f, 0x0c,
+			0x38, 0xb4, 0x23, 0x02,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x3f, 0x0c,
+			0x38, 0xb4, 0x20, 0x02,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0x08, 0x03,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0x08, 0x05,
+			0x38, 0xb4, 0x08, 0x81,
+			0x38, 0xb4, 0x40, 0x86,
+			0x38, 0xb4, 0x20, 0xa1,
+			0x38, 0xb4, 0x40, 0xa6,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x77, 0x60,
+			0x38, 0xb4, 0x03, 0x81,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x01, 0x01,
+			0x38, 0xb4, 0x10, 0xa1,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x77, 0x60,
+			0x38, 0xb4, 0x08, 0xa1,
+			0x38, 0xb4, 0x06, 0xf0,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x77, 0x60,
+			0x38, 0xb4, 0x08, 0x81,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x08, 0xa1,
+			0x38, 0xb4, 0x93, 0xd1,
+			0x38, 0xb4, 0x45, 0xd0,
+			0x38, 0xb4, 0x82, 0xca,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x0e, 0xd7,
+			0x38, 0xb4, 0x6a, 0x60,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x3c, 0x5f,
+			0x38, 0xb4, 0x02, 0xd7,
+			0xff, 0xff, 0xff, 0xff,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x38, 0xb4, 0xfc, 0x60,
+			0x38, 0xb4, 0x10, 0x82,
+			0x38, 0xb4, 0xe0, 0x0c,
+			0x38, 0xb4, 0x20, 0x03,
+			0x38, 0xb4, 0xe0, 0x0c,
+			0x38, 0xb4, 0x20, 0x05,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x10, 0xa2,
+			0x38, 0xb4, 0xc4, 0xd1,
+			0x38, 0xb4, 0x43, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x0e, 0xd7,
+			0x38, 0xb4, 0x6a, 0x60,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x3c, 0x5f,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0xd0, 0x3b,
+			0x38, 0xb4, 0xfc, 0x84,
+			0x38, 0xb4, 0x3f, 0x0c,
+			0x38, 0xb4, 0x0c, 0x02,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x3f, 0x82,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0x4c, 0x03,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0x4c, 0x05,
+			0x38, 0xb4, 0xc4, 0xd1,
+			0x38, 0xb4, 0x44, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x0e, 0xd7,
+			0x38, 0xb4, 0x6a, 0x60,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x3c, 0x5f,
+			0x38, 0xb4, 0x0c, 0x82,
+			0x38, 0xb4, 0x60, 0xa3,
+			0x38, 0xb4, 0x60, 0xa5,
+			0x38, 0xb4, 0xc4, 0xd1,
+			0x38, 0xb4, 0x43, 0xd0,
+			0x38, 0xb4, 0x83, 0xca,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x0e, 0xd7,
+			0x38, 0xb4, 0x6a, 0x60,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x3c, 0x5f,
+			0x38, 0xb4, 0x0e, 0xd7,
+			0x38, 0xb4, 0x6a, 0x40,
+			0x38, 0xb4, 0x80, 0x86,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x80, 0xa6,
+			0x38, 0xb4, 0x40, 0xa2,
+			0x38, 0xb4, 0x0f, 0x0c,
+			0x38, 0xb4, 0x04, 0x06,
+			0x38, 0xb4, 0x70, 0x0c,
+			0x38, 0xb4, 0x50, 0x07,
+			0x38, 0xb4, 0x08, 0xa7,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x9c, 0x60,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x14, 0x09,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x10, 0x09,
+			0x38, 0xb4, 0x40, 0xa9,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xdb, 0x17,
+			0x38, 0xb4, 0x80, 0xa7,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xbe, 0x17,
+			0x38, 0xb4, 0x0e, 0xd7,
+			0x38, 0xb4, 0x6a, 0x60,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xe8, 0x17,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x9c, 0x39,
+			0x38, 0xb4, 0x2f, 0x85,
+			0x38, 0xb4, 0x40, 0x82,
+			0x38, 0xb4, 0x88, 0x87,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0xf8, 0x63,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x3c, 0x64,
+			0x38, 0xb4, 0x02, 0xa4,
+			0x38, 0xb4, 0x12, 0xf0,
+			0x38, 0xb4, 0x02, 0x84,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x1b, 0x61,
+			0x38, 0xb4, 0x01, 0xa4,
+			0x38, 0xb4, 0x02, 0xa3,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x7d, 0x41,
+			0x38, 0xb4, 0x40, 0xa4,
+			0x38, 0xb4, 0x80, 0xa2,
+			0x38, 0xb4, 0x08, 0xf0,
+			0x38, 0xb4, 0x01, 0x84,
+			0x38, 0xb4, 0x02, 0x83,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x60, 0x60,
+			0x38, 0xb4, 0x01, 0xa3,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x01, 0x83,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x80, 0x40,
+			0x38, 0xb4, 0x0e, 0xd7,
+			0x38, 0xb4, 0x4a, 0x60,
+			0x38, 0xb4, 0x5f, 0xff,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0xdd, 0x3c,
+			0x38, 0xb4, 0x5e, 0x85,
+			0x38, 0xb4, 0x5b, 0xff,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0x90, 0x03,
+			0x38, 0xb4, 0xfc, 0x0c,
+			0x38, 0xb4, 0x90, 0x05,
+			0x38, 0xb4, 0x00, 0x08,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xf9, 0x60,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x58, 0x69,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x02, 0x69,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x01, 0x10,
+			0x38, 0xb4, 0x20, 0xa2,
+			0x38, 0xb4, 0x04, 0xa4,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x54, 0x40,
+			0x38, 0xb4, 0x40, 0xa7,
+			0x38, 0xb4, 0x04, 0xa5,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xb5, 0x40,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x03, 0xa0,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x90, 0x81,
+			0x38, 0xb4, 0x91, 0xcb,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xaf, 0x10,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xb9, 0x7f,
+			0x38, 0xb4, 0x20, 0x82,
+			0x38, 0xb4, 0x04, 0x84,
+			0x38, 0xb4, 0x80, 0xa2,
+			0x38, 0xb4, 0x10, 0xa1,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x41, 0x40,
+			0x38, 0xb4, 0x80, 0xa1,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x0c, 0x13,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x0f, 0x85,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x08, 0x0d,
+			0x38, 0xb4, 0xc0, 0x0c,
+			0x38, 0xb4, 0x80, 0x0d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xb5, 0x12,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xaf, 0x10,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x5f, 0x61,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x03, 0x61,
+			0x38, 0xb4, 0x04, 0x85,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xb5, 0x40,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x03, 0x80,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x92, 0xcb,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xaf, 0x10,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0xa3, 0x7f,
+			0x38, 0xb4, 0x80, 0x82,
+			0x38, 0xb4, 0x90, 0x81,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x0f, 0x0c,
+			0x38, 0xb4, 0x0a, 0x05,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x00, 0x0d,
+			0x38, 0xb4, 0xc0, 0x8d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xb5, 0x12,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x01, 0x10,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x00, 0x0d,
+			0x38, 0xb4, 0xc0, 0x8d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xb5, 0x12,
+			0x38, 0xb4, 0x0a, 0x80,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0xb9, 0x40,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x63, 0x60,
+			0x38, 0xb4, 0x20, 0xa0,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x20, 0x80,
+			0x38, 0xb4, 0x04, 0xa5,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xb5, 0x40,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x03, 0xa0,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x54, 0x40,
+			0x38, 0xb4, 0x40, 0xa7,
+			0x38, 0xb4, 0x90, 0x81,
+			0x38, 0xb4, 0x93, 0xcb,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x63, 0x60,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x9c, 0x60,
+			0x38, 0xb4, 0x4b, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x20, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xaf, 0x10,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x08, 0xa0,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x40, 0x40,
+			0x38, 0xb4, 0x02, 0xa0,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x79, 0x40,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x13, 0x13,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0xf0, 0x85,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0xd9, 0x40,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x83, 0x60,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x09, 0x0d,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x0a, 0x0d,
+			0x38, 0xb4, 0xc0, 0x0c,
+			0x38, 0xb4, 0x80, 0x0d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xb5, 0x12,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xaf, 0x10,
+			0x38, 0xb4, 0x20, 0x80,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x99, 0x41,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x5f, 0x61,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x03, 0x61,
+			0x38, 0xb4, 0x04, 0x85,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xb5, 0x40,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x03, 0x80,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x94, 0xcb,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xaf, 0x10,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0xa2, 0x7f,
+			0x38, 0xb4, 0x0a, 0x80,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0xf0, 0x85,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0xb9, 0x40,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x00, 0x0d,
+			0x38, 0xb4, 0xc0, 0x8d,
+			0x38, 0xb4, 0x05, 0xf0,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x07, 0x0d,
+			0x38, 0xb4, 0xc0, 0x8d,
+			0x38, 0xb4, 0x90, 0xa1,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xb5, 0x12,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0xcc, 0x39,
+			0x38, 0xb4, 0x17, 0x86,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x01, 0x10,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xc7, 0x82,
+			0x38, 0xb4, 0x13, 0xcb,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x89, 0x60,
+			0x38, 0xb4, 0xb8, 0xd1,
+			0x38, 0xb4, 0x4a, 0xd0,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x1c, 0xd1,
+			0x38, 0xb4, 0x4b, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0xd5, 0x67,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x74, 0x5f,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x0c, 0x61,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x46, 0x68,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x7b, 0x64,
+			0x38, 0xb4, 0xfa, 0xff,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x30, 0x13,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x1f, 0x0c,
+			0x38, 0xb4, 0x16, 0x0f,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xb3, 0x5f,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x1f, 0x8f,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0x33, 0x7f,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xb5, 0x12,
+			0x38, 0xb4, 0x07, 0x0c,
+			0x38, 0xb4, 0x02, 0x0c,
+			0x38, 0xb4, 0xc0, 0x0c,
+			0x38, 0xb4, 0x80, 0x00,
+			0x38, 0xb4, 0x4a, 0xd1,
+			0x38, 0xb4, 0x48, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x29, 0x86,
+			0x38, 0xb4, 0x0a, 0x80,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x0e, 0x12,
+			0x38, 0xb4, 0x04, 0xa0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x20, 0x12,
+			0x38, 0xb4, 0x04, 0x80,
+			0x38, 0xb4, 0x01, 0xa0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x20, 0x12,
+			0x38, 0xb4, 0x01, 0x80,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x17, 0x12,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x09,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xed, 0x04,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0xab, 0x5f,
+			0x38, 0xb4, 0x08, 0xba,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0x8b, 0x7f,
+			0x38, 0xb4, 0x08, 0x9a,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x81, 0x05,
+			0x38, 0xb4, 0x0a, 0x80,
+			0x38, 0xb4, 0x02, 0xd7,
+			0x38, 0xb4, 0x55, 0x65,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x0e, 0x12,
+			0x38, 0xb4, 0x04, 0xa0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x20, 0x12,
+			0x38, 0xb4, 0x04, 0x80,
+			0x38, 0xb4, 0x01, 0xa0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x20, 0x12,
+			0x38, 0xb4, 0x01, 0x80,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x17, 0x12,
+			0x38, 0xb4, 0x0a, 0xa0,
+			0x38, 0xb4, 0x80, 0xa7,
+			0x38, 0xb4, 0x14, 0xcb,
+			0x38, 0xb4, 0xb8, 0xd1,
+			0x38, 0xb4, 0x4a, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x86, 0x62,
+			0x38, 0xb4, 0x06, 0xd7,
+			0x38, 0xb4, 0x5b, 0x5f,
+			0x38, 0xb4, 0x0a, 0x80,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x0e, 0x12,
+			0x38, 0xb4, 0x04, 0xa0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x20, 0x12,
+			0x38, 0xb4, 0x04, 0x80,
+			0x38, 0xb4, 0x01, 0xa0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x20, 0x12,
+			0x38, 0xb4, 0x01, 0x80,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x17, 0x12,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x09,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x71, 0x86,
+			0x38, 0xb4, 0x0a, 0xa0,
+			0x38, 0xb4, 0x08, 0x93,
+			0x38, 0xb4, 0x10, 0xb2,
+			0x38, 0xb4, 0x01, 0xb3,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0xa4, 0x5f,
+			0x38, 0xb4, 0x02, 0xb3,
+			0x38, 0xb4, 0x10, 0x92,
+			0x38, 0xb4, 0x09, 0xd4,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x03, 0x12,
+			0x38, 0xb4, 0x03, 0xd1,
+			0x38, 0xb4, 0x4c, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x12,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x81, 0x05,
+			0x38, 0xb4, 0x0c, 0xd7,
+			0x38, 0xb4, 0xb3, 0x60,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xb3, 0x86,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1a, 0x00,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xcb, 0x12,
+			0x36, 0xb4, 0x0e, 0xa1,
+			0x38, 0xb4, 0xcf, 0x12,
+			0x36, 0xb4, 0x0c, 0xa1,
+			0x38, 0xb4, 0xf8, 0x04,
+			0x36, 0xb4, 0x0a, 0xa1,
+			0x38, 0xb4, 0x03, 0x10,
+			0x36, 0xb4, 0x08, 0xa1,
+			0x38, 0xb4, 0xfb, 0x15,
+			0x36, 0xb4, 0x06, 0xa1,
+			0x38, 0xb4, 0x2b, 0x0d,
+			0x36, 0xb4, 0x04, 0xa1,
+			0x38, 0xb4, 0xcb, 0x0e,
+			0x36, 0xb4, 0x02, 0xa1,
+			0x38, 0xb4, 0x19, 0x11,
+			0x36, 0xb4, 0x00, 0xa1,
+			0x38, 0xb4, 0x60, 0x09,
+			0x36, 0xb4, 0x10, 0xa1,
+			0x38, 0xb4, 0xff, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x20, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0xf8, 0x1f,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x04, 0xa7,
+			0x38, 0xb4, 0xc7, 0x82,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x64, 0xa1,
+			0x38, 0xb4, 0x9f, 0x11,
+			0x36, 0xb4, 0x66, 0xa1,
+			0x38, 0xb4, 0xa1, 0x11,
+			0x36, 0xb4, 0x68, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x6a, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x6c, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x6e, 0xa1,
+			0xff, 0xff, 0xff, 0xff,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x70, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x72, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x62, 0xa1,
+			0x38, 0xb4, 0x03, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0x63, 0x8a,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0x8a, 0xaf,
+			0x38, 0xb4, 0xaf, 0x7b,
+			0x38, 0xb4, 0xb6, 0x8a,
+			0x38, 0xb4, 0x8a, 0xaf,
+			0x38, 0xb4, 0xaf, 0xd6,
+			0x38, 0xb4, 0xe4, 0x8a,
+			0x38, 0xb4, 0x8a, 0xaf,
+			0x38, 0xb4, 0xaf, 0xf2,
+			0x38, 0xb4, 0x01, 0x8b,
+			0x38, 0xb4, 0x8b, 0xaf,
+			0x38, 0xb4, 0xaf, 0x0a,
+			0x38, 0xb4, 0x10, 0x8b,
+			0x38, 0xb4, 0x35, 0xad,
+			0x38, 0xb4, 0xbf, 0x27,
+			0x38, 0xb4, 0x08, 0x73,
+			0x38, 0xb4, 0x7b, 0x02,
+			0x38, 0xb4, 0xac, 0x07,
+			0x38, 0xb4, 0x0d, 0x28,
+			0x38, 0xb4, 0x73, 0xbf,
+			0x38, 0xb4, 0x02, 0x0b,
+			0x38, 0xb4, 0x07, 0x7b,
+			0x38, 0xb4, 0x28, 0xac,
+			0x38, 0xb4, 0xd0, 0x04,
+			0x38, 0xb4, 0xae, 0x05,
+			0x38, 0xb4, 0xd0, 0x02,
+			0x38, 0xb4, 0xd1, 0x01,
+			0x38, 0xb4, 0xd3, 0x01,
+			0x38, 0xb4, 0xee, 0x04,
+			0x38, 0xb4, 0x40, 0x86,
+			0x38, 0xb4, 0xee, 0x00,
+			0x38, 0xb4, 0x41, 0x86,
+			0x38, 0xb4, 0xaf, 0x00,
+			0x38, 0xb4, 0xa6, 0x6a,
+			0x38, 0xb4, 0x00, 0xd1,
+			0x38, 0xb4, 0x00, 0xd3,
+			0x38, 0xb4, 0x86, 0xee,
+			0x38, 0xb4, 0x01, 0x40,
+			0x38, 0xb4, 0x86, 0xee,
+			0x38, 0xb4, 0x24, 0x41,
+			0x38, 0xb4, 0x0f, 0xd0,
+			0x38, 0xb4, 0x6a, 0xaf,
+			0x38, 0xb4, 0xbf, 0xa6,
+			0x38, 0xb4, 0x9e, 0x73,
+			0x38, 0xb4, 0x7b, 0x02,
+			0x38, 0xb4, 0xad, 0x07,
+			0x38, 0xb4, 0x0b, 0x28,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xad, 0xfd,
+			0x38, 0xb4, 0x05, 0x28,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xae, 0xfe,
+			0x38, 0xb4, 0xe0, 0x03,
+			0x38, 0xb4, 0xff, 0x8f,
+			0x38, 0xb4, 0x89, 0xe4,
+			0x38, 0xb4, 0xe0, 0xe7,
+			0x38, 0xb4, 0xe7, 0x89,
+			0x38, 0xb4, 0x67, 0xaf,
+			0x38, 0xb4, 0xa0, 0x9f,
+			0x38, 0xb4, 0x02, 0x94,
+			0x38, 0xb4, 0x03, 0xae,
+			0x38, 0xb4, 0xb5, 0xa0,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0x89, 0x0d,
+			0x38, 0xb4, 0x0d, 0xaf,
+			0x38, 0xb4, 0xa0, 0xaf,
+			0x38, 0xb4, 0x02, 0x94,
+			0x38, 0xb4, 0x03, 0xae,
+			0x38, 0xb4, 0xb5, 0xa0,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0x64, 0x0c,
+			0x38, 0xb4, 0x0c, 0xaf,
+			0x38, 0xb4, 0xe0, 0xcc,
+			0x38, 0xb4, 0xa5, 0x86,
+			0x38, 0xb4, 0x25, 0xad,
+			0x38, 0xb4, 0x02, 0x06,
+			0x38, 0xb4, 0xa4, 0x6b,
+			0x38, 0xb4, 0x65, 0x02,
+			0x38, 0xb4, 0xaf, 0x4f,
+			0x38, 0xb4, 0x9a, 0x6e,
+			0x38, 0xb4, 0x24, 0xac,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0xb4, 0x6b,
+			0x38, 0xb4, 0x6b, 0xaf,
+			0x38, 0xb4, 0x02, 0xb6,
+			0x38, 0xb4, 0xe8, 0x7a,
+			0x38, 0xb4, 0x6c, 0xaf,
+			0x38, 0xb4, 0x00, 0xa1,
+			0x36, 0xb4, 0x5e, 0xb8,
+			0x38, 0xb4, 0x7f, 0x6a,
+			0x36, 0xb4, 0x60, 0xb8,
+			0x38, 0xb4, 0x9c, 0x67,
+			0x36, 0xb4, 0x62, 0xb8,
+			0x38, 0xb4, 0x86, 0x0d,
+			0x36, 0xb4, 0x64, 0xb8,
+			0x38, 0xb4, 0x61, 0x0c,
+			0x36, 0xb4, 0x86, 0xb8,
+			0x38, 0xb4, 0x7c, 0x6e,
+			0x36, 0xb4, 0x88, 0xb8,
+			0x38, 0xb4, 0xae, 0x6b,
+			0x36, 0xb4, 0x8a, 0xb8,
+			0x38, 0xb4, 0x9b, 0x6c,
+			0x36, 0xb4, 0x8c, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x38, 0xb8,
+			0x38, 0xb4, 0x7f, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0,
+			0x20, 0xb8, 0x10, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x29, 0x86,
+			0x38, 0xb4, 0x86, 0xaf,
+			0x38, 0xb4, 0xaf, 0x41,
+			0x38, 0xb4, 0x44, 0x86,
+			0x38, 0xb4, 0x88, 0xaf,
+			0x38, 0xb4, 0xaf, 0x0c,
+			0x38, 0xb4, 0x13, 0x88,
+			0x38, 0xb4, 0x88, 0xaf,
+			0x38, 0xb4, 0xaf, 0x4b,
+			0x38, 0xb4, 0x4b, 0x88,
+			0x38, 0xb4, 0x88, 0xaf,
+			0x38, 0xb4, 0xaf, 0x4b,
+			0x38, 0xb4, 0x4b, 0x88,
+			0x38, 0xb4, 0x1d, 0xaf,
+			0x38, 0xb4, 0x02, 0x8a,
+			0x38, 0xb4, 0x4d, 0x86,
+			0x38, 0xb4, 0x10, 0x02,
+			0x38, 0xb4, 0xaf, 0x64,
+			0x38, 0xb4, 0x63, 0x10,
+			0x38, 0xb4, 0xfa, 0xf8,
+			0x38, 0xb4, 0x69, 0xef,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xac, 0x4c,
+			0x38, 0xb4, 0x17, 0x25,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xad, 0x40,
+			0x38, 0xb4, 0x1a, 0x25,
+			0x38, 0xb4, 0x86, 0x02,
+			0x38, 0xb4, 0xe0, 0x7c,
+			0x38, 0xb4, 0x40, 0x80,
+			0x38, 0xb4, 0x25, 0xac,
+			0x38, 0xb4, 0xbf, 0x11,
+			0x38, 0xb4, 0xf4, 0x87,
+			0x38, 0xb4, 0x77, 0x02,
+			0x38, 0xb4, 0xae, 0xf6,
+			0x38, 0xb4, 0x02, 0x09,
+			0x38, 0xb4, 0xb3, 0x87,
+			0x38, 0xb4, 0x87, 0x02,
+			0x38, 0xb4, 0x02, 0xe9,
+			0x38, 0xb4, 0xde, 0x87,
+			0x38, 0xb4, 0x96, 0xef,
+			0x38, 0xb4, 0xfc, 0xfe,
+			0x38, 0xb4, 0xf8, 0x04,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xad, 0x18,
+			0x38, 0xb4, 0x11, 0x26,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xac, 0x9c,
+			0x38, 0xb4, 0x05, 0x20,
+			0x38, 0xb4, 0x86, 0x02,
+			0x38, 0xb4, 0xae, 0x99,
+			0x38, 0xb4, 0x02, 0x03,
+			0x38, 0xb4, 0x07, 0x87,
+			0x38, 0xb4, 0x87, 0x02,
+			0x38, 0xb4, 0x02, 0x50,
+			0x38, 0xb4, 0xde, 0x87,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xf9, 0xf8,
+			0x38, 0xb4, 0x79, 0xef,
+			0x38, 0xb4, 0xbf, 0xfb,
+			0x38, 0xb4, 0xf7, 0x87,
+			0x38, 0xb4, 0x78, 0x02,
+			0x38, 0xb4, 0x5c, 0x38,
+			0x38, 0xb4, 0x00, 0x20,
+			0x38, 0xb4, 0x4d, 0x0d,
+			0x38, 0xb4, 0x01, 0xa1,
+			0x38, 0xb4, 0xbf, 0x51,
+			0x38, 0xb4, 0xf7, 0x87,
+			0x38, 0xb4, 0x78, 0x02,
+			0x38, 0xb4, 0x5c, 0x38,
+			0x38, 0xb4, 0xff, 0x07,
+			0x38, 0xb4, 0x8f, 0xe3,
+			0x38, 0xb4, 0x1b, 0x9d,
+			0x38, 0xb4, 0x9f, 0x31,
+			0x38, 0xb4, 0x0d, 0x41,
+			0x38, 0xb4, 0xe3, 0x48,
+			0x38, 0xb4, 0x9e, 0x8f,
+			0x38, 0xb4, 0x31, 0x1b,
+			0x38, 0xb4, 0x38, 0x9f,
+			0x38, 0xb4, 0x87, 0xbf,
+			0x38, 0xb4, 0x02, 0xfa,
+			0x38, 0xb4, 0x38, 0x78,
+			0x38, 0xb4, 0x07, 0x5c,
+			0x38, 0xb4, 0xe3, 0xff,
+			0x38, 0xb4, 0x9f, 0x8f,
+			0x38, 0xb4, 0x31, 0x1b,
+			0x38, 0xb4, 0x28, 0x9f,
+			0x38, 0xb4, 0x48, 0x0d,
+			0x38, 0xb4, 0x8f, 0xe3,
+			0x38, 0xb4, 0x1b, 0xa0,
+			0x38, 0xb4, 0x9f, 0x31,
+			0x38, 0xb4, 0xbf, 0x1f,
+			0x38, 0xb4, 0xfd, 0x87,
+			0x38, 0xb4, 0x78, 0x02,
+			0x38, 0xb4, 0x5c, 0x38,
+			0x38, 0xb4, 0xff, 0x07,
+			0x38, 0xb4, 0x8f, 0xe3,
+			0x38, 0xb4, 0x1b, 0xa1,
+			0x38, 0xb4, 0x9f, 0x31,
+			0x38, 0xb4, 0x0d, 0x0f,
+			0x38, 0xb4, 0xe3, 0x48,
+			0x38, 0xb4, 0xa2, 0x8f,
+			0x38, 0xb4, 0x31, 0x1b,
+			0x38, 0xb4, 0x06, 0x9f,
+			0x38, 0xb4, 0x8f, 0xee,
+			0x38, 0xb4, 0x01, 0x9c,
+			0x38, 0xb4, 0x04, 0xae,
+			0x38, 0xb4, 0x8f, 0xee,
+			0x38, 0xb4, 0x00, 0x9c,
+			0x38, 0xb4, 0xef, 0xff,
+			0x38, 0xb4, 0xfd, 0x97,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xf9, 0xf8,
+			0x38, 0xb4, 0x79, 0xef,
+			0x38, 0xb4, 0xbf, 0xfb,
+			0x38, 0xb4, 0xf7, 0x87,
+			0x38, 0xb4, 0x78, 0x02,
+			0x38, 0xb4, 0x5c, 0x38,
+			0x38, 0xb4, 0x00, 0x20,
+			0x38, 0xb4, 0x4d, 0x0d,
+			0x38, 0xb4, 0x00, 0xa1,
+			0x38, 0xb4, 0xbf, 0x20,
+			0x38, 0xb4, 0xf7, 0x87,
+			0x38, 0xb4, 0x78, 0x02,
+			0x38, 0xb4, 0x5c, 0x38,
+			0x38, 0xb4, 0x00, 0x06,
+			0x38, 0xb4, 0x49, 0x0d,
+			0x38, 0xb4, 0x8f, 0xe3,
+			0x38, 0xb4, 0x1b, 0xa3,
+			0x38, 0xb4, 0x9f, 0x31,
+			0x38, 0xb4, 0xbf, 0x0e,
+			0x38, 0xb4, 0x00, 0x88,
+			0x38, 0xb4, 0x77, 0x02,
+			0x38, 0xb4, 0xbf, 0xf6,
+			0x38, 0xb4, 0x06, 0x88,
+			0x38, 0xb4, 0x77, 0x02,
+			0x38, 0xb4, 0xae, 0xf6,
+			0x38, 0xb4, 0xbf, 0x0c,
+			0x38, 0xb4, 0x00, 0x88,
+			0x38, 0xb4, 0x77, 0x02,
+			0x38, 0xb4, 0xbf, 0xed,
+			0x38, 0xb4, 0x06, 0x88,
+			0x38, 0xb4, 0x77, 0x02,
+			0x38, 0xb4, 0xee, 0xed,
+			0x38, 0xb4, 0x9c, 0x8f,
+			0x38, 0xb4, 0xff, 0x00,
+			0x38, 0xb4, 0x97, 0xef,
+			0x38, 0xb4, 0xfc, 0xfd,
+			0x38, 0xb4, 0xf8, 0x04,
+			0x38, 0xb4, 0xef, 0xf9,
+			0x38, 0xb4, 0xfb, 0x79,
+			0x38, 0xb4, 0x87, 0xbf,
+			0x38, 0xb4, 0x02, 0xf7,
+			0x38, 0xb4, 0x38, 0x78,
+			0x38, 0xb4, 0x20, 0x5c,
+			0x38, 0xb4, 0x0d, 0x00,
+			0x38, 0xb4, 0xa1, 0x4d,
+			0x38, 0xb4, 0x4a, 0x01,
+			0x38, 0xb4, 0x87, 0xbf,
+			0x38, 0xb4, 0x02, 0xf7,
+			0x38, 0xb4, 0x38, 0x78,
+			0x38, 0xb4, 0x07, 0x5c,
+			0x38, 0xb4, 0xe3, 0xff,
+			0x38, 0xb4, 0xa4, 0x8f,
+			0x38, 0xb4, 0x31, 0x1b,
+			0x38, 0xb4, 0x3a, 0x9f,
+			0x38, 0xb4, 0x48, 0x0d,
+			0x38, 0xb4, 0x8f, 0xe3,
+			0x38, 0xb4, 0x1b, 0xa5,
+			0x38, 0xb4, 0x9f, 0x31,
+			0x38, 0xb4, 0xbf, 0x31,
+			0x38, 0xb4, 0xfa, 0x87,
+			0x38, 0xb4, 0x78, 0x02,
+			0x38, 0xb4, 0xe3, 0x38,
+			0x38, 0xb4, 0xa6, 0x8f,
+			0x38, 0xb4, 0x31, 0x1b,
+			0x38, 0xb4, 0x24, 0x9f,
+			0x38, 0xb4, 0x48, 0x0d,
+			0x38, 0xb4, 0x8f, 0xe3,
+			0x38, 0xb4, 0x1b, 0xa7,
+			0x38, 0xb4, 0x9f, 0x31,
+			0x38, 0xb4, 0xbf, 0x1b,
+			0x38, 0xb4, 0xfd, 0x87,
+			0x38, 0xb4, 0x78, 0x02,
+			0x38, 0xb4, 0xe3, 0x38,
+			0x38, 0xb4, 0xa8, 0x8f,
+			0x38, 0xb4, 0x31, 0x1b,
+			0x38, 0xb4, 0x0e, 0x9f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x03,
+			0x38, 0xb4, 0xf6, 0x77,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x09,
+			0x38, 0xb4, 0xf6, 0x77,
+			0x38, 0xb4, 0x00, 0xae,
+			0x38, 0xb4, 0xef, 0xff,
+			0x38, 0xb4, 0xfd, 0x97,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xef, 0xf8,
+			0x38, 0xb4, 0xfb, 0x79,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xad, 0x18,
+			0x38, 0xb4, 0x1c, 0x26,
+			0x38, 0xb4, 0x8f, 0xee,
+			0x38, 0xb4, 0x00, 0x9c,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x00,
+			0x38, 0xb4, 0xed, 0x77,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x06,
+			0x38, 0xb4, 0xed, 0x77,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x03,
+			0x38, 0xb4, 0xed, 0x77,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x09,
+			0x38, 0xb4, 0xed, 0x77,
+			0x38, 0xb4, 0xef, 0xff,
+			0x38, 0xb4, 0xfc, 0x97,
+			0x38, 0xb4, 0xf8, 0x04,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xf6, 0x40,
+			0x38, 0xb4, 0xe4, 0x25,
+			0x38, 0xb4, 0x40, 0x80,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xe0, 0xf8,
+			0x38, 0xb4, 0x4c, 0x80,
+			0x38, 0xb4, 0x25, 0xf6,
+			0x38, 0xb4, 0x80, 0xe4,
+			0x38, 0xb4, 0xfc, 0x4c,
+			0x38, 0xb4, 0x55, 0x04,
+			0x38, 0xb4, 0xba, 0xa4,
+			0x38, 0xb4, 0xa6, 0xf0,
+			0x38, 0xb4, 0xf0, 0x4a,
+			0x38, 0xb4, 0x4c, 0xa6,
+			0x38, 0xb4, 0xa6, 0xf0,
+			0x38, 0xb4, 0x66, 0x4e,
+			0x38, 0xb4, 0xb6, 0xa4,
+			0x38, 0xb4, 0xa4, 0x55,
+			0x38, 0xb4, 0x00, 0xb6,
+			0x38, 0xb4, 0x56, 0xac,
+			0x38, 0xb4, 0xac, 0x11,
+			0x38, 0xb4, 0xee, 0x56,
+			0x38, 0xb4, 0x4c, 0x80,
+			0x38, 0xb4, 0xaf, 0x3a,
+			0x38, 0xb4, 0x27, 0x06,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x48,
+			0x38, 0xb4, 0xed, 0x77,
+			0x38, 0xb4, 0x03, 0xd2,
+			0x38, 0xb4, 0x83, 0xe0,
+			0x38, 0xb4, 0x0d, 0x8a,
+			0x38, 0xb4, 0xf6, 0x01,
+			0x38, 0xb4, 0x1b, 0x27,
+			0x38, 0xb4, 0xaa, 0x03,
+			0x38, 0xb4, 0x82, 0x01,
+			0x38, 0xb4, 0x83, 0xe0,
+			0x38, 0xb4, 0x0d, 0x89,
+			0x38, 0xb4, 0xf6, 0x01,
+			0x38, 0xb4, 0x1b, 0x27,
+			0x38, 0xb4, 0xaa, 0x03,
+			0x38, 0xb4, 0x82, 0x01,
+			0x38, 0xb4, 0x83, 0xe0,
+			0x38, 0xb4, 0x0d, 0x88,
+			0x38, 0xb4, 0xf6, 0x01,
+			0x38, 0xb4, 0x1b, 0x27,
+			0x38, 0xb4, 0xaa, 0x03,
+			0x38, 0xb4, 0x82, 0x07,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x48,
+			0x38, 0xb4, 0xf6, 0x77,
+			0x38, 0xb4, 0x16, 0xaf,
+			0x38, 0xb4, 0x00, 0x15,
+			0x38, 0xb4, 0x6a, 0xa8,
+			0x36, 0xb4, 0x18, 0xb8,
+			0x38, 0xb4, 0x84, 0x1d,
+			0x36, 0xb4, 0x1a, 0xb8,
+			0x38, 0xb4, 0x60, 0x10,
+			0x36, 0xb4, 0x1c, 0xb8,
+			0x38, 0xb4, 0x23, 0x06,
+			0x36, 0xb4, 0x1e, 0xb8,
+			0x38, 0xb4, 0xef, 0x15,
+			0x36, 0xb4, 0x50, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x52, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x78, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x84, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x32, 0xb8,
+			0x38, 0xb4, 0x0f, 0x00,
+			0x36, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0,
+			0x2e, 0xb8, 0x00, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x23, 0x80,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x1e, 0x80,
+			0x38, 0xb4, 0x14, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0,
+			0x20, 0xb8, 0x00, 0x00,
+			0xff, 0xff, 0xff, 0xff};
+
+		code_ver = 0x0014;
+		ret = sram_read(tp, SRAM_GPHY_FW_VER, &fw_version);
+		if (ret < 0)
+			goto out;
+
+		if (fw_version < code_ver) {
+			data = ram16;
+			len = sizeof(ram16);
+
+			if (r8156b_flash_used(tp)) {
+				ret = ocp_word_set_bits(tp, MCU_TYPE_USB,
+							USB_GPHY_CTRL,
+							BYPASS_FLASH);
+				if (ret < 0)
+					goto out;
+			}
+		}
+	} else if (tp->version == RTL_VER_17) {
+		static u8 ram17[] = {
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x23, 0x80,
+			0x38, 0xb4, 0x00, 0x61,
+			0x36, 0xb4, 0x2e, 0xb8,
+			0x38, 0xb4, 0x01, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0,
+			0x20, 0xb8, 0x90, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x10, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1a, 0x80,
+			0x38, 0xb4, 0x00, 0xce,
+			0x38, 0xb4, 0x41, 0x29,
+			0x38, 0xb4, 0x17, 0x80,
+			0x38, 0xb4, 0x59, 0x2c,
+			0x38, 0xb4, 0x17, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x11, 0x0e,
+			0x38, 0xb4, 0xff, 0x8a,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x11, 0x0e,
+			0x36, 0xb4, 0x26, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x24, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x22, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x20, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x06, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x04, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x02, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x00, 0xa0,
+			0x38, 0xb4, 0x10, 0x0e,
+			0x36, 0xb4, 0x08, 0xa0,
+			0x38, 0xb4, 0x00, 0x01,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0xf8, 0x0f,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x9a, 0x21,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x52, 0xa1,
+			0x38, 0xb4, 0xa4, 0x21,
+			0x36, 0xb4, 0x54, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x56, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x58, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x5a, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x5c, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x5e, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x60, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x50, 0xa1,
+			0x38, 0xb4, 0x01, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x10, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x10, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x14, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1e, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x26, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2e, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x36, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3a, 0x80,
+			0x38, 0xb4, 0x01, 0xce,
+			0x38, 0xb4, 0x08, 0x82,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x28, 0x00,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xc5, 0x02,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x04, 0x03,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x19, 0x01,
+			0x38, 0xb4, 0x01, 0xce,
+			0x38, 0xb4, 0x08, 0x82,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x9e, 0x00,
+			0x38, 0xb4, 0x01, 0xd5,
+			0x38, 0xb4, 0x01, 0xce,
+			0x38, 0xb4, 0x0f, 0xa5,
+			0x38, 0xb4, 0x08, 0x82,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x0f, 0xaa,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x5b, 0x01,
+			0x38, 0xb4, 0x01, 0xd5,
+			0x38, 0xb4, 0x01, 0xce,
+			0x38, 0xb4, 0x0f, 0xa5,
+			0x38, 0xb4, 0x08, 0x82,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x0f, 0xaa,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xa9, 0x01,
+			0x38, 0xb4, 0x01, 0xd5,
+			0x38, 0xb4, 0x01, 0xce,
+			0x38, 0xb4, 0x0f, 0xa5,
+			0x38, 0xb4, 0x08, 0x82,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x0f, 0xaa,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xf4, 0x01,
+			0x38, 0xb4, 0x08, 0x82,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xa5, 0x02,
+			0x38, 0xb4, 0x08, 0xa2,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xb8, 0x02,
+			0x36, 0xb4, 0x8e, 0xa0,
+			0x38, 0xb4, 0xb7, 0x02,
+			0x36, 0xb4, 0x8c, 0xa0,
+			0x38, 0xb4, 0xa4, 0x02,
+			0x36, 0xb4, 0x8a, 0xa0,
+			0x38, 0xb4, 0xe7, 0x01,
+			0x36, 0xb4, 0x88, 0xa0,
+			0x38, 0xb4, 0x9c, 0x01,
+			0x36, 0xb4, 0x86, 0xa0,
+			0x38, 0xb4, 0x4e, 0x01,
+			0x36, 0xb4, 0x84, 0xa0,
+			0x38, 0xb4, 0x9d, 0x00,
+			0x36, 0xb4, 0x82, 0xa0,
+			0x38, 0xb4, 0x17, 0x01,
+			0x36, 0xb4, 0x80, 0xa0,
+			0x38, 0xb4, 0x27, 0x00,
+			0x36, 0xb4, 0x90, 0xa0,
+			0x38, 0xb4, 0xff, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x20, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x10, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1d, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3b, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x87, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x8e, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x9d, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xb7, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xc4, 0x80,
+			0x38, 0xb4, 0xbc, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xd2, 0x1c,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xba, 0x5f,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x3d, 0x27,
+			0x38, 0xb4, 0x1b, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xd1, 0x07,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x0e, 0x08,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xc9, 0x37,
+			0x38, 0xb4, 0x32, 0x80,
+			0x38, 0xb4, 0xa9, 0x33,
+			0x38, 0xb4, 0x2a, 0x80,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x84, 0x40,
+			0x38, 0xb4, 0xf4, 0xd1,
+			0x38, 0xb4, 0x48, 0xd0,
+			0x38, 0xb4, 0x13, 0xf0,
+			0x38, 0xb4, 0xb7, 0xd1,
+			0x38, 0xb4, 0x4b, 0xd0,
+			0x38, 0xb4, 0x10, 0xf0,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x84, 0x40,
+			0x38, 0xb4, 0xf4, 0xd1,
+			0x38, 0xb4, 0x48, 0xd0,
+			0x38, 0xb4, 0x0b, 0xf0,
+			0x38, 0xb4, 0xb7, 0xd1,
+			0x38, 0xb4, 0x4b, 0xd0,
+			0x38, 0xb4, 0x08, 0xf0,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x84, 0x40,
+			0x38, 0xb4, 0xf4, 0xd1,
+			0x38, 0xb4, 0x48, 0xd0,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0xb7, 0xd1,
+			0x38, 0xb4, 0x4b, 0xd0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xcc, 0x14,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x59, 0x2b,
+			0x38, 0xb4, 0x3f, 0x80,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x8f, 0x11,
+			0x38, 0xb4, 0x60, 0x60,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x67, 0x11,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xc7, 0x60,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x9f, 0x60,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x43, 0x40,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x50, 0x11,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x02, 0x87,
+			0x38, 0xb4, 0x11, 0x80,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x0a, 0x80,
+			0x38, 0xb4, 0xa0, 0x81,
+			0x38, 0xb4, 0x02, 0x83,
+			0x38, 0xb4, 0x80, 0x84,
+			0x38, 0xb4, 0x86, 0x86,
+			0x38, 0xb4, 0xe0, 0xcd,
+			0x38, 0xb4, 0xff, 0xd1,
+			0x38, 0xb4, 0x49, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xd2, 0x1c,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xba, 0x5f,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x7e, 0x41,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x11, 0xa0,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0xc8, 0xd1,
+			0x38, 0xb4, 0x45, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xd2, 0x1c,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xba, 0x5f,
+			0x38, 0xb4, 0x03, 0x0c,
+			0x38, 0xb4, 0x02, 0x15,
+			0x38, 0xb4, 0x02, 0xa7,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x0a, 0xa0,
+			0x38, 0xb4, 0xa0, 0xa1,
+			0x38, 0xb4, 0x80, 0xa4,
+			0x38, 0xb4, 0x86, 0xa6,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x5e, 0x60,
+			0x38, 0xb4, 0x02, 0xa3,
+			0x38, 0xb4, 0x03, 0x95,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xc9, 0x37,
+			0x38, 0xb4, 0x83, 0x80,
+			0x38, 0xb4, 0xa9, 0x33,
+			0x38, 0xb4, 0x7f, 0x80,
+			0x38, 0xb4, 0x78, 0xd1,
+			0x38, 0xb4, 0x4b, 0xd0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x5d, 0x11,
+			0x38, 0xb4, 0xc8, 0xd1,
+			0x38, 0xb4, 0x4b, 0xd0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x5d, 0x11,
+			0x38, 0xb4, 0xe6, 0xd1,
+			0x38, 0xb4, 0x4b, 0xd0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x5d, 0x11,
+			0x38, 0xb4, 0x1f, 0xd7,
+			0x38, 0xb4, 0x80, 0x60,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xc0, 0x1b,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xc4, 0x1b,
+			0x38, 0xb4, 0x34, 0x41,
+			0x38, 0xb4, 0x15, 0xd1,
+			0x38, 0xb4, 0x4f, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x0b, 0x1d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xad, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xf2, 0x01,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x0b, 0x1d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xad, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xf9, 0x01,
+			0x38, 0xb4, 0x69, 0x29,
+			0x38, 0xb4, 0xa3, 0x80,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x6b, 0x60,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0xb4, 0x60,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xad, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x51, 0x05,
+			0x38, 0xb4, 0x96, 0xd1,
+			0x38, 0xb4, 0x4d, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xad, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x4d, 0x05,
+			0x38, 0xb4, 0x08, 0xd2,
+			0x38, 0xb4, 0x09, 0x0c,
+			0x38, 0xb4, 0x01, 0x13,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xd2, 0x1c,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0xa3, 0x5f,
+			0x38, 0xb4, 0x02, 0xb3,
+			0x38, 0xb4, 0x00, 0xd2,
+			0x38, 0xb4, 0x00, 0x08,
+			0x38, 0xb4, 0x05, 0xd7,
+			0x38, 0xb4, 0x64, 0x60,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x0a, 0x14,
+			0x38, 0xb4, 0x10, 0x88,
+			0x38, 0xb4, 0x99, 0xd1,
+			0x38, 0xb4, 0x4b, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xd2, 0x1c,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xba, 0x5f,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x0a, 0x14,
+			0x36, 0xb4, 0x0e, 0xa1,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x0c, 0xa1,
+			0x38, 0xb4, 0x52, 0x13,
+			0x36, 0xb4, 0x0a, 0xa1,
+			0x38, 0xb4, 0x45, 0x05,
+			0x36, 0xb4, 0x08, 0xa1,
+			0x38, 0xb4, 0xed, 0x01,
+			0x36, 0xb4, 0x06, 0xa1,
+			0x38, 0xb4, 0xbf, 0x1b,
+			0x36, 0xb4, 0x04, 0xa1,
+			0x38, 0xb4, 0x4b, 0x11,
+			0x36, 0xb4, 0x02, 0xa1,
+			0x38, 0xb4, 0xbf, 0x14,
+			0x36, 0xb4, 0x00, 0xa1,
+			0x38, 0xb4, 0xce, 0x07,
+			0x36, 0xb4, 0x10, 0xa1,
+			0x38, 0xb4, 0x7f, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x20, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0xf8, 0x1f,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0xce, 0xd1,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x64, 0xa1,
+			0x38, 0xb4, 0xfc, 0x07,
+			0x36, 0xb4, 0x66, 0xa1,
+			0x38, 0xb4, 0x3d, 0x14,
+			0x36, 0xb4, 0x68, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x6a, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x6c, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x6e, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x70, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x72, 0xa1,
+			0x38, 0xb4, 0xff, 0x3f,
+			0x36, 0xb4, 0x62, 0xa1,
+			0x38, 0xb4, 0x03, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0x94, 0x89,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0x89, 0xaf,
+			0x38, 0xb4, 0xaf, 0xac,
+			0x38, 0xb4, 0xe4, 0x89,
+			0x38, 0xb4, 0x89, 0xaf,
+			0x38, 0xb4, 0xaf, 0xec,
+			0x38, 0xb4, 0x04, 0x8a,
+			0x38, 0xb4, 0x8a, 0xaf,
+			0x38, 0xb4, 0xaf, 0x2e,
+			0x38, 0xb4, 0x4a, 0x8a,
+			0x38, 0xb4, 0x8d, 0xaf,
+			0x38, 0xb4, 0xaf, 0x31,
+			0x38, 0xb4, 0xc6, 0x8d,
+			0x38, 0xb4, 0x55, 0x1f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xa1, 0xe3,
+			0x38, 0xb4, 0x07, 0x00,
+			0x38, 0xb4, 0x86, 0xee,
+			0x38, 0xb4, 0x00, 0xe9,
+			0x38, 0xb4, 0x4f, 0xaf,
+			0x38, 0xb4, 0xad, 0x9e,
+			0x38, 0xb4, 0x1b, 0x28,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xef, 0xfc,
+			0x38, 0xb4, 0xbf, 0x71,
+			0x38, 0xb4, 0xf6, 0x74,
+			0x38, 0xb4, 0x7e, 0x02,
+			0x38, 0xb4, 0xef, 0xd2,
+			0x38, 0xb4, 0x1c, 0x64,
+			0x38, 0xb4, 0x0d, 0x67,
+			0x38, 0xb4, 0xef, 0x67,
+			0x38, 0xb4, 0x1f, 0x46,
+			0x38, 0xb4, 0xbf, 0x00,
+			0x38, 0xb4, 0xf6, 0x74,
+			0x38, 0xb4, 0x7e, 0x02,
+			0x38, 0xb4, 0xe1, 0xde,
+			0x38, 0xb4, 0xe3, 0x8f,
+			0x38, 0xb4, 0x11, 0x0d,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0x13, 0xe3,
+			0x38, 0xb4, 0xca, 0xae,
+			0x38, 0xb4, 0x8d, 0x02,
+			0x38, 0xb4, 0xd3, 0xd1,
+			0x38, 0xb4, 0xaf, 0x01,
+			0x38, 0xb4, 0xd1, 0x40,
+			0x38, 0xb4, 0x7a, 0xbf,
+			0x38, 0xb4, 0x02, 0x61,
+			0x38, 0xb4, 0x44, 0x7d,
+			0x38, 0xb4, 0x00, 0xa1,
+			0x38, 0xb4, 0xe0, 0x09,
+			0x38, 0xb4, 0xfa, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xaf, 0xfb,
+			0x38, 0xb4, 0x3d, 0x68,
+			0x38, 0xb4, 0x7f, 0x02,
+			0x38, 0xb4, 0xaf, 0xa9,
+			0x38, 0xb4, 0x2c, 0x68,
+			0x38, 0xb4, 0x8e, 0xbf,
+			0x38, 0xb4, 0x02, 0x41,
+			0x38, 0xb4, 0x44, 0x7d,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xbf, 0xec,
+			0x38, 0xb4, 0xcc, 0x74,
+			0x38, 0xb4, 0x7d, 0x02,
+			0x38, 0xb4, 0xe3, 0x44,
+			0x38, 0xb4, 0xed, 0x8f,
+			0x38, 0xb4, 0x31, 0x0d,
+			0x38, 0xb4, 0x3f, 0xf6,
+			0x38, 0xb4, 0x11, 0x0d,
+			0x38, 0xb4, 0x2f, 0xf6,
+			0x38, 0xb4, 0x13, 0x1b,
+			0x38, 0xb4, 0x2f, 0xad,
+			0x38, 0xb4, 0xbf, 0x06,
+			0x38, 0xb4, 0x41, 0x8e,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0xd1, 0xf9,
+			0x38, 0xb4, 0xaf, 0x01,
+			0x38, 0xb4, 0x74, 0x59,
+			0x38, 0xb4, 0x88, 0xee,
+			0x38, 0xb4, 0x00, 0x86,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0xff, 0xff, 0xff, 0xff,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x38, 0xb4, 0xad, 0xeb,
+			0x38, 0xb4, 0x0b, 0x20,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xbf, 0xec,
+			0x38, 0xb4, 0x41, 0x8e,
+			0x38, 0xb4, 0x7d, 0x02,
+			0x38, 0xb4, 0xae, 0x25,
+			0x38, 0xb4, 0xee, 0x04,
+			0x38, 0xb4, 0xeb, 0x8f,
+			0x38, 0xb4, 0xaf, 0x01,
+			0x38, 0xb4, 0x45, 0x59,
+			0x38, 0xb4, 0x28, 0xad,
+			0x38, 0xb4, 0xe0, 0x2c,
+			0x38, 0xb4, 0xea, 0x8f,
+			0x38, 0xb4, 0x00, 0xa0,
+			0x38, 0xb4, 0x02, 0x05,
+			0x38, 0xb4, 0xf0, 0x8a,
+			0x38, 0xb4, 0x1e, 0xae,
+			0x38, 0xb4, 0x01, 0xa0,
+			0x38, 0xb4, 0x02, 0x05,
+			0x38, 0xb4, 0x9f, 0x8b,
+			0x38, 0xb4, 0x16, 0xae,
+			0x38, 0xb4, 0x02, 0xa0,
+			0x38, 0xb4, 0x02, 0x05,
+			0x38, 0xb4, 0x0f, 0x8c,
+			0x38, 0xb4, 0x0e, 0xae,
+			0x38, 0xb4, 0x03, 0xa0,
+			0x38, 0xb4, 0x02, 0x05,
+			0x38, 0xb4, 0x95, 0x8c,
+			0x38, 0xb4, 0x06, 0xae,
+			0x38, 0xb4, 0x04, 0xa0,
+			0x38, 0xb4, 0x02, 0x03,
+			0x38, 0xb4, 0x08, 0x8d,
+			0x38, 0xb4, 0x63, 0xaf,
+			0x38, 0xb4, 0x02, 0x89,
+			0x38, 0xb4, 0x7f, 0x8a,
+			0x38, 0xb4, 0x63, 0xaf,
+			0x38, 0xb4, 0xf8, 0x81,
+			0x38, 0xb4, 0x49, 0xef,
+			0x38, 0xb4, 0xe0, 0xf8,
+			0x38, 0xb4, 0x15, 0x80,
+			0x38, 0xb4, 0x21, 0xad,
+			0x38, 0xb4, 0xbf, 0x19,
+			0x38, 0xb4, 0xd8, 0x7b,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0xbf, 0xf9,
+			0x38, 0xb4, 0xf3, 0x7b,
+			0x38, 0xb4, 0x7d, 0x02,
+			0x38, 0xb4, 0xbf, 0x44,
+			0x38, 0xb4, 0xf6, 0x7b,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0x02, 0xf9,
+			0x38, 0xb4, 0x8e, 0x63,
+			0x38, 0xb4, 0x8f, 0xee,
+			0x38, 0xb4, 0x00, 0xea,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xad, 0x16,
+			0x38, 0xb4, 0x3d, 0x23,
+			0x38, 0xb4, 0x7b, 0xbf,
+			0x38, 0xb4, 0x02, 0xf3,
+			0x38, 0xb4, 0x44, 0x7d,
+			0x38, 0xb4, 0x7a, 0xbf,
+			0x38, 0xb4, 0x02, 0x94,
+			0x38, 0xb4, 0xf9, 0x7c,
+			0x38, 0xb4, 0x8e, 0xbf,
+			0x38, 0xb4, 0x02, 0x44,
+			0x38, 0xb4, 0xf9, 0x7c,
+			0x38, 0xb4, 0x7a, 0xbf,
+			0x38, 0xb4, 0x02, 0xa6,
+			0x38, 0xb4, 0xf9, 0x7c,
+			0x38, 0xb4, 0x7a, 0xbf,
+			0x38, 0xb4, 0x02, 0xa3,
+			0x38, 0xb4, 0xf9, 0x7c,
+			0x38, 0xb4, 0x7a, 0xbf,
+			0x38, 0xb4, 0x02, 0xa9,
+			0x38, 0xb4, 0xf9, 0x7c,
+			0x38, 0xb4, 0x7a, 0xbf,
+			0x38, 0xb4, 0x02, 0xac,
+			0x38, 0xb4, 0xf9, 0x7c,
+			0x38, 0xb4, 0x8e, 0xbf,
+			0x38, 0xb4, 0x02, 0x47,
+			0x38, 0xb4, 0xf9, 0x7c,
+			0x38, 0xb4, 0x8e, 0xbf,
+			0x38, 0xb4, 0x02, 0x4a,
+			0x38, 0xb4, 0xf9, 0x7c,
+			0x38, 0xb4, 0x63, 0x02,
+			0x38, 0xb4, 0xee, 0x8e,
+			0x38, 0xb4, 0xea, 0x8f,
+			0x38, 0xb4, 0xbf, 0x00,
+			0x38, 0xb4, 0x02, 0x7c,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0xfc, 0xf9,
+			0x38, 0xb4, 0x94, 0xef,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xf9, 0xf8,
+			0x38, 0xb4, 0xef, 0xfb,
+			0x38, 0xb4, 0xfb, 0x79,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xac, 0x15,
+			0x38, 0xb4, 0x03, 0x21,
+			0x38, 0xb4, 0x8b, 0xaf,
+			0x38, 0xb4, 0xee, 0x70,
+			0x38, 0xb4, 0x88, 0x88,
+			0x38, 0xb4, 0xee, 0x00,
+			0x38, 0xb4, 0x8a, 0x88,
+			0x38, 0xb4, 0xee, 0x00,
+			0x38, 0xb4, 0x8b, 0x88,
+			0x38, 0xb4, 0xbf, 0x00,
+			0x38, 0xb4, 0xd8, 0x7b,
+			0x38, 0xb4, 0x7d, 0x02,
+			0x38, 0xb4, 0xbf, 0x02,
+			0x38, 0xb4, 0x00, 0x60,
+			0x38, 0xb4, 0x88, 0xd7,
+			0x38, 0xb4, 0x1f, 0x88,
+			0x38, 0xb4, 0xd4, 0x44,
+			0x38, 0xb4, 0x0c, 0x00,
+			0x38, 0xb4, 0x73, 0x02,
+			0x38, 0xb4, 0x02, 0x3b,
+			0x38, 0xb4, 0xa9, 0x7f,
+			0x38, 0xb4, 0x28, 0xac,
+			0x38, 0xb4, 0xac, 0x05,
+			0x38, 0xb4, 0x0d, 0x29,
+			0x38, 0xb4, 0x18, 0xae,
+			0x38, 0xb4, 0x88, 0xe1,
+			0x38, 0xb4, 0xbf, 0x98,
+			0x38, 0xb4, 0xe1, 0x7b,
+			0x38, 0xb4, 0x7d, 0x02,
+			0x38, 0xb4, 0xae, 0x25,
+			0x38, 0xb4, 0xe1, 0x18,
+			0x38, 0xb4, 0x98, 0x88,
+			0x38, 0xb4, 0x11, 0x0d,
+			0x38, 0xb4, 0x7b, 0xbf,
+			0x38, 0xb4, 0x02, 0xe1,
+			0x38, 0xb4, 0x25, 0x7d,
+			0x38, 0xb4, 0x0b, 0xae,
+			0x38, 0xb4, 0x88, 0xe1,
+			0x38, 0xb4, 0x0d, 0x98,
+			0x38, 0xb4, 0xbf, 0x12,
+			0x38, 0xb4, 0xe1, 0x7b,
+			0x38, 0xb4, 0x7d, 0x02,
+			0x38, 0xb4, 0xbf, 0x25,
+			0x38, 0xb4, 0xa0, 0x88,
+			0x38, 0xb4, 0x19, 0xda,
+			0x38, 0xb4, 0x19, 0xdb,
+			0x38, 0xb4, 0x19, 0xd8,
+			0x38, 0xb4, 0x1f, 0xd9,
+			0x38, 0xb4, 0xbf, 0x77,
+			0x38, 0xb4, 0xb1, 0x88,
+			0x38, 0xb4, 0x19, 0xde,
+			0x38, 0xb4, 0x19, 0xdf,
+			0x38, 0xb4, 0x19, 0xdc,
+			0x38, 0xb4, 0x19, 0xdd,
+			0x38, 0xb4, 0xa7, 0x17,
+			0x38, 0xb4, 0x04, 0x00,
+			0x38, 0xb4, 0x02, 0xf3,
+			0x38, 0xb4, 0xcd, 0x63,
+			0x38, 0xb4, 0x8f, 0xee,
+			0x38, 0xb4, 0x01, 0xea,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xad, 0x16,
+			0x38, 0xb4, 0x19, 0x23,
+			0x38, 0xb4, 0x88, 0xee,
+			0x38, 0xb4, 0x00, 0x88,
+			0x38, 0xb4, 0x88, 0xee,
+			0x38, 0xb4, 0x00, 0x8a,
+			0x38, 0xb4, 0x88, 0xee,
+			0x38, 0xb4, 0x00, 0x8b,
+			0x38, 0xb4, 0x8e, 0xbf,
+			0x38, 0xb4, 0x02, 0x44,
+			0x38, 0xb4, 0x02, 0x7d,
+			0x38, 0xb4, 0x63, 0x02,
+			0x38, 0xb4, 0xee, 0xcd,
+			0x38, 0xb4, 0xea, 0x8f,
+			0x38, 0xb4, 0x02, 0x01,
+			0x38, 0xb4, 0xde, 0x70,
+			0x38, 0xb4, 0x7c, 0xbf,
+			0x38, 0xb4, 0x02, 0x02,
+			0x38, 0xb4, 0x02, 0x7d,
+			0x38, 0xb4, 0xef, 0xff,
+			0x38, 0xb4, 0xff, 0x97,
+			0x38, 0xb4, 0xfc, 0xfd,
+			0x38, 0xb4, 0xf8, 0x04,
+			0x38, 0xb4, 0xfa, 0xf9,
+			0x38, 0xb4, 0x69, 0xef,
+			0x38, 0xb4, 0xe0, 0xfa,
+			0x38, 0xb4, 0x8a, 0x88,
+			0x38, 0xb4, 0x88, 0xe1,
+			0x38, 0xb4, 0x14, 0x8b,
+			0x38, 0xb4, 0x88, 0xe4,
+			0x38, 0xb4, 0xe5, 0x8a,
+			0x38, 0xb4, 0x8b, 0x88,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0xd8, 0x94,
+			0x38, 0xb4, 0xd9, 0x19,
+			0x38, 0xb4, 0x64, 0xef,
+			0x38, 0xb4, 0x88, 0xe0,
+			0x38, 0xb4, 0xe1, 0x8a,
+			0x38, 0xb4, 0x8b, 0x88,
+			0x38, 0xb4, 0x46, 0x1b,
+			0x38, 0xb4, 0x30, 0x9f,
+			0x38, 0xb4, 0x44, 0x1f,
+			0x38, 0xb4, 0x88, 0xe4,
+			0x38, 0xb4, 0xe5, 0x8a,
+			0x38, 0xb4, 0x8b, 0x88,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xad, 0x15,
+			0x38, 0xb4, 0x1a, 0x21,
+			0x38, 0xb4, 0x60, 0x02,
+			0x38, 0xb4, 0xe0, 0xec,
+			0x38, 0xb4, 0x16, 0x80,
+			0x38, 0xb4, 0x23, 0xad,
+			0x38, 0xb4, 0x02, 0x16,
+			0x38, 0xb4, 0x86, 0x7c,
+			0x38, 0xb4, 0x47, 0xef,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xe9,
+			0x38, 0xb4, 0xe8, 0x8f,
+			0x38, 0xb4, 0x8f, 0xee,
+			0x38, 0xb4, 0x02, 0xea,
+			0x38, 0xb4, 0x0b, 0xae,
+			0x38, 0xb4, 0x8c, 0x02,
+			0x38, 0xb4, 0xae, 0x2e,
+			0x38, 0xb4, 0x02, 0x06,
+			0x38, 0xb4, 0xfe, 0x8b,
+			0x38, 0xb4, 0x70, 0x02,
+			0x38, 0xb4, 0xfe, 0xde,
+			0x38, 0xb4, 0x96, 0xef,
+			0x38, 0xb4, 0xfd, 0xfe,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xe1, 0xf8,
+			0x38, 0xb4, 0x88, 0x88,
+			0x38, 0xb4, 0xe5, 0x11,
+			0x38, 0xb4, 0x88, 0x88,
+			0x38, 0xb4, 0x2a, 0xad,
+			0x38, 0xb4, 0xee, 0x04,
+			0x38, 0xb4, 0x88, 0x88,
+			0x38, 0xb4, 0xfc, 0x00,
+			0x38, 0xb4, 0xf8, 0x04,
+			0x38, 0xb4, 0xfb, 0xfa,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xe1, 0xe9,
+			0x38, 0xb4, 0xe8, 0x8f,
+			0x38, 0xb4, 0x64, 0xef,
+			0x38, 0xb4, 0x00, 0x1f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xef, 0xe6,
+			0x38, 0xb4, 0x02, 0x74,
+			0x38, 0xb4, 0xa1, 0x7c,
+			0x38, 0xb4, 0x50, 0xad,
+			0x38, 0xb4, 0x02, 0x03,
+			0x38, 0xb4, 0x2e, 0x8c,
+			0x38, 0xb4, 0xfe, 0xff,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xfa, 0xf8,
+			0x38, 0xb4, 0x69, 0xef,
+			0x38, 0xb4, 0xbf, 0xfb,
+			0x38, 0xb4, 0xf3, 0x7b,
+			0x38, 0xb4, 0x7d, 0x02,
+			0x38, 0xb4, 0xac, 0x44,
+			0x38, 0xb4, 0x4c, 0x28,
+			0x38, 0xb4, 0x64, 0x02,
+			0x38, 0xb4, 0xbf, 0x1c,
+			0x38, 0xb4, 0x47, 0x8e,
+			0x38, 0xb4, 0x7d, 0x02,
+			0x38, 0xb4, 0xbf, 0x02,
+			0x38, 0xb4, 0x4a, 0x8e,
+			0x38, 0xb4, 0x7d, 0x02,
+			0x38, 0xb4, 0xd1, 0x02,
+			0x38, 0xb4, 0xb1, 0x43,
+			0x38, 0xb4, 0xbf, 0xfe,
+			0x38, 0xb4, 0xa6, 0x7a,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0xbf, 0xf9,
+			0x38, 0xb4, 0xa3, 0x7a,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0xbf, 0xf9,
+			0x38, 0xb4, 0xa9, 0x7a,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0xbf, 0xf9,
+			0x38, 0xb4, 0xac, 0x7a,
+			0x38, 0xb4, 0x7d, 0x02,
+			0x38, 0xb4, 0xd1, 0x02,
+			0x38, 0xb4, 0xe0, 0x80,
+			0x38, 0xb4, 0x88, 0x88,
+			0x38, 0xb4, 0x0e, 0x10,
+			0x38, 0xb4, 0xb0, 0x11,
+			0x38, 0xb4, 0xbf, 0xfc,
+			0x38, 0xb4, 0x94, 0x7a,
+			0x38, 0xb4, 0x7d, 0x02,
+			0x38, 0xb4, 0x02, 0x25,
+			0x38, 0xb4, 0x86, 0x7c,
+			0x38, 0xb4, 0x47, 0xef,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xe9,
+			0x38, 0xb4, 0xe8, 0x8f,
+			0x38, 0xb4, 0x8f, 0xee,
+			0x38, 0xb4, 0x03, 0xea,
+			0x38, 0xb4, 0x07, 0xae,
+			0x38, 0xb4, 0x8f, 0xee,
+			0x38, 0xb4, 0x01, 0xea,
+			0x38, 0xb4, 0x70, 0x02,
+			0x38, 0xb4, 0xff, 0xde,
+			0x38, 0xb4, 0x96, 0xef,
+			0x38, 0xb4, 0xfc, 0xfe,
+			0x38, 0xb4, 0xf8, 0x04,
+			0x38, 0xb4, 0xfa, 0xf9,
+			0x38, 0xb4, 0xef, 0xfb,
+			0x38, 0xb4, 0xfb, 0x79,
+			0x38, 0xb4, 0x7a, 0xbf,
+			0x38, 0xb4, 0x02, 0x94,
+			0x38, 0xb4, 0x44, 0x7d,
+			0x38, 0xb4, 0x21, 0xef,
+			0x38, 0xb4, 0x7a, 0xbf,
+			0x38, 0xb4, 0x02, 0xb8,
+			0x38, 0xb4, 0x44, 0x7d,
+			0x38, 0xb4, 0x21, 0x1f,
+			0x38, 0xb4, 0x19, 0x9e,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xe1, 0xe9,
+			0x38, 0xb4, 0xe8, 0x8f,
+			0x38, 0xb4, 0x64, 0xef,
+			0x38, 0xb4, 0x00, 0x1f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xef, 0xe4,
+			0x38, 0xb4, 0x02, 0x74,
+			0x38, 0xb4, 0xa1, 0x7c,
+			0x38, 0xb4, 0x50, 0xad,
+			0x38, 0xb4, 0xee, 0x3d,
+			0x38, 0xb4, 0xe7, 0x8f,
+			0x38, 0xb4, 0xbf, 0x01,
+			0x38, 0xb4, 0x94, 0x7a,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0xbf, 0xf9,
+			0x38, 0xb4, 0xa6, 0x7a,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0xbf, 0xf9,
+			0x38, 0xb4, 0xa3, 0x7a,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0xbf, 0xf9,
+			0x38, 0xb4, 0xa9, 0x7a,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0xbf, 0xf9,
+			0x38, 0xb4, 0xac, 0x7a,
+			0x38, 0xb4, 0x7d, 0x02,
+			0x38, 0xb4, 0xbf, 0x02,
+			0x38, 0xb4, 0x47, 0x8e,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0xbf, 0xf9,
+			0x38, 0xb4, 0x4a, 0x8e,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0x02, 0xf9,
+			0x38, 0xb4, 0x86, 0x7c,
+			0x38, 0xb4, 0x47, 0xef,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xe9,
+			0x38, 0xb4, 0xe8, 0x8f,
+			0x38, 0xb4, 0x8f, 0xee,
+			0x38, 0xb4, 0x04, 0xea,
+			0x38, 0xb4, 0xef, 0xff,
+			0x38, 0xb4, 0xff, 0x97,
+			0x38, 0xb4, 0xfd, 0xfe,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xfa, 0xf8,
+			0x38, 0xb4, 0xe0, 0xfb,
+			0x38, 0xb4, 0xe9, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xef, 0xe8,
+			0x38, 0xb4, 0x1f, 0x64,
+			0x38, 0xb4, 0xe1, 0x00,
+			0x38, 0xb4, 0xe5, 0x8f,
+			0x38, 0xb4, 0x74, 0xef,
+			0x38, 0xb4, 0x7c, 0x02,
+			0x38, 0xb4, 0xad, 0xa1,
+			0x38, 0xb4, 0x0d, 0x50,
+			0x38, 0xb4, 0x63, 0x02,
+			0x38, 0xb4, 0x02, 0x8e,
+			0x38, 0xb4, 0xfe, 0x8b,
+			0x38, 0xb4, 0x8f, 0xee,
+			0x38, 0xb4, 0x01, 0xea,
+			0x38, 0xb4, 0x70, 0x02,
+			0x38, 0xb4, 0xff, 0xde,
+			0x38, 0xb4, 0xfc, 0xfe,
+			0x38, 0xb4, 0xe3, 0x04,
+			0x38, 0xb4, 0xd8, 0x8f,
+			0x38, 0xb4, 0x87, 0xe7,
+			0x38, 0xb4, 0xe4, 0x75,
+			0x38, 0xb4, 0xe1, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xbf, 0xe2,
+			0x38, 0xb4, 0xd9, 0x8f,
+			0x38, 0xb4, 0x32, 0xef,
+			0x38, 0xb4, 0x31, 0x0c,
+			0x38, 0xb4, 0x93, 0x1a,
+			0x38, 0xb4, 0x19, 0xdc,
+			0x38, 0xb4, 0x02, 0xdd,
+			0x38, 0xb4, 0xa9, 0x7f,
+			0x38, 0xb4, 0x2a, 0xac,
+			0x38, 0xb4, 0xe0, 0x18,
+			0x38, 0xb4, 0xe1, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xef, 0xe2,
+			0x38, 0xb4, 0xe1, 0x74,
+			0x38, 0xb4, 0x75, 0x87,
+			0x38, 0xb4, 0x00, 0x1f,
+			0x38, 0xb4, 0x64, 0xef,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xe5, 0xd8,
+			0x38, 0xb4, 0x75, 0x87,
+			0x38, 0xb4, 0x4d, 0xaf,
+			0x38, 0xb4, 0xbf, 0x72,
+			0x38, 0xb4, 0x3c, 0x7b,
+			0x38, 0xb4, 0x32, 0xef,
+			0x38, 0xb4, 0x03, 0x4b,
+			0x38, 0xb4, 0x93, 0x1a,
+			0x38, 0xb4, 0x7d, 0x02,
+			0x38, 0xb4, 0xef, 0x44,
+			0x38, 0xb4, 0xe1, 0x64,
+			0x38, 0xb4, 0xff, 0x8f,
+			0x38, 0xb4, 0x00, 0x1f,
+			0x38, 0xb4, 0x74, 0xef,
+			0x38, 0xb4, 0x67, 0x1b,
+			0x38, 0xb4, 0x4f, 0xac,
+			0x38, 0xb4, 0xe0, 0xce,
+			0x38, 0xb4, 0xfd, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xef, 0xfe,
+			0x38, 0xb4, 0xe0, 0x64,
+			0x38, 0xb4, 0xe1, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xef, 0xe2,
+			0x38, 0xb4, 0x02, 0x74,
+			0x38, 0xb4, 0x53, 0x7c,
+			0x38, 0xb4, 0x50, 0xac,
+			0x38, 0xb4, 0xae, 0x02,
+			0x38, 0xb4, 0xe1, 0xb6,
+			0x38, 0xb4, 0x75, 0x87,
+			0x38, 0xb4, 0x00, 0x1f,
+			0x38, 0xb4, 0x64, 0xef,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xef, 0xfc,
+			0x38, 0xb4, 0x1c, 0x71,
+			0x38, 0xb4, 0x0d, 0x67,
+			0x38, 0xb4, 0xef, 0x67,
+			0x38, 0xb4, 0xe5, 0x46,
+			0x38, 0xb4, 0x75, 0x87,
+			0x38, 0xb4, 0x32, 0xef,
+			0x38, 0xb4, 0x01, 0xd1,
+			0x38, 0xb4, 0x00, 0xa3,
+			0x38, 0xb4, 0xae, 0x02,
+			0x38, 0xb4, 0x0c, 0x05,
+			0x38, 0xb4, 0x83, 0x11,
+			0x38, 0xb4, 0xf6, 0xae,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0x1e, 0xe3,
+			0x38, 0xb4, 0xe5, 0x10,
+			0x38, 0xb4, 0xe3, 0x8f,
+			0x38, 0xb4, 0x89, 0xae,
+			0x38, 0xb4, 0x87, 0xe2,
+			0x38, 0xb4, 0xe6, 0x75,
+			0x38, 0xb4, 0xd8, 0x8f,
+			0x38, 0xb4, 0x22, 0x1f,
+			0x38, 0xb4, 0x4d, 0xaf,
+			0x38, 0xb4, 0xf8, 0x42,
+			0x38, 0xb4, 0xef, 0xf9,
+			0x38, 0xb4, 0xfa, 0x59,
+			0x38, 0xb4, 0xbf, 0xfb,
+			0x38, 0xb4, 0xee, 0x8f,
+			0x38, 0xb4, 0x7f, 0x02,
+			0x38, 0xb4, 0x0d, 0xa9,
+			0x38, 0xb4, 0x49, 0x11,
+			0x38, 0xb4, 0x1a, 0x04,
+			0x38, 0xb4, 0xd7, 0x91,
+			0x38, 0xb4, 0xf3, 0x8d,
+			0x38, 0xb4, 0x8e, 0xd6,
+			0x38, 0xb4, 0x02, 0x23,
+			0x38, 0xb4, 0xaa, 0x72,
+			0x38, 0xb4, 0xfe, 0xff,
+			0x38, 0xb4, 0x95, 0xef,
+			0x38, 0xb4, 0xfc, 0xfd,
+			0x38, 0xb4, 0x00, 0x04,
+			0x38, 0xb4, 0x91, 0x75,
+			0x38, 0xb4, 0x75, 0x02,
+			0x38, 0xb4, 0x04, 0x44,
+			0x38, 0xb4, 0x8e, 0x75,
+			0x38, 0xb4, 0x75, 0x26,
+			0x38, 0xb4, 0x00, 0x41,
+			0x38, 0xb4, 0x26, 0x8e,
+			0x38, 0xb4, 0x8e, 0x02,
+			0x38, 0xb4, 0x04, 0x23,
+			0x38, 0xb4, 0x9d, 0x75,
+			0x38, 0xb4, 0x75, 0x26,
+			0x38, 0xb4, 0x00, 0x47,
+			0x38, 0xb4, 0x32, 0x8e,
+			0x38, 0xb4, 0x8e, 0x02,
+			0x38, 0xb4, 0x04, 0x2f,
+			0x38, 0xb4, 0x2c, 0x8e,
+			0x38, 0xb4, 0x8e, 0x26,
+			0x38, 0xb4, 0x00, 0x29,
+			0x38, 0xb4, 0x3e, 0x8e,
+			0x38, 0xb4, 0x8e, 0x02,
+			0x38, 0xb4, 0x04, 0x3b,
+			0x38, 0xb4, 0x38, 0x8e,
+			0x38, 0xb4, 0x8e, 0x26,
+			0x38, 0xb4, 0xfe, 0x35,
+			0x38, 0xb4, 0x96, 0xad,
+			0x38, 0xb4, 0xad, 0xdc,
+			0x38, 0xb4, 0xba, 0x96,
+			0x38, 0xb4, 0x96, 0xad,
+			0x38, 0xb4, 0xad, 0x98,
+			0x38, 0xb4, 0x76, 0x96,
+			0xff, 0xff, 0xff, 0xff,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x38, 0xb4, 0x98, 0xad,
+			0x38, 0xb4, 0xad, 0x54,
+			0x38, 0xb4, 0x76, 0x98,
+			0x38, 0xb4, 0x38, 0xae,
+			0x38, 0xb4, 0xae, 0x54,
+			0x38, 0xb4, 0xfe, 0x38,
+			0x38, 0xb4, 0x3a, 0xae,
+			0x38, 0xb4, 0xae, 0xdc,
+			0x38, 0xb4, 0xbb, 0x3a,
+			0x38, 0xb4, 0x14, 0xbf,
+			0x38, 0xb4, 0xbd, 0x99,
+			0x38, 0xb4, 0xcc, 0xe0,
+			0x38, 0xb4, 0xc8, 0xbd,
+			0x38, 0xb4, 0xbd, 0xdd,
+			0x38, 0xb4, 0x00, 0xc8,
+			0x36, 0xb4, 0x5e, 0xb8,
+			0x38, 0xb4, 0x9a, 0x4f,
+			0x36, 0xb4, 0x60, 0xb8,
+			0x38, 0xb4, 0xcf, 0x40,
+			0x36, 0xb4, 0x62, 0xb8,
+			0x38, 0xb4, 0x29, 0x68,
+			0x36, 0xb4, 0x64, 0xb8,
+			0x38, 0xb4, 0x72, 0x59,
+			0x36, 0xb4, 0x86, 0xb8,
+			0x38, 0xb4, 0x41, 0x59,
+			0x36, 0xb4, 0x88, 0xb8,
+			0x38, 0xb4, 0x6b, 0x63,
+			0x36, 0xb4, 0x8a, 0xb8,
+			0x38, 0xb4, 0x6b, 0x4d,
+			0x36, 0xb4, 0x8c, 0xb8,
+			0x38, 0xb4, 0x40, 0x4d,
+			0x36, 0xb4, 0x38, 0xb8,
+			0x38, 0xb4, 0xff, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0,
+			0x20, 0xb8, 0x10, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x08, 0x86,
+			0x38, 0xb4, 0x86, 0xaf,
+			0x38, 0xb4, 0xaf, 0xda,
+			0x38, 0xb4, 0x4c, 0x89,
+			0x38, 0xb4, 0x8a, 0xaf,
+			0x38, 0xb4, 0xaf, 0xf8,
+			0x38, 0xb4, 0xf3, 0x8b,
+			0x38, 0xb4, 0x8b, 0xaf,
+			0x38, 0xb4, 0xaf, 0xf3,
+			0x38, 0xb4, 0xf3, 0x8b,
+			0x38, 0xb4, 0x8b, 0xaf,
+			0x38, 0xb4, 0xaf, 0xf3,
+			0x38, 0xb4, 0xf3, 0x8b,
+			0x38, 0xb4, 0x6f, 0x00,
+			0x38, 0xb4, 0x03, 0x4a,
+			0x38, 0xb4, 0x47, 0x6f,
+			0x38, 0xb4, 0x6f, 0x26,
+			0x38, 0xb4, 0x00, 0x59,
+			0x38, 0xb4, 0x4d, 0x6f,
+			0x38, 0xb4, 0x6f, 0x01,
+			0x38, 0xb4, 0x04, 0x50,
+			0x38, 0xb4, 0x56, 0x6f,
+			0x38, 0xb4, 0x6f, 0x05,
+			0x38, 0xb4, 0x06, 0x5f,
+			0x38, 0xb4, 0x5c, 0x6f,
+			0x38, 0xb4, 0x74, 0x27,
+			0x38, 0xb4, 0x00, 0x78,
+			0x38, 0xb4, 0x68, 0x6f,
+			0x38, 0xb4, 0x6f, 0x24,
+			0x38, 0xb4, 0x20, 0x6b,
+			0x38, 0xb4, 0x6e, 0x6f,
+			0x38, 0xb4, 0x6f, 0x20,
+			0x38, 0xb4, 0x10, 0x74,
+			0x38, 0xb4, 0x69, 0x74,
+			0x38, 0xb4, 0x74, 0x10,
+			0x38, 0xb4, 0x10, 0x6c,
+			0x38, 0xb4, 0x6f, 0x74,
+			0x38, 0xb4, 0x74, 0x10,
+			0x38, 0xb4, 0x25, 0x72,
+			0x38, 0xb4, 0xfc, 0x8b,
+			0x38, 0xb4, 0x8c, 0x00,
+			0x38, 0xb4, 0x02, 0x08,
+			0x38, 0xb4, 0x02, 0x8c,
+			0x38, 0xb4, 0x8b, 0x03,
+			0x38, 0xb4, 0x04, 0xff,
+			0x38, 0xb4, 0xed, 0x6e,
+			0x38, 0xb4, 0x8c, 0x27,
+			0x38, 0xb4, 0x20, 0x05,
+			0x38, 0xb4, 0xda, 0x74,
+			0x38, 0xb4, 0x74, 0x20,
+			0x38, 0xb4, 0x20, 0xdd,
+			0x38, 0xb4, 0xe0, 0x74,
+			0x38, 0xb4, 0x74, 0x00,
+			0x38, 0xb4, 0x00, 0xe3,
+			0x38, 0xb4, 0xf3, 0x6e,
+			0x38, 0xb4, 0x6e, 0x00,
+			0x38, 0xb4, 0x00, 0xf6,
+			0x38, 0xb4, 0xf9, 0x6e,
+			0x38, 0xb4, 0x6e, 0x00,
+			0x38, 0xb4, 0x00, 0xfc,
+			0x38, 0xb4, 0xff, 0x6e,
+			0x38, 0xb4, 0x6f, 0x00,
+			0x38, 0xb4, 0x00, 0x02,
+			0x38, 0xb4, 0x05, 0x6f,
+			0x38, 0xb4, 0x6f, 0x02,
+			0x38, 0xb4, 0x02, 0x08,
+			0x38, 0xb4, 0x0b, 0x6f,
+			0x38, 0xb4, 0x6f, 0x02,
+			0x38, 0xb4, 0x02, 0x0e,
+			0x38, 0xb4, 0x11, 0x6f,
+			0x38, 0xb4, 0x6f, 0x02,
+			0x38, 0xb4, 0x02, 0x14,
+			0x38, 0xb4, 0x17, 0x6f,
+			0x38, 0xb4, 0x6f, 0x22,
+			0x38, 0xb4, 0x00, 0x1a,
+			0x38, 0xb4, 0x3e, 0x72,
+			0x38, 0xb4, 0x6e, 0x01,
+			0x38, 0xb4, 0x24, 0xed,
+			0x38, 0xb4, 0x50, 0x6f,
+			0x38, 0xb4, 0x72, 0x00,
+			0x38, 0xb4, 0x01, 0x47,
+			0x38, 0xb4, 0x4a, 0x72,
+			0x38, 0xb4, 0x72, 0x02,
+			0x38, 0xb4, 0x23, 0x4d,
+			0x38, 0xb4, 0x50, 0x72,
+			0x38, 0xb4, 0x74, 0x10,
+			0x38, 0xb4, 0x10, 0x69,
+			0x38, 0xb4, 0x6c, 0x74,
+			0x38, 0xb4, 0x74, 0x10,
+			0x38, 0xb4, 0x00, 0x6f,
+			0x38, 0xb4, 0x72, 0x74,
+			0x38, 0xb4, 0x8c, 0x15,
+			0x38, 0xb4, 0x15, 0x0b,
+			0x38, 0xb4, 0x0e, 0x8c,
+			0x38, 0xb4, 0x8c, 0x15,
+			0x38, 0xb4, 0x05, 0x11,
+			0x38, 0xb4, 0x14, 0x8c,
+			0x38, 0xb4, 0x6f, 0x00,
+			0x38, 0xb4, 0x03, 0x4a,
+			0x38, 0xb4, 0x47, 0x6f,
+			0x38, 0xb4, 0x6f, 0x26,
+			0x38, 0xb4, 0x00, 0x59,
+			0x38, 0xb4, 0x1f, 0x73,
+			0x38, 0xb4, 0x73, 0x02,
+			0x38, 0xb4, 0x03, 0x22,
+			0x38, 0xb4, 0x08, 0x8c,
+			0x38, 0xb4, 0x84, 0xee,
+			0x38, 0xb4, 0x00, 0x71,
+			0x38, 0xb4, 0x86, 0x02,
+			0x38, 0xb4, 0xe0, 0xec,
+			0x38, 0xb4, 0x43, 0x80,
+			0x38, 0xb4, 0x26, 0xf6,
+			0x38, 0xb4, 0x80, 0xe4,
+			0x38, 0xb4, 0xaf, 0x43,
+			0x38, 0xb4, 0x11, 0x66,
+			0x38, 0xb4, 0xe0, 0xf8,
+			0x38, 0xb4, 0x12, 0x80,
+			0x38, 0xb4, 0x26, 0xac,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0xff, 0x86,
+			0x38, 0xb4, 0x87, 0x02,
+			0x38, 0xb4, 0x02, 0x01,
+			0x38, 0xb4, 0x06, 0x89,
+			0x38, 0xb4, 0x89, 0x02,
+			0x38, 0xb4, 0xfc, 0x29,
+			0x38, 0xb4, 0xf8, 0x04,
+			0x38, 0xb4, 0xef, 0xf9,
+			0x38, 0xb4, 0xf9, 0x59,
+			0x38, 0xb4, 0xee, 0xfa,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x00,
+			0x38, 0xb4, 0x8f, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xef, 0x53,
+			0x38, 0xb4, 0x3e, 0x64,
+			0x38, 0xb4, 0x00, 0x12,
+			0x38, 0xb4, 0x4f, 0xac,
+			0x38, 0xb4, 0xe4, 0x08,
+			0x38, 0xb4, 0xe7, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xae, 0xe8,
+			0x38, 0xb4, 0xe0, 0x06,
+			0x38, 0xb4, 0xe7, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xee, 0xe8,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x01,
+			0x38, 0xb4, 0xc0, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xee, 0x71,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x00,
+			0x38, 0xb4, 0x90, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xef, 0x53,
+			0x38, 0xb4, 0x3e, 0x64,
+			0x38, 0xb4, 0x00, 0x12,
+			0x38, 0xb4, 0x4f, 0xac,
+			0x38, 0xb4, 0xe4, 0x08,
+			0x38, 0xb4, 0xe9, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xae, 0xea,
+			0x38, 0xb4, 0xe0, 0x06,
+			0x38, 0xb4, 0xe9, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xee, 0xea,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x01,
+			0x38, 0xb4, 0xc1, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xee, 0x71,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x00,
+			0x38, 0xb4, 0x91, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xef, 0x53,
+			0x38, 0xb4, 0x3e, 0x64,
+			0x38, 0xb4, 0x00, 0x12,
+			0x38, 0xb4, 0x4f, 0xac,
+			0x38, 0xb4, 0xe4, 0x08,
+			0x38, 0xb4, 0xeb, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xae, 0xec,
+			0x38, 0xb4, 0xe0, 0x06,
+			0x38, 0xb4, 0xeb, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xee, 0xec,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x01,
+			0x38, 0xb4, 0xc2, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xee, 0x71,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x01,
+			0x38, 0xb4, 0x8f, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xef, 0x53,
+			0x38, 0xb4, 0x3e, 0x64,
+			0x38, 0xb4, 0x00, 0x12,
+			0x38, 0xb4, 0x4f, 0xac,
+			0x38, 0xb4, 0xe4, 0x08,
+			0x38, 0xb4, 0xed, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xae, 0xee,
+			0x38, 0xb4, 0xe0, 0x06,
+			0x38, 0xb4, 0xed, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xee, 0xee,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x02,
+			0x38, 0xb4, 0xc0, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xee, 0x71,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x01,
+			0x38, 0xb4, 0x90, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xef, 0x53,
+			0x38, 0xb4, 0x3e, 0x64,
+			0x38, 0xb4, 0x00, 0x12,
+			0x38, 0xb4, 0x4f, 0xac,
+			0x38, 0xb4, 0xe4, 0x08,
+			0x38, 0xb4, 0xef, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xae, 0xf0,
+			0x38, 0xb4, 0xe0, 0x06,
+			0x38, 0xb4, 0xef, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xee, 0xf0,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x02,
+			0x38, 0xb4, 0xc1, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xee, 0x71,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x01,
+			0x38, 0xb4, 0x91, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xef, 0x53,
+			0x38, 0xb4, 0x3e, 0x64,
+			0x38, 0xb4, 0x00, 0x12,
+			0x38, 0xb4, 0x4f, 0xac,
+			0x38, 0xb4, 0xe4, 0x08,
+			0x38, 0xb4, 0xf1, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xae, 0xf2,
+			0x38, 0xb4, 0xe0, 0x06,
+			0x38, 0xb4, 0xf1, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xee, 0xf2,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x02,
+			0x38, 0xb4, 0xc2, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xee, 0x71,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x02,
+			0x38, 0xb4, 0x8f, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xef, 0x53,
+			0x38, 0xb4, 0x3e, 0x64,
+			0x38, 0xb4, 0x00, 0x12,
+			0x38, 0xb4, 0x4f, 0xac,
+			0x38, 0xb4, 0xe4, 0x08,
+			0x38, 0xb4, 0xf3, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xae, 0xf4,
+			0x38, 0xb4, 0xe0, 0x06,
+			0x38, 0xb4, 0xf3, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xee, 0xf4,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x04,
+			0x38, 0xb4, 0xc0, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xee, 0x71,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x02,
+			0x38, 0xb4, 0x90, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xef, 0x53,
+			0x38, 0xb4, 0x3e, 0x64,
+			0x38, 0xb4, 0x00, 0x12,
+			0x38, 0xb4, 0x4f, 0xac,
+			0x38, 0xb4, 0xe4, 0x08,
+			0x38, 0xb4, 0xf5, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xae, 0xf6,
+			0x38, 0xb4, 0xe0, 0x06,
+			0x38, 0xb4, 0xf5, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xee, 0xf6,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x04,
+			0x38, 0xb4, 0xc1, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xee, 0x71,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x02,
+			0x38, 0xb4, 0x91, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xef, 0x53,
+			0x38, 0xb4, 0x3e, 0x64,
+			0x38, 0xb4, 0x00, 0x12,
+			0x38, 0xb4, 0x4f, 0xac,
+			0x38, 0xb4, 0xe4, 0x08,
+			0x38, 0xb4, 0xf7, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xae, 0xf8,
+			0x38, 0xb4, 0xe0, 0x06,
+			0x38, 0xb4, 0xf7, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xee, 0xf8,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x04,
+			0x38, 0xb4, 0xc2, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xee, 0x71,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x03,
+			0x38, 0xb4, 0x8f, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xef, 0x53,
+			0x38, 0xb4, 0x3e, 0x64,
+			0x38, 0xb4, 0x00, 0x12,
+			0x38, 0xb4, 0x4f, 0xac,
+			0x38, 0xb4, 0xe4, 0x08,
+			0x38, 0xb4, 0xf9, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xae, 0xfa,
+			0x38, 0xb4, 0xe0, 0x06,
+			0x38, 0xb4, 0xf9, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xee, 0xfa,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x08,
+			0x38, 0xb4, 0xc0, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xee, 0x71,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x03,
+			0x38, 0xb4, 0x90, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xef, 0x53,
+			0x38, 0xb4, 0x3e, 0x64,
+			0x38, 0xb4, 0x00, 0x12,
+			0x38, 0xb4, 0x4f, 0xac,
+			0x38, 0xb4, 0xe4, 0x08,
+			0x38, 0xb4, 0xfb, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xae, 0xfc,
+			0x38, 0xb4, 0xe0, 0x06,
+			0x38, 0xb4, 0xfb, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xee, 0xfc,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x08,
+			0x38, 0xb4, 0xc1, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xee, 0x71,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x03,
+			0x38, 0xb4, 0x91, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xef, 0x53,
+			0x38, 0xb4, 0x3e, 0x64,
+			0x38, 0xb4, 0x00, 0x12,
+			0x38, 0xb4, 0x4f, 0xac,
+			0x38, 0xb4, 0xe4, 0x08,
+			0x38, 0xb4, 0xfd, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xae, 0xfe,
+			0x38, 0xb4, 0xe0, 0x06,
+			0x38, 0xb4, 0xfd, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xee, 0xfe,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0xd6, 0x08,
+			0x38, 0xb4, 0xc2, 0x00,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xfe, 0x71,
+			0x38, 0xb4, 0xef, 0xfd,
+			0x38, 0xb4, 0xfd, 0x95,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xf9, 0xf8,
+			0x38, 0xb4, 0xd4, 0xfa,
+			0x38, 0xb4, 0x00, 0x04,
+			0x38, 0xb4, 0x00, 0xd6,
+			0x38, 0xb4, 0xd3, 0x0d,
+			0x38, 0xb4, 0xe7, 0x0f,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xd4, 0x71,
+			0x38, 0xb4, 0x00, 0x14,
+			0x38, 0xb4, 0x00, 0xd6,
+			0x38, 0xb4, 0xd3, 0x0d,
+			0x38, 0xb4, 0xe7, 0x0f,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xfe, 0x71,
+			0x38, 0xb4, 0xfc, 0xfd,
+			0x38, 0xb4, 0xf8, 0x04,
+			0x38, 0xb4, 0xfa, 0xf9,
+			0x38, 0xb4, 0x10, 0xd4,
+			0x38, 0xb4, 0xd6, 0x00,
+			0x38, 0xb4, 0x0d, 0x00,
+			0x38, 0xb4, 0x0f, 0xd3,
+			0x38, 0xb4, 0x84, 0xe7,
+			0x38, 0xb4, 0x02, 0x76,
+			0x38, 0xb4, 0x71, 0x66,
+			0x38, 0xb4, 0x00, 0xd4,
+			0x38, 0xb4, 0xd6, 0x00,
+			0x38, 0xb4, 0x0d, 0x00,
+			0x38, 0xb4, 0x0f, 0xd3,
+			0x38, 0xb4, 0x84, 0xe7,
+			0x38, 0xb4, 0x02, 0x76,
+			0x38, 0xb4, 0x71, 0x66,
+			0x38, 0xb4, 0xfd, 0xfe,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xac, 0x4f,
+			0x38, 0xb4, 0x17, 0x23,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xad, 0x44,
+			0x38, 0xb4, 0x1a, 0x23,
+			0x38, 0xb4, 0x89, 0x02,
+			0x38, 0xb4, 0xe0, 0x75,
+			0x38, 0xb4, 0x44, 0x80,
+			0x38, 0xb4, 0x23, 0xac,
+			0x38, 0xb4, 0xbf, 0x11,
+			0x38, 0xb4, 0xcf, 0x6e,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xae, 0x74,
+			0x38, 0xb4, 0x02, 0x09,
+			0x38, 0xb4, 0xdb, 0x8a,
+			0x38, 0xb4, 0x1f, 0x02,
+			0x38, 0xb4, 0x02, 0xe7,
+			0x38, 0xb4, 0xbb, 0x1f,
+			0x38, 0xb4, 0x1f, 0xaf,
+			0x38, 0xb4, 0xf8, 0x95,
+			0x38, 0xb4, 0xef, 0xf9,
+			0x38, 0xb4, 0xf9, 0x59,
+			0x38, 0xb4, 0xfb, 0xfa,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xac, 0x12,
+			0x38, 0xb4, 0x03, 0x23,
+			0x38, 0xb4, 0x8a, 0xaf,
+			0x38, 0xb4, 0xd4, 0xd0,
+			0x38, 0xb4, 0x20, 0x01,
+			0x38, 0xb4, 0x00, 0xd6,
+			0x38, 0xb4, 0xd2, 0x10,
+			0x38, 0xb4, 0xe6, 0x0f,
+			0x38, 0xb4, 0x76, 0x84,
+			0x38, 0xb4, 0x66, 0x02,
+			0x38, 0xb4, 0xee, 0x71,
+			0x38, 0xb4, 0x6f, 0x84,
+			0x38, 0xb4, 0xd4, 0x00,
+			0x38, 0xb4, 0x0f, 0x00,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x9e,
+			0x38, 0xb4, 0x97, 0x76,
+			0x38, 0xb4, 0x75, 0x02,
+			0x38, 0xb4, 0xef, 0xbe,
+			0x38, 0xb4, 0xe4, 0x47,
+			0x38, 0xb4, 0x74, 0x84,
+			0x38, 0xb4, 0x84, 0xe5,
+			0x38, 0xb4, 0xbf, 0x75,
+			0x38, 0xb4, 0x9b, 0x72,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xe5, 0xb6,
+			0x38, 0xb4, 0x6f, 0x84,
+			0x38, 0xb4, 0x31, 0xef,
+			0x38, 0xb4, 0x6e, 0xbf,
+			0x38, 0xb4, 0x02, 0x06,
+			0xff, 0xff, 0xff, 0xff,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x38, 0xb4, 0xb6, 0x76,
+			0x38, 0xb4, 0x64, 0xef,
+			0x38, 0xb4, 0x6e, 0xbf,
+			0x38, 0xb4, 0x02, 0x09,
+			0x38, 0xb4, 0xb6, 0x76,
+			0x38, 0xb4, 0x64, 0x1e,
+			0x38, 0xb4, 0x6e, 0xbf,
+			0x38, 0xb4, 0x02, 0x0f,
+			0x38, 0xb4, 0xb6, 0x76,
+			0x38, 0xb4, 0x64, 0x1e,
+			0x38, 0xb4, 0x40, 0xac,
+			0x38, 0xb4, 0xa3, 0x05,
+			0x38, 0xb4, 0x0c, 0x0f,
+			0x38, 0xb4, 0x26, 0xae,
+			0x38, 0xb4, 0x03, 0xa3,
+			0x38, 0xb4, 0xae, 0x02,
+			0x38, 0xb4, 0xa3, 0x21,
+			0x38, 0xb4, 0x02, 0x0c,
+			0x38, 0xb4, 0x1c, 0xae,
+			0x38, 0xb4, 0x84, 0xe0,
+			0x38, 0xb4, 0xe1, 0x74,
+			0x38, 0xb4, 0x75, 0x84,
+			0x38, 0xb4, 0x64, 0xef,
+			0x38, 0xb4, 0x00, 0xd0,
+			0x38, 0xb4, 0x96, 0xd1,
+			0x38, 0xb4, 0x74, 0xef,
+			0x38, 0xb4, 0x75, 0x02,
+			0x38, 0xb4, 0xad, 0xd9,
+			0x38, 0xb4, 0xb7, 0x50,
+			0x38, 0xb4, 0x83, 0xe0,
+			0x38, 0xb4, 0xf7, 0xec,
+			0x38, 0xb4, 0xe4, 0x23,
+			0x38, 0xb4, 0xec, 0x83,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x9e,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x87, 0x02,
+			0x38, 0xb4, 0x02, 0x01,
+			0x38, 0xb4, 0x06, 0x89,
+			0x38, 0xb4, 0x83, 0xee,
+			0x38, 0xb4, 0x00, 0xe8,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x6b,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x6e,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x71,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x74,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x77,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x7a,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x00, 0xd4,
+			0x38, 0xb4, 0xbf, 0x0f,
+			0x38, 0xb4, 0x95, 0x72,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xd7, 0x97,
+			0x38, 0xb4, 0x00, 0x04,
+			0x38, 0xb4, 0x6e, 0xbf,
+			0x38, 0xb4, 0x02, 0x06,
+			0x38, 0xb4, 0xb6, 0x76,
+			0x38, 0xb4, 0x64, 0xef,
+			0x38, 0xb4, 0x6e, 0xbf,
+			0x38, 0xb4, 0x02, 0x09,
+			0x38, 0xb4, 0xb6, 0x76,
+			0x38, 0xb4, 0x64, 0x1e,
+			0x38, 0xb4, 0x6e, 0xbf,
+			0x38, 0xb4, 0x02, 0x0f,
+			0x38, 0xb4, 0xb6, 0x76,
+			0x38, 0xb4, 0x64, 0x1e,
+			0x38, 0xb4, 0x40, 0xac,
+			0x38, 0xb4, 0xbf, 0x0f,
+			0x38, 0xb4, 0x98, 0x72,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xe5, 0xb6,
+			0x38, 0xb4, 0xe8, 0x83,
+			0x38, 0xb4, 0x0f, 0xa1,
+			0x38, 0xb4, 0xaf, 0x28,
+			0x38, 0xb4, 0x95, 0x8a,
+			0x38, 0xb4, 0x8b, 0xbf,
+			0x38, 0xb4, 0x02, 0xf3,
+			0x38, 0xb4, 0xb6, 0x76,
+			0x38, 0xb4, 0x28, 0xac,
+			0x38, 0xb4, 0xae, 0x02,
+			0x38, 0xb4, 0xbf, 0x0b,
+			0x38, 0xb4, 0xf9, 0x8b,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xe5, 0xb6,
+			0x38, 0xb4, 0xe8, 0x83,
+			0x38, 0xb4, 0x09, 0xae,
+			0x38, 0xb4, 0x8b, 0xbf,
+			0x38, 0xb4, 0x02, 0xf6,
+			0x38, 0xb4, 0xb6, 0x76,
+			0x38, 0xb4, 0x83, 0xe5,
+			0x38, 0xb4, 0xa1, 0xe8,
+			0x38, 0xb4, 0x03, 0x03,
+			0x38, 0xb4, 0x8a, 0xaf,
+			0x38, 0xb4, 0xb7, 0x95,
+			0x38, 0xb4, 0xe2, 0xaf,
+			0x38, 0xb4, 0xec, 0x83,
+			0x38, 0xb4, 0x35, 0xf7,
+			0x38, 0xb4, 0x83, 0xe6,
+			0x38, 0xb4, 0xbf, 0xec,
+			0x38, 0xb4, 0x95, 0x72,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xbf, 0x6b,
+			0x38, 0xb4, 0x6b, 0x72,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xbf, 0x74,
+			0x38, 0xb4, 0x6e, 0x72,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xbf, 0x74,
+			0x38, 0xb4, 0x71, 0x72,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xbf, 0x74,
+			0x38, 0xb4, 0x74, 0x72,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xbf, 0x74,
+			0x38, 0xb4, 0x77, 0x72,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xbf, 0x74,
+			0x38, 0xb4, 0x7a, 0x72,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0x02, 0x74,
+			0x38, 0xb4, 0x29, 0x89,
+			0x38, 0xb4, 0x01, 0xd4,
+			0x38, 0xb4, 0xd6, 0x28,
+			0x38, 0xb4, 0x10, 0x00,
+			0x38, 0xb4, 0x0f, 0xd2,
+			0x38, 0xb4, 0x84, 0xe6,
+			0x38, 0xb4, 0x02, 0x76,
+			0x38, 0xb4, 0x71, 0x66,
+			0x38, 0xb4, 0x1f, 0x02,
+			0x38, 0xb4, 0xff, 0xbb,
+			0x38, 0xb4, 0xfd, 0xfe,
+			0x38, 0xb4, 0x95, 0xef,
+			0x38, 0xb4, 0xfc, 0xfd,
+			0x38, 0xb4, 0xf8, 0x04,
+			0x38, 0xb4, 0xef, 0xf9,
+			0x38, 0xb4, 0xf9, 0x59,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xad, 0x12,
+			0x38, 0xb4, 0x0c, 0x23,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x9e,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x95,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0xef, 0xfd,
+			0x38, 0xb4, 0xfd, 0x95,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0x6e, 0xbf,
+			0x38, 0xb4, 0x02, 0x06,
+			0x38, 0xb4, 0xb6, 0x76,
+			0x38, 0xb4, 0x64, 0xef,
+			0x38, 0xb4, 0x6e, 0xbf,
+			0x38, 0xb4, 0x02, 0x09,
+			0x38, 0xb4, 0xb6, 0x76,
+			0x38, 0xb4, 0x64, 0x1e,
+			0x38, 0xb4, 0x6e, 0xbf,
+			0x38, 0xb4, 0x02, 0x0f,
+			0x38, 0xb4, 0xb6, 0x76,
+			0x38, 0xb4, 0x64, 0x1e,
+			0x38, 0xb4, 0x40, 0xac,
+			0x38, 0xb4, 0xbf, 0x0e,
+			0x38, 0xb4, 0x98, 0x72,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xe5, 0xb6,
+			0x38, 0xb4, 0x78, 0x84,
+			0x38, 0xb4, 0x0f, 0xa1,
+			0x38, 0xb4, 0xae, 0x26,
+			0x38, 0xb4, 0xbf, 0x47,
+			0x38, 0xb4, 0xf3, 0x8b,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xac, 0xb6,
+			0x38, 0xb4, 0x02, 0x28,
+			0x38, 0xb4, 0x0b, 0xae,
+			0x38, 0xb4, 0x8b, 0xbf,
+			0x38, 0xb4, 0x02, 0xf9,
+			0x38, 0xb4, 0xb6, 0x76,
+			0x38, 0xb4, 0x84, 0xe5,
+			0x38, 0xb4, 0xae, 0x78,
+			0x38, 0xb4, 0xbf, 0x09,
+			0x38, 0xb4, 0xf6, 0x8b,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xe5, 0xb6,
+			0x38, 0xb4, 0x78, 0x84,
+			0x38, 0xb4, 0x03, 0xa1,
+			0x38, 0xb4, 0xae, 0x02,
+			0x38, 0xb4, 0xe0, 0x23,
+			0x38, 0xb4, 0x74, 0x84,
+			0x38, 0xb4, 0x84, 0xe1,
+			0x38, 0xb4, 0xef, 0x75,
+			0x38, 0xb4, 0xe0, 0x64,
+			0x38, 0xb4, 0xfc, 0x83,
+			0x38, 0xb4, 0x83, 0xe1,
+			0x38, 0xb4, 0xef, 0xfd,
+			0x38, 0xb4, 0x02, 0x74,
+			0x38, 0xb4, 0xd9, 0x75,
+			0x38, 0xb4, 0x50, 0xad,
+			0x38, 0xb4, 0xe0, 0x0a,
+			0x38, 0xb4, 0xec, 0x83,
+			0x38, 0xb4, 0x21, 0xf7,
+			0x38, 0xb4, 0x83, 0xe4,
+			0x38, 0xb4, 0xae, 0xec,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0xe4, 0x68,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x95,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x83, 0xe0,
+			0x38, 0xb4, 0xad, 0xeb,
+			0x38, 0xb4, 0x70, 0x21,
+			0x38, 0xb4, 0x73, 0xbf,
+			0x38, 0xb4, 0x02, 0x7f,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xbf, 0x64,
+			0x38, 0xb4, 0xc4, 0x73,
+			0x38, 0xb4, 0x76, 0x02,
+			0x38, 0xb4, 0xa4, 0xb6,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0xae, 0x02,
+			0x38, 0xb4, 0x87, 0x0d,
+			0x38, 0xb4, 0x00, 0xa7,
+			0x38, 0xb4, 0xef, 0x00,
+			0x38, 0xb4, 0x83, 0xe1,
+			0x38, 0xb4, 0xf7, 0xec,
+			0x38, 0xb4, 0xe5, 0x2a,
+			0x38, 0xb4, 0xec, 0x83,
+			0x38, 0xb4, 0x73, 0xbf,
+			0x38, 0xb4, 0x02, 0xbe,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x73, 0xbf,
+			0x38, 0xb4, 0x02, 0xb8,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x73, 0xbf,
+			0x38, 0xb4, 0x02, 0xc1,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x73, 0xbf,
+			0x38, 0xb4, 0x02, 0xbb,
+			0x38, 0xb4, 0x6b, 0x76,
+			0x38, 0xb4, 0x84, 0xe0,
+			0x38, 0xb4, 0xe1, 0x9e,
+			0x38, 0xb4, 0x9f, 0x84,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x7d,
+			0x38, 0xb4, 0x97, 0x76,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x80,
+			0x38, 0xb4, 0x97, 0x76,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x83,
+			0x38, 0xb4, 0x97, 0x76,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x86,
+			0x38, 0xb4, 0x97, 0x76,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x89,
+			0x38, 0xb4, 0x74, 0x76,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x8c,
+			0x38, 0xb4, 0x74, 0x76,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x8f,
+			0x38, 0xb4, 0x74, 0x76,
+			0x38, 0xb4, 0x72, 0xbf,
+			0x38, 0xb4, 0x02, 0x92,
+			0x38, 0xb4, 0x74, 0x76,
+			0x38, 0xb4, 0x84, 0xee,
+			0x38, 0xb4, 0x00, 0x77,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xf6, 0x44,
+			0x38, 0xb4, 0xe4, 0x21,
+			0x38, 0xb4, 0x44, 0x80,
+			0x38, 0xb4, 0x68, 0xaf,
+			0x38, 0xb4, 0x11, 0xe4,
+			0x38, 0xb4, 0xa4, 0xd1,
+			0x38, 0xb4, 0xbc, 0x10,
+			0x38, 0xb4, 0x32, 0x74,
+			0x38, 0xb4, 0x74, 0xbc,
+			0x38, 0xb4, 0xbf, 0xbb,
+			0x38, 0xb4, 0xcc, 0x14,
+			0x38, 0xb4, 0xaa, 0xbf,
+			0x38, 0xb4, 0xbf, 0x00,
+			0x38, 0xb4, 0x55, 0x90,
+			0x38, 0xb4, 0x06, 0xbf,
+			0x38, 0xb4, 0xbf, 0x10,
+			0x38, 0xb4, 0x76, 0xb8,
+			0x38, 0xb4, 0x02, 0xbe,
+			0x38, 0xb4, 0xbe, 0x54,
+			0x38, 0xb4, 0x32, 0x02,
+			0x38, 0xb4, 0x02, 0xbe,
+			0x38, 0xb4, 0xbe, 0x10,
+			0x38, 0xb4, 0x00, 0x02,
+			0x36, 0xb4, 0xe7, 0x8f,
+			0x38, 0xb4, 0x00, 0x12,
+			0x36, 0xb4, 0xe9, 0x8f,
+			0x38, 0xb4, 0x00, 0x12,
+			0x36, 0xb4, 0xeb, 0x8f,
+			0x38, 0xb4, 0x00, 0x12,
+			0x36, 0xb4, 0xed, 0x8f,
+			0x38, 0xb4, 0x00, 0x12,
+			0x36, 0xb4, 0xef, 0x8f,
+			0x38, 0xb4, 0x00, 0x12,
+			0x36, 0xb4, 0xf1, 0x8f,
+			0x38, 0xb4, 0x00, 0x12,
+			0x36, 0xb4, 0xf3, 0x8f,
+			0x38, 0xb4, 0x00, 0x12,
+			0x36, 0xb4, 0xf5, 0x8f,
+			0x38, 0xb4, 0x00, 0x12,
+			0x36, 0xb4, 0xf7, 0x8f,
+			0x38, 0xb4, 0x00, 0x12,
+			0x36, 0xb4, 0xf9, 0x8f,
+			0x38, 0xb4, 0x00, 0x12,
+			0x36, 0xb4, 0xfb, 0x8f,
+			0x38, 0xb4, 0x00, 0x12,
+			0x36, 0xb4, 0xfd, 0x8f,
+			0x38, 0xb4, 0x00, 0x12,
+			0x36, 0xb4, 0x18, 0xb8,
+			0x38, 0xb4, 0x02, 0x66,
+			0x36, 0xb4, 0x1a, 0xb8,
+			0x38, 0xb4, 0x75, 0x1f,
+			0x36, 0xb4, 0x1c, 0xb8,
+			0x38, 0xb4, 0xeb, 0x67,
+			0x36, 0xb4, 0x1e, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x50, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x52, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x78, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x84, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x32, 0xb8,
+			0x38, 0xb4, 0x07, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0,
+			0x2e, 0xb8, 0x00, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x23, 0x80,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x1e, 0x80,
+			0x38, 0xb4, 0x13, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0, /* dataram patch */
+			0x92, 0xb8, 0x00, 0x00,
+			0x8e, 0xb8, 0x7c, 0xc0,
+			0x90, 0xb8, 0x03, 0x02,
+			0x90, 0xb8, 0x04, 0x03,
+			0x90, 0xb8, 0x05, 0x04,
+			0x90, 0xb8, 0x07, 0x06,
+			0x90, 0xb8, 0x09, 0x08,
+			0x90, 0xb8, 0x0d, 0x0b,
+			0x90, 0xb8, 0x11, 0x0f,
+			0x90, 0xb8, 0x18, 0x14,
+			0x90, 0xb8, 0x20, 0x1b,
+			0x90, 0xb8, 0x2b, 0x25,
+			0x90, 0xb8, 0x3e, 0x34,
+			0x90, 0xb8, 0x54, 0x48,
+			0x90, 0xb8, 0x03, 0x62,
+			0x90, 0xb8, 0x04, 0x03,
+			0x90, 0xb8, 0x06, 0x05,
+			0x90, 0xb8, 0x0a, 0x08,
+			0x90, 0xb8, 0x0e, 0x0c,
+			0x90, 0xb8, 0x16, 0x12,
+			0x90, 0xb8, 0x22, 0x1b,
+			0x90, 0xb8, 0x34, 0x2a,
+			0x90, 0xb8, 0x4f, 0x40,
+			0x90, 0xb8, 0x71, 0x61,
+			0x90, 0xb8, 0x84, 0x78,
+			0x90, 0xb8, 0x97, 0x90,
+			0x90, 0xb8, 0x03, 0x02,
+			0x90, 0xb8, 0x06, 0x04,
+			0x90, 0xb8, 0x0b, 0x08,
+			0x90, 0xb8, 0x13, 0x0e,
+			0x90, 0xb8, 0x20, 0x18,
+			0x90, 0xb8, 0x39, 0x2a,
+			0x90, 0xb8, 0x56, 0x48,
+			0x90, 0xb8, 0x60, 0xe0,
+			0x90, 0xb8, 0x50, 0xe0,
+			0x90, 0xb8, 0x80, 0xd0,
+			0x90, 0xb8, 0x70, 0x80,
+			0x90, 0xb8, 0xa0, 0x70,
+			0x90, 0xb8, 0x00, 0x10,
+			0x90, 0xb8, 0xd0, 0x60,
+			0x90, 0xb8, 0x10, 0xb0,
+			0x90, 0xb8, 0xb0, 0xe0,
+			0x90, 0xb8, 0xc0, 0x80,
+			0x90, 0xb8, 0x00, 0xe0,
+			0x90, 0xb8, 0x20, 0x20,
+			0x90, 0xb8, 0x20, 0x10,
+			0x90, 0xb8, 0x90, 0xe0,
+			0x90, 0xb8, 0xc0, 0x80,
+			0x90, 0xb8, 0x20, 0x30,
+			0x90, 0xb8, 0xe0, 0x00,
+			0x90, 0xb8, 0xa0, 0x40,
+			0x90, 0xb8, 0x20, 0xe0,
+			0x90, 0xb8, 0x60, 0x50,
+			0x90, 0xb8, 0xd0, 0xe0,
+			0x90, 0xb8, 0x00, 0xa0,
+			0x90, 0xb8, 0x30, 0x30,
+			0x90, 0xb8, 0x70, 0x40,
+			0x90, 0xb8, 0xe0, 0xe0,
+			0x90, 0xb8, 0x80, 0xd0,
+			0x90, 0xb8, 0x10, 0xa0,
+			0x90, 0xb8, 0x40, 0xe0,
+			0x90, 0xb8, 0xb0, 0x80,
+			0x90, 0xb8, 0xb0, 0x50,
+			0x90, 0xb8, 0x90, 0x20,
+			0x20, 0xb8, 0x00, 0x00,
+			0xff, 0xff, 0xff, 0xff};
+
+		code_ver = 0x0013;
+		ret = sram_read(tp, SRAM_GPHY_FW_VER, &fw_version);
+		if (ret < 0)
+			goto out;
+
+		if (fw_version < code_ver) {
+			data = ram17;
+			len = sizeof(ram17);
+
+			if (r8156b_flash_used(tp)) {
+				ret = ocp_word_set_bits(tp, MCU_TYPE_USB,
+							USB_GPHY_CTRL,
+							BYPASS_FLASH);
+				if (ret < 0)
+					goto out;
+			}
+		}
+	}
+
+	if (!data)
+		return 0;
+
+	ret = rtl_phy_patch_request(tp, true, wait);
+	if (ret < 0)
+		goto out;
+
+	while (len) {
+		u32 size;
+		int i;
+
+		if (len < 2048)
+			size = len;
+		else
+			size = 2048;
+
+		ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_GPHY_CTRL,
+					GPHY_PATCH_DONE | BACKUP_RESTRORE);
+		if (ret < 0)
+			goto out;
+
+		ret = generic_ocp_write(tp, 0x9A00, 0xff, size, data,
+					MCU_TYPE_USB);
+		if (ret < 0)
+			goto out;
+
+		data += size;
+		len -= size;
+
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL,
+					POL_GPHY_PATCH);
+		if (ret < 0)
+			goto out;
+
+		for (i = 0; i < 1000; i++) {
+			ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL,
+					    &ocp_data);
+			if (ret < 0)
+				goto out;
+
+			if (!(ocp_data & POL_GPHY_PATCH))
+				break;
+		}
+
+		if (i == 1000) {
+			dev_err(&tp->intf->dev,
+				"ram code speedup mode timeout\n");
+			ret = -ETIMEDOUT;
+			goto out;
+		}
+	}
+
+	rtl_reset_ocp_base(tp);
+
+	ret = rtl_phy_patch_request(tp, false, wait);
+	if (ret < 0)
+		goto out;
+
+	if (sram_read(tp, SRAM_GPHY_FW_VER, &fw_version) < 0)
+		goto out;
+	else if (fw_version != code_ver)
+		dev_err(&tp->intf->dev, "ram code version is wrong %04x(%04x\n",
+			fw_version, code_ver);
+
+out:
+	if (ret < 0)
+		dev_err(&tp->intf->dev, "ram code speedup mode fail %d\n", ret);
+
+	rtl_reset_ocp_base(tp);
+
+	return ret;
+}
+
+static void r8156_ram_code(struct r8152 *tp, bool power_cut)
+{
+	rtl_reset_ocp_base(tp);
+
+	if (tp->version == RTL_VER_10) {
+		rtl_pre_ram_code(tp, 0x8024, 0x8600, !power_cut);
+
+		ocp_reg_set_bits(tp, OCP_PHY_PATCH_CMD, BIT(7));
+
+		/* nc0_patch_180504_usb */
+		sram_write(tp, 0xA016, 0x0000);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8013);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8021);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x802f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x803d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8042);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8051);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8051);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa088);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a50);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8008);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd707);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40c2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a6c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8080);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd019);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd707);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40c4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a84);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8970);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c07);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0901);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcf09);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xceff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf0a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1213);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8580);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1253);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd064);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd181);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4018);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc50f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd706);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2c59);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x804d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc60f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc605);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10fd);
+		sram_write(tp, 0xA026, 0xffff);
+		sram_write(tp, 0xA024, 0xffff);
+		sram_write(tp, 0xA022, 0x10f4);
+		sram_write(tp, 0xA020, 0x1252);
+		sram_write(tp, 0xA006, 0x1206);
+		sram_write(tp, 0xA004, 0x0a78);
+		sram_write(tp, 0xA002, 0x0a60);
+		sram_write(tp, 0xA000, 0x0a4f);
+		sram_write(tp, 0xA008, 0x3f00);
+
+		/* nc1_patch_180423_cml_usb */
+		sram_write(tp, 0xA016, 0x0010);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8066);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x807c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8089);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80b2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80c2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62db);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x655c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd73e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x614a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0505);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0509);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x653c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd73e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x614a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0506);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x050a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd73e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x614a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0505);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0506);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x050c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd73e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x614a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0509);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x050a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x050c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0508);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd73e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x614a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0321);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0321);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0321);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0508);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0321);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0346);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8208);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x609d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa50f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x001a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x001a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x607d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa50f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x017b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a05);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x017b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa50f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a05);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa50f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0231);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a05);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0231);
+		sram_write(tp, 0xA08E, 0xffff);
+		sram_write(tp, 0xA08C, 0x0221);
+		sram_write(tp, 0xA08A, 0x01ce);
+		sram_write(tp, 0xA088, 0x0169);
+		sram_write(tp, 0xA086, 0x00a6);
+		sram_write(tp, 0xA084, 0x000d);
+		sram_write(tp, 0xA082, 0x0308);
+		sram_write(tp, 0xA080, 0x029f);
+		sram_write(tp, 0xA090, 0x007f);
+
+		/* nc2_patch_180508_usb */
+		sram_write(tp, 0xA016, 0x0020);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8017);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8029);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8054);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x805a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8064);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9430);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9480);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb408);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd057);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x064b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9906);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0567);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb94);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8406);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8dff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa840);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0773);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb91);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4063);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd139);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07dc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4045);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x405d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0742);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07ec);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0742);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fb6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07dc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x064b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0481);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x94bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x870c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8220);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x078e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb92);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa840);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4063);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd150);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6121);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6223);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf02f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf00f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d20);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d30);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf005);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa008);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4046);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x405d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0742);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0742);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fb5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ad4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0537);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8840);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x064b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa70c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x890c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8840);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x064b);
+		sram_write(tp, 0xA10E, 0x0642);
+		sram_write(tp, 0xA10C, 0x0686);
+		sram_write(tp, 0xA10A, 0x0788);
+		sram_write(tp, 0xA108, 0x047b);
+		sram_write(tp, 0xA106, 0x065c);
+		sram_write(tp, 0xA104, 0x0769);
+		sram_write(tp, 0xA102, 0x0565);
+		sram_write(tp, 0xA100, 0x06f9);
+		sram_write(tp, 0xA110, 0x00ff);
+
+		/* uc2_patch_180507_usb */
+		sram_write(tp, 0xb87c, 0x8530);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xb87e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3caf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8593);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9caf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85a5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5afb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfb0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x020d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86d7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbe0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x83fc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xda02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdd02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5afb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfd0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x020d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86dd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbe0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x83fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf2f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x65af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x212b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x022c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86b6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf21);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cd1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x870d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8716);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x871f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x871c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8728);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8725);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8707);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x281c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2b02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd101);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2b02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd101);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4c02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2e02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf35);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7ff8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86e3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86fb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86e6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86ec);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0262);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86f2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0262);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86f5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0262);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0262);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0420);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb540);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x53b5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4086);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb540);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb9b5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40c8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb03a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc8b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbac8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb13a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc8b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xba77);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffbd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2677);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffbd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2840);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc8bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc8bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x28bb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa430);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x98b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1eba);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb01e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdcb0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e98);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb09e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbab0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9edc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb09e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x98b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1eba);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb11e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdcb1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e98);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb19e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbab1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9edc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb19e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e22);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb01e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x33b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb09e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x22b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9e33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb09e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e22);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb11e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x33b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb19e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x22b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9e33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb19e);
+		sram_write(tp, 0xb85e, 0x2f71);
+		sram_write(tp, 0xb860, 0x20d9);
+		sram_write(tp, 0xb862, 0x2109);
+		sram_write(tp, 0xb864, 0x34e7);
+		sram_write(tp, 0xb878, 0x000f);
+
+		ocp_reg_clr_bits(tp, OCP_PHY_PATCH_CMD, BIT(7));
+
+		rtl_post_ram_code(tp, 0x8024, !power_cut);
+	} else if (tp->version == RTL_VER_11) {
+		rtl_pre_ram_code(tp, 0x8024, 0x8601, !power_cut);
+
+		ocp_reg_set_bits(tp, OCP_PHY_PATCH_CMD, BIT(7));
+
+		/* nc_patch */
+		sram_write(tp, 0xA016, 0x0000);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8093);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8097);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x809d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80aa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x607b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf00e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf01e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x615b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1456);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f2e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf01c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1456);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f2e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf024);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1456);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f2e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf02c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1456);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f2e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf034);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4118);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa410);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4779);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf034);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4118);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac22);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa420);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4559);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf023);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4118);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac44);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa440);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4339);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf012);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4118);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa480);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4119);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1456);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc48f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x141b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x121a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd0b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1bb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0898);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd0b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1bb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a0e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd064);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd18a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b7e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x053b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0648);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc520);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa201);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x252d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1646);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4006);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1646);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0308);
+		sram_write(tp, 0xA026, 0x0307);
+		sram_write(tp, 0xA024, 0x1645);
+		sram_write(tp, 0xA022, 0x0647);
+		sram_write(tp, 0xA020, 0x053a);
+		sram_write(tp, 0xA006, 0x0b7c);
+		sram_write(tp, 0xA004, 0x0a0c);
+		sram_write(tp, 0xA002, 0x0896);
+		sram_write(tp, 0xA000, 0x11a1);
+		sram_write(tp, 0xA008, 0xff00);
+
+		/* nc1_patch */
+		sram_write(tp, 0xA016, 0x0010);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8015);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02d7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ed);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0509);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x008f);
+		sram_write(tp, 0xA08E, 0xffff);
+		sram_write(tp, 0xA08C, 0xffff);
+		sram_write(tp, 0xA08A, 0xffff);
+		sram_write(tp, 0xA088, 0xffff);
+		sram_write(tp, 0xA086, 0xffff);
+		sram_write(tp, 0xA084, 0xffff);
+		sram_write(tp, 0xA082, 0x008d);
+		sram_write(tp, 0xA080, 0x00eb);
+		sram_write(tp, 0xA090, 0x0103);
+
+		/* nc2_patch */
+		sram_write(tp, 0xA016, 0x0020);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8018);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8024);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8051);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8055);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8072);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80dc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfffd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfffd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa70c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x890c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8840);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa380);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x066e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb91);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4063);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd139);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x405d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0743);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0743);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fb6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x066e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd158);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03d4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x94bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x870c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8380);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd10d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07c4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa220);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd130);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07c4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbb80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1c4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd074);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x604b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa90c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0556);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb92);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4063);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd116);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd119);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6241);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x63e2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6583);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf054);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x611e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf02f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d50);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf02a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x611e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d20);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf021);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d60);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf01c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x611e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d30);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf013);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d70);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf00e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x611e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf005);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x405d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ff4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa008);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4046);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0743);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07fb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f6f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f2d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0743);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fb5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ad4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0556);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x066e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1f5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd049);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01ec);
+		sram_write(tp, 0xA10E, 0x01ea);
+		sram_write(tp, 0xA10C, 0x06a9);
+		sram_write(tp, 0xA10A, 0x078a);
+		sram_write(tp, 0xA108, 0x03d2);
+		sram_write(tp, 0xA106, 0x067f);
+		sram_write(tp, 0xA104, 0x0665);
+		sram_write(tp, 0xA102, 0x0000);
+		sram_write(tp, 0xA100, 0x0000);
+		sram_write(tp, 0xA110, 0x00fc);
+
+		/* uc2 */
+		sram_write(tp, 0xb87c, 0x8530);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xb87e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3caf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8545);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x45af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8545);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf900);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa601);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x58f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa080);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x37a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae16);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa188);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae1c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb463);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6901);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe4b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb463);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb463);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6901);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe4b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb463);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		sram_write(tp, 0xb85e, 0x03b3);
+		sram_write(tp, 0xb860, 0xffff);
+		sram_write(tp, 0xb862, 0xffff);
+		sram_write(tp, 0xb864, 0xffff);
+		sram_write(tp, 0xb878, 0x0001);
+
+		/* data_ram_patch_v02_usb */
+		sram_write(tp, 0xb892, 0x0000);
+		sram_write(tp, 0xb88e, 0xc089);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xb890);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6050);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f6e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e6e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e6e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1214);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1516);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x171b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b1c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2021);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2224);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2424);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2424);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2424);
+		sram_write(tp, 0xb88e, 0xc018);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xb890);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0af2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d4a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x118d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14f3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x175a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x19c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c26);
+
+		ocp_reg_clr_bits(tp, OCP_PHY_PATCH_CMD, BIT(7));
+
+		rtl_post_ram_code(tp, 0x8024, !power_cut);
+
+		/* 100M MLT-3 Tx interpolator coefficient */
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0x81b3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0043);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00d6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ec);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00f6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00fb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00bb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0058);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0029);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0013);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0009);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+	} else if (tp->version == RTL_VER_12) {
+		rtl_pre_ram_code(tp, 0x8024, 0x3700, !power_cut);
+
+		ocp_reg_set_bits(tp, OCP_PHY_PATCH_CMD, BIT(7));
+
+		/* nc_patch */
+		sram_write(tp, 0xA016, 0x0000);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8025);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x803a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8044);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd712);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4077);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4159);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6099);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f44);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9201);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2425);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ce5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1afb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd712);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4077);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4159);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60b9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2421);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c17);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2425);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ce5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6072);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x146e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b77);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x665d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x653e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x641f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62c4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6066);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x165a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc101);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1945);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x807d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1945);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2569);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8058);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x807d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc104);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1945);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x807d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1945);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x807d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1945);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fbe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x807d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1945);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fbd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6018);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x165a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14f6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1e3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1356);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fbe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1559);
+		sram_write(tp, 0xA026, 0xffff);
+		sram_write(tp, 0xA024, 0xffff);
+		sram_write(tp, 0xA022, 0xffff);
+		sram_write(tp, 0xA020, 0x1557);
+		sram_write(tp, 0xA006, 0x1677);
+		sram_write(tp, 0xA004, 0x0b75);
+		sram_write(tp, 0xA002, 0x1c17);
+		sram_write(tp, 0xA000, 0x1b04);
+		sram_write(tp, 0xA008, 0x1f00);
+
+		/* nc1_patch */
+
+		/* nc2_patch */
+		sram_write(tp, 0xA016, 0x0020);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x817f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x83f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8454);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8459);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8465);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa50c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8310);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4076);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0903);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a4d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f84);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60f3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd413);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd410);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa108);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8108);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa910);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa780);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd14a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd048);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6255);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6326);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f07);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffe2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xba08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9a08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6535);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd40d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa780);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd14a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd048);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6206);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f47);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8064);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd40e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6073);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4216);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb21);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f9f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd196);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb22);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8910);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb23);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xafc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5dee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb24);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8f1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f6e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa111);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa215);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b43);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8111);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8205);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa104);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8104);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd193);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd046);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb29);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb820);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f65);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9820);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd13d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8149);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa220);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8151);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f51);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f63);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd411);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd409);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0433);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb15);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa508);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a4d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f9f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd115);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd413);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb16);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd17a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb17);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xafc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ce);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5db4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb18);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b43);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffd6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8f1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa131);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2d5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa407);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8310);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa308);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8308);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb19);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b43);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8111);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82c5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb1b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb820);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f65);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9820);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb1c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb1d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa220);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1f5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd049);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8221);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f51);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f84);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd14a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd048);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa780);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f94);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6208);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffe9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa406);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa220);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x827d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f51);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f63);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd411);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd409);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8406);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0433);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb30);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8380);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9308);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd408);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd141);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd043);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ccc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4c81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x609e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa108);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8108);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa203);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8a0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa111);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd17a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8101);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8201);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa104);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8104);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd193);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd047);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd13d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf024);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8406);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4121);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60f3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb820);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f65);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9820);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb34);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6853);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb35);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd407);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4215);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1c3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd043);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4109);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf01e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb36);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd412);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6309);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42c7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd14a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd048);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcc55);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6041);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd13d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f71);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb38);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8224);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa288);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6041);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd415);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd13d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb39);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6041);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd17a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd047);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0560);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa111);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd3f5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd219);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa215);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd30e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd21a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x63e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f65);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f36);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c35);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c35);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4098);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa108);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c35);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8108);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8294);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0bdb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd39c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd210);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd39c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd210);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x29b5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x840e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f4a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd709);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x901f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c23);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb43);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa508);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3699);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x844a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2109);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ea);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ea);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb90);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ca0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x06db);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd052);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa508);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c50);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x09ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2e70);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x06da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f55);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa90c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0645);
+		sram_write(tp, 0xA10E, 0x0644);
+		sram_write(tp, 0xA10C, 0x09e9);
+		sram_write(tp, 0xA10A, 0x06da);
+		sram_write(tp, 0xA108, 0x05e1);
+		sram_write(tp, 0xA106, 0x0be4);
+		sram_write(tp, 0xA104, 0x0435);
+		sram_write(tp, 0xA102, 0x0141);
+		sram_write(tp, 0xA100, 0x026d);
+		sram_write(tp, 0xA110, 0x00ff);
+
+		/* uc2 */
+		sram_write(tp, 0xb87c, 0x85fe);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xb87e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x16af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8699);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe5af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7aaf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x883a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x58af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b6c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd48b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7c02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8644);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2c00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x503c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffd6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x18e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cd4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b84);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x442c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x003c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x06ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8299);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8299);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x23dc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcefa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x79fb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc4bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b76);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6dac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd203);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd201);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbdd8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x19d9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef94);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6d78);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x648a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbdd8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x19d9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef94);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6d78);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x72cd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac50);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x643a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x019f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe4ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4678);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd0ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x97ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfec6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x041f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x771f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x221c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x450d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x481f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a94);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a94);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac7f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03d7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c45);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef57);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0272);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x941b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x979e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x072d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef76);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef97);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d98);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd400);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xff1d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x941a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x89cf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a75);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b79);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6da1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0005);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa0ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9aac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x284d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe08f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe08f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfe10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04c8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67c8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8c02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc4bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6def);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x74e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x830c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad20);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x74ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xccef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x971b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x76ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef30);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc4ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x46e4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe58f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfce7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcc10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb8d1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4fbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ec4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8f02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0274);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaccc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef97);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b76);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad5f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3111);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaed1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0287);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2293);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfafb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef59);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe080);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x252f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f44);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb91b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x64ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f1d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd688);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2bd7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x882e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0274);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x73ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5008);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x737c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0287);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd0bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x882b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x73e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x824c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf621);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe482);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8834);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x95ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfafb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef79);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x737c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f22);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x31ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8822);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ed6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fba);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac3c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8837);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96d8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x19d9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1616);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdf12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaecc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7373);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef97);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfffe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0466);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x88f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac8a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x92ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbadd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac6c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6cff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x99ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0030);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd4c3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xecee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8298);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1412);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b5d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6d58);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fb8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2901);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe58f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb8a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0049);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef47);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe483);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8303);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbfc2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x95f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffd2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00d8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf605);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef60);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf728);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf628);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0289);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf89);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0149);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef47);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe483);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8305);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbfc2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x95f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffd2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00d8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf605);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef60);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf729);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf629);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0289);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf89);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0249);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef47);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe483);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x06e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8307);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbfc2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x95f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffd2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00d8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf605);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef60);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf72a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf62a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0289);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf89);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x47e4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8308);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe583);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x09bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc25f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a95);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd200);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd8f6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x051f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b30);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ebf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6df7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2bbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ef6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2bbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4e0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x64ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x46bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4e02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8999);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0239);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x20af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8996);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf39);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1ef8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe08f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb838);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x201f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x66ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x65bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc21f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd200);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdaf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc22f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd200);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdbf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x110d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b3c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x031f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x110d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b36);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x031f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x110d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b39);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ebf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc23f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd200);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdaf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc24f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd200);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdbf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x110d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b45);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x031f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x110d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b3f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x031f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x110d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x56d0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x201f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ebf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ebf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b4b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ee1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8578);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x480a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2805);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef20);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3f1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x44e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8560);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b51);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8566);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b54);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x856c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6dbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b57);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8572);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x73bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b5a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ee1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fb8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5900);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf728);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe58f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb8af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x791b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x21ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x373e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f44);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8563);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x68e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8569);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6ee1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x856f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x74e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8575);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb859);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x28e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fb8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae4a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f44);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x64e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8565);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6ae1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x856b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x70e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8571);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x76e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8577);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb859);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x28e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fb8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb839);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2f04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8efc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xacf8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf6f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfef0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xacfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf4f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xacf2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xacb0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaef0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xacac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaaf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xacee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x24f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb0a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x24f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb1a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd400);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3976);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x66ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeabb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa430);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e50);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e53);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e56);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e59);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e5c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e5f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e62);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e65);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd9ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x70f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac6a);
+		sram_write(tp, 0xb85e, 0x23b7);
+		sram_write(tp, 0xb860, 0x74db);
+		sram_write(tp, 0xb862, 0x268c);
+		sram_write(tp, 0xb864, 0x3FE5);
+		sram_write(tp, 0xb886, 0x2250);
+		sram_write(tp, 0xb888, 0x140e);
+		sram_write(tp, 0xb88a, 0x3696);
+		sram_write(tp, 0xb88c, 0x3973);
+		sram_write(tp, 0xb838, 0x00ff);
+
+		ocp_reg_clr_bits(tp, OCP_PHY_PATCH_CMD, BIT(7));
+
+		/* uc */
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0x8464);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf84);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7caf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8485);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x851e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb9af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8684);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac38);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x38bb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf38);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4618);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd400);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0fbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8507);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6759);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3008);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae06);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa183);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x15a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x59f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x16bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x381b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae0b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x84fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x17bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x84fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0254);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x84fb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0254);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x09a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5006);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf84);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfb02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad34);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0670);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00b8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x30bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x30aa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xccbd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2ca1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xec80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf7af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40f5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd101);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd10f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6abf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddd1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85aa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4d6a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbdd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfcdd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfddd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfedd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf3c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2066);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb8bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x30ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb8bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc8bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc8bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1929);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x032e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd10f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7e02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x25a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x041d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf1bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8675);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf3bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x867b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x29a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x070b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae24);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1be1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf5bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8678);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7b02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf09);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8420);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbc32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x20bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3e76);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbc08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfda6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb64e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd101);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd10f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6abf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddd1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85aa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4d6a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbdd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfcdd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfddd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfedd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8800);
+		sram_write(tp, 0xb818, 0x38b8);
+		sram_write(tp, 0xb81a, 0x0444);
+		sram_write(tp, 0xb81c, 0x40ee);
+		sram_write(tp, 0xb81e, 0x3C1A);
+		sram_write(tp, 0xb850, 0x0981);
+		sram_write(tp, 0xb852, 0x0085);
+		sram_write(tp, 0xb878, 0xffff);
+		sram_write(tp, 0xb884, 0xffff);
+		sram_write(tp, 0xb832, 0x003f);
+
+		rtl_post_ram_code(tp, 0x8024, !power_cut);
+	} else {
+		rtl_ram_code_speed_up(tp, !power_cut);
+	}
+
+	rtl_reset_ocp_base(tp);
+}
+
+static int r8157_firmware(struct r8152 *tp, bool power_cut)
+{
+	int ret;
+
+	ret = rtl_ram_code_speed_up(tp, !power_cut);
+
+	return ret;
+}
+
+static void r8156_hw_phy_cfg(struct r8152 *tp)
+{
+	u32 ocp_data;
+	u16 data;
+	int ret;
+
+	r8156_patch_code(tp);
+
+	ocp_word_test_and_clr_bits(tp, MCU_TYPE_USB, USB_MISC_0, PCUT_STATUS);
+
+	ret = r8153_phy_status(tp, 0);
+	if (ret < 0)
+		return;
+
+	switch (ret) {
+	case PHY_STAT_EXT_INIT:
+		r8156_ram_code(tp, true);
+		ocp_reg_clr_bits(tp, 0xa468, BIT(3) | BIT(1));
+		break;
+	case PHY_STAT_LAN_ON:
+	case PHY_STAT_PWRDN:
+	default:
+		r8156_ram_code(tp, false);
+		break;
+	}
+
+	/* disable ALDPS before updating the PHY parameters */
+	r8153_aldps_en(tp, false);
+
+	/* disable EEE before updating the PHY parameters */
+	rtl_eee_enable(tp, false);
+
+	ret = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+	if (ret < 0)
+		return;
+	WARN_ON_ONCE(ret != PHY_STAT_LAN_ON);
+
+	ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_PHY_PWR, PFM_PWM_SWITCH);
+
+	switch (tp->version) {
+	case RTL_VER_10:
+		ocp_reg_w0w1(tp, 0xad40, 0x3ff, BIT(7) | BIT(2));
+
+		ocp_reg_set_bits(tp, 0xad4e, BIT(4));
+		ocp_reg_w0w1(tp, 0xad16, 0x3ff, 0x6);
+		ocp_reg_w0w1(tp, 0xad32, 0x3f, 6);
+		ocp_reg_clr_bits(tp, 0xac08, BIT(12) | BIT(8));
+		ocp_reg_w0w1(tp, 0xac8a, BIT(15), BIT(12) | BIT(13) | BIT(14));
+		ocp_reg_set_bits(tp, 0xad18, BIT(10));
+		ocp_reg_set_bits(tp, 0xad1a, 0x3ff);
+		ocp_reg_set_bits(tp, 0xad1c, 0x3ff);
+
+		sram_write_w0w1(tp, 0x80ea, 0xff00, 0xc400);
+		sram_write_w0w1(tp, 0x80eb, 0x0700, 0x0300);
+		sram_write_w0w1(tp, 0x80f8, 0xff00, 0x1c00);
+		sram_write_w0w1(tp, 0x80f1, 0xff00, 0x3000);
+
+		sram_write_w0w1(tp, 0x80fe, 0xff00, 0xa500);
+		sram_write_w0w1(tp, 0x8102, 0xff00, 0x5000);
+		sram_write_w0w1(tp, 0x8015, 0xff00, 0x3300);
+		sram_write_w0w1(tp, 0x8100, 0xff00, 0x7000);
+		sram_write_w0w1(tp, 0x8014, 0xff00, 0xf000);
+		sram_write_w0w1(tp, 0x8016, 0xff00, 0x6500);
+		sram_write_w0w1(tp, 0x80dc, 0xff00, 0xed00);
+		sram_set_bits(tp, 0x80df, BIT(8));
+		sram_clr_bits(tp, 0x80e1, BIT(8));
+
+		ocp_reg_w0w1(tp, 0xbf06, 0x003f, 0x0038);
+
+		sram_write(tp, 0x819f, 0xddb6);
+
+		ocp_reg_write(tp, 0xbc34, 0x5555);
+		ocp_reg_w0w1(tp, 0xbf0a, 0x0e00, 0x0a00);
+
+		ocp_reg_clr_bits(tp, 0xbd2c, BIT(13));
+		break;
+	case RTL_VER_11:
+		/* 2.5G INRX */
+		ocp_reg_set_bits(tp, 0xad16, 0x3ff);
+		ocp_reg_w0w1(tp, 0xad32, 0x3f, 6);
+		ocp_reg_clr_bits(tp, 0xac08, BIT(12) | BIT(8));
+		ocp_reg_w0w1(tp, 0xacc0, 0x3, BIT(1));
+		ocp_reg_w0w1(tp, 0xad40, 0xe7, BIT(6) | BIT(2));
+		ocp_reg_clr_bits(tp, 0xac14, BIT(7));
+		ocp_reg_clr_bits(tp, 0xac80, BIT(8) | BIT(9));
+		ocp_reg_w0w1(tp, 0xac5e, 0x7, BIT(1));
+		ocp_reg_write(tp, 0xad4c, 0x00a8);
+		ocp_reg_write(tp, 0xac5c, 0x01ff);
+		ocp_reg_w0w1(tp, 0xac8a, 0xf0, BIT(4) | BIT(5));
+		sram2_write_w0w1(tp, 0x8157, 0xff00, 0x0500);
+		sram2_write_w0w1(tp, 0x8159, 0xff00, 0x0700);
+
+		/* AAGC */
+		sram2_write(tp, 0x80a2, 0x0153);
+		sram2_write(tp, 0x809c, 0x0153);
+
+		/* EEE parameter */
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_TXTWSYS_2P5G, 0x0056);
+
+		ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_USB_CFG,
+				  EN_XG_LIP | EN_G_LIP);
+
+		sram_write(tp, 0x8257, 0x020f); /*  XG PLL */
+		sram_write(tp, 0x80ea, 0x7843); /* GIGA Master */
+
+		if (rtl_phy_patch_request(tp, true, true))
+			return;
+
+		/* Advance EEE */
+		ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4,
+				  EEE_SPDWN_EN);
+
+		ocp_reg_w0w1(tp, OCP_DOWN_SPEED, EN_EEE_100 | EN_EEE_1000,
+			     EN_10M_CLKDIV);
+		tp->ups_info._10m_ckdiv = true;
+		tp->ups_info.eee_plloff_100 = false;
+		tp->ups_info.eee_plloff_giga = false;
+
+		ocp_reg_clr_bits(tp, OCP_POWER_CFG, EEE_CLKDIV_EN);
+		tp->ups_info.eee_ckdiv = false;
+
+		ocp_reg_write(tp, OCP_SYSCLK_CFG, 0);
+		ocp_reg_write(tp, OCP_SYSCLK_CFG, sysclk_div_expo(5));
+		tp->ups_info._250m_ckdiv = false;
+
+		rtl_phy_patch_request(tp, false, true);
+
+		/* enable ADC Ibias Cal */
+		ocp_reg_set_bits(tp, 0xd068, BIT(13));
+
+		/* enable Thermal Sensor */
+		sram_clr_bits(tp, 0x81a2, BIT(8));
+		ocp_reg_w0w1(tp, 0xb54c, 0xff00, 0xdb00);
+
+		/* Nway 2.5G Lite */
+		ocp_reg_clr_bits(tp, 0xa454, BIT(0));
+
+		/* CS DSP solution */
+		ocp_reg_set_bits(tp, OCP_10GBT_CTRL, RTL_ADV2_5G_F_R);
+		ocp_reg_clr_bits(tp, 0xad4e, BIT(4));
+		ocp_reg_clr_bits(tp, 0xa86a, BIT(0));
+
+		/* MDI SWAP */
+		ret = ocp_read_word(tp, MCU_TYPE_USB, USB_UPS_CFG, &ocp_data);
+		if (ret < 0)
+			return;
+		ret = ocp_reg_read(tp, 0xd068, &data);
+		if (ret < 0)
+			return;
+		if ((ocp_data & MID_REVERSE) && (data & BIT(1))) {
+			u16 swap_a, swap_b;
+
+			ret = ocp_reg_read(tp, 0xd068, &data);
+			if (ret < 0)
+				return;
+			data &= ~0x1f;
+			data |= 0x1; /* p0 */
+			ocp_reg_write(tp, 0xd068, data);
+			ret = ocp_reg_read(tp, 0xd06a, &swap_a);
+			if (ret < 0)
+				return;
+			data &= ~0x18;
+			data |= 0x18; /* p3 */
+			ocp_reg_write(tp, 0xd068, data);
+			ret = ocp_reg_read(tp, 0xd06a, &swap_b);
+			if (ret < 0)
+				return;
+			data &= ~0x18; /* p0 */
+			ocp_reg_write(tp, 0xd068, data);
+			ocp_reg_write(tp, 0xd06a,
+				      (swap_a & ~0x7ff) | (swap_b & 0x7ff));
+			data |= 0x18; /* p3 */
+			ocp_reg_write(tp, 0xd068, data);
+			ocp_reg_write(tp, 0xd06a,
+				      (swap_b & ~0x7ff) | (swap_a & 0x7ff));
+			data &= ~0x18;
+			data |= 0x08; /* p1 */
+			ocp_reg_write(tp, 0xd068, data);
+			ret = ocp_reg_read(tp, 0xd06a, &swap_a);
+			if (ret < 0)
+				return;
+			data &= ~0x18;
+			data |= 0x10; /* p2 */
+			ocp_reg_write(tp, 0xd068, data);
+			ret = ocp_reg_read(tp, 0xd06a, &swap_b);
+			if (ret < 0)
+				return;
+			data &= ~0x18;
+			data |= 0x08; /* p1 */
+			ocp_reg_write(tp, 0xd068, data);
+			ocp_reg_write(tp, 0xd06a,
+				      (swap_a & ~0x7ff) | (swap_b & 0x7ff));
+			data &= ~0x18;
+			data |= 0x10; /* p2 */
+			ocp_reg_write(tp, 0xd068, data);
+			ocp_reg_write(tp, 0xd06a,
+				      (swap_b & ~0x7ff) | (swap_a & 0x7ff));
+			ret = ocp_reg_read(tp, 0xbd5a, &swap_a);
+			if (ret < 0)
+				return;
+			ret = ocp_reg_read(tp, 0xbd5c, &swap_b);
+			if (ret < 0)
+				return;
+			ocp_reg_write(tp, 0xbd5a, (swap_a & ~0x1f1f) |
+				      ((swap_b & 0x1f) << 8) |
+				      ((swap_b >> 8) & 0x1f));
+			ocp_reg_write(tp, 0xbd5c, (swap_b & ~0x1f1f) |
+				      ((swap_a & 0x1f) << 8) |
+				      ((swap_a >> 8) & 0x1f));
+			ret = ocp_reg_read(tp, 0xbc18, &swap_a);
+			if (ret < 0)
+				return;
+			ret = ocp_reg_read(tp, 0xbc1a, &swap_b);
+			if (ret < 0)
+				return;
+			ocp_reg_write(tp, 0xbc18, (swap_a & ~0x1f1f) |
+				      ((swap_b & 0x1f) << 8) |
+				      ((swap_b >> 8) & 0x1f));
+			ocp_reg_write(tp, 0xbc1a, (swap_b & ~0x1f1f) |
+				      ((swap_a & 0x1f) << 8) |
+				      ((swap_a >> 8) & 0x1f));
+		}
+
+		/* Notify the MAC when the speed is changed to force mode. */
+		ocp_reg_set_bits(tp, OCP_INTR_EN, INTR_SPEED_FORCE);
+		break;
+	default:
+		break;
+	}
+
+	rtl_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));
+
+	ocp_reg_clr_bits(tp, 0xa428, BIT(9));
+	ocp_reg_clr_bits(tp, 0xa5ea, BIT(0));
+	tp->ups_info.lite_mode = 0;
+
+	if (tp->eee_en)
+		rtl_eee_enable(tp, true);
+
+	r8153_aldps_en(tp, true);
+	r8152b_enable_fc(tp);
+	r8153_u2p3en(tp, true);
+
+	set_bit(PHY_RESET, &tp->flags);
+}
+
+static void r8156b_hw_phy_cfg(struct r8152 *tp)
+{
+	int ret;
+
+	r8156_patch_code(tp);
+
+	switch (tp->version) {
+	case RTL_VER_12:
+		ocp_reg_write(tp, 0xbf86, 0x9000);
+		ocp_reg_set_bits(tp, 0xc402, BIT(10));
+		ocp_reg_clr_bits(tp, 0xc402, BIT(10));
+		ocp_reg_write(tp, 0xbd86, 0x1010);
+		ocp_reg_write(tp, 0xbd88, 0x1010);
+		ocp_reg_w0w1(tp, 0xbd4e, BIT(10) | BIT(11), BIT(11));
+		ocp_reg_w0w1(tp, 0xbf46, 0xf00, 0x700);
+		break;
+	case RTL_VER_13:
+	case RTL_VER_15:
+		r8156b_wait_loading_flash(tp);
+		break;
+	default:
+		break;
+	}
+
+	ocp_word_test_and_clr_bits(tp, MCU_TYPE_USB, USB_MISC_0, PCUT_STATUS);
+
+	ret = r8153_phy_status(tp, 0);
+	if (ret < 0)
+		return;
+
+	switch (ret) {
+	case PHY_STAT_EXT_INIT:
+		r8156_ram_code(tp, true);
+		ocp_reg_clr_bits(tp, 0xa466, BIT(0));
+		ocp_reg_clr_bits(tp, 0xa468, BIT(3) | BIT(1));
+		break;
+	case PHY_STAT_LAN_ON:
+	case PHY_STAT_PWRDN:
+	default:
+		r8156_ram_code(tp, false);
+		break;
+	}
+
+	r8152_mdio_test_and_clr_bit(tp, MII_BMCR, BMCR_PDOWN);
+
+	/* disable ALDPS before updating the PHY parameters */
+	r8153_aldps_en(tp, false);
+
+	ret = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+	if (ret < 0)
+		return;
+	WARN_ON_ONCE(ret != PHY_STAT_LAN_ON);
+
+	ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_PHY_PWR, PFM_PWM_SWITCH);
+
+	switch (tp->version) {
+	case RTL_VER_12:
+		ocp_reg_set_bits(tp, 0xbc08, BIT(3) | BIT(2));
+
+		sram_write_w0w1(tp, 0x8fff, 0xff00, 0x0400);
+
+		ocp_reg_set_bits(tp, 0xacda, 0xff00);
+		ocp_reg_set_bits(tp, 0xacde, 0xf000);
+		ocp_reg_write(tp, 0xac8c, 0x0ffc);
+		ocp_reg_write(tp, 0xac46, 0xb7b4);
+		ocp_reg_write(tp, 0xac50, 0x0fbc);
+		ocp_reg_write(tp, 0xac3c, 0x9240);
+		ocp_reg_write(tp, 0xac4e, 0x0db4);
+		ocp_reg_write(tp, 0xacc6, 0x0707);
+		ocp_reg_write(tp, 0xacc8, 0xa0d3);
+		ocp_reg_write(tp, 0xad08, 0x0007);
+
+		sram2_write(tp, 0x8560, 0x19cc);
+		sram2_write(tp, 0x8562, 0x19cc);
+		sram2_write(tp, 0x8564, 0x19cc);
+		sram2_write(tp, 0x8566, 0x147d);
+		sram2_write(tp, 0x8568, 0x147d);
+		sram2_write(tp, 0x856a, 0x147d);
+		sram2_write(tp, 0x8ffe, 0x0907);
+		sram2_write(tp, 0x80d6, 0x2801);
+		sram2_write(tp, 0x80f2, 0x2801);
+		sram2_write(tp, 0x80f4, 0x6077);
+		ocp_reg_write(tp, 0xb506, 0x01e7);
+
+		sram2_write(tp, 0x8013, 0x0700);
+		sram2_write(tp, 0x8fb9, 0x2801);
+		sram2_write(tp, 0x8fba, 0x0100);
+		sram2_write(tp, 0x8fbc, 0x1900);
+		sram2_write(tp, 0x8fbe, 0xe100);
+		sram2_write(tp, 0x8fc0, 0x0800);
+		sram2_write(tp, 0x8fc2, 0xe500);
+		sram2_write(tp, 0x8fc4, 0x0f00);
+		sram2_write(tp, 0x8fc6, 0xf100);
+		sram2_write(tp, 0x8fc8, 0x0400);
+		sram2_write(tp, 0x8fca, 0xf300);
+		sram2_write(tp, 0x8fcc, 0xfd00);
+		sram2_write(tp, 0x8fce, 0xff00);
+		sram2_write(tp, 0x8fd0, 0xfb00);
+		sram2_write(tp, 0x8fd2, 0x0100);
+		sram2_write(tp, 0x8fd4, 0xf400);
+		sram2_write(tp, 0x8fd6, 0xff00);
+		sram2_write(tp, 0x8fd8, 0xf600);
+
+		ocp_byte_set_bits(tp, MCU_TYPE_PLA, PLA_USB_CFG,
+				  EN_XG_LIP | EN_G_LIP);
+		sram2_write(tp, 0x813d, 0x390e);
+		sram2_write(tp, 0x814f, 0x790e);
+		sram2_write(tp, 0x80b0, 0x0f31);
+		ocp_reg_set_bits(tp, 0xbf4c, BIT(1));
+		ocp_reg_set_bits(tp, 0xbcca, BIT(9) | BIT(8));
+		sram2_write(tp, 0x8141, 0x320e);
+		sram2_write(tp, 0x8153, 0x720e);
+		sram2_write(tp, 0x8529, 0x050e);
+		ocp_reg_clr_bits(tp, OCP_EEE_CFG, CTAP_SHORT_EN);
+
+		sram_write(tp, 0x816c, 0xc4a0);
+		sram_write(tp, 0x8170, 0xc4a0);
+		sram_write(tp, 0x8174, 0x04a0);
+		sram_write(tp, 0x8178, 0x04a0);
+		sram_write(tp, 0x817c, 0x0719);
+		sram_write(tp, 0x8ff4, 0x0400);
+		sram_write(tp, 0x8ff1, 0x0404);
+
+		ocp_reg_write(tp, 0xbf4a, 0x001b);
+		sram2_write(tp, 0x8033, 0x7c13);
+		sram2_write(tp, 0x8037, 0x7c13);
+		sram2_write(tp, 0x803b, 0xfc32);
+		sram2_write(tp, 0x803f, 0x7c13);
+		sram2_write(tp, 0x8043, 0x7c13);
+		sram2_write(tp, 0x8047, 0x7c13);
+
+		sram2_write(tp, 0x8145, 0x370e);
+		sram2_write(tp, 0x8157, 0x770e);
+		sram2_write(tp, 0x8169, 0x0d0a);
+		sram2_write(tp, 0x817b, 0x1d0a);
+
+		sram_write_w0w1(tp, 0x8217, 0xff00, 0x5000);
+		sram_write_w0w1(tp, 0x821a, 0xff00, 0x5000);
+		sram_write(tp, 0x80da, 0x0403);
+		sram_write_w0w1(tp, 0x80dc, 0xff00, 0x1000);
+		sram_write(tp, 0x80b3, 0x0384);
+		sram_write(tp, 0x80b7, 0x2007);
+		sram_write_w0w1(tp, 0x80ba, 0xff00, 0x6c00);
+		sram_write(tp, 0x80b5, 0xf009);
+		sram_write_w0w1(tp, 0x80bd, 0xff00, 0x9f00);
+		sram_write(tp, 0x80c7, 0xf083);
+		sram_write(tp, 0x80dd, 0x03f0);
+		sram_write_w0w1(tp, 0x80df, 0xff00, 0x1000);
+		sram_write(tp, 0x80cb, 0x2007);
+		sram_write_w0w1(tp, 0x80ce, 0xff00, 0x6c00);
+		sram_write(tp, 0x80c9, 0x8009);
+		sram_write_w0w1(tp, 0x80d1, 0xff00, 0x8000);
+		sram_write(tp, 0x80a3, 0x200a);
+		sram_write(tp, 0x80a5, 0xf0ad);
+		sram_write(tp, 0x809f, 0x6073);
+		sram_write(tp, 0x80a1, 0x000b);
+		sram_write_w0w1(tp, 0x80a9, 0xff00, 0xc000);
+
+		if (rtl_phy_patch_request(tp, true, true))
+			return;
+
+		ocp_reg_clr_bits(tp, 0xb896, BIT(0));
+		ocp_reg_clr_bits(tp, 0xb892, 0xff00);
+		ocp_reg_write(tp, 0xb88e, 0xc23e);
+		ocp_reg_write(tp, 0xb890, 0x0000);
+		ocp_reg_write(tp, 0xb88e, 0xc240);
+		ocp_reg_write(tp, 0xb890, 0x0103);
+		ocp_reg_write(tp, 0xb88e, 0xc242);
+		ocp_reg_write(tp, 0xb890, 0x0507);
+		ocp_reg_write(tp, 0xb88e, 0xc244);
+		ocp_reg_write(tp, 0xb890, 0x090b);
+		ocp_reg_write(tp, 0xb88e, 0xc246);
+		ocp_reg_write(tp, 0xb890, 0x0c0e);
+		ocp_reg_write(tp, 0xb88e, 0xc248);
+		ocp_reg_write(tp, 0xb890, 0x1012);
+		ocp_reg_write(tp, 0xb88e, 0xc24a);
+		ocp_reg_write(tp, 0xb890, 0x1416);
+		ocp_reg_set_bits(tp, 0xb896, BIT(0));
+
+		rtl_phy_patch_request(tp, false, true);
+
+		ocp_reg_set_bits(tp, 0xa86a, BIT(0));
+		ocp_reg_set_bits(tp, 0xa6f0, BIT(0));
+
+		ocp_reg_write(tp, 0xbfa0, 0xd70d);
+		ocp_reg_write(tp, 0xbfa2, 0x4100);
+		ocp_reg_write(tp, 0xbfa4, 0xe868);
+		ocp_reg_write(tp, 0xbfa6, 0xdc59);
+		ocp_reg_write(tp, 0xb54c, 0x3c18);
+		ocp_reg_clr_bits(tp, 0xbfa4, BIT(5));
+		sram_set_bits(tp, 0x817d, BIT(12));
+		break;
+	case RTL_VER_13:
+		/* 2.5G INRX */
+		ocp_reg_w0w1(tp, 0xac46, 0x00f0, 0x0090);
+		ocp_reg_w0w1(tp, 0xad30, 0x0003, 0x0001);
+		fallthrough;
+	case RTL_VER_15:
+		/* EEE parameter */
+		sram2_write(tp, 0x80f5, 0x760e);
+		sram2_write(tp, 0x8107, 0x360e);
+		sram2_write_w0w1(tp, 0x8551, 0xff00, 0x0800);
+
+		/* ADC_PGA parameter */
+		ocp_reg_w0w1(tp, 0xbf00, 0xe000, 0xa000);
+		ocp_reg_w0w1(tp, 0xbf46, 0x0f00, 0x0300);
+
+		/* Green Table-PGA, 1G full viterbi */
+		sram_write(tp, 0x8044, 0x2417);
+		sram_write(tp, 0x804a, 0x2417);
+		sram_write(tp, 0x8050, 0x2417);
+		sram_write(tp, 0x8056, 0x2417);
+		sram_write(tp, 0x805c, 0x2417);
+		sram_write(tp, 0x8062, 0x2417);
+		sram_write(tp, 0x8068, 0x2417);
+		sram_write(tp, 0x806e, 0x2417);
+		sram_write(tp, 0x8074, 0x2417);
+		sram_write(tp, 0x807a, 0x2417);
+
+		/* Nway DACONB parameter */
+		ocp_reg_w0w1(tp, 0xa4ca, 0x6000, 0x0040);
+
+		/* XG PLL */
+		ocp_reg_w0w1(tp, 0xbf84, 0xe000, 0xa000);
+		break;
+	default:
+		break;
+	}
+
+	/* Notify the MAC when the speed is changed to force mode. */
+	ocp_reg_set_bits(tp, OCP_INTR_EN, INTR_SPEED_FORCE);
+
+	if (rtl_phy_patch_request(tp, true, true))
+		return;
+
+	ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, EEE_SPDWN_EN);
+
+	ocp_reg_w0w1(tp, OCP_DOWN_SPEED, EN_EEE_100 | EN_EEE_1000,
+		     EN_10M_CLKDIV);
+	tp->ups_info._10m_ckdiv = true;
+	tp->ups_info.eee_plloff_100 = false;
+	tp->ups_info.eee_plloff_giga = false;
+
+	ocp_reg_clr_bits(tp, OCP_POWER_CFG, EEE_CLKDIV_EN);
+	tp->ups_info.eee_ckdiv = false;
+
+	rtl_phy_patch_request(tp, false, true);
+
+	rtl_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));
+
+	ocp_reg_clr_bits(tp, 0xa428, BIT(9));
+	ocp_reg_clr_bits(tp, 0xa5ea, BIT(0));
+	tp->ups_info.lite_mode = 0;
+
+	rtl_eee_enable(tp, tp->eee_en);
+
+	r8153_aldps_en(tp, true);
+	r8152b_enable_fc(tp);
+	r8153_u2p3en(tp, true);
+
+	set_bit(PHY_RESET, &tp->flags);
+}
+
+static void r8156_hw_phy_cfg_test(struct r8152 *tp)
+{
+	u16 data;
+	int ret;
+
+	data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+
+	/* disable ALDPS before updating the PHY parameters */
+	r8153_aldps_en(tp, false);
+
+	/* disable EEE before updating the PHY parameters */
+	if (r8153_eee_en(tp, false) < 0)
+		return;
+	ocp_reg_write(tp, OCP_EEE_ADV, 0);
+
+	r8156_firmware(tp);
+
+	ocp_reg_set_bits(tp, 0xa5d4, BIT(7) | BIT(0));
+	ocp_reg_write(tp, 0xa5e6, 0x6290);
+
+	ocp_reg_clr_bits(tp, 0xa5e8, BIT(3));
+	ocp_reg_set_bits(tp, 0xa428, BIT(9));
+
+	ocp_reg_write(tp, 0xb636, 0x2c00);
+	ocp_reg_clr_bits(tp, 0xb460, BIT(13));
+	ocp_reg_write(tp, 0xb83e, 0x00a9);
+	ocp_reg_write(tp, 0xb840, 0x0035);
+	ocp_reg_write(tp, 0xb680, 0x0022);
+	ocp_reg_write(tp, 0xb468, 0x10c0);
+	ocp_reg_write(tp, 0xb468, 0x90c0);
+
+	ocp_reg_w0w1(tp, 0xb60a, 0xfff, 0xc0);
+	ocp_reg_w0w1(tp, 0xb628, 0xfff, 0xc0);
+	ocp_reg_w0w1(tp, 0xb62a, 0xfff, 0xc0);
+
+	ret = ocp_reg_read(tp, 0xbc1e, &data);
+	data &= 0xf;
+	data |= (data << 4) | (data << 8) | (data << 12);
+	ocp_reg_write(tp, 0xbce0, data);
+	ocp_reg_clr_bits(tp, 0xbd42, BIT(8));
+
+	ocp_reg_w0w1(tp, 0xbf90, 0xf0, BIT(7));
+	ocp_reg_w0w1(tp, 0xbf92, 0x3f, 0x3fc0);
+
+	ocp_reg_set_bits(tp, 0xbf94, 0x3e00);
+	ocp_reg_w0w1(tp, 0xbf88, 0x3eff, 0x1e01);
+
+	ocp_reg_clr_bits(tp, 0xbc58, BIT(1));
+	ocp_reg_clr_bits(tp, 0xbd0c, 0x3f);
+	ocp_reg_clr_bits(tp, 0xbcc2, BIT(14));
+
+	ocp_reg_write(tp, 0xd098, 0x0427);
+
+	ocp_reg_clr_bits(tp, 0xa430, BIT(12));
+
+	ocp_dword_set_bits(tp, MCU_TYPE_PLA, 0xe84c, BIT(6));
+
+	ocp_reg_clr_bits(tp, 0xbeb4, BIT(1));
+	ocp_reg_w0w1(tp, 0xbf0c, BIT(13), BIT(12));
+	ocp_reg_clr_bits(tp, 0xbd44, BIT(2));
+
+	ocp_reg_set_bits(tp, 0xa442, BIT(11));
+	ocp_dword_set_bits(tp, MCU_TYPE_PLA, 0xe84c, BIT(7));
+
+	r8156_lock_main(tp, true);
+	ocp_reg_clr_bits(tp, 0xcc46, 0x700);
+	ocp_reg_clr_bits(tp, 0xcc46, 0x70);
+	ocp_reg_w0w1(tp, 0xcc46, 0x70, BIT(6) | BIT(4));
+	r8156_lock_main(tp, false);
+
+	ocp_reg_clr_bits(tp, 0xbd38, BIT(13));
+	ocp_reg_set_bits(tp, 0xbd38, BIT(12));
+	ocp_reg_write(tp, 0xbd36, 0x0fb4);
+	ocp_reg_set_bits(tp, 0xbd38, BIT(13));
+
+//	if (tp->eee_en) {
+//		r8153_eee_en(tp, true);
+//		ocp_reg_write(tp, OCP_EEE_ADV, tp->eee_adv);
+//	}
+
+	r8153_aldps_en(tp, true);
+	r8152b_enable_fc(tp);
+	r8153_u2p3en(tp, true);
+}
+
+static void r8157_hw_phy_cfg(struct r8152 *tp)
+{
+	int ret;
+
+	r8156b_wait_loading_flash(tp);
+
+	r8157_patch_code(tp);
+
+	ocp_word_test_and_clr_bits(tp, MCU_TYPE_USB, USB_MISC_0, PCUT_STATUS);
+
+	ret = r8153_phy_status(tp, 0);
+	if (ret < 0)
+		return;
+
+	switch (ret) {
+	case PHY_STAT_EXT_INIT:
+		r8157_firmware(tp, true);
+		ocp_reg_clr_bits(tp, 0xa466, BIT(0));
+		ocp_reg_clr_bits(tp, 0xa468, BIT(3) | BIT(1));
+		break;
+	case PHY_STAT_LAN_ON:
+	case PHY_STAT_PWRDN:
+	default:
+		r8157_firmware(tp, false);
+		break;
+	}
+
+	r8152_mdio_test_and_clr_bit(tp, MII_BMCR, BMCR_PDOWN);
+
+	/* disable ALDPS before updating the PHY parameters */
+	r8153_aldps_en(tp, false);
+
+	/* disable EEE before updating the PHY parameters */
+	rtl_eee_enable(tp, false);
+
+	ret = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+	if (ret < 0)
+		return;
+	WARN_ON_ONCE(ret != PHY_STAT_LAN_ON);
+
+	/* PFM mode */
+	ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_PHY_PWR, PFM_PWM_SWITCH);
+
+	/* advanced Power Saving paramater */
+	ocp_reg_set_bits(tp, 0xa430, BIT(0) | BIT(1));
+
+	/* aldpsce force mode */
+	ocp_reg_clr_bits(tp, 0xa44a, BIT(2));
+
+	switch (tp->version) {
+	case RTL_VER_16:
+		/* XG_INRX parameter */
+		sram_write_w0w1(tp, 0x8183, 0xff00, 0x5900);
+
+		ocp_reg_set_bits(tp, 0xa654, BIT(11));
+		ocp_reg_set_bits(tp, 0xb648, BIT(14));
+		ocp_reg_clr_bits(tp, 0xad2c, BIT(15));
+		ocp_reg_set_bits(tp, 0xad94, BIT(5));
+		ocp_reg_set_bits(tp, 0xada0, BIT(1));
+		ocp_reg_w0w1(tp, 0xae06, 0xfc00, 0x7c00);
+
+		sram2_write_w0w1(tp, 0x8647, 0xff00, 0xe600);
+		sram2_write_w0w1(tp, 0x8036, 0xff00, 0x3000);
+		sram2_write_w0w1(tp, 0x8078, 0xff00, 0x3000);
+
+		/* green mode */
+		sram2_clr_bits(tp, 0x89e9, 0xff00);
+		sram2_write_w0w1(tp, 0x8ffd, 0xff00, 0x0100);
+		sram2_write_w0w1(tp, 0x8ffe, 0xff00, 0x0200);
+		sram2_write_w0w1(tp, 0x8fff, 0xff00, 0x0400);
+
+		/* recognize AQC/Bcom function */
+		sram_write_w0w1(tp, 0x8018, 0xff00, 0x7700);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0x8f9c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0005);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ed);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd401);
+		sram_write_w0w1(tp, 0x8fa8, 0xff00, 0x2900);
+
+		/* RFI_corr_thd 5g */
+		sram2_write_w0w1(tp, 0x814b, 0xff00, 0x1100);
+		sram2_write_w0w1(tp, 0x814d, 0xff00, 0x1100);
+		sram2_write_w0w1(tp, 0x814f, 0xff00, 0x0b00);
+		sram2_write_w0w1(tp, 0x8142, 0xff00, 0x0100);
+		sram2_write_w0w1(tp, 0x8144, 0xff00, 0x0100);
+		sram2_write_w0w1(tp, 0x8150, 0xff00, 0x0100);
+		/* RFI_corr_thd 2p5g */
+		sram2_write_w0w1(tp, 0x8118, 0xff00, 0x0700);
+		sram2_write_w0w1(tp, 0x811a, 0xff00, 0x0700);
+		sram2_write_w0w1(tp, 0x811c, 0xff00, 0x0500);
+		sram2_write_w0w1(tp, 0x810f, 0xff00, 0x0100);
+		sram2_write_w0w1(tp, 0x8111, 0xff00, 0x0100);
+		sram2_write_w0w1(tp, 0x811d, 0xff00, 0x0100);
+
+		/* RFI parameter */
+		ocp_reg_clr_bits(tp, 0xad1c, BIT(8));
+		ocp_reg_w0w1(tp, 0xade8, 0xffc0, 0x1400);
+
+		sram2_write_w0w1(tp, 0x864b, 0xff00, 0x9d00);
+		sram2_write_w0w1(tp, 0x862c, 0xff00, 0x1200);
+
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0x8566);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x003f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3f02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3b0a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+
+		/* RFI-color noise gen parameter 5g */
+		ocp_reg_set_bits(tp, 0xad9c, BIT(5));
+		sram2_write_w0w1(tp, 0x8122, 0xff00, 0x0c00);
+		ocp_reg_write(tp, OCP_SRAM2_ADDR, 0x82c8);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03ed);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03ff);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x0009);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03fe);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x000b);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x0021);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03f7);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03b8);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03e0);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x0049);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x0049);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03e0);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03b8);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03f7);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x0021);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x000b);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03fe);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x0009);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03ff);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03ed);
+		/* RFI-color noise gen parameter 2p5g */
+		sram2_write_w0w1(tp, 0x80ef, 0xff00, 0x0c00);
+		ocp_reg_write(tp, OCP_SRAM2_ADDR, 0x82a0);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x000e);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03fe);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03ed);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x0006);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x001a);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03f1);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03d8);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x0023);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x0054);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x0322);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x00dd);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03ab);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03dc);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x0027);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x000e);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03e5);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03f9);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x0012);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x0001);
+		ocp_reg_write(tp, OCP_SRAM2_DATA, 0x03f1);
+
+		/* modify thermal speed down threshold */
+		ocp_reg_w0w1(tp, 0xb54c, 0xffc0, 0x3700);
+
+		/* XG compatibility modification */
+		ocp_reg_set_bits(tp, 0xb648, BIT(6));
+		sram2_write_w0w1(tp, 0x8082, 0xff00, 0x5d00);
+		sram2_write_w0w1(tp, 0x807c, 0xff00, 0x5000);
+		sram2_write_w0w1(tp, 0x809d, 0xff00, 0x5000);
+		break;
+	default:
+		break;
+	}
+
+	if (rtl_phy_patch_request(tp, true, true))
+		return;
+
+	ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, EEE_SPDWN_EN);
+
+	ocp_reg_w0w1(tp, OCP_DOWN_SPEED, EN_EEE_100 | EN_EEE_1000,
+		     EN_10M_CLKDIV);
+	tp->ups_info._10m_ckdiv = true;
+	tp->ups_info.eee_plloff_100 = false;
+	tp->ups_info.eee_plloff_giga = false;
+
+	ocp_reg_set_bits(tp, OCP_POWER_CFG, EEE_CLKDIV_EN);
+	tp->ups_info.eee_ckdiv = true;
+
+	rtl_phy_patch_request(tp, false, true);
+
+	rtl_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));
+
+	ocp_reg_clr_bits(tp, 0xa428, BIT(9));
+	ocp_reg_clr_bits(tp, 0xa5ea, BIT(0) | BIT(1));
+	tp->ups_info.lite_mode = 0;
+
+	if (tp->eee_en)
+		rtl_eee_enable(tp, true);
+
+	r8153_aldps_en(tp, true);
+	r8152b_enable_fc(tp);
+
+	set_bit(PHY_RESET, &tp->flags);
+}
+
+static void r8159_hw_phy_cfg(struct r8152 *tp)
+{
+	int ret;
+
+	r8156b_wait_loading_flash(tp);
+
+	r8159_patch_code(tp);
+
+	ocp_word_test_and_clr_bits(tp, MCU_TYPE_USB, USB_MISC_0, PCUT_STATUS);
+
+	ret = r8153_phy_status(tp, 0);
+	if (ret < 0)
+		return;
+
+	switch (ret) {
+	case PHY_STAT_EXT_INIT:
+		rtl_ram_code_speed_up(tp, false);
+		ocp_reg_clr_bits(tp, 0xa466, BIT(0));
+		ocp_reg_clr_bits(tp, 0xa468, BIT(3) | BIT(1));
+		break;
+	case PHY_STAT_LAN_ON:
+	case PHY_STAT_PWRDN:
+	default:
+		rtl_ram_code_speed_up(tp, true);
+		break;
+	}
+
+	r8152_mdio_test_and_clr_bit(tp, MII_BMCR, BMCR_PDOWN);
+
+	/* disable ALDPS before updating the PHY parameters */
+	r8153_aldps_en(tp, false);
+
+	ret = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+	if (ret < 0)
+		return;
+	WARN_ON_ONCE(ret != PHY_STAT_LAN_ON);
+
+	/* PFM mode */
+	ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_PHY_PWR, PFM_PWM_SWITCH);
+
+	/* advanced Power Saving paramater */
+	ocp_reg_set_bits(tp, 0xa430, BIT(0) | BIT(1));
+
+	/* Disable ALDPS force mode */
+	ret = ocp_reg_clr_bits(tp, 0xa44a, BIT(2));
+	if (ret < 0)
+		return;
+
+	/* Disable bypass_turn_off_clk_in_aldps */
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, 0xd3c8, BIT(0));
+	if (ret < 0)
+		return;
+
+	switch (tp->version) {
+	case RTL_VER_17:
+		/* power level tune */
+		// test mode power level
+		sram_write_w0w1(tp, 0x8415, 0xff00, 0x9300);
+		// normal link power level 10G, 5G, 2.5G
+		sram_write_w0w1(tp, 0x81a3, 0xff00, 0x0f00);
+		sram_write_w0w1(tp, 0x81ae, 0xff00, 0x0f00);
+		sram_write_w0w1(tp, 0x81b9, 0xff00, 0xb900);
+		//nomal link TX filter
+		sram2_clr_bits(tp, 0x83b0, 0x0e00);
+		sram2_clr_bits(tp, 0x83c5, 0x0e00);
+		sram2_clr_bits(tp, 0x83da, 0x0e00);
+		sram2_clr_bits(tp, 0x83ef, 0x0e00);
+
+		/* AFE power saving for 2.5G & 5G */
+		sram_write(tp, 0x8173, 0x8620);
+		sram_write(tp, 0x8175, 0x8671);
+
+		sram_set_bits(tp, 0x817c, BIT(13));
+		sram_set_bits(tp, 0x8187, BIT(13));
+		sram_set_bits(tp, 0x8192, BIT(13));
+		sram_set_bits(tp, 0x819d, BIT(13));
+		sram_clr_bits(tp, 0x81a8, BIT(13));
+		sram_clr_bits(tp, 0x81b3, BIT(13));
+		sram_set_bits(tp, 0x81be, BIT(13));
+
+		sram_write_w0w1(tp, 0x817d, 0xff00, 0xa600);
+		sram_write_w0w1(tp, 0x8188, 0xff00, 0xa600);
+		sram_write_w0w1(tp, 0x8193, 0xff00, 0xa600);
+		sram_write_w0w1(tp, 0x819e, 0xff00, 0xa600);
+		sram_write_w0w1(tp, 0x81a9, 0xff00, 0x1400);
+		sram_write_w0w1(tp, 0x81b4, 0xff00, 0x1400);
+		sram_write_w0w1(tp, 0x81bf, 0xff00, 0xa600);
+
+		/* RFI parameter */
+		// disable preset FBE
+		ocp_reg_clr_bits(tp, 0xaeaa, BIT(5) | BIT(3));
+		// modify PGA for 5G&10G
+		sram2_write(tp, 0x84f0, 0x201c);
+		sram2_write(tp, 0x84f2, 0x3117);
+		// RFI parameter
+		ocp_reg_write(tp, 0xaec6, 0x0000);
+		ocp_reg_write(tp, 0xae20, 0xffff);
+		ocp_reg_write(tp, 0xaece, 0xffff);
+		ocp_reg_write(tp, 0xaed2, 0xffff);
+		ocp_reg_write(tp, 0xaec8, 0x0000);
+		ocp_reg_clr_bits(tp, 0xaed0, BIT(0));
+		ocp_reg_write(tp, 0xadb8, 0x0150);
+		sram2_write_w0w1(tp, 0x8197, 0xff00, 0x5000);
+		sram2_write_w0w1(tp, 0x8231, 0xff00, 0x5000);
+		sram2_write_w0w1(tp, 0x82cb, 0xff00, 0x5000);
+		sram2_write_w0w1(tp, 0x82cd, 0xff00, 0x5700);
+		sram2_write_w0w1(tp, 0x8233, 0xff00, 0x5700);
+		sram2_write_w0w1(tp, 0x8199, 0xff00, 0x5700);
+
+		sram2_write(tp, 0x815a, 0x0150);
+		sram2_write(tp, 0x81f4, 0x0150);
+		sram2_write(tp, 0x828e, 0x0150);
+		sram2_write(tp, 0x81b1, 0x0000);
+		sram2_write(tp, 0x824b, 0x0000);
+		sram2_write(tp, 0x82e5, 0x0000);
+
+		sram2_write_w0w1(tp, 0x84f7, 0xff00, 0x2800);
+		ocp_reg_set_bits(tp, 0xaec2, BIT(12));
+		sram2_write_w0w1(tp, 0x81b3, 0xff00, 0xad00);
+		sram2_write_w0w1(tp, 0x824d, 0xff00, 0xad00);
+		sram2_write_w0w1(tp, 0x82e7, 0xff00, 0xad00);
+		ocp_reg_w0w1(tp, 0xae4e, 0x000f, 0x0001);
+		sram2_write_w0w1(tp, 0x82ce, 0xf000, 0x4000);
+
+		/* XG INRX parameter */
+		// RC coefficients
+		sram2_write(tp, 0x84ac, 0x0000);
+		sram2_write(tp, 0x84ae, 0x0000);
+		sram2_write(tp, 0x84b0, 0xf818);
+		sram2_write_w0w1(tp, 0x84b2, 0xff00, 0x6000);
+		//Training AAGC PAR (with uc2 patch)
+		sram2_write(tp, 0x8ffc, 0x6008);
+		sram2_write(tp, 0x8ffe, 0xf450);
+		// DAC BGK
+		sram2_set_bits(tp, 0x8015, BIT(9));
+		sram2_set_bits(tp, 0x8016, BIT(11));
+		sram2_write_w0w1(tp, 0x8fe6, 0xff00, 0x0800);
+		sram2_write(tp, 0x8fe4, 0x2114);
+		// 10G PBO table
+		sram2_write(tp, 0x8647, 0xa7b1);
+		sram2_write(tp, 0x8649, 0xbbca);
+		sram2_write_w0w1(tp, 0x864b, 0xff00, 0xdc00);
+		// 2.5G ado power window size
+		sram2_write_w0w1(tp, 0x8154, 0xc000, 0x4000);
+		sram2_clr_bits(tp, 0x8158, 0xc000);
+		// 10G lock far
+		sram2_write(tp, 0x826c, 0xffff);
+		sram2_write(tp, 0x826e, 0xffff);
+		// XG INRX parameter
+		sram2_write_w0w1(tp, 0x8872, 0xff00, 0x0e00);
+		sram_set_bits(tp, 0x8012, BIT(11));
+		sram_set_bits(tp, 0x8012, BIT(14));
+		ocp_reg_set_bits(tp, 0xb576, BIT(0));
+		sram_write_w0w1(tp, 0x834a, 0xff00, 0x0700);
+		sram2_write_w0w1(tp, 0x8217, 0x3f00, 0x2a00);
+		sram_write_w0w1(tp, 0x81b1, 0xff00, 0x0b00);
+		sram2_write_w0w1(tp, 0x8fed, 0xff00, 0x4e00);
+
+		/* XG Test Mode */
+		// xgtstm_map_tbl for mdi_cap_sel
+		sram_write(tp, 0x8370, 0x8671);
+		sram_write(tp, 0x8372, 0x86c8);
+		//xgtstm_amp_map_tbl for  REG_IBX_UP_SHIFT_L
+		sram_write(tp, 0x8401, 0x86c8);
+		sram_write(tp, 0x8403, 0x86da);
+		sram_write_w0w1(tp, 0x8406, 0x1800, 0x1000);
+		sram_write_w0w1(tp, 0x8408, 0x1800, 0x1000);
+		sram_write_w0w1(tp, 0x840a, 0x1800, 0x1000);
+		sram_write_w0w1(tp, 0x840c, 0x1800, 0x1000);
+		sram_write_w0w1(tp, 0x840e, 0x1800, 0x1000);
+		sram_write_w0w1(tp, 0x8410, 0x1800, 0x1000);
+		sram_write_w0w1(tp, 0x8412, 0x1800, 0x1000);
+		sram_write_w0w1(tp, 0x8414, 0x1800, 0x1000);
+		sram_write_w0w1(tp, 0x8416, 0x1800, 0x1000);
+
+		/* Cable Test Pacth */
+		sram_write(tp, 0x82bd, 0x1f40);
+
+		/* thermal sensor parameter */
+		ocp_reg_w0w1(tp, 0xbfb4, 0x07ff, 0x0328);
+		ocp_reg_write(tp, 0xbfb6, 0x3e14);
+
+		/* spdchg_gtx_shape_100M */
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0x81c4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x003b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0086);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00db);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00c3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0078);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0047);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0023);
+
+		/* lsbmsk_parameter */
+		// RL6961_lsbmsk_parameter_250207
+		sram2_write(tp, 0x88d7, 0x01a0);
+		sram2_write(tp, 0x88d9, 0x01a0);
+		sram2_write(tp, 0x8ffa, 0x002a);
+
+		sram2_write(tp, 0x8fee, 0xffdf);
+		sram2_write(tp, 0x8ff0, 0xffff);
+		sram2_write(tp, 0x8ff2, 0x0a4a);
+		sram2_write(tp, 0x8ff4, 0xaa5a);
+		sram2_write(tp, 0x8ff6, 0x0a4a);
+		sram2_write(tp, 0x8ff8, 0xaa5a);
+
+		sram2_write_w0w1(tp, 0x88d5, 0xff00, 0x0200);
+		break;
+	default:
+		break;
+	}
+
+	if (rtl_phy_patch_request(tp, true, true))
+		return;
+
+	ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, EEE_SPDWN_EN);
+
+	ocp_reg_w0w1(tp, OCP_DOWN_SPEED, EN_EEE_100 | EN_EEE_1000,
+		     EN_10M_CLKDIV);
+	tp->ups_info._10m_ckdiv = true;
+	tp->ups_info.eee_plloff_100 = false;
+	tp->ups_info.eee_plloff_giga = false;
+
+	ocp_reg_set_bits(tp, OCP_POWER_CFG, EEE_CLKDIV_EN);
+	tp->ups_info.eee_ckdiv = true;
+
+	rtl_phy_patch_request(tp, false, true);
+
+	rtl_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));
+
+	ocp_reg_clr_bits(tp, 0xa428, BIT(9));
+	ocp_reg_clr_bits(tp, 0xa5ea, BIT(0) | BIT(1));
+	tp->ups_info.lite_mode = 0;
+
+	if (tp->eee_en)
+		rtl_eee_enable(tp, true);
+
+	r8153_aldps_en(tp, true);
+	r8152b_enable_fc(tp);
+
+	set_bit(PHY_RESET, &tp->flags);
+}
+
+static int r8156_init(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i, ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_ECM_OP, EN_ALL_SPEED);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION, 0);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_ECM_OPTION,
+				BYPASS_MAC_RESET);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	for (i = 0; i < 500; i++) {
+		ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL, &ocp_data);
+		if (ret < 0)
+			goto out;
+		if (ocp_data & AUTOLOAD_DONE)
+			break;
+
+		msleep(20);
+	}
+
+	ret = r8153_phy_status(tp, 0);
+	if (ret < 0)
+		goto out;
+
+	if (ret == PHY_STAT_EXT_INIT) {
+		ret = ocp_reg_clr_bits(tp, 0xa468, BIT(3) | BIT(1));
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = r8152_mdio_test_and_clr_bit(tp, MII_BMCR, BMCR_PDOWN);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+	if (ret < 0)
+		goto out;
+	WARN_ON_ONCE(ret != PHY_STAT_LAN_ON);
+
+	ret = r8153_u2p3en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	/* MSC timer = 0xfff * 8ms = 32760 ms */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);
+	if (ret < 0)
+		goto out;
+
+	/* U1/U2/L1 idle timer. 500 us */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_U1U2_TIMER, 500);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_power_cut_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8156_ups_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_queue_wake(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_runtime_suspend_enable(tp, false);
+	if (ret < 0)
+		goto out;
+
+	if (tp->udev->speed >= USB_SPEED_SUPER) {
+		ret = r8153b_u1u2en(tp, true);
+		if (ret < 0)
+			goto out;
+	}
+
+	usb_enable_lpm(tp->udev);
+
+//	ret = ocp_read_word(tp, MCU_TYPE_USB, 0xd850, &ocp_data);
+//	if (ret < 0)
+//		goto out;
+//	ocp_data &= 0xc000;
+//	switch (ocp_data) {
+//	case 0x4000:
+//		tp->dash_mode = 1;
+//		ret = r8156_mac_clk_spd(tp, false);
+//		if (ret < 0)
+//			goto out;
+//		break;
+//	case 0x8000:
+//		tp->dash_mode = 0;
+		ret = r8156_mac_clk_spd(tp, false);
+		if (ret < 0)
+			goto out;
+//		break;
+//	default:
+//		netif_warn(tp, drv, tp->netdev, "Invalid type %x\n", ocp_data);
+//		break;
+//	}
+
+
+	ret = r8153b_mcu_spdown_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	/* enable fc timer and set timer to 1s. */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_FC_TIMER,
+			     CTRL_TIMER_EN | (1000 / 8));
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_TASK, FC_PATCH_TASK);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_CTRL,
+				FLOW_CTRL_PATCH_OPT);
+	if (ret < 0)
+		goto out;
+
+	if (rtl8152_get_speed(tp) & LINK_STATUS)
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+					CUR_LINK_OK | POLL_LINK_CHG);
+	else
+		ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+				    CUR_LINK_OK, POLL_LINK_CHG);
+	if (ret < 0)
+		goto out;
+
+	set_bit(GREEN_ETHERNET, &tp->flags);
+
+	/* rx aggregation */
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_USB_CTRL,
+				RX_AGG_DISABLE | RX_ZERO_EN);
+	if (ret < 0)
+		goto out;
+
+	/* Set Rx aggregation parameters to default value
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, 0xd4c9, BIT(2));
+	*/
+
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, USB_BMU_CONFIG, ACT_ODMA);
+	if (ret < 0)
+		goto out;
+
+	ret = r8156_mdio_force_mode(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_tally_reset(tp);
+	if (ret < 0)
+		goto out;
+
+	tp->coalesce = 15000;	/* 15 us */
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static int r8156b_init(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i, ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_ECM_OP, EN_ALL_SPEED);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION, 0);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_ECM_OPTION,
+				BYPASS_MAC_RESET);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_U2P3_CTRL, RX_DETECT8);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	switch (tp->version) {
+	case RTL_VER_13:
+	case RTL_VER_15:
+		ret = r8156b_wait_loading_flash(tp);
+		if (ret < 0)
+			goto out;
+		break;
+	default:
+		break;
+	}
+
+	for (i = 0; i < 500; i++) {
+		ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL, &ocp_data);
+		if (ret < 0)
+			goto out;
+		if (ocp_data & AUTOLOAD_DONE)
+			break;
+
+		msleep(20);
+	}
+
+	ret = r8153_phy_status(tp, 0);
+	if (ret < 0)
+		goto out;
+	if (ret == PHY_STAT_EXT_INIT) {
+		ret = ocp_reg_clr_bits(tp, 0xa468, BIT(3) | BIT(1));
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_reg_clr_bits(tp, 0xa466, BIT(0));
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = r8152_mdio_test_and_clr_bit(tp, MII_BMCR, BMCR_PDOWN);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_u2p3en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	/* MSC timer = 0xfff * 8ms = 32760 ms */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);
+	if (ret < 0)
+		goto out;
+
+	/* U1/U2/L1 idle timer. 500 us */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_U1U2_TIMER, 500);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_power_cut_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8156_ups_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_queue_wake(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_runtime_suspend_enable(tp, false);
+	if (ret < 0)
+		goto out;
+
+	if (tp->udev->speed >= USB_SPEED_SUPER) {
+		ret = r8153b_u1u2en(tp, true);
+		if (ret < 0)
+			goto out;
+	}
+
+	usb_enable_lpm(tp->udev);
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_RCR, SLOT_EN);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_CPCR, FLOW_CTRL_EN);
+	if (ret < 0)
+		goto out;
+
+	/* enable fc timer and set timer to 600 ms. */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_FC_TIMER,
+			     CTRL_TIMER_EN | (600 / 8));
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL, &ocp_data);
+	if (ret < 0)
+		goto out;
+
+	if (!(ocp_data & DACK_DET_EN))
+		ret = ocp_word_w0w1(tp, MCU_TYPE_USB, USB_FW_CTRL, AUTO_SPEEDUP,
+			      FLOW_CTRL_PATCH_2);
+	else
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_FW_CTRL,
+					AUTO_SPEEDUP);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_TASK, FC_PATCH_TASK);
+	if (ret < 0)
+		goto out;
+
+	ret = r8156_mac_clk_spd(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_mcu_spdown_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	if (rtl8152_get_speed(tp) & LINK_STATUS)
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+					CUR_LINK_OK | POLL_LINK_CHG);
+	else
+		ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+				    CUR_LINK_OK, POLL_LINK_CHG);
+	if (ret < 0)
+		goto out;
+
+	set_bit(GREEN_ETHERNET, &tp->flags);
+
+	/* rx aggregation */
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_USB_CTRL,
+				RX_AGG_DISABLE | RX_ZERO_EN);
+	if (ret < 0)
+		goto out;
+
+	/* Set Rx aggregation parameters to default value
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, 0xd4c9, BIT(2));
+	if (ret < 0)
+		goto out;
+	*/
+
+	ret = r8156_mdio_force_mode(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_tally_reset(tp);
+	if (ret < 0)
+		goto out;
+
+	tp->coalesce = 15000;	/* 15 us */
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static int r8157_init(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i, ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	rtl_set_dbg_info_init(tp, 0x9);
+
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, 0xcffe, BIT(3));
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, 0xd3ca, BIT(0));
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_ECM_OP, EN_ALL_SPEED);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_ECM_OPTION,
+				BYPASS_MAC_RESET);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_U2P3_CTRL, RX_DETECT8);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	for (i = 0; i < 500; i++) {
+		ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL, &ocp_data);
+		if (ret < 0)
+			goto out;
+		else if (ocp_data & AUTOLOAD_DONE)
+			break;
+
+		msleep(20);
+	}
+
+	ret = r8156b_wait_loading_flash(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_phy_status(tp, 0);
+	if (ret < 0)
+		goto out;
+	if (ret == PHY_STAT_EXT_INIT) {
+		ret = ocp_reg_clr_bits(tp, 0xa468, BIT(3) | BIT(1));
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_reg_clr_bits(tp, 0xa466, BIT(0));
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = r8152_mdio_test_and_clr_bit(tp, MII_BMCR, BMCR_PDOWN);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+	if (ret < 0)
+		goto out;
+
+	ret = r8157_u2p3en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	/* Disable Interrupt Mitigation */
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, 0xcf04,
+				BIT(0) | BIT(1) | BIT(2) | BIT(7));
+	if (ret < 0)
+		goto out;
+
+	/* Disable all_speed_capability & rg_pwrdn_en */
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_SPEED_OPTION,
+				RG_PWRDN_EN | ALL_SPEED_OFF);
+	if (ret < 0)
+		goto out;
+
+	/* Disable Auto Speed up */
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_FW_CTRL,
+				AUTO_SPEEDUP);
+	if (ret < 0)
+		goto out;
+
+	/* MSC timer = 0xfff * 8ms = 32760 ms */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);
+	if (ret < 0)
+		goto out;
+
+	/* U1/U2/L1 idle timer. 500 us */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_U1U2_TIMER, 500);
+	if (ret < 0)
+		goto out;
+
+	ret = r8157_power_cut_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+//	ret = r8156_ups_en(tp, false);
+//	if (ret < 0)
+//		goto out;
+
+	ret = r8153_queue_wake(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_runtime_suspend_enable(tp, false);
+	if (ret < 0)
+		goto out;
+
+//	if (tp->udev->speed >= USB_SPEED_SUPER) {
+//		ret = r8153b_u1u2en(tp, true);
+//		if (ret < 0)
+//			goto out;
+//	}
+
+	usb_disable_lpm(tp->udev);
+	usb_disable_ltm(tp->udev);
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_RCR, SLOT_EN);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_CPCR, FLOW_CTRL_EN);
+	if (ret < 0)
+		goto out;
+
+	/* enable fc timer and set timer to 600 ms. */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_FC_TIMER,
+			     CTRL_TIMER_EN | (600 / 8));
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL, &ocp_data);
+	if (ret < 0)
+		goto out;
+
+	if (!(ocp_data & DACK_DET_EN))
+		ret = ocp_word_w0w1(tp, MCU_TYPE_USB, USB_FW_CTRL, AUTO_SPEEDUP,
+				    FLOW_CTRL_PATCH_2);
+	else
+		ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_FW_CTRL,
+					AUTO_SPEEDUP);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_FW_TASK, FC_PATCH_TASK);
+	if (ret < 0)
+		goto out;
+
+	/* Disable bypass_turn_off_clk_in_aldps */
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_PLA, 0xd3c8, BIT(0));
+	if (ret < 0)
+		goto out;
+
+	ret = r8156_mac_clk_spd(tp, false);
+	if (ret < 0)
+		goto out;
+
+	if (rtl8152_get_speed(tp) & LINK_STATUS)
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+					CUR_LINK_OK | POLL_LINK_CHG);
+	else
+		ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+				    CUR_LINK_OK, POLL_LINK_CHG);
+	if (ret < 0)
+		goto out;
+
+	set_bit(GREEN_ETHERNET, &tp->flags);
+
+	/* rx aggregation, 16 bytes Rx descriptor */
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_USB_CTRL,
+				RX_AGG_DISABLE | BIT(10));
+	if (ret < 0)
+		goto out;
+
+	/* Disable Rx Zero Len */
+	ret = rtl_bmu_clr_bits(tp, 0x2300, BIT(3));
+	if (ret < 0)
+		goto out;
+
+	/* Set Rx aggregation parameters to default value
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, 0xd4c9, BIT(2));
+	if (ret < 0)
+		goto out;
+	*/
+
+	/* TX descriptor Signature */
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, 0xd4ae, BIT(1));
+	if (ret < 0)
+		goto out;
+
+	ret = r8156_mdio_force_mode(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_tally_reset(tp);
+	if (ret < 0)
+		goto out;
+
+	tp->coalesce = 15000;	/* 15 us */
+
+out:
+	if (ret < 0)
+		return ret;
+	else
+		return 0;
+}
+
+static int r8159_wait_backup_restore(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int ret, i;
+
+	ret = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0, &ocp_data);
+	if (ret < 0)
+		goto out;
+
+	if (!(ocp_data & PCUT_STATUS))
+		goto out;
+
+	for (i = 0; i < 100; i++) {
+		ret = ocp_read_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL, &ocp_data);
+		if (ret < 0)
+			goto out;
+
+		if (ocp_data & BACKUP_RESTRORE)
+			break;
+	}
+
+	if (i == 100)
+		ret = -ETIME;
+
+out:
+	return ret;
+}
+
+static int r8159_init(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i, ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	rtl_set_dbg_info_init(tp, 0x9);
+
+	ret = ocp_byte_set_bits(tp, MCU_TYPE_USB, 0xcffe, BIT(3));
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, 0xd3ca, BIT(0));
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, USB_ECM_OP, EN_ALL_SPEED);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_USB, USB_ECM_OPTION,
+				BYPASS_MAC_RESET);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153b_u1u2en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	for (i = 0; i < 500; i++) {
+		ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL, &ocp_data);
+		if (ret < 0)
+			goto out;
+		else if (ocp_data & AUTOLOAD_DONE)
+			break;
+
+		msleep(20);
+	}
+
+	ret = r8159_wait_backup_restore(tp);
+	if (ret < 0)
+		goto out;
+
+	/* MSC timer = 0xfff * 8ms = 32760 ms */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);
+	if (ret < 0)
+		goto out;
+
+	/* U1/U2/L1 idle timer. 500 us */
+	ret = ocp_write_word(tp, MCU_TYPE_USB, USB_U1U2_TIMER, 500);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_PLA, PLA_RCR, SLOT_EN);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, 0xe61e, 0xf0 | BIT(3), 0x9 << 4);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, 0xe61e, BIT(3));
+	if (ret < 0)
+		goto out;
+
+	ret = r8156b_wait_loading_flash(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_phy_status(tp, 0);
+	if (ret < 0)
+		goto out;
+	if (ret == PHY_STAT_EXT_INIT) {
+		ret = ocp_reg_clr_bits(tp, 0xa468, BIT(3) | BIT(1));
+		if (ret < 0)
+			goto out;
+
+		ret = ocp_reg_clr_bits(tp, 0xa466, BIT(0));
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = r8152_mdio_test_and_clr_bit(tp, MII_BMCR, BMCR_PDOWN);
+	if (ret < 0)
+		goto out;
+
+	ret = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+	if (ret < 0)
+		goto out;
+
+	ret = r8157_u2p3en(tp, false);
+	if (ret < 0)
+		goto out;
+
+	/* Disable Interrupt Mitigation */
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, 0xcf04,
+				BIT(0) | BIT(1) | BIT(2) | BIT(7));
+	if (ret < 0)
+		goto out;
+
+	/* Disable all_speed_capability & rg_pwrdn_en */
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_SPEED_OPTION,
+				RG_PWRDN_EN | ALL_SPEED_OFF);
+	if (ret < 0)
+		goto out;
+
+	/* Disable Auto Speed up */
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_FW_CTRL,
+				AUTO_SPEEDUP);
+	if (ret < 0)
+		goto out;
+
+	ret = r8157_power_cut_en(tp, false);
+	if (ret < 0)
+		goto out;
+
+//	ret = r8156_ups_en(tp, false);
+//	if (ret < 0)
+//		goto out;
+
+	ret = r8153_queue_wake(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_runtime_suspend_enable(tp, false);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, 0xcd06, BIT(11));
+	if (ret < 0)
+		goto out;
+
+	usb_disable_lpm(tp->udev);
+	usb_disable_ltm(tp->udev);
+
+	ret = r8156_mac_clk_spd(tp, false);
+	if (ret < 0)
+		goto out;
+
+	if (rtl8152_get_speed(tp) & LINK_STATUS)
+		ret = ocp_word_set_bits(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+					CUR_LINK_OK | POLL_LINK_CHG);
+	else
+		ret = ocp_word_w0w1(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+				    CUR_LINK_OK, POLL_LINK_CHG);
+	if (ret < 0)
+		goto out;
+
+	set_bit(GREEN_ETHERNET, &tp->flags);
+
+	/* rx aggregation, 16 bytes Rx descriptor */
+	ret = ocp_word_clr_bits(tp, MCU_TYPE_USB, USB_USB_CTRL,
+				RX_AGG_DISABLE | BIT(10) | BIT(11));
+	if (ret < 0)
+		goto out;
+
+	/* Disable Rx Zero Len */
+	ret = rtl_bmu_clr_bits(tp, 0x2300, BIT(3));
+	if (ret < 0)
+		goto out;
+
+	/* TX descriptor Signature */
+	ret = ocp_byte_clr_bits(tp, MCU_TYPE_USB, 0xd4ae, BIT(1));
+	if (ret < 0)
+		goto out;
+
+	ret = r8156_mdio_force_mode(tp);
+	if (ret < 0)
+		goto out;
+
+	ret = rtl_tally_reset(tp);
+	if (ret < 0)
+		goto out;
+
+	tp->coalesce = 15000;	/* 15 us */
+
+out:
+	if (ret < 0)
+		return ret;
+	else
+		return 0;
+}
+
+static bool rtl_check_vendor_ok(struct usb_interface *intf)
+{
+	struct usb_host_interface *alt = intf->cur_altsetting;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
+	struct usb_host_endpoint *in = NULL, *out = NULL, *intr = NULL;
+	unsigned int ep;
+
+	if (alt->desc.bNumEndpoints < 3) {
+		dev_err(&intf->dev, "Unexpected bNumEndpoints %d\n", alt->desc.bNumEndpoints);
+		return false;
+	}
+
+	for (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {
+		struct usb_host_endpoint *e;
+
+		e = alt->endpoint + ep;
+
+		/* ignore endpoints which cannot transfer data */
+		if (!usb_endpoint_maxp(&e->desc))
+			continue;
+
+		switch (e->desc.bmAttributes) {
+		case USB_ENDPOINT_XFER_INT:
+			if (!usb_endpoint_dir_in(&e->desc))
+				continue;
+			if (!intr)
+				intr = e;
+			break;
+		case USB_ENDPOINT_XFER_BULK:
+			if (usb_endpoint_dir_in(&e->desc)) {
+				if (!in)
+					in = e;
+			} else if (!out) {
+				out = e;
+			}
+			break;
+		default:
+			continue;
+		}
+	}
+
+	if (!in || !out || !intr) {
+		dev_err(&intf->dev, "Miss Endpoints\n");
+		return false;
+	}
+
+	if ((in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) != 1) {
+		dev_err(&intf->dev, "Invalid Rx endpoint address\n");
+		return false;
+	}
+
+	if ((out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) != 2) {
+		dev_err(&intf->dev, "Invalid Tx endpoint address\n");
+		return false;
+	}
+
+	if ((intr->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) != 3) {
+		dev_err(&intf->dev, "Invalid interrupt endpoint address\n");
+		return false;
+	}
+#else
+	struct usb_endpoint_descriptor *in, *out, *intr;
+
+	if (usb_find_common_endpoints(alt, &in, &out, &intr, NULL) < 0) {
+		dev_err(&intf->dev, "Expected endpoints are not found\n");
+		return false;
+	}
+
+	/* Check Rx endpoint address */
+	if (usb_endpoint_num(in) != 1) {
+		dev_err(&intf->dev, "Invalid Rx endpoint address\n");
+		return false;
+	}
+
+	/* Check Tx endpoint address */
+	if (usb_endpoint_num(out) != 2) {
+		dev_err(&intf->dev, "Invalid Tx endpoint address\n");
+		return false;
+	}
+
+	/* Check interrupt endpoint address */
+	if (usb_endpoint_num(intr) != 3) {
+		dev_err(&intf->dev, "Invalid interrupt endpoint address\n");
+		return false;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0) */
+
+	return true;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0)
+static bool rtl_vendor_mode(struct usb_interface *intf)
+{
+	struct usb_host_interface *alt = intf->cur_altsetting;
+	struct usb_device *udev;
+	struct usb_host_config *c;
+	int i, num_configs;
+
+	if (alt->desc.bInterfaceClass == USB_CLASS_VENDOR_SPEC)
+		return rtl_check_vendor_ok(intf);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	dev_err(&intf->dev, "The kernel is too old to set configuration\n");
+#else
+	/* The vendor mode is not always config #1, so to find it out. */
+	udev = interface_to_usbdev(intf);
+	c = udev->config;
+	num_configs = udev->descriptor.bNumConfigurations;
+	if (num_configs < 2)
+		return false;
+
+	for (i = 0; i < num_configs; (i++, c++)) {
+		struct usb_interface_descriptor	*desc = NULL;
+
+		if (c->desc.bNumInterfaces > 0)
+			desc = &c->intf_cache[0]->altsetting->desc;
+		else
+			continue;
+
+		if (desc->bInterfaceClass == USB_CLASS_VENDOR_SPEC) {
+			usb_driver_set_configuration(udev, c->desc.bConfigurationValue);
+			break;
+		}
+	}
+
+	if (i == num_configs)
+		dev_err(&intf->dev, "Unexpected Device\n");
+#endif
+
+	return false;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0) */
+
+static int rtl8152_pre_reset(struct usb_interface *intf)
+{
+	struct r8152 *tp = usb_get_intfdata(intf);
+	struct net_device *netdev;
+
+	if (!tp)
+		return 0;
+
+	netdev = tp->netdev;
+	if (!netif_running(netdev))
+		return 0;
+
+	netif_stop_queue(netdev);
+	tasklet_disable(&tp->tx_tl);
+	smp_mb__before_atomic();
+	clear_bit(WORK_ENABLE, &tp->flags);
+	smp_mb__after_atomic();
+	usb_kill_urb(tp->intr_urb);
+	cancel_delayed_work_sync(&tp->schedule);
+	napi_disable(&tp->napi);
+	if (netif_carrier_ok(netdev)) {
+		mutex_lock(&tp->control);
+		tp->rtl_ops.disable(tp);
+		mutex_unlock(&tp->control);
+	}
+
+	return 0;
+}
+
+static int rtl8152_post_reset(struct usb_interface *intf)
+{
+	struct r8152 *tp = usb_get_intfdata(intf);
+	struct net_device *netdev;
+	struct sockaddr sa;
+
+	if (!tp)
+		return 0;
+
+	/* reset the MAC address in case of policy change */
+	if (determine_ethernet_addr(tp, &sa) >= 0) {
+		rtnl_lock();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+		dev_set_mac_address(tp->netdev, &sa);
+#else
+		dev_set_mac_address(tp->netdev, &sa, NULL);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0) */
+		rtnl_unlock();
+	}
+
+	netdev = tp->netdev;
+	if (!netif_running(netdev))
+		return 0;
+
+	smp_mb__before_atomic();
+	set_bit(WORK_ENABLE, &tp->flags);
+	smp_mb__after_atomic();
+	if (netif_carrier_ok(netdev)) {
+		mutex_lock(&tp->control);
+		tp->rtl_ops.enable(tp);
+		rtl_start_rx(tp);
+		rtl8152_set_rx_mode(netdev);
+		mutex_unlock(&tp->control);
+	}
+
+	napi_enable(&tp->napi);
+	tasklet_enable(&tp->tx_tl);
+	netif_wake_queue(netdev);
+	usb_submit_urb(tp->intr_urb, GFP_KERNEL);
+
+	if (!list_empty(&tp->rx_done))
+		napi_schedule(&tp->napi);
+
+	return 0;
+}
+
+static bool delay_autosuspend(struct r8152 *tp)
+{
+	bool sw_linking = !!netif_carrier_ok(tp->netdev);
+	bool hw_linking = !!(rtl8152_get_speed(tp) & LINK_STATUS);
+
+	/* This means a linking change occurs and the driver doesn't detect it,
+	 * yet. If the driver has disabled tx/rx and hw is linking on, the
+	 * device wouldn't wake up by receiving any packet.
+	 */
+	if (work_busy(&tp->schedule.work) || sw_linking != hw_linking)
+		return true;
+
+	/* If the linking down is occurred by nway, the device may miss the
+	 * linking change event. And it wouldn't wake when linking on.
+	 */
+	if (!sw_linking && tp->rtl_ops.in_nway(tp))
+		return true;
+	else if (!skb_queue_empty(&tp->tx_queue))
+		return true;
+	else
+		return false;
+}
+
+static int rtl8152_runtime_resume(struct r8152 *tp)
+{
+	struct net_device *netdev = tp->netdev;
+
+	if (netif_running(netdev) && netdev->flags & IFF_UP) {
+		struct napi_struct *napi = &tp->napi;
+
+		tp->rtl_ops.autosuspend_en(tp, false);
+		napi_disable(napi);
+		smp_mb__before_atomic();
+		set_bit(WORK_ENABLE, &tp->flags);
+		smp_mb__after_atomic();
+
+		if (netif_carrier_ok(netdev)) {
+			if (rtl8152_get_speed(tp) & LINK_STATUS) {
+				rtl_start_rx(tp);
+			} else {
+				netif_carrier_off(netdev);
+				tp->rtl_ops.disable(tp);
+				netif_info(tp, link, netdev, "linking down\n");
+			}
+		}
+
+		napi_enable(napi);
+		clear_bit(SELECTIVE_SUSPEND, &tp->flags);
+		smp_mb__after_atomic();
+
+		if (!list_empty(&tp->rx_done)) {
+			local_bh_disable();
+			napi_schedule(&tp->napi);
+			local_bh_enable();
+		}
+
+		usb_submit_urb(tp->intr_urb, GFP_NOIO);
+	} else {
+		if (netdev->flags & IFF_UP)
+			tp->rtl_ops.autosuspend_en(tp, false);
+
+		clear_bit(SELECTIVE_SUSPEND, &tp->flags);
+		smp_mb__after_atomic();
+	}
+
+	return 0;
+}
+
+static int rtl8152_system_resume(struct r8152 *tp)
+{
+	struct net_device *netdev = tp->netdev;
+
+	netif_device_attach(netdev);
+
+	if (netif_running(netdev) && (netdev->flags & IFF_UP)) {
+		tp->rtl_ops.up(tp);
+		netif_carrier_off(netdev);
+		smp_mb__before_atomic();
+		set_bit(WORK_ENABLE, &tp->flags);
+		smp_mb__after_atomic();
+		if (test_and_clear_bit(RECOVER_SPEED, &tp->flags))
+			rtl8152_set_speed(tp, tp->autoneg, tp->speed,
+					  tp->duplex, tp->advertising);
+		usb_submit_urb(tp->intr_urb, GFP_NOIO);
+	}
+
+	return 0;
+}
+
+static int rtl8152_runtime_suspend(struct r8152 *tp)
+{
+	struct net_device *netdev = tp->netdev;
+	int ret = 0;
+
+	if (!tp->rtl_ops.autosuspend_en)
+		return -EBUSY;
+
+	set_bit(SELECTIVE_SUSPEND, &tp->flags);
+	smp_mb__after_atomic();
+
+	if (netif_running(netdev) && test_bit(WORK_ENABLE, &tp->flags)) {
+		u32 rcr = 0;
+
+		if (netif_carrier_ok(netdev)) {
+			u32 ocp_data;
+
+			ret = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR, &rcr);
+			if (ret < 0)
+				goto out2;
+			ocp_data = rcr & ~RCR_ACPT_ALL;
+			ret = ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR,
+					      ocp_data);
+			if (ret < 0)
+				goto out3;
+			ret = rxdy_gated_en(tp, true);
+			if (ret < 0)
+				goto out3;
+			ret = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL,
+					    &ocp_data);
+			if (ret < 0 || !(ocp_data & RXFIFO_EMPTY)) {
+				rxdy_gated_en(tp, false);
+out3:
+				ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, rcr);
+out2:
+				clear_bit(SELECTIVE_SUSPEND, &tp->flags);
+				smp_mb__after_atomic();
+				if (ret >= 0)
+					ret = -EBUSY;
+				goto out1;
+			}
+		}
+
+		smp_mb__before_atomic();
+		clear_bit(WORK_ENABLE, &tp->flags);
+		smp_mb__after_atomic();
+		usb_kill_urb(tp->intr_urb);
+
+		tp->rtl_ops.autosuspend_en(tp, true);
+
+		if (netif_carrier_ok(netdev)) {
+			struct napi_struct *napi = &tp->napi;
+
+			napi_disable(napi);
+			rtl_stop_rx(tp);
+			rxdy_gated_en(tp, false);
+			ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, rcr);
+			napi_enable(napi);
+		}
+
+		if (delay_autosuspend(tp)) {
+			rtl8152_runtime_resume(tp);
+			ret = -EBUSY;
+		}
+	}
+
+out1:
+	return (ret < 0) ? ret : 0;
+}
+
+static int rtl8152_system_suspend(struct r8152 *tp)
+{
+	struct net_device *netdev = tp->netdev;
+
+	netif_device_detach(netdev);
+
+	if (netif_running(netdev) && test_bit(WORK_ENABLE, &tp->flags)) {
+		struct napi_struct *napi = &tp->napi;
+
+		smp_mb__before_atomic();
+		clear_bit(WORK_ENABLE, &tp->flags);
+		smp_mb__after_atomic();
+		usb_kill_urb(tp->intr_urb);
+		tasklet_disable(&tp->tx_tl);
+		napi_disable(napi);
+		cancel_delayed_work_sync(&tp->schedule);
+		tp->rtl_ops.down(tp);
+
+		if (tp->version == RTL_VER_01)
+			rtl8152_set_speed(tp, AUTONEG_ENABLE, 0, 0, 3);
+		else
+			rtl_speed_down(tp);
+
+		napi_enable(napi);
+		tasklet_enable(&tp->tx_tl);
+	}
+
+	return 0;
+}
+
+static int rtl8152_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct r8152 *tp = usb_get_intfdata(intf);
+	int ret;
+
+	mutex_lock(&tp->control);
+
+	if (PMSG_IS_AUTO(message))
+		ret = rtl8152_runtime_suspend(tp);
+	else
+		ret = rtl8152_system_suspend(tp);
+
+	mutex_unlock(&tp->control);
+
+	return ret;
+}
+
+static int rtl8152_resume(struct usb_interface *intf)
+{
+	struct r8152 *tp = usb_get_intfdata(intf);
+	int ret;
+
+	mutex_lock(&tp->control);
+
+	rtl_reset_ocp_base(tp);
+
+	if (test_bit(SELECTIVE_SUSPEND, &tp->flags))
+		ret = rtl8152_runtime_resume(tp);
+	else
+		ret = rtl8152_system_resume(tp);
+
+	mutex_unlock(&tp->control);
+
+	return ret;
+}
+
+static int rtl8152_reset_resume(struct usb_interface *intf)
+{
+	struct r8152 *tp = usb_get_intfdata(intf);
+
+	clear_bit(SELECTIVE_SUSPEND, &tp->flags);
+	rtl_reset_ocp_base(tp);
+	tp->rtl_ops.init(tp);
+	queue_delayed_work(system_long_wq, &tp->hw_phy_work, 0);
+	set_ethernet_addr(tp, true);
+	return rtl8152_resume(intf);
+}
+
+static void rtl8152_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
+
+	if (!rtl_can_wakeup(tp)) {
+		wol->supported = 0;
+		wol->wolopts = 0;
+	} else {
+		mutex_lock(&tp->control);
+		wol->supported = WAKE_ANY;
+		wol->wolopts = __rtl_get_wol(tp);
+		mutex_unlock(&tp->control);
+	}
+
+	usb_autopm_put_interface(tp->intf);
+}
+
+static int rtl8152_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	int ret;
+
+	if (!rtl_can_wakeup(tp))
+		return -EOPNOTSUPP;
+
+	if (wol->wolopts & ~WAKE_ANY)
+		return -EINVAL;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out_set_wol;
+
+	mutex_lock(&tp->control);
+
+	__rtl_set_wol(tp, wol->wolopts);
+	tp->saved_wolopts = wol->wolopts & WAKE_ANY;
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out_set_wol:
+	return ret;
+}
+
+static u32 rtl8152_get_msglevel(struct net_device *dev)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	return tp->msg_enable;
+}
+
+static void rtl8152_set_msglevel(struct net_device *dev, u32 value)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	tp->msg_enable = value;
+}
+
+static void rtl8152_get_drvinfo(struct net_device *netdev,
+				struct ethtool_drvinfo *info)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+	strscpy(info->driver, MODULENAME, sizeof(info->driver));
+	strscpy(info->version, DRIVER_VERSION, sizeof(info->version));
+	usb_make_path(tp->udev, info->bus_info, sizeof(info->bus_info));
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0)
+static
+int rtl8152_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	u16 bmcr, bmsr;
+	int ret, advert;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	cmd->supported =
+	    (SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+	     SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+	     SUPPORTED_Autoneg | SUPPORTED_MII);
+
+	/* only supports twisted-pair */
+	cmd->port = PORT_MII;
+
+	/* only supports internal transceiver */
+	cmd->transceiver = XCVR_INTERNAL;
+	cmd->phy_address = 32;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+	cmd->mdio_support = ETH_MDIO_SUPPORTS_C22;
+#endif
+	cmd->advertising = ADVERTISED_MII;
+
+	mutex_lock(&tp->control);
+
+	ret = r8152_mdio_read(tp, MII_BMCR);
+	if (ret < 0)
+		goto out1;
+	bmcr = ret;
+	ret = r8152_mdio_read(tp, MII_BMSR);
+	if (ret < 0)
+		goto out1;
+	bmsr = ret;
+
+	ret = r8152_mdio_read(tp, MII_ADVERTISE);
+	if (ret < 0)
+		goto out1;
+	advert = ret;
+	if (advert & ADVERTISE_10HALF)
+		cmd->advertising |= ADVERTISED_10baseT_Half;
+	if (advert & ADVERTISE_10FULL)
+		cmd->advertising |= ADVERTISED_10baseT_Full;
+	if (advert & ADVERTISE_100HALF)
+		cmd->advertising |= ADVERTISED_100baseT_Half;
+	if (advert & ADVERTISE_100FULL)
+		cmd->advertising |= ADVERTISED_100baseT_Full;
+	if (advert & ADVERTISE_PAUSE_CAP)
+		cmd->advertising |= ADVERTISED_Pause;
+	if (advert & ADVERTISE_PAUSE_ASYM)
+		cmd->advertising |= ADVERTISED_Asym_Pause;
+	if (tp->mii.supports_gmii) {
+		u16 ctrl1000;
+
+		ret = r8152_mdio_read(tp, MII_CTRL1000);
+		if (ret < 0)
+			goto out1;
+
+		ctrl1000 = ret;
+
+		cmd->supported |= SUPPORTED_1000baseT_Full;
+
+		if (tp->support_2500full) {
+			u16 data;
+
+			ret = ocp_reg_read(tp, OCP_10GBT_CTRL, &data);
+			if (ret < 0)
+				goto out1;
+
+			cmd->supported |= SUPPORTED_2500baseX_Full;
+			if (data & MDIO_AN_10GBT_CTRL_ADV2_5G)
+				cmd->advertising |= ADVERTISED_2500baseX_Full;
+		}
+
+		/* The legacy API couldn't support 5G speed */
+
+		if (ctrl1000 & ADVERTISE_1000HALF)
+			cmd->advertising |= ADVERTISED_1000baseT_Half;
+		if (ctrl1000 & ADVERTISE_1000FULL)
+			cmd->advertising |= ADVERTISED_1000baseT_Full;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+	if (bmsr & BMSR_ANEGCOMPLETE) {
+		ret = r8152_mdio_read(tp, MII_LPA);
+		if (ret < 0)
+			goto out1;
+		advert = ret;
+		if (advert & LPA_LPACK)
+			cmd->lp_advertising |= ADVERTISED_Autoneg;
+		if (advert & ADVERTISE_10HALF)
+			cmd->lp_advertising |=
+				ADVERTISED_10baseT_Half;
+		if (advert & ADVERTISE_10FULL)
+			cmd->lp_advertising |=
+				ADVERTISED_10baseT_Full;
+		if (advert & ADVERTISE_100HALF)
+			cmd->lp_advertising |=
+				ADVERTISED_100baseT_Half;
+		if (advert & ADVERTISE_100FULL)
+			cmd->lp_advertising |=
+				ADVERTISED_100baseT_Full;
+
+		if (tp->mii.supports_gmii) {
+			u16 stat1000;
+
+			ret = r8152_mdio_read(tp, MII_STAT1000);
+			if (ret < 0)
+				goto out1;
+
+			stat1000 = ret;
+			if (stat1000 & LPA_1000HALF)
+				cmd->lp_advertising |=
+					ADVERTISED_1000baseT_Half;
+			if (stat1000 & LPA_1000FULL)
+				cmd->lp_advertising |=
+					ADVERTISED_1000baseT_Full;
+		}
+	} else {
+		cmd->lp_advertising = 0;
+	}
+#endif
+
+	if (bmcr & BMCR_ANENABLE) {
+		cmd->advertising |= ADVERTISED_Autoneg;
+		cmd->autoneg = AUTONEG_ENABLE;
+	} else {
+		cmd->autoneg = AUTONEG_DISABLE;
+	}
+
+
+	if (netif_running(netdev) && netif_carrier_ok(netdev)) {
+		u16 speed = rtl8152_get_speed(tp);
+
+		if (speed & _100bps)
+			cmd->speed = SPEED_100;
+		else if (speed & _10bps)
+			cmd->speed = SPEED_10;
+		else if (tp->mii.supports_gmii && (speed & _1000bps))
+			cmd->speed = SPEED_1000;
+		else if (tp->support_2500full && (speed & _2500bps))
+			cmd->speed = SPEED_2500;
+
+		/* The legacy API couldn't support 5G speed */
+
+		cmd->duplex = (speed & FULL_DUP) ? DUPLEX_FULL : DUPLEX_HALF;
+	} else {
+		cmd->speed = SPEED_UNKNOWN;
+		cmd->duplex = DUPLEX_UNKNOWN;
+	}
+
+out1:
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static int rtl8152_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	u32 advertising = 0;
+	int ret;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	if (cmd->advertising & ADVERTISED_10baseT_Half)
+		advertising |= RTL_ADVERTISED_10_HALF;
+	if (cmd->advertising & ADVERTISED_10baseT_Full)
+		advertising |= RTL_ADVERTISED_10_FULL;
+	if (cmd->advertising & ADVERTISED_100baseT_Half)
+		advertising |= RTL_ADVERTISED_100_HALF;
+	if (cmd->advertising & ADVERTISED_100baseT_Full)
+		advertising |= RTL_ADVERTISED_100_FULL;
+	if (cmd->advertising & ADVERTISED_1000baseT_Half)
+		advertising |= RTL_ADVERTISED_1000_HALF;
+	if (cmd->advertising & ADVERTISED_1000baseT_Full)
+		advertising |= RTL_ADVERTISED_1000_FULL;
+	if (cmd->advertising & ADVERTISED_2500baseX_Full)
+		advertising |= RTL_ADVERTISED_2500_FULL;
+
+	/* The legacy API couldn't support 5G speed */
+
+	mutex_lock(&tp->control);
+
+	ret = rtl8152_set_speed(tp, cmd->autoneg, cmd->speed, cmd->duplex,
+				advertising);
+	if (!ret) {
+		tp->autoneg = cmd->autoneg;
+		tp->speed = cmd->speed;
+		tp->duplex = cmd->duplex;
+		tp->advertising = advertising;
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+static int rtl8152_get_link_ksettings(struct net_device *netdev,
+				      struct ethtool_link_ksettings *cmd)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	u16 bmcr, bmsr, advert;
+	int ret;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out1;
+
+	/* only supports twisted-pair */
+	cmd->base.port = PORT_MII;
+
+	/* this isn't fully supported at higher layers */
+	cmd->base.phy_address = 32;
+	cmd->base.mdio_support = ETH_MDIO_SUPPORTS_C22;
+
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+			 cmd->link_modes.supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+			 cmd->link_modes.supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+			 cmd->link_modes.supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+			 cmd->link_modes.supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
+			 cmd->link_modes.supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_MII_BIT,
+			 cmd->link_modes.supported);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+			 cmd->link_modes.supported, tp->mii.supports_gmii);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+			 cmd->link_modes.supported, tp->support_2500full);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+			 cmd->link_modes.supported, tp->support_5000full);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+			 cmd->link_modes.supported, tp->support_10gfull);
+
+	ret = mutex_lock_interruptible(&tp->control);
+	if (ret < 0)
+		goto out2;
+
+	ret = r8152_mdio_read(tp, MII_BMCR);
+	if (ret < 0)
+		goto out3;
+	bmcr = ret;
+
+	ret = r8152_mdio_read(tp, MII_BMSR);
+	if (ret < 0)
+		goto out3;
+	bmsr = ret;
+
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
+			 cmd->link_modes.advertising, bmcr & BMCR_ANENABLE);
+
+	if (bmcr & BMCR_ANENABLE)
+		cmd->base.autoneg = AUTONEG_ENABLE;
+	else
+		cmd->base.autoneg = AUTONEG_DISABLE;
+
+	ret = r8152_mdio_read(tp, MII_ADVERTISE);
+	if (ret < 0)
+		goto out3;
+
+	advert = ret;
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+			 cmd->link_modes.advertising,
+			 advert & ADVERTISE_10HALF);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+			 cmd->link_modes.advertising,
+			 advert & ADVERTISE_10FULL);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+			 cmd->link_modes.advertising,
+			 advert & ADVERTISE_100HALF);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+			 cmd->link_modes.advertising,
+			 advert & ADVERTISE_100FULL);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+			 cmd->link_modes.advertising,
+			 advert & ADVERTISE_PAUSE_CAP);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+			 cmd->link_modes.advertising,
+			 advert & ADVERTISE_PAUSE_ASYM);
+
+	if (tp->mii.supports_gmii) {
+		u16 ctrl1000;
+
+		ret = r8152_mdio_read(tp, MII_CTRL1000);
+		if (ret < 0)
+			goto out3;
+
+		ctrl1000 = ret;
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+				 cmd->link_modes.advertising,
+				 ctrl1000 & ADVERTISE_1000HALF);
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+				 cmd->link_modes.advertising,
+				 ctrl1000 & ADVERTISE_1000FULL);
+	}
+
+	if (tp->support_2500full || tp->support_5000full ||
+	    tp->support_10gfull) {
+		u16 data;
+
+		ret = ocp_reg_read(tp, OCP_10GBT_CTRL, &data);
+		if (ret < 0)
+			goto out3;
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+				 cmd->link_modes.advertising,
+				 data & MDIO_AN_10GBT_CTRL_ADV2_5G);
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+				 cmd->link_modes.advertising,
+				 data & MDIO_AN_10GBT_CTRL_ADV5G);
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+				 cmd->link_modes.advertising,
+				 data & MDIO_AN_10GBT_CTRL_ADV10G);
+	}
+
+	if (bmsr & BMSR_ANEGCOMPLETE) {
+		ret = r8152_mdio_read(tp, MII_LPA);
+		if (ret < 0)
+			goto out3;
+
+		advert = ret;
+
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
+				 cmd->link_modes.lp_advertising,
+				 advert & LPA_LPACK);
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+				 cmd->link_modes.lp_advertising,
+				 advert & ADVERTISE_10HALF);
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+				 cmd->link_modes.lp_advertising,
+				 advert & ADVERTISE_10FULL);
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+				 cmd->link_modes.lp_advertising,
+				 advert & ADVERTISE_100HALF);
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+				 cmd->link_modes.lp_advertising,
+				 advert & ADVERTISE_100FULL);
+
+		if (tp->mii.supports_gmii) {
+			u16 stat1000;
+
+			ret = r8152_mdio_read(tp, MII_STAT1000);
+			if (ret < 0)
+				goto out3;
+
+			stat1000 = ret;
+
+			linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+					 cmd->link_modes.lp_advertising,
+					 stat1000 & LPA_1000HALF);
+			linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+					 cmd->link_modes.lp_advertising,
+					 stat1000 & LPA_1000FULL);
+		}
+
+		if (tp->support_2500full || tp->support_5000full ||
+		    tp->support_10gfull) {
+			u16 data;
+
+			ret = ocp_reg_read(tp, OCP_10GBT_STAT, &data);
+			if (ret < 0)
+				goto out3;
+			linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+					 cmd->link_modes.lp_advertising,
+					 data & MDIO_AN_10GBT_STAT_LP2_5G);
+			linkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+					 cmd->link_modes.lp_advertising,
+					 data & MDIO_AN_10GBT_STAT_LP5G);
+			linkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+					 cmd->link_modes.lp_advertising,
+					 data & MDIO_AN_10GBT_STAT_LP10G);
+		}
+	}
+
+	if (netif_running(netdev) && netif_carrier_ok(netdev)) {
+		u16 speed = rtl8152_get_speed(tp);
+
+		if (speed & _100bps)
+			cmd->base.speed = SPEED_100;
+		else if (speed & _10bps)
+			cmd->base.speed = SPEED_10;
+		else if (tp->mii.supports_gmii && (speed & _1000bps))
+			cmd->base.speed = SPEED_1000;
+		else if (tp->support_2500full && (speed & _2500bps))
+			cmd->base.speed = SPEED_2500;
+		else if (tp->support_5000full && (speed & _5000bps))
+			cmd->base.speed = SPEED_5000;
+		else if (tp->support_10gfull && (speed & _10000bps))
+			cmd->base.speed = SPEED_10000;
+
+		cmd->base.duplex = (speed & FULL_DUP) ? DUPLEX_FULL :
+							DUPLEX_HALF;
+	} else {
+		cmd->base.speed = SPEED_UNKNOWN;
+		cmd->base.duplex = DUPLEX_UNKNOWN;
+	}
+
+out3:
+	mutex_unlock(&tp->control);
+
+out2:
+	usb_autopm_put_interface(tp->intf);
+out1:
+	return (ret < 0) ? ret : 0;
+}
+
+static int rtl8152_set_link_ksettings(struct net_device *dev,
+				      const struct ethtool_link_ksettings *cmd)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	u32 advertising = 0;
+	int ret;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	if (test_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+		     cmd->link_modes.advertising))
+		advertising |= RTL_ADVERTISED_10_HALF;
+
+	if (test_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+		     cmd->link_modes.advertising))
+		advertising |= RTL_ADVERTISED_10_FULL;
+
+	if (test_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+		     cmd->link_modes.advertising))
+		advertising |= RTL_ADVERTISED_100_HALF;
+
+	if (test_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+		     cmd->link_modes.advertising))
+		advertising |= RTL_ADVERTISED_100_FULL;
+
+	if (test_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+		     cmd->link_modes.advertising))
+		advertising |= RTL_ADVERTISED_1000_HALF;
+
+	if (test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+		     cmd->link_modes.advertising))
+		advertising |= RTL_ADVERTISED_1000_FULL;
+
+	if (test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+		     cmd->link_modes.advertising))
+		advertising |= RTL_ADVERTISED_2500_FULL;
+
+	if (test_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+		     cmd->link_modes.advertising))
+		advertising |= RTL_ADVERTISED_5000_FULL;
+
+	if (test_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+		     cmd->link_modes.advertising))
+		advertising |= RTL_ADVERTISED_10GT_FULL;
+
+	mutex_lock(&tp->control);
+
+	ret = rtl8152_set_speed(tp, cmd->base.autoneg, cmd->base.speed,
+				cmd->base.duplex, advertising);
+	if (!ret) {
+		tp->autoneg = cmd->base.autoneg;
+		tp->speed = cmd->base.speed;
+		tp->duplex = cmd->base.duplex;
+		tp->advertising = advertising;
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0) */
+
+static const char rtl8152_gstrings[][ETH_GSTRING_LEN] = {
+	"tx_packets",
+	"rx_packets",
+	"tx_errors",
+	"rx_errors",
+	"rx_missed",
+	"align_errors",
+	"tx_single_collisions",
+	"tx_multi_collisions",
+	"rx_unicast",
+	"rx_broadcast",
+	"rx_multicast",
+	"tx_aborted",
+	"tx_underrun",
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+static int rtl8152_get_sset_count(struct net_device *dev)
+{
+	return ARRAY_SIZE(rtl8152_gstrings);
+}
+#else
+static int rtl8152_get_sset_count(struct net_device *dev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return ARRAY_SIZE(rtl8152_gstrings);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+#endif
+
+static void rtl8152_get_ethtool_stats(struct net_device *dev,
+				      struct ethtool_stats *stats, u64 *data)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	struct tally_counter tally;
+	int ret;
+
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
+
+	if (mutex_lock_interruptible(&tp->control) < 0) {
+		usb_autopm_put_interface(tp->intf);
+		return;
+	}
+
+	ret = generic_ocp_read(tp, PLA_TALLYCNT, sizeof(tally), &tally,
+			       MCU_TYPE_PLA);
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+	if (ret < 0)
+		return;
+
+	data[0] = le64_to_cpu(tally.tx_packets);
+	data[1] = le64_to_cpu(tally.rx_packets);
+	data[2] = le64_to_cpu(tally.tx_errors);
+	data[3] = le32_to_cpu(tally.rx_errors);
+	data[4] = le16_to_cpu(tally.rx_missed);
+	data[5] = le16_to_cpu(tally.align_errors);
+	data[6] = le32_to_cpu(tally.tx_one_collision);
+	data[7] = le32_to_cpu(tally.tx_multi_collision);
+	data[8] = le64_to_cpu(tally.rx_unicast);
+	data[9] = le64_to_cpu(tally.rx_broadcast);
+	data[10] = le32_to_cpu(tally.rx_multicast);
+	data[11] = le16_to_cpu(tally.tx_aborted);
+	data[12] = le16_to_cpu(tally.tx_underrun);
+}
+
+static void rtl8152_get_strings(struct net_device *dev, u32 stringset, u8 *data)
+{
+	switch (stringset) {
+	case ETH_SS_STATS:
+		memcpy(data, rtl8152_gstrings, sizeof(rtl8152_gstrings));
+		break;
+	}
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,9,0)
+static int r8152_get_eee(struct r8152 *tp, struct ethtool_keee *eee)
+{
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(common);
+	int ret;
+	u16 val;
+
+	ret = r8152_mmd_read(tp, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE, &val);
+	if (ret < 0)
+		goto out;
+	mii_eee_cap1_mod_linkmode_t(eee->supported, val);
+
+	ret = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, &val);
+	if (ret < 0)
+		goto out;
+	mii_eee_cap1_mod_linkmode_t(eee->advertised, val);
+
+	ret = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE, &val);
+	if (ret < 0)
+		goto out;
+	mii_eee_cap1_mod_linkmode_t(eee->lp_advertised, val);
+
+	eee->eee_enabled = tp->eee_en;
+
+	linkmode_and(common, eee->advertised, eee->lp_advertised);
+	eee->eee_active = phy_check_valid(tp->speed, tp->duplex, common);
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static int r8152_set_eee(struct r8152 *tp, struct ethtool_keee *eee)
+{
+	u16 val = linkmode_to_mii_eee_cap1_t(eee->advertised);
+
+	tp->eee_en = eee->eee_enabled;
+	tp->eee_adv = val;
+
+	return rtl_eee_enable(tp, tp->eee_en);
+}
+
+static int r8153_get_eee(struct r8152 *tp, struct ethtool_keee *eee)
+{
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(common);
+	u16 val;
+	int ret;
+
+	ret = ocp_reg_read(tp, OCP_EEE_ABLE, &val);
+	if (ret < 0)
+		goto out;
+	mii_eee_cap1_mod_linkmode_t(eee->supported, val);
+
+	ret = ocp_reg_read(tp, OCP_EEE_ADV, &val);
+	if (ret < 0)
+		goto out;
+	mii_eee_cap1_mod_linkmode_t(eee->advertised, val);
+
+	ret = ocp_reg_read(tp, OCP_EEE_LPABLE, &val);
+	if (ret < 0)
+		goto out;
+	mii_eee_cap1_mod_linkmode_t(eee->lp_advertised, val);
+
+	eee->eee_enabled = tp->eee_en;
+
+	linkmode_and(common, eee->advertised, eee->lp_advertised);
+	eee->eee_active = phy_check_valid(tp->speed, tp->duplex, common);
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static int r8156_get_eee(struct r8152 *tp, struct ethtool_keee *eee)
+{
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(common);
+	u16 val;
+	int ret;
+
+	ret = r8153_get_eee(tp, eee);
+	if (ret < 0)
+		goto out;
+
+	ret = ocp_reg_read(tp, OCP_EEE_ABLE2, &val);
+	if (ret < 0)
+		goto out;
+	mii_eee_cap2_mod_linkmode_sup_t(eee->supported, val);
+
+	ret = ocp_reg_read(tp, OCP_EEE_ADV2, &val);
+	if (ret < 0)
+		goto out;
+	mii_eee_cap2_mod_linkmode_adv_t(eee->advertised, val);
+
+	ret = ocp_reg_read(tp, OCP_EEE_LPABLE2, &val);
+	if (ret < 0)
+		goto out;
+	mii_eee_cap2_mod_linkmode_adv_t(eee->lp_advertised, val);
+
+	linkmode_and(common, eee->advertised, eee->lp_advertised);
+	eee->eee_active = phy_check_valid(tp->speed, tp->duplex, common);
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static int r8156_set_eee(struct r8152 *tp, struct ethtool_keee *eee)
+{
+	/* 2.5G EEE, 5G EEE */
+	tp->eee_adv2 = linkmode_to_mii_eee_cap2_t(eee->advertised);
+
+	return r8152_set_eee(tp, eee);
+}
+#else
+static int r8152_get_eee(struct r8152 *tp, struct ethtool_eee *eee)
+{
+	u32 lp, adv, supported = 0;
+	int ret;
+	u16 val;
+
+	ret = r8152_mmd_read(tp, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE, &val);
+	if (ret < 0)
+		goto out;
+	supported = mmd_eee_cap_to_ethtool_sup_t(val);
+
+	ret = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, &val);
+	if (ret < 0)
+		goto out;
+	adv = mmd_eee_adv_to_ethtool_adv_t(val);
+
+	ret = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE, &val);
+	if (ret < 0)
+		goto out;
+	lp = mmd_eee_adv_to_ethtool_adv_t(val);
+
+	eee->eee_enabled = tp->eee_en;
+	eee->eee_active = !!(supported & adv & lp);
+	eee->supported = supported;
+	eee->advertised = mmd_eee_adv_to_ethtool_adv_t(tp->eee_adv);
+	eee->lp_advertised = lp;
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static int r8152_set_eee(struct r8152 *tp, struct ethtool_eee *eee)
+{
+	u16 val = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);
+
+	tp->eee_en = eee->eee_enabled;
+	tp->eee_adv = val;
+
+	return rtl_eee_enable(tp, tp->eee_en);
+}
+
+static int r8153_get_eee(struct r8152 *tp, struct ethtool_eee *eee)
+{
+	u32 lp, adv, supported = 0;
+	u16 val;
+	int ret;
+
+	ret = ocp_reg_read(tp, OCP_EEE_ABLE, &val);
+	if (ret < 0)
+		goto out;
+	supported = mmd_eee_cap_to_ethtool_sup_t(val);
+
+	ret = ocp_reg_read(tp, OCP_EEE_ADV, &val);
+	if (ret < 0)
+		goto out;
+	adv = mmd_eee_adv_to_ethtool_adv_t(val);
+
+	ret = ocp_reg_read(tp, OCP_EEE_LPABLE, &val);
+	if (ret < 0)
+		goto out;
+	lp = mmd_eee_adv_to_ethtool_adv_t(val);
+
+	eee->eee_enabled = tp->eee_en;
+	eee->eee_active = !!(supported & adv & lp);
+	eee->supported = supported;
+	eee->advertised = mmd_eee_adv_to_ethtool_adv_t(tp->eee_adv);
+	eee->lp_advertised = lp;
+
+out:
+	return (ret < 0) ? ret : 0;
+}
+
+static int r8156_get_eee(struct r8152 *tp, struct ethtool_keee *eee)
+{
+	return r8153_get_eee(tp, eee);
+}
+
+static int r8156_set_eee(struct r8152 *tp, struct ethtool_keee *eee)
+{
+	return r8152_set_eee(tp, eee);
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,9,0) */
+
+static int
+rtl_ethtool_get_eee(struct net_device *net, struct ethtool_keee *edata)
+{
+	struct r8152 *tp = netdev_priv(net);
+	int ret;
+
+	if (!tp->rtl_ops.eee_get) {
+		ret = -EOPNOTSUPP;
+		goto out;
+	}
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	mutex_lock(&tp->control);
+
+	ret = tp->rtl_ops.eee_get(tp, edata);
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+
+static int
+rtl_ethtool_set_eee(struct net_device *net, struct ethtool_keee *edata)
+{
+	struct r8152 *tp = netdev_priv(net);
+	int ret;
+
+	if (!tp->rtl_ops.eee_set) {
+		ret = -EOPNOTSUPP;
+		goto out;
+	}
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	mutex_lock(&tp->control);
+
+	ret = tp->rtl_ops.eee_set(tp, edata);
+	if (!ret) {
+		ret = rtl_nway_restart(tp);
+		if (test_and_clear_bit(DISABLE_EEE_BOTTOM, &tp->flags))
+			ret = rtl_disable_eee_bottom(tp);
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+
+static int rtl8152_nway_reset(struct net_device *dev)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	int ret;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	mutex_lock(&tp->control);
+
+	ret = rtl_nway_restart(tp);
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+
+static int rtl8152_get_coalesce(struct net_device *netdev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+				struct ethtool_coalesce *coalesce)
+#else
+				struct ethtool_coalesce *coalesce,
+				struct kernel_ethtool_coalesce *kernel_coal,
+				struct netlink_ext_ack *extack)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+		return -EOPNOTSUPP;
+	default:
+		break;
+	}
+
+	coalesce->rx_coalesce_usecs = tp->coalesce / 1000;
+
+	return 0;
+}
+
+static int rtl8152_set_coalesce(struct net_device *netdev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+				struct ethtool_coalesce *coalesce)
+#else
+				struct ethtool_coalesce *coalesce,
+				struct kernel_ethtool_coalesce *kernel_coal,
+				struct netlink_ext_ack *extack)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	u32 rx_coalesce_nsecs;
+	int ret;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+	case RTL_TEST_01: /* fix me */
+		return -EOPNOTSUPP;
+	default:
+		break;
+	}
+
+	rx_coalesce_nsecs = coalesce->rx_coalesce_usecs * 1000;
+
+	if (rx_coalesce_nsecs > COALESCE_SLOW)
+		return -EINVAL;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&tp->control);
+
+	if (tp->coalesce != rx_coalesce_nsecs) {
+		tp->coalesce = rx_coalesce_nsecs;
+
+		if (netif_running(netdev) && netif_carrier_ok(netdev)) {
+			netif_stop_queue(netdev);
+			napi_disable(&tp->napi);
+			tp->rtl_ops.disable(tp);
+			tp->rtl_ops.enable(tp);
+			rtl_start_rx(tp);
+			napi_enable(&tp->napi);
+			rtl8152_set_rx_mode(netdev);
+			netif_wake_queue(netdev);
+		}
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+	return ret;
+}
+
+static int rtl8152_ethtool_begin(struct net_device *netdev)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
+static int rtl8152_get_tunable(struct net_device *netdev,
+			       const struct ethtool_tunable *tunable, void *d)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+	switch (tunable->id) {
+	case ETHTOOL_RX_COPYBREAK:
+		*(u32 *)d = tp->rx_copybreak;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int rtl8152_set_tunable(struct net_device *netdev,
+			       const struct ethtool_tunable *tunable,
+			       const void *d)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	u32 val;
+
+	switch (tunable->id) {
+	case ETHTOOL_RX_COPYBREAK:
+		val = *(u32 *)d;
+		if (val < ETH_ZLEN) {
+			netif_err(tp, rx_err, netdev,
+				  "Invalid rx copy break value\n");
+			return -EINVAL;
+		}
+
+		if (tp->rx_copybreak != val) {
+			if (netdev->flags & IFF_UP) {
+				mutex_lock(&tp->control);
+				napi_disable(&tp->napi);
+				tp->rx_copybreak = val;
+				napi_enable(&tp->napi);
+				mutex_unlock(&tp->control);
+			} else {
+				tp->rx_copybreak = val;
+			}
+		}
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0) */
+
+static void rtl8152_get_ringparam(struct net_device *netdev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,17,0)
+				  struct ethtool_ringparam *ring)
+#else
+				  struct ethtool_ringparam *ring,
+				  struct kernel_ethtool_ringparam *kernel_ring,
+				  struct netlink_ext_ack *extack)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+	ring->rx_max_pending = RTL8152_RX_MAX_PENDING;
+	ring->rx_pending = tp->rx_pending;
+}
+
+static int rtl8152_set_ringparam(struct net_device *netdev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,17,0)
+				 struct ethtool_ringparam *ring)
+#else
+				 struct ethtool_ringparam *ring,
+				 struct kernel_ethtool_ringparam *kernel_ring,
+				 struct netlink_ext_ack *extack)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+	if (ring->rx_pending < RTL8152_MAX_RX)
+		return -EINVAL;
+
+	if (tp->rx_pending != ring->rx_pending) {
+		if (netdev->flags & IFF_UP) {
+			mutex_lock(&tp->control);
+			napi_disable(&tp->napi);
+			tp->rx_pending = ring->rx_pending;
+			napi_enable(&tp->napi);
+			mutex_unlock(&tp->control);
+		} else {
+			tp->rx_pending = ring->rx_pending;
+		}
+	}
+
+	return 0;
+}
+
+static void rtl8152_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	int bmcr, lcladv, rmtadv;
+	u8 cap;
+
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
+
+	mutex_lock(&tp->control);
+
+	bmcr = r8152_mdio_read(tp, MII_BMCR);
+	lcladv = r8152_mdio_read(tp, MII_ADVERTISE);
+	rmtadv = r8152_mdio_read(tp, MII_LPA);
+
+	mutex_unlock(&tp->control);
+
+	if (bmcr < 0 || lcladv < 0 || rmtadv < 0)
+		return;
+
+	usb_autopm_put_interface(tp->intf);
+
+	if (!(bmcr & BMCR_ANENABLE)) {
+		pause->autoneg = 0;
+		pause->rx_pause = 0;
+		pause->tx_pause = 0;
+		return;
+	}
+
+	pause->autoneg = 1;
+
+	cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);
+
+	if (cap & FLOW_CTRL_RX)
+		pause->rx_pause = 1;
+
+	if (cap & FLOW_CTRL_TX)
+		pause->tx_pause = 1;
+}
+
+static int rtl8152_set_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	u16 old, new1;
+	u8 cap = 0;
+	int ret;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&tp->control);
+
+	ret = r8152_mdio_read(tp, MII_BMCR);
+	if (ret < 0)
+		goto out;
+
+	if (pause->autoneg && !(ret & BMCR_ANENABLE)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (pause->rx_pause)
+		cap |= FLOW_CTRL_RX;
+
+	if (pause->tx_pause)
+		cap |= FLOW_CTRL_TX;
+
+	ret = r8152_mdio_read(tp, MII_ADVERTISE);
+	if (ret < 0)
+		goto out;
+
+	old = ret;
+	new1 = (old & ~(ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM)) | mii_advertise_flowctrl(cap);
+	if (old != new1)
+		ret = r8152_mdio_write(tp, MII_ADVERTISE, new1);
+
+	if (new1 & (ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM))
+		tp->ups_info.flow_control = true;
+	else
+		tp->ups_info.flow_control = false;
+
+out:
+	mutex_unlock(&tp->control);
+	usb_autopm_put_interface(tp->intf);
+
+	return (ret < 0) ? ret : 0;
+}
+
+static const struct ethtool_ops ops = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0)
+	.supported_coalesce_params = ETHTOOL_COALESCE_USECS,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0) */
+	.get_drvinfo = rtl8152_get_drvinfo,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0)
+	.get_settings = rtl8152_get_settings,
+	.set_settings = rtl8152_set_settings,
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0) */
+	.get_link = ethtool_op_get_link,
+	.nway_reset = rtl8152_nway_reset,
+	.get_msglevel = rtl8152_get_msglevel,
+	.set_msglevel = rtl8152_set_msglevel,
+	.get_wol = rtl8152_get_wol,
+	.set_wol = rtl8152_set_wol,
+	.get_strings = rtl8152_get_strings,
+	.get_sset_count = rtl8152_get_sset_count,
+	.get_ethtool_stats = rtl8152_get_ethtool_stats,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+	.get_tx_csum = ethtool_op_get_tx_csum,
+	.set_tx_csum = ethtool_op_set_tx_csum,
+	.get_sg = ethtool_op_get_sg,
+	.set_sg = ethtool_op_set_sg,
+#ifdef NETIF_F_TSO
+	.get_tso = ethtool_op_get_tso,
+	.set_tso = ethtool_op_set_tso,
+#endif
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0) */
+	.get_coalesce = rtl8152_get_coalesce,
+	.set_coalesce = rtl8152_set_coalesce,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+	.get_eee = rtl_ethtool_get_eee,
+	.set_eee = rtl_ethtool_set_eee,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+	.get_link_ksettings = rtl8152_get_link_ksettings,
+	.set_link_ksettings = rtl8152_set_link_ksettings,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0) */
+	.begin = rtl8152_ethtool_begin,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
+	.get_tunable = rtl8152_get_tunable,
+	.set_tunable = rtl8152_set_tunable,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0) */
+	.get_ringparam = rtl8152_get_ringparam,
+	.set_ringparam = rtl8152_set_ringparam,
+	.get_pauseparam = rtl8152_get_pauseparam,
+	.set_pauseparam = rtl8152_set_pauseparam,
+};
+
+static int rtltool_ioctl(struct r8152 *tp, struct ifreq *ifr)
+{
+	struct net_device *netdev = tp->netdev;
+	struct rtltool_cmd my_cmd, *myptr;
+	struct usb_device_info *uinfo;
+	struct usb_device *udev;
+	__le32	ocp_data;
+	void	*buffer;
+	int	ret;
+
+	myptr = (struct rtltool_cmd *)ifr->ifr_data;
+	if (copy_from_user(&my_cmd, myptr, sizeof(my_cmd)))
+		return -EFAULT;
+
+	ret = 0;
+
+	switch (my_cmd.cmd) {
+	case RTLTOOL_PLA_OCP_READ_DWORD:
+		pla_ocp_read(tp, (u16)my_cmd.offset, sizeof(ocp_data),
+			     &ocp_data);
+		my_cmd.data = __le32_to_cpu(ocp_data);
+
+		if (copy_to_user(myptr, &my_cmd, sizeof(my_cmd))) {
+			ret = -EFAULT;
+			break;
+		}
+		break;
+
+	case RTLTOOL_PLA_OCP_WRITE_DWORD:
+		if (!tp->rtk_enable_diag && net_ratelimit())
+			netif_warn(tp, drv, netdev,
+				   "rtk diag isn't enable\n");
+
+		ocp_data = __cpu_to_le32(my_cmd.data);
+		pla_ocp_write(tp, (u16)my_cmd.offset, (u16)my_cmd.byteen,
+			      sizeof(ocp_data), &ocp_data);
+		break;
+
+	case RTLTOOL_USB_OCP_READ_DWORD:
+		usb_ocp_read(tp, (u16)my_cmd.offset, sizeof(ocp_data),
+			     &ocp_data);
+		my_cmd.data = __le32_to_cpu(ocp_data);
+
+		if (copy_to_user(myptr, &my_cmd, sizeof(my_cmd))) {
+			ret = -EFAULT;
+			break;
+		}
+		break;
+
+
+	case RTLTOOL_USB_OCP_WRITE_DWORD:
+		if (!tp->rtk_enable_diag && net_ratelimit())
+			netif_warn(tp, drv, netdev,
+				   "rtk diag isn't enable\n");
+
+		ocp_data = __cpu_to_le32(my_cmd.data);
+		usb_ocp_write(tp, (u16)my_cmd.offset, (u16)my_cmd.byteen,
+			      sizeof(ocp_data), &ocp_data);
+		break;
+
+	case RTLTOOL_PLA_OCP_READ:
+		buffer = kmalloc(my_cmd.data, GFP_KERNEL);
+		if (!buffer) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		pla_ocp_read(tp, (u16)my_cmd.offset, my_cmd.data, buffer);
+
+		if (copy_to_user(my_cmd.buf, buffer, my_cmd.data))
+			ret = -EFAULT;
+
+		kfree(buffer);
+		break;
+
+	case RTLTOOL_PLA_OCP_WRITE:
+		if (!tp->rtk_enable_diag && net_ratelimit())
+			netif_warn(tp, drv, netdev,
+				   "rtk diag isn't enable\n");
+
+		buffer = kmalloc(my_cmd.data, GFP_KERNEL);
+		if (!buffer) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		if (copy_from_user(buffer, my_cmd.buf, my_cmd.data)) {
+			ret = -EFAULT;
+			kfree(buffer);
+			break;
+		}
+
+		pla_ocp_write(tp, (u16)my_cmd.offset, (u16)my_cmd.byteen,
+			      my_cmd.data, buffer);
+		kfree(buffer);
+		break;
+
+	case RTLTOOL_USB_OCP_READ:
+		buffer = kmalloc(my_cmd.data, GFP_KERNEL);
+		if (!buffer) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		usb_ocp_read(tp, (u16)my_cmd.offset, my_cmd.data, buffer);
+
+		if (copy_to_user(my_cmd.buf, buffer, my_cmd.data))
+			ret = -EFAULT;
+
+		kfree(buffer);
+		break;
+
+	case RTLTOOL_USB_OCP_WRITE:
+		if (!tp->rtk_enable_diag && net_ratelimit())
+			netif_warn(tp, drv, netdev,
+				   "rtk diag isn't enable\n");
+
+		buffer = kmalloc(my_cmd.data, GFP_KERNEL);
+		if (!buffer) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		if (copy_from_user(buffer, my_cmd.buf, my_cmd.data)) {
+			ret = -EFAULT;
+			kfree(buffer);
+			break;
+		}
+
+		usb_ocp_write(tp, (u16)my_cmd.offset, (u16)my_cmd.byteen,
+			      my_cmd.data, buffer);
+		kfree(buffer);
+		break;
+
+	case RTLTOOL_USB_INFO:
+		uinfo = (struct usb_device_info *)&my_cmd.nic_info;
+		udev = tp->udev;
+		uinfo->idVendor = __le16_to_cpu(udev->descriptor.idVendor);
+		uinfo->idProduct = __le16_to_cpu(udev->descriptor.idProduct);
+		uinfo->bcdDevice = __le16_to_cpu(udev->descriptor.bcdDevice);
+		strscpy(uinfo->devpath, udev->devpath, sizeof(udev->devpath));
+		pla_ocp_read(tp, PLA_IDR, sizeof(uinfo->dev_addr),
+			     uinfo->dev_addr);
+
+		if (copy_to_user(myptr, &my_cmd, sizeof(my_cmd)))
+			ret = -EFAULT;
+
+		break;
+
+	case RTL_ENABLE_USB_DIAG:
+		ret = usb_autopm_get_interface(tp->intf);
+		if (ret < 0)
+			break;
+
+		mutex_lock(&tp->control);
+		tp->rtk_enable_diag++;
+		netif_info(tp, drv, netdev, "enable rtk diag %d\n",
+			   tp->rtk_enable_diag);
+		break;
+
+	case RTL_DISABLE_USB_DIAG:
+		if (!tp->rtk_enable_diag) {
+			netif_err(tp, drv, netdev,
+				  "Invalid using rtk diag\n");
+			ret = -EPERM;
+			break;
+		}
+
+		rtk_disable_diag(tp);
+		break;
+
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0)
+static int rtl8152_siocdevprivate(struct net_device *netdev, struct ifreq *rq,
+				  void __user *data, int cmd)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	switch (cmd) {
+	case SIOCDEVPRIVATE:
+		if (!capable(CAP_NET_ADMIN)) {
+			ret = -EPERM;
+			break;
+		}
+		ret = rtltool_ioctl(tp, rq);
+		break;
+
+	default:
+		ret = -EOPNOTSUPP;
+	}
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0) */
+
+static int rtl8152_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	struct mii_ioctl_data *data = if_mii(rq);
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	switch (cmd) {
+	case SIOCGMIIPHY:
+		data->phy_id = R8152_PHY_ID; /* Internal PHY */
+		break;
+
+	case SIOCGMIIREG:
+		if (unlikely(tp->rtk_enable_diag)) {
+			ret = -EBUSY;
+			break;
+		}
+
+		mutex_lock(&tp->control);
+		data->val_out = r8152_mdio_read(tp, data->reg_num);
+		mutex_unlock(&tp->control);
+		break;
+
+	case SIOCSMIIREG:
+		if (!capable(CAP_NET_ADMIN)) {
+			ret = -EPERM;
+			break;
+		}
+
+		if (unlikely(tp->rtk_enable_diag)) {
+			ret = -EBUSY;
+			break;
+		}
+
+		mutex_lock(&tp->control);
+		ret = r8152_mdio_write(tp, data->reg_num, data->val_in);
+		if (ret > 0)
+			ret = 0;
+		mutex_unlock(&tp->control);
+		break;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+	case SIOCDEVPRIVATE:
+		if (!capable(CAP_NET_ADMIN)) {
+			ret = -EPERM;
+			break;
+		}
+		ret = rtltool_ioctl(tp, rq);
+		break;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
+
+	default:
+		ret = -EOPNOTSUPP;
+	}
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+
+static int rtl8152_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	int ret;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+	u32 max_mtu;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0) */
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+		return eth_change_mtu(dev, new_mtu);
+#else
+		dev->mtu = new_mtu;
+		return 0;
+#endif
+	default:
+		break;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+	switch (tp->version) {
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_VER_14:
+		max_mtu = size_to_mtu(9 * 1024);
+		break;
+	case RTL_VER_10:
+	case RTL_VER_11:
+		max_mtu = size_to_mtu(15 * 1024);
+		break;
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_15:
+	case RTL_VER_16:
+	case RTL_VER_17:
+		max_mtu = size_to_mtu(16 * 1024);
+		break;
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+	default:
+		max_mtu = ETH_DATA_LEN;
+		break;
+	}
+
+	if (new_mtu < 68 || new_mtu > max_mtu)
+		return -EINVAL;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0) */
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&tp->control);
+
+	dev->mtu = new_mtu;
+
+	if (netif_running(dev)) {
+		if (tp->rtl_ops.change_mtu)
+			tp->rtl_ops.change_mtu(tp);
+
+		if (netif_carrier_ok(dev)) {
+			netif_stop_queue(dev);
+			napi_disable(&tp->napi);
+			tasklet_disable(&tp->tx_tl);
+			tp->rtl_ops.disable(tp);
+			tp->rtl_ops.enable(tp);
+			rtl_start_rx(tp);
+			tasklet_enable(&tp->tx_tl);
+			napi_enable(&tp->napi);
+			rtl8152_set_rx_mode(dev);
+			netif_wake_queue(dev);
+		}
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+static const struct net_device_ops rtl8152_netdev_ops = {
+	.ndo_open		= rtl8152_open,
+	.ndo_stop		= rtl8152_close,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+	.ndo_do_ioctl		= rtl8152_ioctl,
+#else
+	.ndo_siocdevprivate	= rtl8152_siocdevprivate,
+	.ndo_eth_ioctl		= rtl8152_ioctl,
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
+	.ndo_start_xmit		= rtl8152_start_xmit,
+	.ndo_tx_timeout		= rtl8152_tx_timeout,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+	.ndo_vlan_rx_register	= rtl8152_vlan_rx_register,
+#else
+	.ndo_set_features	= rtl8152_set_features,
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) */
+	.ndo_set_rx_mode	= rtl8152_set_rx_mode,
+	.ndo_set_mac_address	= rtl8152_set_mac_address,
+	.ndo_change_mtu		= rtl8152_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,4)
+	.ndo_features_check	= rtl8152_features_check,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,4) */
+};
+#endif
+
+static void rtl8152_unload(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	r8152_power_cut_en(tp, false);
+}
+
+static void rtl8153_unload(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	r8153_power_cut_en(tp, false);
+}
+
+static void rtl8153b_unload(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (!r8153b_power_cut_en(tp, false))
+		rtl_set_dbg_info_state(tp, DGB_DRV_STATE_UNLOAD);
+}
+
+static void rtl8157_unload(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	r8153_power_cut_en(tp, false);
+
+	/* Disable Interrupt Mitigation */
+	if (ocp_byte_clr_bits(tp, MCU_TYPE_USB, 0xcf04,
+			      BIT(0) | BIT(1) | BIT(2) | BIT(7)) < 0)
+		return;
+}
+
+static int r8152_desc_init(struct r8152 *tp)
+{
+	tp->rx_desc.size = sizeof(struct rx_desc);
+	tp->rx_desc.align = 8;
+	tp->rx_desc.vlan_tag = r8152_rx_vlan_tag;
+	tp->rx_desc.csum = r8152_rx_csum;
+	tp->rx_desc.len = r8152_rx_len;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+	tp->vlan_put_tag = r8152_vlan_put_tag;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) */
+
+	tp->tx_desc.size = sizeof(struct tx_desc);
+	tp->tx_desc.align = 4;
+	tp->tx_desc.vlan_tag = r8152_tx_vlan_tag;
+	tp->tx_desc.csum = r8152_tx_csum;
+	tp->tx_desc.len = r8152_tx_len;
+
+	return 0;
+}
+
+static int r8157_desc_init(struct r8152 *tp)
+{
+	tp->rx_desc.size = sizeof(struct rx_desc_v2);
+	tp->rx_desc.align = 16;
+	tp->rx_desc.vlan_tag = r8157_rx_vlan_tag;
+	tp->rx_desc.csum = r8157_rx_csum;
+	tp->rx_desc.len = r8157_rx_len;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+	tp->vlan_put_tag = r8157_vlan_put_tag;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) */
+
+	tp->tx_desc.size = sizeof(struct tx_desc_v2);
+	tp->tx_desc.align = 16;
+	tp->tx_desc.vlan_tag = r8152_tx_vlan_tag;
+	tp->tx_desc.csum = r8157_tx_csum;
+	tp->tx_desc.len = r8157_tx_len;
+
+	return 0;
+}
+
+static void rtl8153c_unload(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	r8153_power_cut_en(tp, false);
+	rtl_set_dbg_info_state(tp, DGB_DRV_STATE_UNLOAD);
+}
+
+static int rtl_ops_init(struct r8152 *tp)
+{
+	struct rtl_ops *ops = &tp->rtl_ops;
+	int ret = 0;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+		ops->init		= r8152b_init;
+		ops->enable		= rtl8152_enable;
+		ops->disable		= rtl8152_disable;
+		ops->up			= rtl8152_up;
+		ops->down		= rtl8152_down;
+		ops->unload		= rtl8152_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8152_get_eee;
+		ops->eee_set		= r8152_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8152_in_nway;
+		ops->hw_phy_cfg		= r8152b_hw_phy_cfg;
+		ops->autosuspend_en	= rtl_runtime_suspend_enable;
+		ops->phy_read		= r8152_phy_read;
+		ops->phy_write		= r8152_phy_write;
+		tp->rx_buf_sz		= 16 * 1024;
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_100TX;
+		r8152_desc_init(tp);
+		break;
+
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+		ops->init		= r8153_init;
+		ops->enable		= rtl8153_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8153_up;
+		ops->down		= rtl8153_down;
+		ops->unload		= rtl8153_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8153_get_eee;
+		ops->eee_set		= r8152_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8153_hw_phy_cfg;
+		ops->autosuspend_en	= rtl8153_runtime_enable;
+		ops->change_mtu		= rtl8153_change_mtu;
+		ops->phy_read		= r8152_phy_read;
+		ops->phy_write		= r8152_phy_write;
+		if (tp->udev->speed < USB_SPEED_SUPER)
+			tp->rx_buf_sz	= 16 * 1024;
+		else
+			tp->rx_buf_sz	= 32 * 1024;
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
+		r8152_desc_init(tp);
+		break;
+
+	case RTL_VER_08:
+	case RTL_VER_09:
+		ops->init		= r8153b_init;
+		ops->enable		= rtl8153_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8153b_up;
+		ops->down		= rtl8153b_down;
+		ops->unload		= rtl8153b_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8153_get_eee;
+		ops->eee_set		= r8152_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8153b_hw_phy_cfg;
+		ops->autosuspend_en	= rtl8153b_runtime_enable;
+		ops->change_mtu		= rtl8153_change_mtu;
+		ops->phy_read		= r8152_phy_read;
+		ops->phy_write		= r8152_phy_write;
+		tp->rx_buf_sz		= 32 * 1024;
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
+		r8152_desc_init(tp);
+		break;
+
+	case RTL_TEST_01:
+		ops->init		= r8156_init;
+		ops->enable		= rtl8156_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8156_up;
+		ops->down		= rtl8156_down;
+		ops->unload		= rtl8153_unload;
+//#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+//		ops->eee_get		= r8156_get_eee;
+//		ops->eee_set		= r8156_set_eee;
+//#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8156_hw_phy_cfg_test;
+		ops->autosuspend_en	= rtl8156_runtime_enable;
+		ops->phy_read		= r8152_phy_read;
+		ops->phy_write		= r8152_phy_write;
+		tp->rx_buf_sz		= 48 * 1024;
+		tp->support_2500full	= 1;
+		r8152_desc_init(tp);
+		break;
+
+	case RTL_VER_11:
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
+		tp->eee_adv2		= MDIO_EEE_2_5GT;
+		fallthrough;
+	case RTL_VER_10:
+		ops->init		= r8156_init;
+		ops->enable		= rtl8156_enable;
+		ops->disable		= rtl8156_disable;
+		ops->up			= rtl8156_up;
+		ops->down		= rtl8156_down;
+		ops->unload		= rtl8153_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8156_get_eee;
+		ops->eee_set		= r8156_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8156_hw_phy_cfg;
+		ops->autosuspend_en	= rtl8156_runtime_enable;
+		ops->change_mtu		= rtl8156_change_mtu;
+		ops->phy_read		= r8152_phy_read;
+		ops->phy_write		= r8152_phy_write;
+		tp->rx_buf_sz		= 48 * 1024;
+		tp->support_2500full	= 1;
+		r8152_desc_init(tp);
+		break;
+
+	case RTL_VER_12:
+	case RTL_VER_13:
+		tp->support_2500full	= 1;
+		fallthrough;
+	case RTL_VER_15:
+		ops->init		= r8156b_init;
+		ops->enable		= rtl8156b_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8156_up;
+		ops->down		= rtl8156_down;
+		ops->unload		= rtl8153_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8156_get_eee;
+		ops->eee_set		= r8156_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8156b_hw_phy_cfg;
+		ops->autosuspend_en	= rtl8156_runtime_enable;
+		ops->change_mtu		= rtl8156_change_mtu;
+		ops->phy_read		= r8152_phy_read;
+		ops->phy_write		= r8152_phy_write;
+		tp->rx_buf_sz		= 48 * 1024;
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
+		tp->eee_adv2		= MDIO_EEE_2_5GT;
+		r8152_desc_init(tp);
+		break;
+
+	case RTL_VER_14:
+		ops->init		= r8153c_init;
+		ops->enable		= rtl8153_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8153c_up;
+		ops->down		= rtl8153b_down;
+		ops->unload		= rtl8153c_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8153_get_eee;
+		ops->eee_set		= r8152_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8153c_hw_phy_cfg;
+		ops->autosuspend_en	= rtl8153c_runtime_enable;
+		ops->change_mtu		= rtl8153c_change_mtu;
+		ops->phy_read		= r8152_phy_read;
+		ops->phy_write		= r8152_phy_write;
+		tp->rx_buf_sz		= 32 * 1024;
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
+		r8152_desc_init(tp);
+		break;
+
+	case RTL_VER_16:
+		ops->init		= r8157_init;
+		ops->enable		= rtl8157_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8157_up;
+		ops->down		= rtl8157_down;
+		ops->unload		= rtl8157_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8156_get_eee;
+		ops->eee_set		= r8156_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8157_hw_phy_cfg;
+		ops->autosuspend_en	= rtl8157_runtime_enable;
+		ops->change_mtu		= rtl8157_change_mtu;
+		ops->phy_read		= r8157_phy_read;
+		ops->phy_write		= r8157_phy_write;
+		tp->rx_buf_sz		= 32 * 1024;
+		tp->support_2500full	= 1;
+		tp->support_5000full	= 1;
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
+		tp->eee_adv2		= MDIO_EEE_2_5GT | MDIO_EEE_5GT;
+		r8157_desc_init(tp);
+		break;
+
+	case RTL_VER_17:
+		ops->init		= r8159_init;
+		ops->enable		= rtl8157_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8157_up;
+		ops->down		= rtl8157_down;
+		ops->unload		= rtl8157_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8156_get_eee;
+		ops->eee_set		= r8156_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8159_hw_phy_cfg;
+		ops->autosuspend_en	= rtl8157_runtime_enable;
+		ops->change_mtu		= rtl8157_change_mtu;
+		ops->phy_read		= r8157_phy_read;
+		ops->phy_write		= r8157_phy_write;
+		tp->rx_buf_sz		= 48 * 1024;
+		tp->support_2500full	= 1;
+		tp->support_5000full	= 1;
+		tp->support_10gfull	= 1;
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_100TX | MDIO_EEE_1000T | MDIO_EEE_10GT;
+		tp->eee_adv2		= MDIO_EEE_2_5GT | MDIO_EEE_5GT;
+		r8157_desc_init(tp);
+		break;
+
+	default:
+		ret = -ENODEV;
+		dev_err(&tp->intf->dev, "Unknown Device\n");
+		break;
+	}
+
+	return ret;
+}
+
+static u8 __rtl_get_hw_ver(struct usb_device *udev)
+{
+	u32 ocp_data = 0;
+	__le32 *tmp;
+	u8 version;
+	int ret, i;
+
+	tmp = kmalloc(sizeof(*tmp), GFP_KERNEL);
+	if (!tmp)
+		return 0;
+
+	for (i = 0, ret = 0; i < 3 && ret != 4; i++)
+		ret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+				      RTL8152_REQ_GET_REGS, RTL8152_REQT_READ,
+				      PLA_TCR0, MCU_TYPE_PLA, tmp, sizeof(*tmp),
+				      USB_CTRL_GET_TIMEOUT);
+
+	if (ret > 0)
+		ocp_data = (__le32_to_cpu(*tmp) >> 16) & VERSION_MASK;
+
+	kfree(tmp);
+
+	switch (ocp_data) {
+	case 0x4c00:
+		version = RTL_VER_01;
+		break;
+	case 0x4c10:
+		version = RTL_VER_02;
+		break;
+	case 0x5c00:
+		version = RTL_VER_03;
+		break;
+	case 0x5c10:
+		version = RTL_VER_04;
+		break;
+	case 0x5c20:
+		version = RTL_VER_05;
+		break;
+	case 0x5c30:
+		version = RTL_VER_06;
+		break;
+	case 0x4800:
+		version = RTL_VER_07;
+		break;
+	case 0x6000:
+		version = RTL_VER_08;
+		break;
+	case 0x6010:
+		version = RTL_VER_09;
+		break;
+	case 0x7010:
+		version = RTL_TEST_01;
+		break;
+	case 0x7020:
+		version = RTL_VER_10;
+		break;
+	case 0x7030:
+		version = RTL_VER_11;
+		break;
+	case 0x7400:
+		version = RTL_VER_12;
+		break;
+	case 0x7410:
+		version = RTL_VER_13;
+		break;
+	case 0x6400:
+		version = RTL_VER_14;
+		break;
+	case 0x7420:
+		version = RTL_VER_15;
+		break;
+//	case 0x1010:
+//	case 0x1020:
+	case 0x1030:
+		version = RTL_VER_16;
+		break;
+//	case 0x2010:
+	case 0x2020:
+		version = RTL_VER_17;
+		break;
+	default:
+		version = RTL_VER_UNKNOWN;
+		dev_info(&udev->dev, "Unknown version 0x%04x\n", ocp_data);
+		break;
+	}
+
+	return version;
+}
+
+u8 rtl8152_get_version(struct usb_interface *intf);
+u8 rtl8152_get_version(struct usb_interface *intf)
+{
+	u8 version;
+
+	version = __rtl_get_hw_ver(interface_to_usbdev(intf));
+
+	dev_dbg(&intf->dev, "Detected version 0x%04x\n", version);
+
+	return version;
+}
+EXPORT_SYMBOL_GPL(rtl8152_get_version);
+
+#ifdef RTL8152_DEBUG
+
+static ssize_t
+ocp_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+	struct usb_interface *intf = tp->intf;
+	char tmp[256];
+	struct tally_counter tally;
+	int ret;
+
+	strcpy(buf, dev_name(dev));
+	strcat(buf, "\n");
+	strcat(buf, DRIVER_VERSION);
+	strcat(buf, "\n");
+
+	switch (tp->version) {
+	case RTL_VER_05:
+		strcat(buf, "RTL_VER_05\n");
+		strcat(buf, "usb_patch_code_20190904\n");
+		strcat(buf, "pla_patch_code_20190220_0\n");
+		strcat(buf, "\n\n\n\n");
+		break;
+	case RTL_VER_06:
+		strcat(buf, "RTL_VER_06\n");
+		strcat(buf, "usb_patch_20190909\n");
+		strcat(buf, "pla_patch_code_20190408_0\n");
+		strcat(buf, "\n\n\n\n");
+		break;
+	case RTL_VER_09:
+		strcat(buf, "RTL_VER_09\n");
+		strcat(buf, "usb_patch_code_20190906.cfg\n");
+		strcat(buf, "plamcu_patch_code_20190408_0\n");
+		strcat(buf, "\n\n\n\n");
+		break;
+	case RTL_VER_11:
+		strcat(buf, "RTL_VER_11\n");
+		strcat(buf, "nc0_patch_190128_usb\n");
+		strcat(buf, "nc1_patch_181029_usb\n");
+		strcat(buf, "nc2_patch_180821_usb\n");
+		strcat(buf, "uc2_patch_181018_usb\n");
+		strcat(buf, "data_ram_patch_v02_usb\n");
+		strcat(buf, "100m_tx_coefficient_180716_usb\n");
+		strcat(buf, "USB_patch_code_20210310_v4\n");
+		strcat(buf, "PLA_patch_code_20210318_v6\n");
+		break;
+	case RTL_VER_12:
+		strcat(buf, "RTL_VER_12\n");
+		strcat(buf, "nc_patch_190821_usb\n");
+		strcat(buf, "nc2_patch_190823_usb\n");
+		strcat(buf, "uc2_patch_190817_usb\n");
+		strcat(buf, "uc_patch_190731_usb\n");
+		strcat(buf, "USB_patch_code_20190816_v2\n");
+		strcat(buf, "PLA_patch_code_20190827_v2\n");
+		break;
+	case RTL_VER_13:
+	case RTL_VER_15:
+		strcat(buf, "RTL_VER_13\n");
+		strcat(buf, "tgphy_ramcode_v21_usb_20220324\n");
+		strcat(buf, "\n");
+		strcat(buf, "\n");
+		strcat(buf, "\n");
+		strcat(buf, "USB_patch_code_20220314_v4\n");
+		strcat(buf, "PLA_SVN8948_20220330_v06\n");
+		break;
+	case RTL_VER_14:
+		strcat(buf, "RTL_VER_14\n");
+		strcat(buf, "USB_Patch_Code_svn3347\n");
+		strcat(buf, "PLA_Patch_Code_svn3346\n");
+		strcat(buf, "\n\n\n\n");
+		break;
+	default:
+		strcat(buf, "\n\n\n\n\n\n\n");
+		break;
+	}
+
+	ret = usb_autopm_get_interface(intf);
+	if (ret < 0)
+		return ret;
+
+	ret = mutex_lock_interruptible(&tp->control);
+	if (ret < 0) {
+		usb_autopm_put_interface(intf);
+		goto err1;
+	}
+
+	generic_ocp_read(tp, PLA_TALLYCNT, sizeof(tally), &tally, MCU_TYPE_PLA);
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(intf);
+
+	sprintf(tmp, "tx_packets = %Lu\n", le64_to_cpu(tally.tx_packets));
+	strcat(buf, tmp);
+	sprintf(tmp, "rx_packets = %Lu\n", le64_to_cpu(tally.rx_packets));
+	strcat(buf, tmp);
+	sprintf(tmp, "tx_errors = %Lu\n", le64_to_cpu(tally.tx_errors));
+	strcat(buf, tmp);
+	sprintf(tmp, "tx_errors = %u\n", le32_to_cpu(tally.rx_errors));
+	strcat(buf, tmp);
+	sprintf(tmp, "rx_missed = %u\n", le16_to_cpu(tally.rx_missed));
+	strcat(buf, tmp);
+	sprintf(tmp, "align_errors = %u\n", le16_to_cpu(tally.align_errors));
+	strcat(buf, tmp);
+	sprintf(tmp, "tx_one_collision = %u\n",
+		le32_to_cpu(tally.tx_one_collision));
+	strcat(buf, tmp);
+	sprintf(tmp, "tx_multi_collision = %u\n",
+		le32_to_cpu(tally.tx_multi_collision));
+	strcat(buf, tmp);
+	sprintf(tmp, "rx_unicast = %Lu\n", le64_to_cpu(tally.rx_unicast));
+	strcat(buf, tmp);
+	sprintf(tmp, "rx_broadcast = %Lu\n", le64_to_cpu(tally.rx_broadcast));
+	strcat(buf, tmp);
+	sprintf(tmp, "rx_multicast = %u\n", le32_to_cpu(tally.rx_multicast));
+	strcat(buf, tmp);
+	sprintf(tmp, "tx_aborted = %u\n", le16_to_cpu(tally.tx_aborted));
+	strcat(buf, tmp);
+	sprintf(tmp, "tx_underrun = %u\n", le16_to_cpu(tally.tx_underrun));
+	strcat(buf, tmp);
+
+err1:
+	if (ret < 0)
+		return ret;
+	else
+		return strlen(buf);
+}
+
+static inline bool hex_value(char p)
+{
+	return (p >= '0' && p <= '9') ||
+	       (p >= 'a' && p <= 'f') ||
+	       (p >= 'A' && p <= 'F');
+}
+
+static int ocp_count(char *v1)
+{
+	int len = strlen(v1), count = 0;
+	char *v2 = strchr(v1, ' ');
+	bool is_vaild = false;
+
+	if (len < 5 || !v2)
+		goto out1;
+//	else if (strncmp(v1, "pla ", 4) && strncmp(v1, "usb ", 4))
+//		goto out1;
+
+	v1 = v2;
+	len = strlen(v2);
+	while(len) {
+		if (*v1 != ' ')
+			break;
+		v1++;
+		len--;
+	}
+
+	if (!len || *v1 == '\n')
+		goto out1;
+
+check:
+	v2 = strchr(v1, ' ');
+
+	if (len > 2 && !strncasecmp(v1, "0x", 2)) {
+		v1 += 2;
+		len -= 2;
+		if (v1 == v2 || *v1 == '\n')
+			goto out1;
+	}
+
+	if (v2) {
+		while (v1 < v2) {
+			if (!hex_value(*v1))
+				goto out1;
+			v1++;
+			len--;
+		}
+
+		count++;
+
+		while(len) {
+			if (*v1 != ' ')
+				break;
+			v1++;
+			len--;
+		}
+
+		if (len)
+			goto check;
+
+		is_vaild = true;
+	} else {
+		int i;
+
+		if (len && v1[len - 1] == '\n')
+			len--;
+
+		for (i = 0; i < len; i++) {
+			if (!hex_value(*v1))
+				goto out1;
+			v1++;
+		}
+
+		if (len)
+			count++;
+
+		is_vaild = true;
+	}
+
+out1:
+	if (is_vaild)
+		return count;
+	else
+		return 0;
+}
+
+static ssize_t ocp_store(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+	struct usb_interface *intf = tp->intf;
+	u32 v1, v2, v3, v4;
+	int num, ret;
+	u32 ocp_data;
+	u16 type;
+
+	if (!strncmp(buf, "pla ", 4))
+		type = MCU_TYPE_PLA;
+	else if (!strncmp(buf, "usb ", 4))
+		type = MCU_TYPE_USB;
+	else
+		return -EINVAL;
+
+	if (!ocp_count((char *)buf))
+		return -EINVAL;
+
+	num = sscanf(strchr(buf, ' '), "%x %x %x %x\n", &v1, &v2, &v3, &v4);
+
+	if (num > 1) {
+		if ((v1 == 2 && (v2 & 1)) ||
+		    (v1 == 4 && (v2 & 3)) ||
+		    (type == MCU_TYPE_PLA &&
+		     (v2 < 0xc000 || (v2 & ~3) == PLA_OCP_GPHY_BASE)))
+			return -EINVAL;
+	}
+
+	ret = usb_autopm_get_interface(intf);
+	if (ret < 0)
+		return ret;
+
+	ret = mutex_lock_interruptible(&tp->control);
+	if (ret < 0)
+		goto put;
+
+	switch(num) {
+	case 2:
+		switch (v1) {
+		case 1:
+			ret = ocp_read_byte(tp, type, v2, &ocp_data);
+			if (ret < 0)
+				break;
+			netif_info(tp, drv, netdev, "%s read byte %x = %x\n",
+				   type ? "PLA" : "USB", v2,
+				   ocp_data);
+			break;
+		case 2:
+			ret = ocp_read_word(tp, type, v2, &ocp_data);
+			if (ret < 0)
+				break;
+			netif_info(tp, drv, netdev, "%s read word %x = %x\n",
+				   type ? "PLA" : "USB", v2,
+				   ocp_data);
+			break;
+		case 4:
+			ret = ocp_read_dword(tp, type, v2, &ocp_data);
+			if (ret < 0)
+				break;
+			netif_info(tp, drv, netdev, "%s read dword %x = %x\n",
+				   type ? "PLA" : "USB", v2,
+				   ocp_data);
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+		break;
+	case 3:
+		switch (v1) {
+		case 1:
+			netif_info(tp, drv, netdev, "%s write byte %x = %x\n",
+				   type ? "PLA" : "USB", v2, v3);
+			ret = ocp_write_byte(tp, type, v2, v3);
+			break;
+		case 2:
+			netif_info(tp, drv, netdev, "%s write word %x = %x\n",
+				   type ? "PLA" : "USB", v2, v3);
+			ret = ocp_write_word(tp, type, v2, v3);
+			break;
+		case 4:
+			netif_info(tp, drv, netdev, "%s write dword %x = %x\n",
+				   type ? "PLA" : "USB", v2, v3);
+			ret = ocp_write_dword(tp, type, v2, v3);
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+		break;
+	case 4:
+	case 1:
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&tp->control);
+
+put:
+	usb_autopm_put_interface(intf);
+
+	if (ret < 0)
+		return ret;
+	else
+		return count;
+}
+
+static DEVICE_ATTR_RW(ocp);
+
+static struct attribute *rtk_attrs[] = {
+	&dev_attr_ocp.attr,
+	NULL
+};
+
+#define ATTR_PLA_SIZE	0x3000
+
+/* hexdump -e '"%04_ax\t" 16/1 "%02X " "\n"' pla */
+static ssize_t pla_read(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf, loff_t offset,
+			size_t size)
+{
+	struct device *dev = kobj_to_dev(kobj);
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+	int ret;
+
+	if (size <= ATTR_PLA_SIZE)
+		size = min(size, ATTR_PLA_SIZE - (size_t)offset);
+	else
+		return -EINVAL;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		return ret;
+
+	/* rtnl_lock(); */
+	ret = mutex_lock_interruptible(&tp->control);
+	if (ret < 0)
+		goto put;
+
+	ret = pla_ocp_read(tp, offset + 0xc000, (u16)size, buf);
+	if (ret < 0)
+		netif_err(tp, drv, netdev,
+			  "Read PLA offset 0x%Lx, len = %zd fail\n",
+			  offset + 0xc000, size);
+
+	mutex_unlock(&tp->control);
+	/* rtnl_unlock(); */
+
+put:
+	usb_autopm_put_interface(tp->intf);
+
+	if (ret < 0)
+		return ret;
+	else
+		return size;
+}
+
+static BIN_ATTR_RO(pla, ATTR_PLA_SIZE);
+
+static struct bin_attribute *rtk_bin_attrs[] = {
+	&bin_attr_pla,
+	NULL
+};
+
+static struct attribute_group rtk_dbg_grp = {
+	.name = "nic_swsd",
+	.attrs = rtk_attrs,
+	.bin_attrs = rtk_bin_attrs,
+};
+
+#endif /* RTL8152_DEBUG */
+
+static ssize_t rx_copybreak_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+
+	sprintf(buf, "%u\n", tp->rx_copybreak);
+
+	return strlen(buf);
+}
+
+static ssize_t rx_copybreak_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+	u32 rx_copybreak;
+
+	if (sscanf(buf, "%u\n", &rx_copybreak) != 1)
+		return -EINVAL;
+
+	if (rx_copybreak < ETH_ZLEN)
+		return -EINVAL;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	if (tp->rx_copybreak != rx_copybreak) {
+		if (tp->netdev->flags & IFF_UP) {
+			int ret;
+
+			ret = mutex_lock_interruptible(&tp->control);
+			if (ret < 0)
+				return ret;
+
+			napi_disable(&tp->napi);
+			tp->rx_copybreak = rx_copybreak;
+			napi_enable(&tp->napi);
+
+			mutex_unlock(&tp->control);
+		} else {
+			tp->rx_copybreak = rx_copybreak;
+		}
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(rx_copybreak);
+
+static ssize_t fc_pause_on_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct r8152 *tp = netdev_priv(to_net_dev(dev));
+
+	if (!tp->fc_pause_on)
+		sprintf(buf, "(Auto)%u\n", fc_pause_on_auto(tp));
+	else
+		sprintf(buf, "%u\n", tp->fc_pause_on);
+
+	return strlen(buf);
+}
+
+static ssize_t fc_pause_on_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+	struct usb_interface *intf = tp->intf;
+	u32 pause_on, pause_off, tmp;
+	int ret = 0;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	if (sscanf(buf, "%u\n", &pause_on) != 1)
+		return -EINVAL;
+
+	if (tp->fc_pause_off)
+		pause_off = tp->fc_pause_off;
+	else
+		pause_off = fc_pause_off_auto(tp);
+
+	if (pause_on)
+		tmp = pause_on;
+	else
+		tmp = fc_pause_on_auto(tp);
+
+	if (tmp >= pause_off) {
+		netif_err(tp, drv, netdev, "fc_pause_on must be less than %u\n",
+			  pause_off);
+		return -EINVAL;
+	}
+
+	if (tp->fc_pause_on != pause_on) {
+		ret = usb_autopm_get_interface(intf);
+		if (ret < 0)
+			return ret;
+
+		ret = mutex_lock_interruptible(&tp->control);
+		if (ret < 0)
+			goto put;
+
+		tp->fc_pause_on = pause_on;
+
+		if (netdev->flags & IFF_UP) {
+			r8156_fc_parameter(tp);
+
+			if (netif_carrier_ok(netdev)) {
+				netif_stop_queue(netdev);
+				napi_disable(&tp->napi);
+				tasklet_disable(&tp->tx_tl);
+				tp->rtl_ops.disable(tp);
+				tp->rtl_ops.enable(tp);
+				rtl_start_rx(tp);
+				tasklet_enable(&tp->tx_tl);
+				napi_enable(&tp->napi);
+				rtl8152_set_rx_mode(netdev);
+				netif_wake_queue(netdev);
+			}
+		}
+
+		mutex_unlock(&tp->control);
+
+put:
+		usb_autopm_put_interface(intf);
+	}
+
+	if (ret < 0)
+		return ret;
+	else
+		return count;
+}
+
+static DEVICE_ATTR_RW(fc_pause_on);
+
+static ssize_t fc_pause_off_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct r8152 *tp = netdev_priv(to_net_dev(dev));
+
+	if (!tp->fc_pause_off)
+		sprintf(buf, "(Auto)%u\n", fc_pause_off_auto(tp));
+	else
+		sprintf(buf, "%u\n", tp->fc_pause_off);
+
+	return strlen(buf);
+}
+
+static ssize_t fc_pause_off_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+	struct usb_interface *intf = tp->intf;
+	u32 pause_on, pause_off, tmp;
+	int ret = 0;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	if (sscanf(buf, "%u\n", &pause_off) != 1)
+		return -EINVAL;
+
+	if (tp->fc_pause_on)
+		pause_on = tp->fc_pause_on;
+	else
+		pause_on = fc_pause_on_auto(tp);
+
+	if (pause_off)
+		tmp = pause_off;
+	else
+		tmp = fc_pause_off_auto(tp);
+
+	if (tmp <= pause_on){
+		netif_err(tp, drv, netdev, "fc_pause_off must be more than %u\n",
+			  pause_on);
+		return -EINVAL;
+	}
+
+	if (tp->fc_pause_off != pause_off) {
+		ret = usb_autopm_get_interface(intf);
+		if (ret < 0)
+			return ret;
+
+		ret = mutex_lock_interruptible(&tp->control);
+		if (ret < 0)
+			goto put;
+
+		tp->fc_pause_off = pause_off;
+
+		if (netdev->flags & IFF_UP) {
+			r8156_fc_parameter(tp);
+
+			if (netif_carrier_ok(netdev)) {
+				netif_stop_queue(netdev);
+				napi_disable(&tp->napi);
+				tasklet_disable(&tp->tx_tl);
+				tp->rtl_ops.disable(tp);
+				tp->rtl_ops.enable(tp);
+				rtl_start_rx(tp);
+				tasklet_enable(&tp->tx_tl);
+				napi_enable(&tp->napi);
+				rtl8152_set_rx_mode(netdev);
+				netif_wake_queue(netdev);
+			}
+		}
+
+		mutex_unlock(&tp->control);
+
+put:
+		usb_autopm_put_interface(intf);
+	}
+
+	if (ret < 0)
+		return ret;
+	else
+		return count;
+}
+
+static DEVICE_ATTR_RW(fc_pause_off);
+
+static ssize_t
+sg_en_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+
+	if (tp->sg_use)
+		strcat(buf, "enable\n");
+	else
+		strcat(buf, "disable\n");
+
+	return strlen(buf);
+}
+
+static ssize_t sg_en_store(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+
+	if (!strncmp(buf, "enable", 6) &&
+	    usb_device_no_sg_constraint(tp->udev))
+		tp->sg_use = true;
+	else if (!strncmp(buf, "disable", 7))
+		tp->sg_use = false;
+	else
+		return -EINVAL;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (tp->sg_use) {
+		netif_set_tso_max_segs(netdev, RTL_MAX_SG_NUM);
+		netif_set_tso_max_size(netdev, TSO_LEGACY_MAX_SIZE / 2);
+	} else {
+		netif_set_tso_max_segs(netdev, GSO_MAX_SEGS);
+		netif_set_tso_max_size(netdev, RTL_LIMITED_TSO_SIZE);
+	}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26) */
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(sg_en);
+
+static struct attribute *rtk_adv_attrs[] = {
+	&dev_attr_rx_copybreak.attr,
+	&dev_attr_sg_en.attr,
+	&dev_attr_fc_pause_on.attr,
+	&dev_attr_fc_pause_off.attr,
+	NULL
+};
+
+static struct attribute_group rtk_adv_grp = {
+	.name = "rtl_adv",
+	.attrs = rtk_adv_attrs,
+};
+
+static bool rtl8152_supports_lenovo_macpassthru(struct usb_device *udev)
+{
+	int parent_vendor_id = le16_to_cpu(udev->parent->descriptor.idVendor);
+	int product_id = le16_to_cpu(udev->descriptor.idProduct);
+	int vendor_id = le16_to_cpu(udev->descriptor.idVendor);
+
+	if (vendor_id == VENDOR_ID_LENOVO) {
+		switch (product_id) {
+		case DEVICE_ID_LENOVO_USB_C_TRAVEL_HUB:
+		case DEVICE_ID_THINKPAD_ONELINK_PLUS_DOCK:
+		case DEVICE_ID_THINKPAD_THUNDERBOLT3_DOCK_GEN2:
+		case DEVICE_ID_THINKPAD_USB_C_DOCK_GEN2:
+		case DEVICE_ID_THINKPAD_USB_C_DOCK_GEN3:
+		case DEVICE_ID_THINKPAD_USB_C_DONGLE:
+			return 1;
+		}
+	} else if (vendor_id == VENDOR_ID_REALTEK && parent_vendor_id == VENDOR_ID_LENOVO) {
+		switch (product_id) {
+		case 0x8153:
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static void rtl_get_mapt_ver(struct r8152 *tp)
+{
+	struct usb_device *udev = tp->udev;
+	u32 ocp_data;
+
+	/* test for -AD variant of RTL8153 */
+	if (ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0, &ocp_data) < 0)
+		return;
+
+	if ((ocp_data & AD_MASK) == 0x1000) {
+		/* test for MAC address pass-through bit */
+		if (ocp_read_byte(tp, MCU_TYPE_USB, USB_EFUSE, &ocp_data) < 0)
+			return;
+		if (ocp_data & PASS_THRU_MASK) {
+			tp->dell_macpassthru = 1;
+			return;
+		}
+	}
+
+	/* test for RTL8153-BND and RTL8153-BD */
+	if (ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_1, &ocp_data) < 0)
+		return;
+
+	if ((ocp_data & BND_MASK) || (ocp_data & BD_MASK)) {
+		tp->dell_macpassthru = 1;
+		return;
+	}
+
+	tp->lenovo_macpassthru = rtl8152_supports_lenovo_macpassthru(udev);
+}
+
+static int rtl8152_probe(struct usb_interface *intf,
+			 const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct r8152 *tp;
+	struct net_device *netdev;
+	u8 version;
+	int ret;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0)
+	version = rtl8152_get_version(intf);
+	if (version == RTL_VER_UNKNOWN)
+		return -ENODEV;
+
+	if (!rtl_vendor_mode(intf))
+		return -ENODEV;
+#else
+	if (intf->cur_altsetting->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC)
+		return -ENODEV;
+
+	if (!rtl_check_vendor_ok(intf))
+		return -ENODEV;
+
+	version = rtl8152_get_version(intf);
+	if (version == RTL_VER_UNKNOWN)
+		return -ENODEV;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0) */
+
+	usb_reset_device(udev);
+	netdev = alloc_etherdev(sizeof(struct r8152));
+	if (!netdev) {
+		dev_err(&intf->dev, "Out of memory\n");
+		return -ENOMEM;
+	}
+
+	SET_NETDEV_DEV(netdev, &intf->dev);
+	tp = netdev_priv(netdev);
+	tp->msg_enable = 0x7FFF;
+
+	tp->udev = udev;
+	tp->netdev = netdev;
+	tp->intf = intf;
+	tp->version = version;
+
+	tp->pipe_ctrl_in = usb_rcvctrlpipe(udev, 0);
+	tp->pipe_ctrl_out = usb_sndctrlpipe(udev, 0);
+	tp->pipe_in = usb_rcvbulkpipe(udev, 1);
+	tp->pipe_out = usb_sndbulkpipe(udev, 2);
+	tp->pipe_intr = usb_rcvintpipe(udev, 3);
+
+	switch (version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+		tp->mii.supports_gmii = 0;
+		break;
+	default:
+		tp->mii.supports_gmii = 1;
+		break;
+	}
+
+	ret = rtl_ops_init(tp);
+	if (ret)
+		goto out;
+
+	mutex_init(&tp->control);
+	INIT_DELAYED_WORK(&tp->schedule, rtl_work_func_t);
+	INIT_DELAYED_WORK(&tp->hw_phy_work, rtl_hw_phy_work_func_t);
+	tasklet_setup(&tp->tx_tl, bottom_half);
+	tasklet_disable(&tp->tx_tl);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,2,3)
+	if (usb_device_no_sg_constraint(udev))
+		tp->sg_use = true;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,2,3) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	netdev->open = rtl8152_open;
+	netdev->stop = rtl8152_close;
+	netdev->get_stats = rtl8152_get_stats;
+	netdev->hard_start_xmit = rtl8152_start_xmit;
+	netdev->tx_timeout = rtl8152_tx_timeout;
+	netdev->change_mtu = rtl8152_change_mtu;
+	netdev->set_mac_address = rtl8152_set_mac_address;
+	netdev->do_ioctl = rtl8152_ioctl;
+	netdev->set_multicast_list = rtl8152_set_rx_mode;
+	netdev->vlan_rx_register = rtl8152_vlan_rx_register;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	netdev->vlan_rx_kill_vid = rtl8152_vlan_rx_kill_vid;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) */
+#else
+	netdev->netdev_ops = &rtl8152_netdev_ops;
+#endif /* HAVE_NET_DEVICE_OPS */
+
+	netdev->watchdog_timeo = RTL8152_TX_TIMEOUT;
+
+	netdev->features |= NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG |
+			    NETIF_F_TSO | NETIF_F_FRAGLIST | NETIF_F_IPV6_CSUM |
+			    NETIF_F_TSO6 | NETIF_F_HW_VLAN_CTAG_RX |
+			    NETIF_F_HW_VLAN_CTAG_TX;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)
+	netdev->hw_features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG |
+			      NETIF_F_TSO | NETIF_F_FRAGLIST |
+			      NETIF_F_IPV6_CSUM | NETIF_F_TSO6 |
+			      NETIF_F_HW_VLAN_CTAG_RX | NETIF_F_HW_VLAN_CTAG_TX;
+	netdev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
+				NETIF_F_HIGHDMA | NETIF_F_FRAGLIST |
+				NETIF_F_IPV6_CSUM | NETIF_F_TSO6;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39) */
+
+	if (tp->version == RTL_VER_01) {
+		netdev->features &= ~NETIF_F_RXCSUM;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)
+		netdev->hw_features &= ~NETIF_F_RXCSUM;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39) */
+	}
+
+	rtl_get_mapt_ver(tp);
+
+	netdev->ethtool_ops = &ops;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (tp->sg_use) {
+		netif_set_tso_max_segs(netdev, RTL_MAX_SG_NUM);
+		netif_set_tso_max_size(netdev, TSO_LEGACY_MAX_SIZE / 2);
+	} else {
+		netif_set_tso_max_segs(netdev, GSO_MAX_SEGS);
+		netif_set_tso_max_size(netdev, RTL_LIMITED_TSO_SIZE);
+	}
+#else
+	netdev->features &= ~(NETIF_F_TSO | NETIF_F_TSO6);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+	/* MTU range: 68 - 1500 or 9194 */
+	netdev->min_mtu = ETH_MIN_MTU;
+	switch (tp->version) {
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_VER_14:
+		netdev->max_mtu = size_to_mtu(9 * 1024);
+		break;
+	case RTL_VER_10:
+	case RTL_VER_11:
+		netdev->max_mtu = size_to_mtu(15 * 1024);
+		break;
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_15:
+	case RTL_VER_16:
+	case RTL_VER_17:
+		netdev->max_mtu = size_to_mtu(16 * 1024);
+		break;
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+	default:
+		netdev->max_mtu = ETH_DATA_LEN;
+		break;
+	}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0) */
+
+	tp->mii.dev = netdev;
+	tp->mii.mdio_read = read_mii_word;
+	tp->mii.mdio_write = write_mii_word;
+	tp->mii.phy_id_mask = 0x3f;
+	tp->mii.reg_num_mask = 0x1f;
+	tp->mii.phy_id = R8152_PHY_ID;
+	tp->mii.force_media = 0;
+	tp->mii.advertising = ADVERTISE_10HALF | ADVERTISE_10FULL |
+			      ADVERTISE_100HALF | ADVERTISE_100FULL;
+
+	tp->autoneg = AUTONEG_ENABLE;
+	tp->speed = SPEED_100;
+	tp->advertising = RTL_ADVERTISED_10_HALF | RTL_ADVERTISED_10_FULL |
+			  RTL_ADVERTISED_100_HALF | RTL_ADVERTISED_100_FULL;
+	if (tp->mii.supports_gmii) {
+		tp->speed = SPEED_1000;
+		tp->advertising |= RTL_ADVERTISED_1000_FULL;
+	}
+
+	if (tp->udev->speed >= USB_SPEED_SUPER) {
+		if (tp->support_2500full) {
+			tp->speed = SPEED_2500;
+			tp->advertising |= RTL_ADVERTISED_2500_FULL;
+		}
+
+		if (tp->support_5000full) {
+			tp->speed = SPEED_5000;
+			tp->advertising |= RTL_ADVERTISED_5000_FULL;
+		}
+
+		if (tp->support_10gfull) {
+			tp->speed = SPEED_10000;
+			tp->advertising |= RTL_ADVERTISED_10GT_FULL;
+		}
+	}
+
+	tp->duplex = DUPLEX_FULL;
+
+	tp->rx_copybreak = RTL8152_RXFG_HEADSZ;
+	tp->rx_pending = 10 * RTL8152_MAX_RX;
+
+	intf->needs_remote_wakeup = 1;
+
+	if (!rtl_can_wakeup(tp))
+		__rtl_set_wol(tp, 0);
+	else
+		tp->saved_wolopts = __rtl_get_wol(tp);
+
+	ret = tp->rtl_ops.init(tp);
+	if (ret < 0)
+		goto out1;
+
+	queue_delayed_work(system_long_wq, &tp->hw_phy_work, 0);
+	set_ethernet_addr(tp, false);
+
+	usb_set_intfdata(intf, tp);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
+	netif_napi_add_weight(netdev, &tp->napi, r8152_poll, NAPI_POLL_WEIGHT);
+#else
+	netif_napi_add(netdev, &tp->napi, r8152_poll);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0) */
+
+	ret = register_netdev(netdev);
+	if (ret != 0) {
+		dev_err(&intf->dev, "couldn't register the device\n");
+		goto out2;
+	}
+
+	if (tp->saved_wolopts)
+		device_set_wakeup_enable(&udev->dev, true);
+	else
+		device_set_wakeup_enable(&udev->dev, false);
+
+	/* usb_enable_autosuspend(udev); */
+
+	netif_info(tp, probe, netdev, "%s\n", DRIVER_VERSION);
+	netif_info(tp, probe, netdev, "%s\n", PATENTS);
+
+	ret = sysfs_create_group(&netdev->dev.kobj, &rtk_adv_grp);
+	if (ret < 0) {
+		netif_err(tp, probe, netdev, "create rtk_adv_grp fail\n");
+		goto out3;
+	}
+
+#ifdef RTL8152_DEBUG
+	ret = sysfs_create_group(&netdev->dev.kobj, &rtk_dbg_grp);
+	if (ret < 0) {
+		netif_err(tp, probe, netdev, "create rtk_dbg_grp fail\n");
+		goto out4;
+	}
+#endif
+
+	return 0;
+
+#ifdef RTL8152_DEBUG
+out4:
+	sysfs_remove_group(&netdev->dev.kobj, &rtk_adv_grp);
+#endif
+out3:
+	unregister_netdev(netdev);
+out2:
+	netif_napi_del(&tp->napi);
+out1:
+	tasklet_kill(&tp->tx_tl);
+	cancel_delayed_work_sync(&tp->hw_phy_work);
+	usb_set_intfdata(intf, NULL);
+out:
+	free_netdev(netdev);
+	return ret;
+}
+
+static void rtl8152_disconnect(struct usb_interface *intf)
+{
+	struct r8152 *tp = usb_get_intfdata(intf);
+
+	usb_set_intfdata(intf, NULL);
+	if (tp) {
+		struct net_device *netdev = tp->netdev;
+
+#ifdef RTL8152_DEBUG
+		sysfs_remove_group(&netdev->dev.kobj, &rtk_dbg_grp);
+#endif
+		sysfs_remove_group(&netdev->dev.kobj, &rtk_adv_grp);
+
+		rtl_set_unplug(tp);
+		unregister_netdev(netdev);
+		netif_napi_del(&tp->napi);
+		tasklet_kill(&tp->tx_tl);
+		cancel_delayed_work_sync(&tp->hw_phy_work);
+		if (tp->rtl_ops.unload)
+			tp->rtl_ops.unload(tp);
+		free_netdev(netdev);
+	}
+}
+
+#define REALTEK_USB_DEVICE(vend, prod)	{ \
+	USB_DEVICE_INTERFACE_CLASS(vend, prod, USB_CLASS_VENDOR_SPEC), \
+}, \
+{ \
+	USB_DEVICE_AND_INTERFACE_INFO(vend, prod, USB_CLASS_COMM, \
+			USB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE), \
+}, \
+{ \
+	USB_DEVICE_AND_INTERFACE_INFO(vend, prod, USB_CLASS_COMM, \
+			USB_CDC_SUBCLASS_NCM, USB_CDC_PROTO_NONE), \
+}
+
+/* table of devices that work with this driver */
+static const struct usb_device_id rtl8152_table[] = {
+	/* Realtek */
+	REALTEK_USB_DEVICE(VENDOR_ID_REALTEK, 0x8050),
+	REALTEK_USB_DEVICE(VENDOR_ID_REALTEK, 0x8053),
+	REALTEK_USB_DEVICE(VENDOR_ID_REALTEK, 0x8152),
+	REALTEK_USB_DEVICE(VENDOR_ID_REALTEK, 0x8153),
+	REALTEK_USB_DEVICE(VENDOR_ID_REALTEK, 0x8155),
+	REALTEK_USB_DEVICE(VENDOR_ID_REALTEK, 0x8156),
+	REALTEK_USB_DEVICE(VENDOR_ID_REALTEK, 0x8157),
+	REALTEK_USB_DEVICE(VENDOR_ID_REALTEK, 0x815a),
+
+	/* Microsoft */
+	REALTEK_USB_DEVICE(VENDOR_ID_MICROSOFT, 0x07ab),
+	REALTEK_USB_DEVICE(VENDOR_ID_MICROSOFT, 0x07c6),
+	REALTEK_USB_DEVICE(VENDOR_ID_MICROSOFT, 0x0927),
+	REALTEK_USB_DEVICE(VENDOR_ID_MICROSOFT, 0x0c5e),
+
+	/* Samsung */
+	REALTEK_USB_DEVICE(VENDOR_ID_SAMSUNG, 0xa101),
+
+	/* Lenovo */
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x304f),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3052),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3054),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3057),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3062),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3069),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3082),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3098),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x7205),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x720a),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x720b),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x720c),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x7214),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x721e),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x8153),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0xa359),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0xa387),
+
+	/* LINKSYS */
+	REALTEK_USB_DEVICE(VENDOR_ID_LINKSYS, 0x0041),
+
+	/* Nvidia */
+	REALTEK_USB_DEVICE(VENDOR_ID_NVIDIA, 0x09ff),
+
+	/* TP-LINK */
+	REALTEK_USB_DEVICE(VENDOR_ID_TPLINK, 0x0601),
+
+	/* Getac */
+	REALTEK_USB_DEVICE(0x2baf, 0x0012),
+
+	/* ASUSTek */
+	REALTEK_USB_DEVICE(0x0b05, 0x1976),
+
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, rtl8152_table);
+
+static struct usb_driver rtl8152_driver = {
+	.name =		MODULENAME,
+	.id_table =	rtl8152_table,
+	.probe =	rtl8152_probe,
+	.disconnect =	rtl8152_disconnect,
+	.suspend =	rtl8152_suspend,
+	.resume =	rtl8152_resume,
+	.reset_resume =	rtl8152_reset_resume,
+	.pre_reset =	rtl8152_pre_reset,
+	.post_reset =	rtl8152_post_reset,
+	.supports_autosuspend = 1,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+	.disable_hub_initiated_lpm = 1,
+#endif
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0)
+module_usb_driver(rtl8152_driver);
+#else
+static int rtl8152_cfgselector_probe(struct usb_device *udev)
+{
+	struct usb_host_config *c;
+	int i, num_configs;
+
+	/* Switch the device to vendor mode, if and only if the vendor mode
+	 * driver supports it.
+	 */
+	if (__rtl_get_hw_ver(udev) == RTL_VER_UNKNOWN)
+		return 0;
+
+	/* The vendor mode is not always config #1, so to find it out. */
+	c = udev->config;
+	num_configs = udev->descriptor.bNumConfigurations;
+	for (i = 0; i < num_configs; (i++, c++)) {
+		struct usb_interface_descriptor	*desc = NULL;
+
+		if (!c->desc.bNumInterfaces)
+			continue;
+		desc = &c->intf_cache[0]->altsetting->desc;
+		if (desc->bInterfaceClass == USB_CLASS_VENDOR_SPEC)
+			break;
+	}
+
+	if (i == num_configs)
+		return -ENODEV;
+
+	if (usb_set_configuration(udev, c->desc.bConfigurationValue)) {
+		dev_err(&udev->dev, "Failed to set configuration %d\n",
+			c->desc.bConfigurationValue);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static struct usb_device_driver rtl8152_cfgselector_driver = {
+	.name =		MODULENAME "-cfgselector",
+	.probe =	rtl8152_cfgselector_probe,
+	.id_table =	rtl8152_table,
+	.generic_subclass = 1,
+	.supports_autosuspend = 1,
+};
+
+static int __init rtl8152_driver_init(void)
+{
+	int ret;
+
+	ret = usb_register_device_driver(&rtl8152_cfgselector_driver, THIS_MODULE);
+	if (ret)
+		return ret;
+	return usb_register(&rtl8152_driver);
+}
+
+static void __exit rtl8152_driver_exit(void)
+{
+	usb_deregister(&rtl8152_driver);
+	usb_deregister_device_driver(&rtl8152_cfgselector_driver);
+}
+
+module_init(rtl8152_driver_init);
+module_exit(rtl8152_driver_exit);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0) */
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
Index: drivers/net/ethernet/r8126-10.016.00/rtl_eeprom.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/rtl_eeprom.c b/drivers/net/ethernet/r8126-10.016.00/rtl_eeprom.c
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/rtl_eeprom.c	(date 1763109333415)
@@ -0,0 +1,285 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/ethtool.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+
+#include "r8126.h"
+#include "rtl_eeprom.h"
+
+//-------------------------------------------------------------------
+//rtl8126_eeprom_type():
+//  tell the eeprom type
+//return value:
+//  0: the eeprom type is 93C46
+//  1: the eeprom type is 93C56 or 93C66
+//-------------------------------------------------------------------
+void rtl8126_eeprom_type(struct rtl8126_private *tp)
+{
+        u16 magic = 0;
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                goto out_no_eeprom;
+
+        if(RTL_R8(tp, 0xD2)&0x04) {
+                //not support
+                //tp->eeprom_type = EEPROM_TWSI;
+                //tp->eeprom_len = 256;
+                goto out_no_eeprom;
+        } else if(RTL_R32(tp, RxConfig) & RxCfg_9356SEL) {
+                tp->eeprom_type = EEPROM_TYPE_93C56;
+                tp->eeprom_len = 256;
+        } else {
+                tp->eeprom_type = EEPROM_TYPE_93C46;
+                tp->eeprom_len = 128;
+        }
+
+        magic = rtl8126_eeprom_read_sc(tp, 0);
+
+out_no_eeprom:
+        if ((magic != 0x8129) && (magic != 0x8128)) {
+                tp->eeprom_type = EEPROM_TYPE_NONE;
+                tp->eeprom_len = 0;
+        }
+}
+
+void rtl8126_eeprom_cleanup(struct rtl8126_private *tp)
+{
+        u8 x;
+
+        x = RTL_R8(tp, Cfg9346);
+        x &= ~(Cfg9346_EEDI | Cfg9346_EECS);
+
+        RTL_W8(tp, Cfg9346, x);
+
+        rtl8126_raise_clock(tp, &x);
+        rtl8126_lower_clock(tp, &x);
+}
+
+static int rtl8126_eeprom_cmd_done(struct rtl8126_private *tp)
+{
+        u8 x;
+        int i;
+
+        rtl8126_stand_by(tp);
+
+        for (i = 0; i < 50000; i++) {
+                x = RTL_R8(tp, Cfg9346);
+
+                if (x & Cfg9346_EEDO) {
+                        udelay(RTL_CLOCK_RATE * 2 * 3);
+                        return 0;
+                }
+                udelay(1);
+        }
+
+        return -1;
+}
+
+//-------------------------------------------------------------------
+//rtl8126_eeprom_read_sc():
+//  read one word from eeprom
+//-------------------------------------------------------------------
+u16 rtl8126_eeprom_read_sc(struct rtl8126_private *tp, u16 reg)
+{
+        int addr_sz = 6;
+        u8 x;
+        u16 data;
+
+        if(tp->eeprom_type == EEPROM_TYPE_NONE)
+                return -1;
+
+        if (tp->eeprom_type==EEPROM_TYPE_93C46)
+                addr_sz = 6;
+        else if (tp->eeprom_type==EEPROM_TYPE_93C56)
+                addr_sz = 8;
+
+        x = Cfg9346_EEM1 | Cfg9346_EECS;
+        RTL_W8(tp, Cfg9346, x);
+
+        rtl8126_shift_out_bits(tp, RTL_EEPROM_READ_OPCODE, 3);
+        rtl8126_shift_out_bits(tp, reg, addr_sz);
+
+        data = rtl8126_shift_in_bits(tp);
+
+        rtl8126_eeprom_cleanup(tp);
+
+        RTL_W8(tp, Cfg9346, 0);
+
+        return data;
+}
+
+//-------------------------------------------------------------------
+//rtl8126_eeprom_write_sc():
+//  write one word to a specific address in the eeprom
+//-------------------------------------------------------------------
+void rtl8126_eeprom_write_sc(struct rtl8126_private *tp, u16 reg, u16 data)
+{
+        u8 x;
+        int addr_sz = 6;
+        int w_dummy_addr = 4;
+
+        if(tp->eeprom_type == EEPROM_TYPE_NONE)
+                return;
+
+        if (tp->eeprom_type==EEPROM_TYPE_93C46) {
+                addr_sz = 6;
+                w_dummy_addr = 4;
+        } else if (tp->eeprom_type==EEPROM_TYPE_93C56) {
+                addr_sz = 8;
+                w_dummy_addr = 6;
+        }
+
+        x = Cfg9346_EEM1 | Cfg9346_EECS;
+        RTL_W8(tp, Cfg9346, x);
+
+        rtl8126_shift_out_bits(tp, RTL_EEPROM_EWEN_OPCODE, 5);
+        rtl8126_shift_out_bits(tp, reg, w_dummy_addr);
+        rtl8126_stand_by(tp);
+
+        rtl8126_shift_out_bits(tp, RTL_EEPROM_ERASE_OPCODE, 3);
+        rtl8126_shift_out_bits(tp, reg, addr_sz);
+        if (rtl8126_eeprom_cmd_done(tp) < 0)
+                return;
+        rtl8126_stand_by(tp);
+
+        rtl8126_shift_out_bits(tp, RTL_EEPROM_WRITE_OPCODE, 3);
+        rtl8126_shift_out_bits(tp, reg, addr_sz);
+        rtl8126_shift_out_bits(tp, data, 16);
+        if (rtl8126_eeprom_cmd_done(tp) < 0)
+                return;
+        rtl8126_stand_by(tp);
+
+        rtl8126_shift_out_bits(tp, RTL_EEPROM_EWDS_OPCODE, 5);
+        rtl8126_shift_out_bits(tp, reg, w_dummy_addr);
+
+        rtl8126_eeprom_cleanup(tp);
+        RTL_W8(tp, Cfg9346, 0);
+}
+
+void rtl8126_raise_clock(struct rtl8126_private *tp, u8 *x)
+{
+        *x = *x | Cfg9346_EESK;
+        RTL_W8(tp, Cfg9346, *x);
+        udelay(RTL_CLOCK_RATE);
+}
+
+void rtl8126_lower_clock(struct rtl8126_private *tp, u8 *x)
+{
+
+        *x = *x & ~Cfg9346_EESK;
+        RTL_W8(tp, Cfg9346, *x);
+        udelay(RTL_CLOCK_RATE);
+}
+
+void rtl8126_shift_out_bits(struct rtl8126_private *tp, int data, int count)
+{
+        u8 x;
+        int  mask;
+
+        mask = 0x01 << (count - 1);
+        x = RTL_R8(tp, Cfg9346);
+        x &= ~(Cfg9346_EEDI | Cfg9346_EEDO);
+
+        do {
+                if (data & mask)
+                        x |= Cfg9346_EEDI;
+                else
+                        x &= ~Cfg9346_EEDI;
+
+                RTL_W8(tp, Cfg9346, x);
+                udelay(RTL_CLOCK_RATE);
+                rtl8126_raise_clock(tp, &x);
+                rtl8126_lower_clock(tp, &x);
+                mask = mask >> 1;
+        } while(mask);
+
+        x &= ~Cfg9346_EEDI;
+        RTL_W8(tp, Cfg9346, x);
+}
+
+u16 rtl8126_shift_in_bits(struct rtl8126_private *tp)
+{
+        u8 x;
+        u16 d, i;
+
+        x = RTL_R8(tp, Cfg9346);
+        x &= ~(Cfg9346_EEDI | Cfg9346_EEDO);
+
+        d = 0;
+
+        for (i = 0; i < 16; i++) {
+                d = d << 1;
+                rtl8126_raise_clock(tp, &x);
+
+                x = RTL_R8(tp, Cfg9346);
+                x &= ~Cfg9346_EEDI;
+
+                if (x & Cfg9346_EEDO)
+                        d |= 1;
+
+                rtl8126_lower_clock(tp, &x);
+        }
+
+        return d;
+}
+
+void rtl8126_stand_by(struct rtl8126_private *tp)
+{
+        u8 x;
+
+        x = RTL_R8(tp, Cfg9346);
+        x &= ~(Cfg9346_EECS | Cfg9346_EESK);
+        RTL_W8(tp, Cfg9346, x);
+        udelay(RTL_CLOCK_RATE);
+
+        x |= Cfg9346_EECS;
+        RTL_W8(tp, Cfg9346, x);
+}
+
+void rtl8126_set_eeprom_sel_low(struct rtl8126_private *tp)
+{
+        RTL_W8(tp, Cfg9346, Cfg9346_EEM1);
+        RTL_W8(tp, Cfg9346, Cfg9346_EEM1 | Cfg9346_EESK);
+
+        udelay(20);
+
+        RTL_W8(tp, Cfg9346, Cfg9346_EEM1);
+}
Index: drivers/net/ethernet/r8126-10.016.00/rtl_eeprom.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/rtl_eeprom.h b/drivers/net/ethernet/r8126-10.016.00/rtl_eeprom.h
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/rtl_eeprom.h	(date 1763109333415)
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_RTLEEPROM_H
+#define _LINUX_RTLEEPROM_H
+
+//EEPROM opcodes
+#define RTL_EEPROM_READ_OPCODE      06
+#define RTL_EEPROM_WRITE_OPCODE     05
+#define RTL_EEPROM_ERASE_OPCODE     07
+#define RTL_EEPROM_EWEN_OPCODE      19
+#define RTL_EEPROM_EWDS_OPCODE      16
+
+#define RTL_CLOCK_RATE  3
+
+void rtl8126_eeprom_type(struct rtl8126_private *tp);
+void rtl8126_eeprom_cleanup(struct rtl8126_private *tp);
+u16 rtl8126_eeprom_read_sc(struct rtl8126_private *tp, u16 reg);
+void rtl8126_eeprom_write_sc(struct rtl8126_private *tp, u16 reg, u16 data);
+void rtl8126_shift_out_bits(struct rtl8126_private *tp, int data, int count);
+u16 rtl8126_shift_in_bits(struct rtl8126_private *tp);
+void rtl8126_raise_clock(struct rtl8126_private *tp, u8 *x);
+void rtl8126_lower_clock(struct rtl8126_private *tp, u8 *x);
+void rtl8126_stand_by(struct rtl8126_private *tp);
+void rtl8126_set_eeprom_sel_low(struct rtl8126_private *tp);
+
+#endif /* _LINUX_RTLEEPROM_H */
Index: drivers/net/ethernet/r8125-9.016.01/r8125_realwow.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/r8125_realwow.h b/drivers/net/ethernet/r8125-9.016.01/r8125_realwow.h
new file mode 100755
--- /dev/null	(date 1763113879455)
+++ b/drivers/net/ethernet/r8125-9.016.01/r8125_realwow.h	(date 1763113879455)
@@ -0,0 +1,118 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_R8125_REALWOW_H
+#define _LINUX_R8125_REALWOW_H
+
+#define SIOCDEVPRIVATE_RTLREALWOW   SIOCDEVPRIVATE+3
+
+#define MAX_RealWoW_KCP_SIZE (100)
+#define MAX_RealWoW_Payload (64)
+
+#define KA_TX_PACKET_SIZE (100)
+#define KA_WAKEUP_PATTERN_SIZE (120)
+
+//HwSuppKeepAliveOffloadVer
+#define HW_SUPPORT_KCP_OFFLOAD(_M)        ((_M)->HwSuppKCPOffloadVer > 0)
+
+enum rtl_realwow_cmd {
+
+        RTL_REALWOW_SET_KCP_DISABLE=0,
+        RTL_REALWOW_SET_KCP_INFO,
+        RTL_REALWOW_SET_KCP_CONTENT,
+
+        RTL_REALWOW_SET_KCP_ACKPKTINFO,
+        RTL_REALWOW_SET_KCP_WPINFO,
+        RTL_REALWOW_SET_KCPDHCP_TIMEOUT,
+
+        RTLT_REALWOW_COMMAND_INVALID
+};
+
+struct rtl_realwow_ioctl_struct {
+        __u32	cmd;
+        __u32	offset;
+        __u32	len;
+        union {
+                __u32	data;
+                void *data_buffer;
+        };
+};
+
+typedef struct _MP_KCPInfo {
+        u8 DIPv4[4];
+        u8 MacID[6];
+        u16 UdpPort[2];
+        u8 PKTLEN[2];
+
+        u16 ackLostCnt;
+        u8 KCP_WakePattern[MAX_RealWoW_Payload];
+        u8 KCP_AckPacket[MAX_RealWoW_Payload];
+        u32 KCP_interval;
+        u8 KCP_WakePattern_Len;
+        u8 KCP_AckPacket_Len;
+        u8 KCP_TxPacket[2][KA_TX_PACKET_SIZE];
+} MP_KCP_INFO, *PMP_KCP_INFO;
+
+typedef struct _KCPInfo {
+        u32 nId; // = id
+        u8 DIPv4[4];
+        u8 MacID[6];
+        u16 UdpPort;
+        u16 PKTLEN;
+} KCPInfo, *PKCPInfo;
+
+typedef struct _KCPContent {
+        u32 id; // = id
+        u32 mSec; // = msec
+        u32 size; // =size
+        u8 bPacket[MAX_RealWoW_KCP_SIZE]; // put packet here
+} KCPContent, *PKCPContent;
+
+typedef struct _RealWoWAckPktInfo {
+        u16 ackLostCnt;
+        u16 patterntSize;
+        u8 pattern[MAX_RealWoW_Payload];
+} RealWoWAckPktInfo,*PRealWoWAckPktInfo;
+
+typedef struct _RealWoWWPInfo {
+        u16 patterntSize;
+        u8 pattern[MAX_RealWoW_Payload];
+} RealWoWWPInfo,*PRealWoWWPInfo;
+
+int rtl8125_realwow_ioctl(struct net_device *dev, struct ifreq *ifr);
+void rtl8125_realwow_hw_init(struct net_device *dev);
+void rtl8125_get_realwow_hw_version(struct net_device *dev);
+void rtl8125_set_realwow_d3_para(struct net_device *dev);
+
+#endif /* _LINUX_R8125_REALWOW_H */
Index: drivers/net/ethernet/Makefile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
--- a/drivers/net/ethernet/Makefile	(revision 7475d784169c7df48b0c55525fb862e06674d63c)
+++ b/drivers/net/ethernet/Makefile	(date 1763114054580)
@@ -106,3 +106,6 @@
 obj-$(CONFIG_NET_VENDOR_SYNOPSYS) += synopsys/
 obj-$(CONFIG_NET_VENDOR_PENSANDO) += pensando/
 obj-$(CONFIG_OA_TC6) += oa_tc6.o
+obj-$(CONFIG_R8125) += r8125-9.016.01/
+obj-$(CONFIG_R8126) += r8126-10.016.00/
+obj-$(CONFIG_R8152) += r8152-2.20.1/
Index: drivers/net/ethernet/r8125-9.016.01/r8125_rss.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/r8125_rss.h b/drivers/net/ethernet/r8125-9.016.01/r8125_rss.h
new file mode 100755
--- /dev/null	(date 1763113879456)
+++ b/drivers/net/ethernet/r8125-9.016.01/r8125_rss.h	(date 1763113879456)
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_rtl8125_RSS_H
+#define _LINUX_rtl8125_RSS_H
+
+#include <linux/netdevice.h>
+#include <linux/types.h>
+
+#define RTL8125_RSS_KEY_SIZE     40  /* size of RSS Hash Key in bytes */
+#define RTL8125_MAX_INDIRECTION_TABLE_ENTRIES 128
+
+enum rtl8125_rss_flag {
+        RTL_8125_RSS_FLAG_HASH_UDP_IPV4  = (1 << 0),
+        RTL_8125_RSS_FLAG_HASH_UDP_IPV6  = (1 << 1),
+};
+
+struct rtl8125_private;
+struct RxDesc;
+
+int rtl8125_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
+                      u32 *rule_locs);
+int rtl8125_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd);
+u32 rtl8125_get_rxfh_key_size(struct net_device *netdev);
+u32 rtl8125_rss_indir_size(struct net_device *netdev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,8,0)
+int rtl8125_get_rxfh(struct net_device *dev, struct ethtool_rxfh_param *rxfh);
+int rtl8125_set_rxfh(struct net_device *dev, struct ethtool_rxfh_param *rxfh,
+                     struct netlink_ext_ack *extack);
+#else
+int rtl8125_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
+                     u8 *hfunc);
+int rtl8125_set_rxfh(struct net_device *netdev, const u32 *indir,
+                     const u8 *key, const u8 hfunc);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,8,0) */
+void rtl8125_rx_hash(struct rtl8125_private *tp,
+                     struct RxDesc *desc,
+                     struct sk_buff *skb);
+void _rtl8125_config_rss(struct rtl8125_private *tp);
+void rtl8125_config_rss(struct rtl8125_private *tp);
+void rtl8125_init_rss(struct rtl8125_private *tp);
+u32 rtl8125_rss_indir_tbl_entries(struct rtl8125_private *tp);
+void rtl8125_disable_rss(struct rtl8125_private *tp);
+
+#endif /* _LINUX_rtl8125_RSS_H */
Index: drivers/net/ethernet/r8125-9.016.01/r8125_dash.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/r8125_dash.h b/drivers/net/ethernet/r8125-9.016.01/r8125_dash.h
new file mode 100755
--- /dev/null	(date 1763113879452)
+++ b/drivers/net/ethernet/r8125-9.016.01/r8125_dash.h	(date 1763113879452)
@@ -0,0 +1,196 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_R8125_DASH_H
+#define _LINUX_R8125_DASH_H
+
+#include <linux/if.h>
+
+#define SIOCDEVPRIVATE_RTLDASH   SIOCDEVPRIVATE+2
+
+enum rtl_dash_cmd {
+        RTL_DASH_ARP_NS_OFFLOAD = 0,
+        RTL_DASH_SET_OOB_IPMAC,
+        RTL_DASH_NOTIFY_OOB,
+
+        RTL_DASH_SEND_BUFFER_DATA_TO_DASH_FW,
+        RTL_DASH_CHECK_SEND_BUFFER_TO_DASH_FW_COMPLETE,
+        RTL_DASH_GET_RCV_FROM_FW_BUFFER_DATA,
+        RTL_DASH_OOB_REQ,
+        RTL_DASH_OOB_ACK,
+        RTL_DASH_DETACH_OOB_REQ,
+        RTL_DASH_DETACH_OOB_ACK,
+
+        RTL_FW_SET_IPV4 = 0x10,
+        RTL_FW_GET_IPV4,
+        RTL_FW_SET_IPV6,
+        RTL_FW_GET_IPV6,
+        RTL_FW_SET_EXT_SNMP,
+        RTL_FW_GET_EXT_SNMP,
+        RTL_FW_SET_WAKEUP_PATTERN,
+        RTL_FW_GET_WAKEUP_PATTERN,
+        RTL_FW_DEL_WAKEUP_PATTERN,
+
+        RTLT_DASH_COMMAND_INVALID,
+};
+
+struct rtl_dash_ip_mac {
+        struct sockaddr ifru_addr;
+        struct sockaddr ifru_netmask;
+        struct sockaddr ifru_hwaddr;
+};
+
+struct rtl_dash_ioctl_struct {
+        __u32	cmd;
+        __u32	offset;
+        __u32	len;
+        union {
+                __u32	data;
+                void *data_buffer;
+        };
+};
+
+typedef struct _OSOOBHdr {
+        __le32 len;
+        u8 type;
+        u8 flag;
+        u8 hostReqV;
+        u8 res;
+}
+OSOOBHdr, *POSOOBHdr;
+
+typedef struct _RX_DASH_BUFFER_TYPE_2 {
+        OSOOBHdr oobhdr;
+        u8 RxDataBuffer[0];
+}
+RX_DASH_BUFFER_TYPE_2, *PRX_DASH_BUFFER_TYPE_2;
+
+#define ALIGN_8                 (0x7)
+#define ALIGN_16                (0xf)
+#define ALIGN_32                (0x1f)
+#define ALIGN_64                (0x3f)
+#define ALIGN_256               (0xff)
+#define ALIGN_4096              (0xfff)
+
+#define OCP_REG_FIRMWARE_MAJOR_VERSION (0x120)
+
+#define HW_DASH_SUPPORT_DASH(_M)        ((_M)->HwSuppDashVer > 0)
+#define HW_DASH_SUPPORT_TYPE_1(_M)      ((_M)->HwSuppDashVer == 1)
+#define HW_DASH_SUPPORT_TYPE_2(_M)      ((_M)->HwSuppDashVer == 2)
+#define HW_DASH_SUPPORT_TYPE_3(_M)      ((_M)->HwSuppDashVer == 3)
+#define HW_DASH_SUPPORT_TYPE_4(_M)      ((_M)->HwSuppDashVer == 4)
+#define HW_DASH_SUPPORT_CMAC(_M)        (HW_DASH_SUPPORT_TYPE_2(_M) || HW_DASH_SUPPORT_TYPE_3(_M))
+#define HW_DASH_SUPPORT_IPC2(_M)        (HW_DASH_SUPPORT_TYPE_4(_M))
+#define HW_DASH_SUPPORT_GET_FIRMWARE_VERSION(_M) (HW_DASH_SUPPORT_TYPE_2(_M) || \
+                                                  HW_DASH_SUPPORT_TYPE_3(_M) || \
+                                                  HW_DASH_SUPPORT_TYPE_4(_M))
+
+#define RECV_FROM_FW_BUF_SIZE (1520)
+#define SEND_TO_FW_BUF_SIZE (1520)
+
+#define TXS_CC3_0       (BIT_0|BIT_1|BIT_2|BIT_3)
+#define TXS_EXC         BIT_4
+#define TXS_LNKF        BIT_5
+#define TXS_OWC         BIT_6
+#define TXS_TES         BIT_7
+#define TXS_UNF         BIT_9
+#define TXS_LGSEN       BIT_11
+#define TXS_LS          BIT_12
+#define TXS_FS          BIT_13
+#define TXS_EOR         BIT_14
+#define TXS_OWN         BIT_15
+
+#define TPPool_HRDY     0x20
+
+#define RXS_OWN      BIT_15
+#define RXS_EOR      BIT_14
+#define RXS_FS       BIT_13
+#define RXS_LS       BIT_12
+
+#define ISRIMR_DASH_INTR_EN BIT_12
+
+#define NO_BASE_ADDRESS 0x00000000
+
+/* IB2SOC registers */
+#define IPC2_SWISR_DRIVER_READY 0x05
+#define IPC2_SWISR_DRIVER_EXIT 0x06
+#define IPC2_SWISR_CLIENTTOOL_SYNC_HOSTNAME 0x20
+#define IPC2_SWISR_DIS_DASH 0x55
+#define IPC2_SWISR_EN_DASH 0x56
+
+#define IPC2_IB2SOC_SET 0x10
+#define IPC2_IB2SOC_DATA 0x14
+#define IPC2_IB2SOC_CMD 0x18
+#define IPC2_IB2SOC_IMR 0x1C
+
+/* IPC2 registers */
+#define IPC2_PCIE_BASE      0xC100
+#define IPC2_TX_SET_REG     IPC2_PCIE_BASE
+#define IPC2_TX_STATUS_REG  (IPC2_PCIE_BASE+0x04)
+#define IPC2_RX_STATUS_REG  (IPC2_PCIE_BASE+0x08)
+#define IPC2_RX_CLEAR_REG   (IPC2_PCIE_BASE+0x0C)
+#define IPC2_DATA_BASE      0x32000
+#define IPC2_BUFFER_LENGTH  0x1000
+#define IPC2_DATA_MASTER    IPC2_DATA_BASE                        //dash tx buffer base
+#define IPC2_DATA_SLAVE     (IPC2_DATA_BASE+IPC2_BUFFER_LENGTH)   //dash rx buffer base
+#define IPC2_TX_BUFFER      IPC2_DATA_MASTER
+#define IPC2_RX_BUFFER      IPC2_DATA_SLAVE
+
+#define IPC2_TX_SEND_BIT        BIT_0
+#define IPC2_TX_ACK_BIT         BIT_8
+#define IPC2_RX_ROK_BIT         BIT_0
+#define IPC2_RX_ACK_BIT         BIT_8
+
+/* IPC2 write/read MMIO register */
+#define RTL_DASH_IPC2_W8(tp, reg, val8)   RTL_W8(tp, reg, val8)
+#define RTL_DASH_IPC2_W16(tp, reg, val16) RTL_W16(tp, reg, val16)
+#define RTL_DASH_IPC2_W32(tp, reg, val32)  RTL_W32(tp, reg, val32)
+#define RTL_DASH_IPC2_R8(tp, reg)     RTL_R8(tp, reg)
+#define RTL_DASH_IPC2_R16(tp, reg)    RTL_R16(tp, reg)
+#define RTL_DASH_IPC2_R32(tp, reg)    RTL_R32(tp, reg)
+
+/* DASH OOB Header Type */
+#define DASH_OOB_HDR_TYPE_REQ 0x91
+#define DASH_OOB_HDR_TYPE_ACK 0x92
+
+struct  rtl8125_private;
+
+int rtl8125_dash_ioctl(struct net_device *dev, struct ifreq *ifr);
+bool rtl8125_check_dash_interrupt(struct rtl8125_private *tp);
+void rtl8125_handle_dash_interrupt(struct net_device *dev);
+void rtl8125_clear_ipc2_isr(struct rtl8125_private *tp);
+void rtl8125_set_ipc2_soc_imr_bit(struct rtl8125_private *tp, u16 mask);
+void rtl8125_clear_ipc2_soc_imr_bit(struct rtl8125_private *tp, u16 mask);
+
+#endif /* _LINUX_R8125_DASH_H */
Index: drivers/net/ethernet/r8125-9.016.01/rtltool.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/rtltool.c b/drivers/net/ethernet/r8125-9.016.01/rtltool.c
new file mode 100755
--- /dev/null	(date 1763113879457)
+++ b/drivers/net/ethernet/r8125-9.016.01/rtltool.c	(date 1763113879457)
@@ -0,0 +1,312 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/in.h>
+#include <linux/ethtool.h>
+#include <asm/uaccess.h>
+#include "r8125.h"
+#include "rtl_eeprom.h"
+#include "rtltool.h"
+
+int rtl8125_tool_ioctl(struct rtl8125_private *tp, struct ifreq *ifr)
+{
+        struct rtltool_cmd my_cmd;
+        unsigned long flags;
+        int ret;
+
+        if (copy_from_user(&my_cmd, ifr->ifr_data, sizeof(my_cmd)))
+                return -EFAULT;
+
+        ret = 0;
+        switch (my_cmd.cmd) {
+        case RTLTOOL_READ_MAC:
+                if ((my_cmd.offset + my_cmd.len) > pci_resource_len(tp->pci_dev, 2)) {
+                        ret = -EINVAL;
+                        break;
+                }
+
+                if (my_cmd.len==1)
+                        my_cmd.data = readb(tp->mmio_addr+my_cmd.offset);
+                else if (my_cmd.len==2)
+                        my_cmd.data = readw(tp->mmio_addr+(my_cmd.offset&~1));
+                else if (my_cmd.len==4)
+                        my_cmd.data = readl(tp->mmio_addr+(my_cmd.offset&~3));
+                else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+                break;
+
+        case RTLTOOL_WRITE_MAC:
+                if ((my_cmd.offset + my_cmd.len) > pci_resource_len(tp->pci_dev, 2)) {
+                        ret = -EINVAL;
+                        break;
+                }
+
+                if (my_cmd.len==1)
+                        writeb(my_cmd.data, tp->mmio_addr+my_cmd.offset);
+                else if (my_cmd.len==2)
+                        writew(my_cmd.data, tp->mmio_addr+(my_cmd.offset&~1));
+                else if (my_cmd.len==4)
+                        writel(my_cmd.data, tp->mmio_addr+(my_cmd.offset&~3));
+                else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_READ_PHY:
+                r8125_spin_lock(&tp->phy_lock, flags);
+                my_cmd.data = rtl8125_mdio_prot_read(tp, my_cmd.offset);
+                r8125_spin_unlock(&tp->phy_lock, flags);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_WRITE_PHY:
+                r8125_spin_lock(&tp->phy_lock, flags);
+                rtl8125_mdio_prot_write(tp, my_cmd.offset, my_cmd.data);
+                r8125_spin_unlock(&tp->phy_lock, flags);
+                break;
+
+        case RTLTOOL_READ_EPHY:
+                my_cmd.data = rtl8125_ephy_read(tp, my_cmd.offset);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_WRITE_EPHY:
+                rtl8125_ephy_write(tp, my_cmd.offset, my_cmd.data);
+                break;
+
+        case RTLTOOL_READ_ERI:
+                my_cmd.data = 0;
+                if (my_cmd.len==1 || my_cmd.len==2 || my_cmd.len==4) {
+                        my_cmd.data = rtl8125_eri_read(tp, my_cmd.offset, my_cmd.len, ERIAR_ExGMAC);
+                } else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_WRITE_ERI:
+                if (my_cmd.len==1 || my_cmd.len==2 || my_cmd.len==4) {
+                        rtl8125_eri_write(tp, my_cmd.offset, my_cmd.len, my_cmd.data, ERIAR_ExGMAC);
+                } else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+                break;
+
+        case RTLTOOL_READ_PCI:
+                my_cmd.data = 0;
+                if (my_cmd.len==1)
+                        pci_read_config_byte(tp->pci_dev, my_cmd.offset,
+                                             (u8 *)&my_cmd.data);
+                else if (my_cmd.len==2)
+                        pci_read_config_word(tp->pci_dev, my_cmd.offset,
+                                             (u16 *)&my_cmd.data);
+                else if (my_cmd.len==4)
+                        pci_read_config_dword(tp->pci_dev, my_cmd.offset,
+                                              &my_cmd.data);
+                else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+                break;
+
+        case RTLTOOL_WRITE_PCI:
+                if (my_cmd.len==1)
+                        pci_write_config_byte(tp->pci_dev, my_cmd.offset,
+                                              my_cmd.data);
+                else if (my_cmd.len==2)
+                        pci_write_config_word(tp->pci_dev, my_cmd.offset,
+                                              my_cmd.data);
+                else if (my_cmd.len==4)
+                        pci_write_config_dword(tp->pci_dev, my_cmd.offset,
+                                               my_cmd.data);
+                else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_READ_EEPROM:
+                my_cmd.data = rtl8125_eeprom_read_sc(tp, my_cmd.offset);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_WRITE_EEPROM:
+                rtl8125_eeprom_write_sc(tp, my_cmd.offset, my_cmd.data);
+                break;
+
+        case RTL_READ_OOB_MAC:
+                rtl8125_oob_mutex_lock(tp);
+                my_cmd.data = rtl8125_ocp_read(tp, my_cmd.offset, 4);
+                rtl8125_oob_mutex_unlock(tp);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+                break;
+
+        case RTL_WRITE_OOB_MAC:
+                if (my_cmd.len == 0 || my_cmd.len > 4)
+                        return -EOPNOTSUPP;
+
+                rtl8125_oob_mutex_lock(tp);
+                rtl8125_ocp_write(tp, my_cmd.offset, my_cmd.len, my_cmd.data);
+                rtl8125_oob_mutex_unlock(tp);
+                break;
+
+        case RTL_ENABLE_PCI_DIAG:
+                r8125_spin_lock(&tp->phy_lock, flags);
+                tp->rtk_enable_diag = 1;
+                r8125_spin_unlock(&tp->phy_lock, flags);
+
+                dprintk("enable rtk diag\n");
+                break;
+
+        case RTL_DISABLE_PCI_DIAG:
+                r8125_spin_lock(&tp->phy_lock, flags);
+                tp->rtk_enable_diag = 0;
+                r8125_spin_unlock(&tp->phy_lock, flags);
+
+                dprintk("disable rtk diag\n");
+                break;
+
+        case RTL_READ_MAC_OCP:
+                if (my_cmd.offset % 2)
+                        return -EOPNOTSUPP;
+
+                my_cmd.data = rtl8125_mac_ocp_read(tp, my_cmd.offset);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+                break;
+
+        case RTL_WRITE_MAC_OCP:
+                if ((my_cmd.offset % 2) || (my_cmd.len != 2))
+                        return -EOPNOTSUPP;
+
+                rtl8125_mac_ocp_write(tp, my_cmd.offset, (u16)my_cmd.data);
+                break;
+
+        case RTL_DIRECT_READ_PHY_OCP:
+                r8125_spin_lock(&tp->phy_lock, flags);
+                my_cmd.data = rtl8125_mdio_prot_direct_read_phy_ocp(tp, my_cmd.offset);
+                r8125_spin_unlock(&tp->phy_lock, flags);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTL_DIRECT_WRITE_PHY_OCP:
+                r8125_spin_lock(&tp->phy_lock, flags);
+                rtl8125_mdio_prot_direct_write_phy_ocp(tp, my_cmd.offset, my_cmd.data);
+                r8125_spin_unlock(&tp->phy_lock, flags);
+                break;
+
+#ifdef ENABLE_FIBER_SUPPORT
+        case RTL_READ_FIBER_PHY:
+                if (!HW_FIBER_STATUS_CONNECTED(tp)) {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                r8125_spin_lock(&tp->phy_lock, flags);
+                my_cmd.data = rtl8125_fiber_mdio_read(tp, my_cmd.offset);
+                r8125_spin_unlock(&tp->phy_lock, flags);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTL_WRITE_FIBER_PHY:
+                if (!HW_FIBER_STATUS_CONNECTED(tp)) {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                r8125_spin_lock(&tp->phy_lock, flags);
+                rtl8125_fiber_mdio_write(tp, my_cmd.offset, my_cmd.data);
+                r8125_spin_unlock(&tp->phy_lock, flags);
+                break;
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        default:
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        return ret;
+}
Index: drivers/net/ethernet/r8125-9.016.01/r8125_n.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/r8125_n.c b/drivers/net/ethernet/r8125-9.016.01/r8125_n.c
new file mode 100755
--- /dev/null	(date 1763113879454)
+++ b/drivers/net/ethernet/r8125-9.016.01/r8125_n.c	(date 1763113879454)
@@ -0,0 +1,21312 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+/*
+ * This driver is modified from r8169.c in Linux kernel 2.6.18
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/mii.h>
+#include <linux/if_vlan.h>
+#include <linux/crc32.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#include <linux/ipv6.h>
+#include <net/ip6_checksum.h>
+#endif
+#include <linux/tcp.h>
+#include <linux/init.h>
+#include <linux/rtnetlink.h>
+#include <linux/completion.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)
+#include <linux/pci-aspm.h>
+#endif
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
+#include <linux/prefetch.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define dev_printk(A,B,fmt,args...) printk(A fmt,##args)
+#else
+#include <linux/dma-mapping.h>
+#include <linux/moduleparam.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+#include <linux/mdio.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,4,10)
+#include <net/gso.h>
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,4,10) */
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "r8125.h"
+#include "rtl_eeprom.h"
+#include "rtltool.h"
+#include "r8125_firmware.h"
+
+#ifdef ENABLE_R8125_PROCFS
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#endif
+
+#define FIRMWARE_8125A_3	"rtl_nic/rtl8125a-3.fw"
+#define FIRMWARE_8125B_2	"rtl_nic/rtl8125b-2.fw"
+#define FIRMWARE_8125BP_1	"rtl_nic/rtl8125bp-1.fw"
+#define FIRMWARE_8125BP_2	"rtl_nic/rtl8125bp-2.fw"
+#define FIRMWARE_8125D_1	"rtl_nic/rtl8125d-1.fw"
+#define FIRMWARE_8125D_2	"rtl_nic/rtl8125d-2.fw"
+#define FIRMWARE_8125CP_1	"rtl_nic/rtl8125cp-1.fw"
+
+static const struct {
+        const char *name;
+        const char *fw_name;
+} rtl_chip_fw_infos[] = {
+        /* PCI-E devices. */
+        [CFG_METHOD_2] = {"RTL8125A"				},
+        [CFG_METHOD_3] = {"RTL8125A",		FIRMWARE_8125A_3},
+        [CFG_METHOD_4] = {"RTL8125B",                       },
+        [CFG_METHOD_5] = {"RTL8125B",		FIRMWARE_8125B_2},
+        [CFG_METHOD_6] = {"RTL8168KB",		FIRMWARE_8125A_3},
+        [CFG_METHOD_7] = {"RTL8168KB",		FIRMWARE_8125B_2},
+        [CFG_METHOD_8] = {"RTL8125BP",		FIRMWARE_8125BP_1},
+        [CFG_METHOD_9] = {"RTL8125BP",		FIRMWARE_8125BP_2},
+        [CFG_METHOD_10] = {"RTL8125D",		FIRMWARE_8125D_1},
+        [CFG_METHOD_11] = {"RTL8125D",		FIRMWARE_8125D_2},
+        [CFG_METHOD_12] = {"RTL8125CP",		FIRMWARE_8125CP_1},
+        [CFG_METHOD_13] = {"RTL8168KD",		FIRMWARE_8125D_2},
+        [CFG_METHOD_DEFAULT] = {"Unknown",                  },
+};
+
+#define _R(NAME,MAC,RCR,MASK,JumFrameSz) \
+    { .name = NAME, .mcfg = MAC, .RCR_Cfg = RCR, .RxConfigMask = MASK, .jumbo_frame_sz = JumFrameSz }
+
+static const struct {
+        const char *name;
+        u8 mcfg;
+        u32 RCR_Cfg;
+        u32 RxConfigMask;   /* Clears the bits supported by this chip */
+        u32 jumbo_frame_sz;
+} rtl_chip_info[] = {
+        _R("RTL8125A",
+        CFG_METHOD_2,
+        Rx_Fetch_Number_8 | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_256 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8125A",
+        CFG_METHOD_3,
+        Rx_Fetch_Number_8 | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_256 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8125B",
+        CFG_METHOD_4,
+        Rx_Fetch_Number_8 | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_256 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8125B",
+        CFG_METHOD_5,
+        Rx_Fetch_Number_8 | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_256 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8168KB",
+        CFG_METHOD_6,
+        Rx_Fetch_Number_8 | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_256 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8168KB",
+        CFG_METHOD_7,
+        Rx_Fetch_Number_8 | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_256 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8125BP",
+        CFG_METHOD_8,
+        Rx_Fetch_Number_8 | Rx_Close_Multiple | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_256 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8125BP",
+        CFG_METHOD_9,
+        Rx_Fetch_Number_8 | Rx_Close_Multiple | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_256 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8125D",
+        CFG_METHOD_10,
+        Rx_Fetch_Number_8 | Rx_Close_Multiple | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_256 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8125D",
+        CFG_METHOD_11,
+        Rx_Fetch_Number_8 | Rx_Close_Multiple | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_256 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8125CP",
+        CFG_METHOD_12,
+        Rx_Fetch_Number_8 | Rx_Close_Multiple | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_256 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8168KD",
+        CFG_METHOD_13,
+        Rx_Fetch_Number_8 | Rx_Close_Multiple | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_256 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("Unknown",
+        CFG_METHOD_DEFAULT,
+        (RX_DMA_BURST_512 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_1k)
+};
+#undef _R
+
+
+#ifndef PCI_VENDOR_ID_DLINK
+#define PCI_VENDOR_ID_DLINK 0x1186
+#endif
+
+static struct pci_device_id rtl8125_pci_tbl[] = {
+        { PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8125), },
+        { PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8162), },
+        { PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x3000), },
+        {0,},
+};
+
+MODULE_DEVICE_TABLE(pci, rtl8125_pci_tbl);
+
+static int use_dac = 1;
+static int timer_count = 0x2600;
+static int timer_count_v2 = (0x2600 / 0x100);
+
+static struct {
+        u32 msg_enable;
+} debug = { -1 };
+
+static unsigned int speed_mode = SPEED_2500;
+static unsigned int duplex_mode = DUPLEX_FULL;
+static unsigned int autoneg_mode = AUTONEG_ENABLE;
+#ifdef CONFIG_ASPM
+static int aspm = 1;
+#else
+static int aspm = 0;
+#endif
+#ifdef ENABLE_S5WOL
+static int s5wol = 1;
+#else
+static int s5wol = 0;
+#endif
+#ifdef ENABLE_S5_KEEP_CURR_MAC
+static int s5_keep_curr_mac = 1;
+#else
+static int s5_keep_curr_mac = 0;
+#endif
+#ifdef ENABLE_EEE
+static int eee_enable = 1;
+#else
+static int eee_enable = 0;
+#endif
+#ifdef CONFIG_SOC_LAN
+static ulong hwoptimize = HW_PATCH_SOC_LAN;
+#else
+static ulong hwoptimize = 0;
+#endif
+#ifdef ENABLE_S0_MAGIC_PACKET
+static int s0_magic_packet = 1;
+#else
+static int s0_magic_packet = 0;
+#endif
+#ifdef ENABLE_TX_NO_CLOSE
+static int tx_no_close_enable = 1;
+#else
+static int tx_no_close_enable = 0;
+#endif
+#ifdef ENABLE_PTP_MASTER_MODE
+static int enable_ptp_master_mode = 1;
+#else
+static int enable_ptp_master_mode = 0;
+#endif
+#ifdef DISABLE_WOL_SUPPORT
+static int disable_wol_support = 1;
+#else
+static int disable_wol_support = 0;
+#endif
+#ifdef ENABLE_DOUBLE_VLAN
+static int enable_double_vlan = 1;
+#else
+static int enable_double_vlan = 0;
+#endif
+#ifdef ENABLE_GIGA_LITE
+static int eee_giga_lite = 1;
+#else
+static int eee_giga_lite = 0;
+#endif
+
+MODULE_AUTHOR("Realtek and the Linux r8125 crew <netdev@vger.kernel.org>");
+MODULE_DESCRIPTION("Realtek r8125 Ethernet controller driver");
+
+module_param(speed_mode, uint, 0);
+MODULE_PARM_DESC(speed_mode, "force phy operation. Deprecated by ethtool (8).");
+
+module_param(duplex_mode, uint, 0);
+MODULE_PARM_DESC(duplex_mode, "force phy operation. Deprecated by ethtool (8).");
+
+module_param(autoneg_mode, uint, 0);
+MODULE_PARM_DESC(autoneg_mode, "force phy operation. Deprecated by ethtool (8).");
+
+module_param(aspm, int, 0);
+MODULE_PARM_DESC(aspm, "Enable ASPM.");
+
+module_param(s5wol, int, 0);
+MODULE_PARM_DESC(s5wol, "Enable Shutdown Wake On Lan.");
+
+module_param(s5_keep_curr_mac, int, 0);
+MODULE_PARM_DESC(s5_keep_curr_mac, "Enable Shutdown Keep Current MAC Address.");
+
+module_param(use_dac, int, 0);
+MODULE_PARM_DESC(use_dac, "Enable PCI DAC. Unsafe on 32 bit PCI slot.");
+
+module_param(timer_count, int, 0);
+MODULE_PARM_DESC(timer_count, "Timer Interrupt Interval.");
+
+module_param(eee_enable, int, 0);
+MODULE_PARM_DESC(eee_enable, "Enable Energy Efficient Ethernet.");
+
+module_param(hwoptimize, ulong, 0);
+MODULE_PARM_DESC(hwoptimize, "Enable HW optimization function.");
+
+module_param(s0_magic_packet, int, 0);
+MODULE_PARM_DESC(s0_magic_packet, "Enable S0 Magic Packet.");
+
+module_param(tx_no_close_enable, int, 0);
+MODULE_PARM_DESC(tx_no_close_enable, "Enable TX No Close.");
+
+module_param(enable_ptp_master_mode, int, 0);
+MODULE_PARM_DESC(enable_ptp_master_mode, "Enable PTP Master Mode.");
+
+module_param(disable_wol_support, int, 0);
+MODULE_PARM_DESC(disable_wol_support, "Disable PM support.");
+
+module_param(enable_double_vlan, int, 0);
+MODULE_PARM_DESC(enable_double_vlan, "Enable Double VLAN.");
+
+module_param(eee_giga_lite, int, 0);
+MODULE_PARM_DESC(eee_giga_lite, "Enable Giga Lite.");
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+module_param_named(debug, debug.msg_enable, int, 0);
+MODULE_PARM_DESC(debug, "Debug verbosity level (0=none, ..., 16=all)");
+#endif//LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+
+MODULE_LICENSE("GPL");
+#ifdef ENABLE_USE_FIRMWARE_FILE
+MODULE_FIRMWARE(FIRMWARE_8125A_3);
+MODULE_FIRMWARE(FIRMWARE_8125B_2);
+MODULE_FIRMWARE(FIRMWARE_8125BP_1);
+MODULE_FIRMWARE(FIRMWARE_8125BP_2);
+MODULE_FIRMWARE(FIRMWARE_8125D_1);
+MODULE_FIRMWARE(FIRMWARE_8125D_2);
+MODULE_FIRMWARE(FIRMWARE_8125CP_1);
+#endif
+
+MODULE_VERSION(RTL8125_VERSION);
+
+/*
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+static void rtl8125_esd_timer(unsigned long __opaque);
+#else
+static void rtl8125_esd_timer(struct timer_list *t);
+#endif
+*/
+/*
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+static void rtl8125_link_timer(unsigned long __opaque);
+#else
+static void rtl8125_link_timer(struct timer_list *t);
+#endif
+*/
+
+static netdev_tx_t rtl8125_start_xmit(struct sk_buff *skb, struct net_device *dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t rtl8125_interrupt(int irq, void *dev_instance, struct pt_regs *regs);
+#else
+static irqreturn_t rtl8125_interrupt(int irq, void *dev_instance);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t rtl8125_interrupt_msix(int irq, void *dev_instance, struct pt_regs *regs);
+#else
+static irqreturn_t rtl8125_interrupt_msix(int irq, void *dev_instance);
+#endif
+static void rtl8125_set_rx_mode(struct net_device *dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+static void rtl8125_tx_timeout(struct net_device *dev, unsigned int txqueue);
+#else
+static void rtl8125_tx_timeout(struct net_device *dev);
+#endif
+static int rtl8125_rx_interrupt(struct net_device *, struct rtl8125_private *, struct rtl8125_rx_ring *, napi_budget);
+static int rtl8125_tx_interrupt(struct rtl8125_tx_ring *ring, int budget);
+static int rtl8125_tx_interrupt_with_vector(struct rtl8125_private *tp, const int message_id, int budget);
+static void rtl8125_wait_for_quiescence(struct net_device *dev);
+static int rtl8125_change_mtu(struct net_device *dev, int new_mtu);
+static void rtl8125_down(struct net_device *dev);
+
+static int rtl8125_set_mac_address(struct net_device *dev, void *p);
+static void rtl8125_rar_set(struct rtl8125_private *tp, const u8 *addr);
+static void rtl8125_desc_addr_fill(struct rtl8125_private *);
+static void rtl8125_tx_desc_init(struct rtl8125_private *tp);
+static void rtl8125_rx_desc_init(struct rtl8125_private *tp);
+
+static u16 rtl8125_get_hw_phy_mcu_code_ver(struct rtl8125_private *tp);
+static void rtl8125_phy_power_up(struct net_device *dev);
+static void rtl8125_phy_power_down(struct net_device *dev);
+static int rtl8125_set_speed(struct net_device *dev, u8 autoneg, u32 speed, u8 duplex, u64 adv);
+static bool rtl8125_set_phy_mcu_patch_request(struct rtl8125_private *tp);
+static bool rtl8125_clear_phy_mcu_patch_request(struct rtl8125_private *tp);
+
+#ifdef CONFIG_R8125_NAPI
+static int rtl8125_poll(napi_ptr napi, napi_budget budget);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8125_reset_task(void *_data);
+static void rtl8125_esd_task(void *_data);
+static void rtl8125_linkchg_task(void *_data);
+static void rtl8125_link_task(void *_data);
+static void rtl8125_dash_task(void *_data);
+#else
+static void rtl8125_reset_task(struct work_struct *work);
+static void rtl8125_esd_task(struct work_struct *work);
+static void rtl8125_linkchg_task(struct work_struct *work);
+static void rtl8125_link_task(struct work_struct *work);
+static void rtl8125_dash_task(struct work_struct *work);
+#endif
+static void rtl8125_schedule_reset_work(struct rtl8125_private *tp);
+static void rtl8125_schedule_esd_work(struct rtl8125_private *tp);
+static void rtl8125_schedule_linkchg_work(struct rtl8125_private *tp);
+static void rtl8125_schedule_link_work(struct rtl8125_private *tp);
+void rtl8125_schedule_dash_work(struct rtl8125_private *tp);
+static void rtl8125_init_all_schedule_work(struct rtl8125_private *tp);
+static void rtl8125_cancel_all_schedule_work(struct rtl8125_private *tp);
+
+static inline struct device *tp_to_dev(struct rtl8125_private *tp)
+{
+        return &tp->pci_dev->dev;
+}
+
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0) && \
+     LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,00)))
+void ethtool_convert_legacy_u32_to_link_mode(unsigned long *dst,
+                u32 legacy_u32)
+{
+        bitmap_zero(dst, __ETHTOOL_LINK_MODE_MASK_NBITS);
+        dst[0] = legacy_u32;
+}
+
+bool ethtool_convert_link_mode_to_legacy_u32(u32 *legacy_u32,
+                const unsigned long *src)
+{
+        bool retval = true;
+
+        /* TODO: following test will soon always be true */
+        if (__ETHTOOL_LINK_MODE_MASK_NBITS > 32) {
+                __ETHTOOL_DECLARE_LINK_MODE_MASK(ext);
+
+                bitmap_zero(ext, __ETHTOOL_LINK_MODE_MASK_NBITS);
+                bitmap_fill(ext, 32);
+                bitmap_complement(ext, ext, __ETHTOOL_LINK_MODE_MASK_NBITS);
+                if (bitmap_intersects(ext, src,
+                                      __ETHTOOL_LINK_MODE_MASK_NBITS)) {
+                        /* src mask goes beyond bit 31 */
+                        retval = false;
+                }
+        }
+        *legacy_u32 = src[0];
+        return retval;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+
+#ifndef LPA_1000FULL
+#define LPA_1000FULL            0x0800
+#endif
+
+#ifndef LPA_1000HALF
+#define LPA_1000HALF            0x0400
+#endif
+
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+static inline void eth_hw_addr_random(struct net_device *dev)
+{
+        random_ether_addr(dev->dev_addr);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#undef ethtool_ops
+#define ethtool_ops _kc_ethtool_ops
+
+struct _kc_ethtool_ops {
+        int  (*get_settings)(struct net_device *, struct ethtool_cmd *);
+        int  (*set_settings)(struct net_device *, struct ethtool_cmd *);
+        void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
+        int  (*get_regs_len)(struct net_device *);
+        void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
+        void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
+        int  (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
+        u32  (*get_msglevel)(struct net_device *);
+        void (*set_msglevel)(struct net_device *, u32);
+        int  (*nway_reset)(struct net_device *);
+        u32  (*get_link)(struct net_device *);
+        int  (*get_eeprom_len)(struct net_device *);
+        int  (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
+        int  (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
+        int  (*get_coalesce)(struct net_device *, struct ethtool_coalesce *);
+        int  (*set_coalesce)(struct net_device *, struct ethtool_coalesce *);
+        void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *);
+        int  (*set_ringparam)(struct net_device *, struct ethtool_ringparam *);
+        void (*get_pauseparam)(struct net_device *,
+                               struct ethtool_pauseparam*);
+        int  (*set_pauseparam)(struct net_device *,
+                               struct ethtool_pauseparam*);
+        u32  (*get_rx_csum)(struct net_device *);
+        int  (*set_rx_csum)(struct net_device *, u32);
+        u32  (*get_tx_csum)(struct net_device *);
+        int  (*set_tx_csum)(struct net_device *, u32);
+        u32  (*get_sg)(struct net_device *);
+        int  (*set_sg)(struct net_device *, u32);
+        u32  (*get_tso)(struct net_device *);
+        int  (*set_tso)(struct net_device *, u32);
+        int  (*self_test_count)(struct net_device *);
+        void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
+        void (*get_strings)(struct net_device *, u32 stringset, u8 *);
+        int  (*phys_id)(struct net_device *, u32);
+        int  (*get_stats_count)(struct net_device *);
+        void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *,
+                                  u64 *);
+} *ethtool_ops = NULL;
+
+#undef SET_ETHTOOL_OPS
+#define SET_ETHTOOL_OPS(netdev, ops) (ethtool_ops = (ops))
+
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0)
+#ifndef SET_ETHTOOL_OPS
+#define SET_ETHTOOL_OPS(netdev,ops) \
+         ((netdev)->ethtool_ops = (ops))
+#endif //SET_ETHTOOL_OPS
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0)
+
+//#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5)
+#ifndef netif_msg_init
+#define netif_msg_init _kc_netif_msg_init
+/* copied from linux kernel 2.6.20 include/linux/netdevice.h */
+static inline u32 netif_msg_init(int debug_value, int default_msg_enable_bits)
+{
+        /* use default */
+        if (debug_value < 0 || debug_value >= (sizeof(u32) * 8))
+                return default_msg_enable_bits;
+        if (debug_value == 0)   /* no output */
+                return 0;
+        /* set low N bits */
+        return (1 << debug_value) - 1;
+}
+
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5)
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+static inline void eth_copy_and_sum (struct sk_buff *dest,
+                                     const unsigned char *src,
+                                     int len, int base)
+{
+        skb_copy_to_linear_data(dest, src, len);
+}
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7)
+/* copied from linux kernel 2.6.20 /include/linux/time.h */
+/* Parameters used to convert the timespec values: */
+#define MSEC_PER_SEC    1000L
+
+/* copied from linux kernel 2.6.20 /include/linux/jiffies.h */
+/*
+ * Change timeval to jiffies, trying to avoid the
+ * most obvious overflows..
+ *
+ * And some not so obvious.
+ *
+ * Note that we don't want to return MAX_LONG, because
+ * for various timeout reasons we often end up having
+ * to wait "jiffies+1" in order to guarantee that we wait
+ * at _least_ "jiffies" - so "jiffies+1" had better still
+ * be positive.
+ */
+#define MAX_JIFFY_OFFSET ((~0UL >> 1)-1)
+
+/*
+ * Convert jiffies to milliseconds and back.
+ *
+ * Avoid unnecessary multiplications/divisions in the
+ * two most common HZ cases:
+ */
+static inline unsigned int _kc_jiffies_to_msecs(const unsigned long j)
+{
+#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)
+        return (MSEC_PER_SEC / HZ) * j;
+#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)
+        return (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);
+#else
+        return (j * MSEC_PER_SEC) / HZ;
+#endif
+}
+
+static inline unsigned long _kc_msecs_to_jiffies(const unsigned int m)
+{
+        if (m > _kc_jiffies_to_msecs(MAX_JIFFY_OFFSET))
+                return MAX_JIFFY_OFFSET;
+#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)
+        return (m + (MSEC_PER_SEC / HZ) - 1) / (MSEC_PER_SEC / HZ);
+#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)
+        return m * (HZ / MSEC_PER_SEC);
+#else
+        return (m * HZ + MSEC_PER_SEC - 1) / MSEC_PER_SEC;
+#endif
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7)
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+
+/* copied from linux kernel 2.6.12.6 /include/linux/pm.h */
+typedef int __bitwise pci_power_t;
+
+/* copied from linux kernel 2.6.12.6 /include/linux/pci.h */
+typedef u32 __bitwise pm_message_t;
+
+#define PCI_D0  ((pci_power_t __force) 0)
+#define PCI_D1  ((pci_power_t __force) 1)
+#define PCI_D2  ((pci_power_t __force) 2)
+#define PCI_D3hot   ((pci_power_t __force) 3)
+#define PCI_D3cold  ((pci_power_t __force) 4)
+#define PCI_POWER_ERROR ((pci_power_t __force) -1)
+
+/* copied from linux kernel 2.6.12.6 /drivers/pci/pci.c */
+/**
+ * pci_choose_state - Choose the power state of a PCI device
+ * @dev: PCI device to be suspended
+ * @state: target sleep state for the whole system. This is the value
+ *  that is passed to suspend() function.
+ *
+ * Returns PCI power state suitable for given device and given system
+ * message.
+ */
+
+pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
+{
+        if (!pci_find_capability(dev, PCI_CAP_ID_PM))
+                return PCI_D0;
+
+        switch (state) {
+        case 0:
+                return PCI_D0;
+        case 3:
+                return PCI_D3hot;
+        default:
+                printk("They asked me for state %d\n", state);
+//      BUG();
+        }
+        return PCI_D0;
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+/**
+ * msleep_interruptible - sleep waiting for waitqueue interruptions
+ * @msecs: Time in milliseconds to sleep for
+ */
+#define msleep_interruptible _kc_msleep_interruptible
+unsigned long _kc_msleep_interruptible(unsigned int msecs)
+{
+        unsigned long timeout = _kc_msecs_to_jiffies(msecs);
+
+        while (timeout && !signal_pending(current)) {
+                set_current_state(TASK_INTERRUPTIBLE);
+                timeout = schedule_timeout(timeout);
+        }
+        return _kc_jiffies_to_msecs(timeout);
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7)
+/* copied from linux kernel 2.6.20 include/linux/sched.h */
+#ifndef __sched
+#define __sched     __attribute__((__section__(".sched.text")))
+#endif
+
+/* copied from linux kernel 2.6.20 kernel/timer.c */
+signed long __sched schedule_timeout_uninterruptible(signed long timeout)
+{
+        __set_current_state(TASK_UNINTERRUPTIBLE);
+        return schedule_timeout(timeout);
+}
+
+/* copied from linux kernel 2.6.20 include/linux/mii.h */
+#undef if_mii
+#define if_mii _kc_if_mii
+static inline struct mii_ioctl_data *if_mii(struct ifreq *rq)
+{
+        return (struct mii_ioctl_data *) &rq->ifr_ifru;
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7)
+
+static u16 _rtl8125_read_thermal_sensor(struct rtl8125_private *tp)
+{
+        u16 ts_digout;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                ts_digout = rtl8125_mdio_direct_read_phy_ocp(tp, 0xBD84);
+                ts_digout &= 0x3ff;
+                break;
+        default:
+                ts_digout = 0xffff;
+                break;
+        }
+
+        return ts_digout;
+}
+
+static int rtl8125_read_thermal_sensor(struct rtl8125_private *tp)
+{
+        int tmp;
+
+        tmp = _rtl8125_read_thermal_sensor(tp);
+        if (tmp > 512)
+                return (0 - ((512 - (tmp - 512)) / 2));
+        else
+                return (tmp / 2);
+}
+
+int rtl8125_dump_tally_counter(struct rtl8125_private *tp, dma_addr_t paddr)
+{
+        u32 cmd;
+        u32 WaitCnt;
+        int retval = -1;
+
+        RTL_W32(tp, CounterAddrHigh, (u64)paddr >> 32);
+        cmd = (u64)paddr & DMA_BIT_MASK(32);
+        RTL_W32(tp, CounterAddrLow, cmd);
+        RTL_W32(tp, CounterAddrLow, cmd | CounterDump);
+
+        WaitCnt = 0;
+        while (RTL_R32(tp, CounterAddrLow) & CounterDump) {
+                udelay(10);
+
+                WaitCnt++;
+                if (WaitCnt > 20)
+                        break;
+        }
+
+        if (WaitCnt <= 20)
+                retval = 0;
+
+        return retval;
+}
+
+static u32
+rtl8125_get_hw_clo_ptr(struct rtl8125_tx_ring *ring)
+{
+        struct rtl8125_private *tp = ring->priv;
+
+        if (!tp)
+                return 0;
+
+        switch (tp->HwSuppTxNoCloseVer) {
+        case 3:
+                return RTL_R16(tp, ring->hw_clo_ptr_reg);
+        case 4:
+        case 5:
+        case 6:
+                return RTL_R32(tp, ring->hw_clo_ptr_reg);
+        default:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                WARN_ON(1);
+#endif
+                return 0;
+        }
+}
+
+static u32
+rtl8125_get_sw_tail_ptr(struct rtl8125_tx_ring *ring)
+{
+        struct rtl8125_private *tp = ring->priv;
+
+        if (!tp)
+                return 0;
+
+        switch (tp->HwSuppTxNoCloseVer) {
+        case 3:
+                return RTL_R16(tp, ring->sw_tail_ptr_reg);
+        case 4:
+        case 5:
+        case 6:
+                return RTL_R32(tp, ring->sw_tail_ptr_reg);
+        default:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                WARN_ON(1);
+#endif
+                return 0;
+        }
+}
+
+static u32
+rtl8125_get_phy_status(struct rtl8125_private *tp)
+{
+        return RTL_R32(tp, PHYstatus);
+}
+
+static bool
+rtl8125_sysfs_testmode_on(struct rtl8125_private *tp)
+{
+#ifdef ENABLE_R8125_SYSFS
+        return !!tp->testmode;
+#else
+        return 1;
+#endif
+}
+
+static u32 rtl8125_convert_link_speed(u32 status)
+{
+        u32 speed = SPEED_UNKNOWN;
+
+        if (status & LinkStatus) {
+                if (status & _2500bpsF)
+                        speed = SPEED_2500;
+                else if (status & (_1000bpsF | _2500bpsL | _1000bpsL))
+                        speed = SPEED_1000;
+                else if (status & _100bps)
+                        speed = SPEED_100;
+                else if (status & _10bps)
+                        speed = SPEED_10;
+        }
+
+        return speed;
+}
+
+static void rtl8125_mdi_swap(struct rtl8125_private *tp)
+{
+        int i;
+        u16 reg, val, mdi_reverse;
+        u16 tps_p0, tps_p1, tps_p2, tps_p3, tps_p3_p0;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                reg = 0x8284;
+                break;
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                reg = 0x81aa;
+                break;
+        default:
+                return;
+        };
+
+        tps_p3_p0 = rtl8125_mac_ocp_read(tp, 0xD440) & 0xF000;
+        tps_p3 = !!(tps_p3_p0 & BIT_15);
+        tps_p2 = !!(tps_p3_p0 & BIT_14);
+        tps_p1 = !!(tps_p3_p0 & BIT_13);
+        tps_p0 = !!(tps_p3_p0 & BIT_12);
+        mdi_reverse = rtl8125_mac_ocp_read(tp, 0xD442);
+
+        if ((mdi_reverse & BIT_5) && tps_p3_p0 == 0xA000)
+                return;
+
+        if (!(mdi_reverse & BIT_5))
+                val = tps_p0 << 8 |
+                      tps_p1 << 9 |
+                      tps_p2 << 10 |
+                      tps_p3 << 11;
+        else
+                val = tps_p3 << 8 |
+                      tps_p2 << 9 |
+                      tps_p1 << 10 |
+                      tps_p0 << 11;
+
+        for (i=8; i<12; i++) {
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, reg);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xA438,
+                                                      BIT(i),
+                                                      val & BIT(i));
+        }
+}
+
+static int _rtl8125_vcd_test(struct rtl8125_private *tp)
+{
+        u16 val;
+        u32 wait_cnt;
+        int ret = -1;
+
+        rtl8125_mdi_swap(tp);
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA422, BIT(0));
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA422, 0x00F0);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA422, BIT(0));
+
+        wait_cnt = 0;
+        do {
+                mdelay(1);
+                val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA422);
+                wait_cnt++;
+        } while (!(val & BIT_15) && (wait_cnt < 5000));
+
+        if (wait_cnt == 5000)
+                goto exit;
+
+        ret = 0;
+
+exit:
+        return ret;
+}
+
+static int rtl8125_vcd_test(struct rtl8125_private *tp, bool poe_mode)
+{
+        int ret;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                /* update rtct threshold for poe mode */
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FE1);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, poe_mode ? 0x0A44 : 0x0000);
+
+                /* enable rtct poe mode */
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FE3);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, poe_mode ? 0x0100 : 0x0000);
+
+                ret = _rtl8125_vcd_test(tp);
+
+                /* disable rtct poe mode */
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FE3);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+
+                /* restore rtct threshold */
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FE1);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+                break;
+        default:
+                ret = _rtl8125_vcd_test(tp);
+                break;
+        }
+
+        return ret;
+}
+
+static void rtl8125_get_cp_len(struct rtl8125_private *tp,
+                               int cp_len[RTL8125_CP_NUM])
+{
+        int i;
+        u32 status;
+        int tmp_cp_len;
+
+        status = rtl8125_get_phy_status(tp);
+        if (status & LinkStatus) {
+                if (status & _10bps) {
+                        tmp_cp_len = -1;
+                } else if (status & (_100bps | _1000bpsF)) {
+                        rtl8125_mdio_write(tp, 0x1f, 0x0a88);
+                        tmp_cp_len = rtl8125_mdio_read(tp, 0x10);
+                } else if (status & _2500bpsF) {
+                        switch (tp->mcfg) {
+                        case CFG_METHOD_2:
+                        case CFG_METHOD_3:
+                        case CFG_METHOD_6:
+                                rtl8125_mdio_write(tp, 0x1f, 0x0ac5);
+                                tmp_cp_len = rtl8125_mdio_read(tp, 0x14);
+                                tmp_cp_len >>= 4;
+                                break;
+                        default:
+                                rtl8125_mdio_write(tp, 0x1f, 0x0acb);
+                                tmp_cp_len = rtl8125_mdio_read(tp, 0x15);
+                                tmp_cp_len >>= 2;
+                                break;
+                        }
+                } else
+                        tmp_cp_len = 0;
+        } else
+                tmp_cp_len = 0;
+
+        if (tmp_cp_len > 0)
+                tmp_cp_len &= 0xff;
+        for (i=0; i<RTL8125_CP_NUM; i++)
+                cp_len[i] = tmp_cp_len;
+
+        rtl8125_mdio_write(tp, 0x1f, 0x0000);
+
+        for (i=0; i<RTL8125_CP_NUM; i++)
+                if (cp_len[i] > RTL8125_MAX_SUPPORT_CP_LEN)
+                        cp_len[i] = RTL8125_MAX_SUPPORT_CP_LEN;
+
+        return;
+}
+
+static int __rtl8125_get_cp_status(u16 val)
+{
+        switch (val) {
+        case 0x0060:
+                return rtl8125_cp_normal;
+        case 0x0048:
+                return rtl8125_cp_open;
+        case 0x0050:
+                return rtl8125_cp_short;
+        case 0x0042:
+        case 0x0044:
+                return rtl8125_cp_mismatch;
+        default:
+                return rtl8125_cp_normal;
+        }
+}
+
+static int _rtl8125_get_cp_status(struct rtl8125_private *tp, u8 pair_num)
+{
+        u16 val;
+        int cp_status = rtl8125_cp_unknown;
+
+        if (pair_num > 3)
+                goto exit;
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8027 + 4 * pair_num);
+        val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA438);
+
+        cp_status = __rtl8125_get_cp_status(val);
+
+exit:
+        return cp_status;
+}
+
+static const char * rtl8125_get_cp_status_string(int cp_status)
+{
+        switch(cp_status) {
+        case rtl8125_cp_normal:
+                return "normal  ";
+        case rtl8125_cp_short:
+                return "short   ";
+        case rtl8125_cp_open:
+                return "open    ";
+        case rtl8125_cp_mismatch:
+                return "mismatch";
+        default:
+                return "unknown ";
+        }
+}
+
+static u16 rtl8125_get_cp_pp(struct rtl8125_private *tp, u8 pair_num)
+{
+        u16 pp = 0;
+
+        if (pair_num > 3)
+                goto exit;
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8029 + 4 * pair_num);
+        pp = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA438);
+
+        pp &= 0x3fff;
+        pp /= 80;
+
+exit:
+        return pp;
+}
+
+static void rtl8125_get_cp_status(struct rtl8125_private *tp,
+                                  int cp_status[RTL8125_CP_NUM],
+                                  bool poe_mode)
+{
+        u32 status;
+        int i;
+
+        status = rtl8125_get_phy_status(tp);
+        if (status & LinkStatus && !(status & (_10bps | _100bps))) {
+                for (i=0; i<RTL8125_CP_NUM; i++)
+                        cp_status[i] = rtl8125_cp_normal;
+        } else {
+                /* cannot do vcd when link is on */
+                rtl8125_vcd_test(tp, poe_mode);
+
+                for (i=0; i<RTL8125_CP_NUM; i++)
+                        cp_status[i] = _rtl8125_get_cp_status(tp, i);
+        }
+
+        if (poe_mode) {
+                for (i=0; i<RTL8125_CP_NUM; i++) {
+                        if (cp_status[i] == rtl8125_cp_mismatch)
+                                cp_status[i] = rtl8125_cp_normal;
+                }
+        }
+}
+
+static int rtl8125_cel_to_fah(int cel)
+{
+        return (cel * 9 / 5) + 32;
+}
+
+#ifdef ENABLE_R8125_PROCFS
+/****************************************************************************
+*   -----------------------------PROCFS STUFF-------------------------
+*****************************************************************************
+*/
+
+static struct proc_dir_entry *rtl8125_proc;
+static int proc_init_num = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+static int proc_get_driver_variable(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump Driver Variable\n");
+
+        rtnl_lock();
+
+        seq_puts(m, "Variable\tValue\n----------\t-----\n");
+        seq_printf(m, "MODULENAME\t%s\n", MODULENAME);
+        seq_printf(m, "driver version\t%s\n", RTL8125_VERSION);
+        seq_printf(m, "mcfg\t%d\n", tp->mcfg);
+        seq_printf(m, "chipset\t%d\n", tp->chipset);
+        seq_printf(m, "chipset_name\t%s\n", rtl_chip_info[tp->chipset].name);
+        seq_printf(m, "mtu\t%d\n", dev->mtu);
+        seq_printf(m, "NUM_RX_DESC\t0x%x\n", tp->rx_ring[0].num_rx_desc);
+        seq_printf(m, "cur_rx0\t0x%x\n", tp->rx_ring[0].cur_rx);
+        seq_printf(m, "dirty_rx0\t0x%x\n", tp->rx_ring[0].dirty_rx);
+        seq_printf(m, "cur_rx1\t0x%x\n", tp->rx_ring[1].cur_rx);
+        seq_printf(m, "dirty_rx1\t0x%x\n", tp->rx_ring[1].dirty_rx);
+        seq_printf(m, "cur_rx2\t0x%x\n", tp->rx_ring[2].cur_rx);
+        seq_printf(m, "dirty_rx2\t0x%x\n", tp->rx_ring[2].dirty_rx);
+        seq_printf(m, "cur_rx3\t0x%x\n", tp->rx_ring[3].cur_rx);
+        seq_printf(m, "dirty_rx3\t0x%x\n", tp->rx_ring[3].dirty_rx);
+        seq_printf(m, "NUM_TX_DESC\t0x%x\n", tp->tx_ring[0].num_tx_desc);
+        seq_printf(m, "cur_tx0\t0x%x\n", tp->tx_ring[0].cur_tx);
+        seq_printf(m, "dirty_tx0\t0x%x\n", tp->tx_ring[0].dirty_tx);
+        seq_printf(m, "cur_tx1\t0x%x\n", tp->tx_ring[1].cur_tx);
+        seq_printf(m, "dirty_tx1\t0x%x\n", tp->tx_ring[1].dirty_tx);
+        seq_printf(m, "rx_buf_sz\t0x%x\n", tp->rx_buf_sz);
+#ifdef ENABLE_PAGE_REUSE
+        seq_printf(m, "rx_buf_page_order\t0x%x\n", tp->rx_buf_page_order);
+        seq_printf(m, "rx_buf_page_size\t0x%x\n", tp->rx_buf_page_size);
+        seq_printf(m, "page_reuse_fail_cnt\t0x%x\n", tp->page_reuse_fail_cnt);
+#endif //ENABLE_PAGE_REUSE
+        seq_printf(m, "esd_flag\t0x%x\n", tp->esd_flag);
+        seq_printf(m, "pci_cfg_is_read\t0x%x\n", tp->pci_cfg_is_read);
+        seq_printf(m, "rtl8125_rx_config\t0x%x\n", tp->rtl8125_rx_config);
+        seq_printf(m, "cp_cmd\t0x%x\n", tp->cp_cmd);
+        seq_printf(m, "intr_mask\t0x%x\n", tp->intr_mask);
+        seq_printf(m, "timer_intr_mask\t0x%x\n", tp->timer_intr_mask);
+        seq_printf(m, "wol_enabled\t0x%x\n", tp->wol_enabled);
+        seq_printf(m, "wol_opts\t0x%x\n", tp->wol_opts);
+        seq_printf(m, "efuse_ver\t0x%x\n", tp->efuse_ver);
+        seq_printf(m, "eeprom_type\t0x%x\n", tp->eeprom_type);
+        seq_printf(m, "autoneg\t0x%x\n", tp->autoneg);
+        seq_printf(m, "duplex\t0x%x\n", tp->duplex);
+        seq_printf(m, "speed\t%d\n", tp->speed);
+        seq_printf(m, "advertising\t0x%llx\n", tp->advertising);
+        seq_printf(m, "eeprom_len\t0x%x\n", tp->eeprom_len);
+        seq_printf(m, "cur_page\t0x%x\n", tp->cur_page);
+        seq_printf(m, "features\t0x%x\n", tp->features);
+        seq_printf(m, "org_pci_offset_99\t0x%x\n", tp->org_pci_offset_99);
+        seq_printf(m, "org_pci_offset_180\t0x%x\n", tp->org_pci_offset_180);
+        seq_printf(m, "issue_offset_99_event\t0x%x\n", tp->issue_offset_99_event);
+        seq_printf(m, "org_pci_offset_80\t0x%x\n", tp->org_pci_offset_80);
+        seq_printf(m, "org_pci_offset_81\t0x%x\n", tp->org_pci_offset_81);
+        seq_printf(m, "use_timer_interrupt\t0x%x\n", tp->use_timer_interrupt);
+        seq_printf(m, "HwIcVerUnknown\t0x%x\n", tp->HwIcVerUnknown);
+        seq_printf(m, "NotWrRamCodeToMicroP\t0x%x\n", tp->NotWrRamCodeToMicroP);
+        seq_printf(m, "NotWrMcuPatchCode\t0x%x\n", tp->NotWrMcuPatchCode);
+        seq_printf(m, "HwHasWrRamCodeToMicroP\t0x%x\n", tp->HwHasWrRamCodeToMicroP);
+        seq_printf(m, "sw_ram_code_ver\t0x%x\n", tp->sw_ram_code_ver);
+        seq_printf(m, "hw_ram_code_ver\t0x%x\n", tp->hw_ram_code_ver);
+        seq_printf(m, "rtk_enable_diag\t0x%x\n", tp->rtk_enable_diag);
+        seq_printf(m, "ShortPacketSwChecksum\t0x%x\n", tp->ShortPacketSwChecksum);
+        seq_printf(m, "UseSwPaddingShortPkt\t0x%x\n", tp->UseSwPaddingShortPkt);
+        seq_printf(m, "RequireAdcBiasPatch\t0x%x\n", tp->RequireAdcBiasPatch);
+        seq_printf(m, "AdcBiasPatchIoffset\t0x%x\n", tp->AdcBiasPatchIoffset);
+        seq_printf(m, "RequireAdjustUpsTxLinkPulseTiming\t0x%x\n", tp->RequireAdjustUpsTxLinkPulseTiming);
+        seq_printf(m, "SwrCnt1msIni\t0x%x\n", tp->SwrCnt1msIni);
+        seq_printf(m, "HwSuppNowIsOobVer\t0x%x\n", tp->HwSuppNowIsOobVer);
+        seq_printf(m, "HwFiberModeVer\t0x%x\n", tp->HwFiberModeVer);
+        seq_printf(m, "HwFiberStat\t0x%x\n", tp->HwFiberStat);
+        seq_printf(m, "HwSwitchMdiToFiber\t0x%x\n", tp->HwSwitchMdiToFiber);
+        seq_printf(m, "Led0\t0x%x\n", tp->BackupLedSel[0]);
+        seq_printf(m, "RequiredSecLanDonglePatch\t0x%x\n", tp->RequiredSecLanDonglePatch);
+        seq_printf(m, "RequiredPfmPatch\t0x%x\n", tp->RequiredPfmPatch);
+        seq_printf(m, "HwSuppDashVer\t0x%x\n", tp->HwSuppDashVer);
+        seq_printf(m, "DASH\t0x%x\n", tp->DASH);
+        seq_printf(m, "DashFirmwareVersion\t0x%x\n", tp->DashFirmwareVersion);
+        seq_printf(m, "HwSuppKCPOffloadVer\t0x%x\n", tp->HwSuppKCPOffloadVer);
+        seq_printf(m, "speed_mode\t0x%x\n", speed_mode);
+        seq_printf(m, "duplex_mode\t0x%x\n", duplex_mode);
+        seq_printf(m, "autoneg_mode\t0x%x\n", autoneg_mode);
+        seq_printf(m, "aspm\t0x%x\n", aspm);
+        seq_printf(m, "s5wol\t0x%x\n", s5wol);
+        seq_printf(m, "s5_keep_curr_mac\t0x%x\n", s5_keep_curr_mac);
+        seq_printf(m, "eee_enable\t0x%x\n", tp->eee.eee_enabled);
+        seq_printf(m, "hwoptimize\t0x%lx\n", hwoptimize);
+        seq_printf(m, "proc_init_num\t0x%x\n", proc_init_num);
+        seq_printf(m, "s0_magic_packet\t0x%x\n", s0_magic_packet);
+        seq_printf(m, "disable_wol_support\t0x%x\n", disable_wol_support);
+        seq_printf(m, "enable_double_vlan\t0x%x\n", enable_double_vlan);
+        seq_printf(m, "eee_giga_lite\t0x%x\n", eee_giga_lite);
+        seq_printf(m, "HwSuppMagicPktVer\t0x%x\n", tp->HwSuppMagicPktVer);
+        seq_printf(m, "HwSuppEsdVer\t0x%x\n", tp->HwSuppEsdVer);
+        seq_printf(m, "HwSuppLinkChgWakeUpVer\t0x%x\n", tp->HwSuppLinkChgWakeUpVer);
+        seq_printf(m, "HwSuppD0SpeedUpVer\t0x%x\n", tp->HwSuppD0SpeedUpVer);
+        seq_printf(m, "D0SpeedUpSpeed\t0x%x\n", tp->D0SpeedUpSpeed);
+        seq_printf(m, "HwSuppCheckPhyDisableModeVer\t0x%x\n", tp->HwSuppCheckPhyDisableModeVer);
+        seq_printf(m, "HwPkgDet\t0x%x\n", tp->HwPkgDet);
+        seq_printf(m, "HwSuppTxNoCloseVer\t0x%x\n", tp->HwSuppTxNoCloseVer);
+        seq_printf(m, "EnableTxNoClose\t0x%x\n", tp->EnableTxNoClose);
+        seq_printf(m, "NextHwDesCloPtr0\t0x%x\n", tp->tx_ring[0].NextHwDesCloPtr);
+        seq_printf(m, "BeginHwDesCloPtr0\t0x%x\n", tp->tx_ring[0].BeginHwDesCloPtr);
+        seq_printf(m, "hw_clo_ptr_reg0\t0x%x\n", rtl8125_get_hw_clo_ptr(&tp->tx_ring[0]));
+        seq_printf(m, "sw_tail_ptr_reg0\t0x%x\n", rtl8125_get_sw_tail_ptr(&tp->tx_ring[0]));
+        seq_printf(m, "NextHwDesCloPtr1\t0x%x\n", tp->tx_ring[1].NextHwDesCloPtr);
+        seq_printf(m, "BeginHwDesCloPtr1\t0x%x\n", tp->tx_ring[1].BeginHwDesCloPtr);
+        seq_printf(m, "hw_clo_ptr_reg1\t0x%x\n", rtl8125_get_hw_clo_ptr(&tp->tx_ring[1]));
+        seq_printf(m, "sw_tail_ptr_reg1\t0x%x\n", rtl8125_get_sw_tail_ptr(&tp->tx_ring[1]));
+        seq_printf(m, "InitRxDescType\t0x%x\n", tp->InitRxDescType);
+        seq_printf(m, "RxDescLength\t0x%x\n", tp->RxDescLength);
+        seq_printf(m, "num_rx_rings\t0x%x\n", tp->num_rx_rings);
+        seq_printf(m, "num_tx_rings\t0x%x\n", tp->num_tx_rings);
+        seq_printf(m, "tot_rx_rings\t0x%x\n", rtl8125_tot_rx_rings(tp));
+        seq_printf(m, "tot_tx_rings\t0x%x\n", rtl8125_tot_tx_rings(tp));
+        seq_printf(m, "HwSuppNumRxQueues\t0x%x\n", tp->HwSuppNumRxQueues);
+        seq_printf(m, "HwSuppNumTxQueues\t0x%x\n", tp->HwSuppNumTxQueues);
+        seq_printf(m, "EnableRss\t0x%x\n", tp->EnableRss);
+        seq_printf(m, "EnablePtp\t0x%x\n", tp->EnablePtp);
+        seq_printf(m, "ptp_master_mode\t0x%x\n", tp->ptp_master_mode);
+        seq_printf(m, "min_irq_nvecs\t0x%x\n", tp->min_irq_nvecs);
+        seq_printf(m, "irq_nvecs\t0x%x\n", tp->irq_nvecs);
+        seq_printf(m, "hw_supp_irq_nvecs\t0x%x\n", tp->hw_supp_irq_nvecs);
+        seq_printf(m, "ring_lib_enabled\t0x%x\n", tp->ring_lib_enabled);
+        seq_printf(m, "HwSuppIsrVer\t0x%x\n", tp->HwSuppIsrVer);
+        seq_printf(m, "HwCurrIsrVer\t0x%x\n", tp->HwCurrIsrVer);
+        seq_printf(m, "HwSuppMacMcuVer\t0x%x\n", tp->HwSuppMacMcuVer);
+        seq_printf(m, "MacMcuPageSize\t0x%x\n", tp->MacMcuPageSize);
+        seq_printf(m, "hw_mcu_patch_code_ver\t0x%llx\n", tp->hw_mcu_patch_code_ver);
+        seq_printf(m, "bin_mcu_patch_code_ver\t0x%llx\n", tp->bin_mcu_patch_code_ver);
+#ifdef ENABLE_PTP_SUPPORT
+        seq_printf(m, "tx_hwtstamp_timeouts\t0x%x\n", tp->tx_hwtstamp_timeouts);
+        seq_printf(m, "tx_hwtstamp_skipped\t0x%x\n", tp->tx_hwtstamp_skipped);
+#endif
+        seq_printf(m, "random_mac\t0x%x\n", tp->random_mac);
+        seq_printf(m, "org_mac_addr\t%pM\n", tp->org_mac_addr);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+        seq_printf(m, "perm_addr\t%pM\n", dev->perm_addr);
+#endif
+        seq_printf(m, "dev_addr\t%pM\n", dev->dev_addr);
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_tally_counter(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct rtl8125_counters *counters;
+        dma_addr_t paddr;
+
+        seq_puts(m, "\nDump Tally Counter\n");
+
+        rtnl_lock();
+
+        counters = tp->tally_vaddr;
+        paddr = tp->tally_paddr;
+        if (!counters) {
+                seq_puts(m, "\nDump Tally Counter Fail\n");
+                goto out_unlock;
+        }
+
+        rtl8125_dump_tally_counter(tp, paddr);
+
+        seq_puts(m, "Statistics\tValue\n----------\t-----\n");
+        seq_printf(m, "tx_packets\t%lld\n", le64_to_cpu(counters->tx_packets));
+        seq_printf(m, "rx_packets\t%lld\n", le64_to_cpu(counters->rx_packets));
+        seq_printf(m, "tx_errors\t%lld\n", le64_to_cpu(counters->tx_errors));
+        seq_printf(m, "rx_errors\t%d\n", le32_to_cpu(counters->rx_errors));
+        seq_printf(m, "rx_missed\t%d\n", le16_to_cpu(counters->rx_missed));
+        seq_printf(m, "align_errors\t%d\n", le16_to_cpu(counters->align_errors));
+        seq_printf(m, "tx_one_collision\t%d\n", le32_to_cpu(counters->tx_one_collision));
+        seq_printf(m, "tx_multi_collision\t%d\n", le32_to_cpu(counters->tx_multi_collision));
+        seq_printf(m, "rx_unicast\t%lld\n", le64_to_cpu(counters->rx_unicast));
+        seq_printf(m, "rx_broadcast\t%lld\n", le64_to_cpu(counters->rx_broadcast));
+        seq_printf(m, "rx_multicast\t%d\n", le32_to_cpu(counters->rx_multicast));
+        seq_printf(m, "tx_aborted\t%d\n", le16_to_cpu(counters->tx_aborted));
+        seq_printf(m, "tx_underrun\t%d\n", le16_to_cpu(counters->tx_underrun));
+
+        seq_printf(m, "tx_octets\t%lld\n", le64_to_cpu(counters->tx_octets));
+        seq_printf(m, "rx_octets\t%lld\n", le64_to_cpu(counters->rx_octets));
+        seq_printf(m, "rx_multicast64\t%lld\n", le64_to_cpu(counters->rx_multicast64));
+        seq_printf(m, "tx_unicast64\t%lld\n", le64_to_cpu(counters->tx_unicast64));
+        seq_printf(m, "tx_broadcast64\t%lld\n", le64_to_cpu(counters->tx_broadcast64));
+        seq_printf(m, "tx_multicast64\t%lld\n", le64_to_cpu(counters->tx_multicast64));
+        seq_printf(m, "tx_pause_on\t%d\n", le32_to_cpu(counters->tx_pause_on));
+        seq_printf(m, "tx_pause_off\t%d\n", le32_to_cpu(counters->tx_pause_off));
+        seq_printf(m, "tx_pause_all\t%d\n", le32_to_cpu(counters->tx_pause_all));
+        seq_printf(m, "tx_deferred\t%d\n", le32_to_cpu(counters->tx_deferred));
+        seq_printf(m, "tx_late_collision\t%d\n", le32_to_cpu(counters->tx_late_collision));
+        seq_printf(m, "tx_all_collision\t%d\n", le32_to_cpu(counters->tx_all_collision));
+        seq_printf(m, "tx_aborted32\t%d\n", le32_to_cpu(counters->tx_aborted32));
+        seq_printf(m, "align_errors32\t%d\n", le32_to_cpu(counters->align_errors32));
+        seq_printf(m, "rx_frame_too_long\t%d\n", le32_to_cpu(counters->rx_frame_too_long));
+        seq_printf(m, "rx_runt\t%d\n", le32_to_cpu(counters->rx_runt));
+        seq_printf(m, "rx_pause_on\t%d\n", le32_to_cpu(counters->rx_pause_on));
+        seq_printf(m, "rx_pause_off\t%d\n", le32_to_cpu(counters->rx_pause_off));
+        seq_printf(m, "rx_pause_all\t%d\n", le32_to_cpu(counters->rx_pause_all));
+        seq_printf(m, "rx_unknown_opcode\t%d\n", le32_to_cpu(counters->rx_unknown_opcode));
+        seq_printf(m, "rx_mac_error\t%d\n", le32_to_cpu(counters->rx_mac_error));
+        seq_printf(m, "tx_underrun32\t%d\n", le32_to_cpu(counters->tx_underrun32));
+        seq_printf(m, "rx_mac_missed\t%d\n", le32_to_cpu(counters->rx_mac_missed));
+        seq_printf(m, "rx_tcam_dropped\t%d\n", le32_to_cpu(counters->rx_tcam_dropped));
+        seq_printf(m, "tdu\t%d\n", le32_to_cpu(counters->tdu));
+        seq_printf(m, "rdu\t%d\n", le32_to_cpu(counters->rdu));
+
+        seq_putc(m, '\n');
+
+out_unlock:
+        rtnl_unlock();
+
+        return 0;
+}
+
+static int proc_get_registers(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8125_MAC_REGS_SIZE;
+        u8 byte_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+
+        seq_puts(m, "\nDump MAC Registers\n");
+        seq_puts(m, "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%04x:\t", n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        seq_printf(m, "%02x ", byte_rd);
+                }
+        }
+
+        max = 0xB00;
+        for (n = 0xA00; n < max;) {
+                seq_printf(m, "\n0x%04x:\t", n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        seq_printf(m, "%02x ", byte_rd);
+                }
+        }
+
+        max = 0xD40;
+        for (n = 0xD00; n < max;) {
+                seq_printf(m, "\n0x%04x:\t", n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        seq_printf(m, "%02x ", byte_rd);
+                }
+        }
+
+        max = 0x2840;
+        for (n = 0x2800; n < max;) {
+                seq_printf(m, "\n0x%04x:\t", n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        seq_printf(m, "%02x ", byte_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_all_registers(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max;
+        u8 byte_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+        struct pci_dev *pdev = tp->pci_dev;
+
+        seq_puts(m, "\nDump All MAC Registers\n");
+        seq_puts(m, "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        max = pci_resource_len(pdev, 2);
+        max = min(max, 0x8000);
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%04x:\t", n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        seq_printf(m, "%02x ", byte_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        seq_printf(m, "\nTotal length:0x%X", max);
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_pcie_phy(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8125_EPHY_REGS_SIZE/2;
+        u16 word_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump PCIE PHY\n");
+        seq_puts(m, "\nOffset\tValue\n------\t-----\n ");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%02x:\t", n);
+
+                for (i = 0; i < 8 && n < max; i++, n++) {
+                        word_rd = rtl8125_ephy_read(tp, n);
+                        seq_printf(m, "%04x ", word_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_eth_phy(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8125_PHY_REGS_SIZE/2;
+        u16 word_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long flags;
+
+        seq_puts(m, "\nDump Ethernet PHY\n");
+        seq_puts(m, "\nOffset\tValue\n------\t-----\n ");
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        seq_puts(m, "\n####################page 0##################\n ");
+        rtl8125_mdio_write(tp, 0x1f, 0x0000);
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%02x:\t", n);
+
+                for (i = 0; i < 8 && n < max; i++, n++) {
+                        word_rd = rtl8125_mdio_read(tp, n);
+                        seq_printf(m, "%04x ", word_rd);
+                }
+        }
+
+        seq_puts(m, "\n####################extra reg##################\n ");
+        n = 0xA400;
+        seq_printf(m, "\n0x%02x:\t", n);
+        for (i = 0; i < 8; i++, n+=2) {
+                word_rd = rtl8125_mdio_direct_read_phy_ocp(tp, n);
+                seq_printf(m, "%04x ", word_rd);
+        }
+
+        n = 0xA410;
+        seq_printf(m, "\n0x%02x:\t", n);
+        for (i = 0; i < 3; i++, n+=2) {
+                word_rd = rtl8125_mdio_direct_read_phy_ocp(tp, n);
+                seq_printf(m, "%04x ", word_rd);
+        }
+
+        n = 0xA434;
+        seq_printf(m, "\n0x%02x:\t", n);
+        word_rd = rtl8125_mdio_direct_read_phy_ocp(tp, n);
+        seq_printf(m, "%04x ", word_rd);
+
+        n = 0xA5D0;
+        seq_printf(m, "\n0x%02x:\t", n);
+        for (i = 0; i < 4; i++, n+=2) {
+                word_rd = rtl8125_mdio_direct_read_phy_ocp(tp, n);
+                seq_printf(m, "%04x ", word_rd);
+        }
+
+        n = 0xA61A;
+        seq_printf(m, "\n0x%02x:\t", n);
+        word_rd = rtl8125_mdio_direct_read_phy_ocp(tp, n);
+        seq_printf(m, "%04x ", word_rd);
+
+        n = 0xA6D0;
+        seq_printf(m, "\n0x%02x:\t", n);
+        for (i = 0; i < 3; i++, n+=2) {
+                word_rd = rtl8125_mdio_direct_read_phy_ocp(tp, n);
+                seq_printf(m, "%04x ", word_rd);
+        }
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_extended_registers(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8125_ERI_REGS_SIZE;
+        u32 dword_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump Extended Registers\n");
+        seq_puts(m, "\nOffset\tValue\n------\t-----\n ");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%02x:\t", n);
+
+                for (i = 0; i < 4 && n < max; i++, n+=4) {
+                        dword_rd = rtl8125_eri_read(tp, n, 4, ERIAR_ExGMAC);
+                        seq_printf(m, "%08x ", dword_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_pci_registers(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8125_PCI_REGS_SIZE;
+        u32 dword_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump PCI Registers\n");
+        seq_puts(m, "\nOffset\tValue\n------\t-----\n ");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%03x:\t", n);
+
+                for (i = 0; i < 4 && n < max; i++, n+=4) {
+                        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+                        seq_printf(m, "%08x ", dword_rd);
+                }
+        }
+
+        n = 0x110;
+        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+        seq_printf(m, "\n0x%03x:\t%08x ", n, dword_rd);
+        n = 0x70c;
+        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+        seq_printf(m, "\n0x%03x:\t%08x ", n, dword_rd);
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_temperature(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long flags;
+        int cel, fah;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                seq_puts(m, "\nChip Temperature\n");
+                break;
+        default:
+                return -EOPNOTSUPP;
+        }
+
+        rtnl_lock();
+
+        if (!rtl8125_sysfs_testmode_on(tp)) {
+                seq_puts(m, "\nPlease turn on ""/sys/class/net/<iface>/rtk_adv/testmode"".\n\n");
+                rtnl_unlock();
+                return 0;
+        }
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        netif_testing_on(dev);
+        cel = rtl8125_read_thermal_sensor(tp);
+        netif_testing_off(dev);
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        rtnl_unlock();
+
+        fah = rtl8125_cel_to_fah(cel);
+
+        seq_printf(m, "Cel:%d\n", cel);
+        seq_printf(m, "Fah:%d\n", fah);
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int _proc_get_cable_info(struct seq_file *m, void *v, bool poe_mode)
+{
+        int i;
+        u32 status;
+        int cp_status[RTL8125_CP_NUM];
+        int cp_len[RTL8125_CP_NUM] = {0};
+        struct net_device *dev = m->private;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        const char *pair_str[RTL8125_CP_NUM] = {"1-2", "3-6", "4-5", "7-8"};
+        unsigned long flags;
+        int ret;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2 ... CFG_METHOD_7:
+                /* support */
+                break;
+        default:
+                ret = -EOPNOTSUPP;
+                goto error_out;
+        }
+
+        rtnl_lock();
+
+        if (!rtl8125_sysfs_testmode_on(tp)) {
+                seq_puts(m, "\nPlease turn on ""/sys/class/net/<iface>/rtk_adv/testmode"".\n\n");
+                ret = 0;
+                goto error_unlock;
+        }
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        if (rtl8125_mdio_read(tp, MII_BMCR) & BMCR_PDOWN) {
+                r8125_spin_unlock(&tp->phy_lock, flags);
+                ret = -EIO;
+                goto error_unlock;
+        }
+
+        netif_testing_on(dev);
+
+        status = rtl8125_get_phy_status(tp);
+        if (status & LinkStatus)
+                seq_printf(m, "\nlink speed:%d",
+                           rtl8125_convert_link_speed(status));
+        else
+                seq_puts(m, "\nlink status:off");
+
+        rtl8125_get_cp_len(tp, cp_len);
+
+        rtl8125_get_cp_status(tp, cp_status, poe_mode);
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        seq_puts(m, "\npair\tlength\tstatus   \tpp\n");
+
+        for (i=0; i<RTL8125_CP_NUM; i++) {
+                if (cp_len[i] < 0)
+                        seq_printf(m, "%s\t%s\t%s\t",
+                                   pair_str[i], "none",
+                                   rtl8125_get_cp_status_string(cp_status[i]));
+                else
+                        seq_printf(m, "%s\t%d\t%s\t",
+                                   pair_str[i], cp_len[i],
+                                   rtl8125_get_cp_status_string(cp_status[i]));
+                if (cp_status[i] == rtl8125_cp_normal)
+                        seq_printf(m, "none\n");
+                else
+                        seq_printf(m, "%dm\n", rtl8125_get_cp_pp(tp, i));
+        }
+
+        netif_testing_off(dev);
+
+        seq_putc(m, '\n');
+
+        ret = 0;
+
+error_unlock:
+        rtnl_unlock();
+
+error_out:
+        return ret;
+}
+
+static int proc_get_cable_info(struct seq_file *m, void *v)
+{
+        return _proc_get_cable_info(m, v, 0);
+}
+
+static int proc_get_poe_cable_info(struct seq_file *m, void *v)
+{
+        return _proc_get_cable_info(m, v, 1);
+}
+
+static void _proc_dump_desc(struct seq_file *m, void *desc_base, u32 alloc_size)
+{
+        u32 *pdword;
+        int i;
+
+        if (desc_base == NULL ||
+            alloc_size == 0)
+                return;
+
+        pdword = (u32*)desc_base;
+        for (i=0; i<(alloc_size/4); i++) {
+                if (!(i % 4))
+                        seq_printf(m, "\n%04x ", i);
+                seq_printf(m, "%08x ", pdword[i]);
+        }
+
+        seq_putc(m, '\n');
+        return;
+}
+
+static int proc_dump_rx_desc(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        rtnl_lock();
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
+
+                if (!ring)
+                        continue;
+
+                seq_printf(m, "\ndump rx %d desc:%d\n", i, ring->num_rx_desc);
+
+                _proc_dump_desc(m, (void*)ring->RxDescArray, ring->RxDescAllocSize);
+        }
+
+#ifdef ENABLE_LIB_SUPPORT
+        if (rtl8125_num_lib_rx_rings(tp) > 0) {
+                for (i = 0; i < tp->HwSuppNumRxQueues; i++) {
+                        struct rtl8125_ring *lib_ring = &tp->lib_rx_ring[i];
+                        if (lib_ring->enabled) {
+                                seq_printf(m, "\ndump lib rx %d desc:%d\n", i,
+                                           lib_ring->ring_size);
+                                _proc_dump_desc(m, (void*)lib_ring->desc_addr,
+                                                lib_ring->desc_size);
+                        }
+                }
+        }
+#endif //ENABLE_LIB_SUPPORT
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_dump_tx_desc(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        rtnl_lock();
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8125_tx_ring *ring = &tp->tx_ring[i];
+
+                if (!ring)
+                        continue;
+
+                seq_printf(m, "\ndump tx %d desc:%d\n", i, ring->num_tx_desc);
+
+                _proc_dump_desc(m, (void*)ring->TxDescArray, ring->TxDescAllocSize);
+        }
+
+#ifdef ENABLE_LIB_SUPPORT
+        if (rtl8125_num_lib_tx_rings(tp) > 0) {
+                for (i = 0; i < tp->HwSuppNumTxQueues; i++) {
+                        struct rtl8125_ring *lib_ring = &tp->lib_tx_ring[i];
+                        if (lib_ring->enabled) {
+                                seq_printf(m, "\ndump lib tx %d desc:%d\n", i,
+                                           lib_ring->ring_size);
+                                _proc_dump_desc(m, (void*)lib_ring->desc_addr,
+                                                lib_ring->desc_size);
+                        }
+                }
+        }
+#endif //ENABLE_LIB_SUPPORT
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_dump_msix_tbl(struct seq_file *m, void *v)
+{
+        int i, j;
+        void __iomem *ioaddr;
+        struct net_device *dev = m->private;
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        /* ioremap MMIO region */
+        ioaddr = ioremap(pci_resource_start(tp->pci_dev, 4), pci_resource_len(tp->pci_dev, 4));
+        if (!ioaddr)
+                return -EFAULT;
+
+        rtnl_lock();
+
+        seq_printf(m, "\ndump MSI-X Table. Total Entry %d. \n", tp->hw_supp_irq_nvecs);
+
+        for (i=0; i<tp->hw_supp_irq_nvecs; i++) {
+                seq_printf(m, "\n%04x ", i);
+                for (j=0; j<4; j++)
+                        seq_printf(m, "%08x ",
+                                   readl(ioaddr + i*0x10 + 4*j));
+        }
+
+        rtnl_unlock();
+
+        iounmap(ioaddr);
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+#else //LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+
+static int proc_get_driver_variable(char *page, char **start,
+                                    off_t offset, int count,
+                                    int *eof, void *data)
+{
+        struct net_device *dev = data;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump Driver Driver\n");
+
+        rtnl_lock();
+
+        len += snprintf(page + len, count - len,
+                        "Variable\tValue\n----------\t-----\n");
+
+        len += snprintf(page + len, count - len,
+                        "MODULENAME\t%s\n"
+                        "driver version\t%s\n"
+                        "mcfg\t%d\n"
+                        "chipset\t%d\n"
+                        "chipset_name\t%s\n"
+                        "mtu\t%d\n"
+                        "NUM_RX_DESC\t0x%x\n"
+                        "cur_rx0\t0x%x\n"
+                        "dirty_rx0\t0x%x\n"
+                        "cur_rx1\t0x%x\n"
+                        "dirty_rx1\t0x%x\n"
+                        "cur_rx2\t0x%x\n"
+                        "dirty_rx2\t0x%x\n"
+                        "cur_rx3\t0x%x\n"
+                        "dirty_rx3\t0x%x\n"
+                        "NUM_TX_DESC\t0x%x\n"
+                        "cur_tx0\t0x%x\n"
+                        "dirty_tx0\t0x%x\n"
+                        "cur_tx1\t0x%x\n"
+                        "dirty_tx1\t0x%x\n"
+                        "rx_buf_sz\t0x%x\n"
+#ifdef ENABLE_PAGE_REUSE
+                        "rx_buf_page_order\t0x%x\n"
+                        "rx_buf_page_size\t0x%x\n"
+                        "page_reuse_fail_cnt\t0x%x\n"
+#endif //ENABLE_PAGE_REUSE
+                        "esd_flag\t0x%x\n"
+                        "pci_cfg_is_read\t0x%x\n"
+                        "rtl8125_rx_config\t0x%x\n"
+                        "cp_cmd\t0x%x\n"
+                        "intr_mask\t0x%x\n"
+                        "timer_intr_mask\t0x%x\n"
+                        "wol_enabled\t0x%x\n"
+                        "wol_opts\t0x%x\n"
+                        "efuse_ver\t0x%x\n"
+                        "eeprom_type\t0x%x\n"
+                        "autoneg\t0x%x\n"
+                        "duplex\t0x%x\n"
+                        "speed\t%d\n"
+                        "advertising\t0x%llx\n"
+                        "eeprom_len\t0x%x\n"
+                        "cur_page\t0x%x\n"
+                        "features\t0x%x\n"
+                        "org_pci_offset_99\t0x%x\n"
+                        "org_pci_offset_180\t0x%x\n"
+                        "issue_offset_99_event\t0x%x\n"
+                        "org_pci_offset_80\t0x%x\n"
+                        "org_pci_offset_81\t0x%x\n"
+                        "use_timer_interrupt\t0x%x\n"
+                        "HwIcVerUnknown\t0x%x\n"
+                        "NotWrRamCodeToMicroP\t0x%x\n"
+                        "NotWrMcuPatchCode\t0x%x\n"
+                        "HwHasWrRamCodeToMicroP\t0x%x\n"
+                        "sw_ram_code_ver\t0x%x\n"
+                        "hw_ram_code_ver\t0x%x\n"
+                        "rtk_enable_diag\t0x%x\n"
+                        "ShortPacketSwChecksum\t0x%x\n"
+                        "UseSwPaddingShortPkt\t0x%x\n"
+                        "RequireAdcBiasPatch\t0x%x\n"
+                        "AdcBiasPatchIoffset\t0x%x\n"
+                        "RequireAdjustUpsTxLinkPulseTiming\t0x%x\n"
+                        "SwrCnt1msIni\t0x%x\n"
+                        "HwSuppNowIsOobVer\t0x%x\n"
+                        "HwFiberModeVer\t0x%x\n"
+                        "HwFiberStat\t0x%x\n"
+                        "HwSwitchMdiToFiber\t0x%x\n"
+                        "Led0\t0x%x\n"
+                        "RequiredSecLanDonglePatch\t0x%x\n"
+                        "RequiredPfmPatch\t0x%x\n"
+                        "HwSuppDashVer\t0x%x\n"
+                        "DASH\t0x%x\n"
+                        "DashFirmwareVersion\t0x%x\n"
+                        "HwSuppKCPOffloadVer\t0x%x\n"
+                        "speed_mode\t0x%x\n"
+                        "duplex_mode\t0x%x\n"
+                        "autoneg_mode\t0x%x\n"
+                        "aspm\t0x%x\n"
+                        "s5wol\t0x%x\n"
+                        "s5_keep_curr_mac\t0x%x\n"
+                        "eee_enable\t0x%x\n"
+                        "hwoptimize\t0x%lx\n"
+                        "proc_init_num\t0x%x\n"
+                        "s0_magic_packet\t0x%x\n"
+                        "disable_wol_support\t0x%x\n"
+                        "enable_double_vlan\t0x%x\n"
+                        "eee_giga_lite\t0x%x\n"
+                        "HwSuppMagicPktVer\t0x%x\n"
+                        "HwSuppEsdVer\t0x%x\n"
+                        "HwSuppLinkChgWakeUpVer\t0x%x\n"
+                        "HwSuppD0SpeedUpVer\t0x%x\n"
+                        "D0SpeedUpSpeed\t0x%x\n"
+                        "HwSuppCheckPhyDisableModeVer\t0x%x\n"
+                        "HwPkgDet\t0x%x\n"
+                        "HwSuppTxNoCloseVer\t0x%x\n"
+                        "EnableTxNoClose\t0x%x\n"
+                        "NextHwDesCloPtr0\t0x%x\n"
+                        "BeginHwDesCloPtr0\t0x%x\n"
+                        "hw_clo_ptr_reg0\t0x%x\n"
+                        "sw_tail_ptr_reg0\t0x%x\n"
+                        "NextHwDesCloPtr1\t0x%x\n"
+                        "BeginHwDesCloPtr1\t0x%x\n"
+                        "hw_clo_ptr_reg1\t0x%x\n"
+                        "sw_tail_ptr_reg1\t0x%x\n"
+                        "InitRxDescType\t0x%x\n"
+                        "RxDescLength\t0x%x\n"
+                        "num_rx_rings\t0x%x\n"
+                        "num_tx_rings\t0x%x\n"
+                        "tot_rx_rings\t0x%x\n"
+                        "tot_tx_rings\t0x%x\n"
+                        "HwSuppNumRxQueues\t0x%x\n"
+                        "HwSuppNumTxQueues\t0x%x\n"
+                        "EnableRss\t0x%x\n"
+                        "EnablePtp\t0x%x\n"
+                        "ptp_master_mode\t0x%x\n"
+                        "min_irq_nvecs\t0x%x\n"
+                        "irq_nvecs\t0x%x\n"
+                        "hw_supp_irq_nvecs\t0x%x\n"
+                        "ring_lib_enabled\t0x%x\n"
+                        "HwSuppIsrVer\t0x%x\n"
+                        "HwCurrIsrVer\t0x%x\n"
+                        "HwSuppMacMcuVer\t0x%x\n"
+                        "MacMcuPageSize\t0x%x\n"
+                        "hw_mcu_patch_code_ver\t0x%llx\n"
+                        "bin_mcu_patch_code_ver\t0x%llx\n"
+#ifdef ENABLE_PTP_SUPPORT
+                        "tx_hwtstamp_timeouts\t0x%x\n"
+                        "tx_hwtstamp_skipped\t0x%x\n"
+#endif
+                        "random_mac\t0x%x\n"
+                        "org_mac_addr\t%pM\n"
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+                        "perm_addr\t%pM\n"
+#endif
+                        "dev_addr\t%pM\n",
+                        MODULENAME,
+                        RTL8125_VERSION,
+                        tp->mcfg,
+                        tp->chipset,
+                        rtl_chip_info[tp->chipset].name,
+                        dev->mtu,
+                        tp->rx_ring[0].num_rx_desc,
+                        tp->rx_ring[0].cur_rx,
+                        tp->rx_ring[0].dirty_rx,
+                        tp->rx_ring[1].cur_rx,
+                        tp->rx_ring[1].dirty_rx,
+                        tp->rx_ring[2].cur_rx,
+                        tp->rx_ring[2].dirty_rx,
+                        tp->rx_ring[3].cur_rx,
+                        tp->rx_ring[3].dirty_rx,
+                        tp->tx_ring[0].num_tx_desc,
+                        tp->tx_ring[0].cur_tx,
+                        tp->tx_ring[0].dirty_tx,
+                        tp->tx_ring[1].cur_tx,
+                        tp->tx_ring[1].dirty_tx,
+                        tp->rx_buf_sz,
+#ifdef ENABLE_PAGE_REUSE
+                        tp->rx_buf_page_order,
+                        tp->rx_buf_page_size,
+                        tp->page_reuse_fail_cnt,
+#endif //ENABLE_PAGE_REUSE
+                        tp->esd_flag,
+                        tp->pci_cfg_is_read,
+                        tp->rtl8125_rx_config,
+                        tp->cp_cmd,
+                        tp->intr_mask,
+                        tp->timer_intr_mask,
+                        tp->wol_enabled,
+                        tp->wol_opts,
+                        tp->efuse_ver,
+                        tp->eeprom_type,
+                        tp->autoneg,
+                        tp->duplex,
+                        tp->speed,
+                        tp->advertising,
+                        tp->eeprom_len,
+                        tp->cur_page,
+                        tp->features,
+                        tp->org_pci_offset_99,
+                        tp->org_pci_offset_180,
+                        tp->issue_offset_99_event,
+                        tp->org_pci_offset_80,
+                        tp->org_pci_offset_81,
+                        tp->use_timer_interrupt,
+                        tp->HwIcVerUnknown,
+                        tp->NotWrRamCodeToMicroP,
+                        tp->NotWrMcuPatchCode,
+                        tp->HwHasWrRamCodeToMicroP,
+                        tp->sw_ram_code_ver,
+                        tp->hw_ram_code_ver,
+                        tp->rtk_enable_diag,
+                        tp->ShortPacketSwChecksum,
+                        tp->UseSwPaddingShortPkt,
+                        tp->RequireAdcBiasPatch,
+                        tp->AdcBiasPatchIoffset,
+                        tp->RequireAdjustUpsTxLinkPulseTiming,
+                        tp->SwrCnt1msIni,
+                        tp->HwSuppNowIsOobVer,
+                        tp->HwFiberModeVer,
+                        tp->HwFiberStat,
+                        tp->HwSwitchMdiToFiber,
+                        tp->BackupLedSel[0],
+                        tp->RequiredSecLanDonglePatch,
+                        tp->RequiredPfmPatch,
+                        tp->HwSuppDashVer,
+                        tp->DASH,
+                        tp->DashFirmwareVersion,
+                        tp->HwSuppKCPOffloadVer,
+                        speed_mode,
+                        duplex_mode,
+                        autoneg_mode,
+                        aspm,
+                        s5wol,
+                        s5_keep_curr_mac,
+                        tp->eee.eee_enabled,
+                        hwoptimize,
+                        proc_init_num,
+                        s0_magic_packet,
+                        disable_wol_support,
+                        enable_double_vlan,
+                        eee_giga_lite,
+                        tp->HwSuppMagicPktVer,
+                        tp->HwSuppEsdVer,
+                        tp->HwSuppLinkChgWakeUpVer,
+                        tp->HwSuppD0SpeedUpVer,
+                        tp->D0SpeedUpSpeed,
+                        tp->HwSuppCheckPhyDisableModeVer,
+                        tp->HwPkgDet,
+                        tp->HwSuppTxNoCloseVer,
+                        tp->EnableTxNoClose,
+                        tp->tx_ring[0].NextHwDesCloPtr,
+                        tp->tx_ring[0].BeginHwDesCloPtr,
+                        rtl8125_get_hw_clo_ptr(&tp->tx_ring[0]),
+                        rtl8125_get_sw_tail_ptr(&tp->tx_ring[0]),
+                        tp->tx_ring[1].NextHwDesCloPtr,
+                        tp->tx_ring[1].BeginHwDesCloPtr,
+                        rtl8125_get_hw_clo_ptr(&tp->tx_ring[1]),
+                        rtl8125_get_sw_tail_ptr(&tp->tx_ring[1]),
+                        tp->InitRxDescType,
+                        tp->RxDescLength,
+                        tp->num_rx_rings,
+                        tp->num_tx_rings,
+                        rtl8125_tot_rx_rings(tp),
+                        rtl8125_tot_tx_rings(tp),
+                        tp->HwSuppNumRxQueues,
+                        tp->HwSuppNumTxQueues,
+                        tp->EnableRss,
+                        tp->EnablePtp,
+                        tp->ptp_master_mode,
+                        tp->min_irq_nvecs,
+                        tp->irq_nvecs,
+                        tp->hw_supp_irq_nvecs,
+                        tp->ring_lib_enabled,
+                        tp->HwSuppIsrVer,
+                        tp->HwCurrIsrVer,
+                        tp->HwSuppMacMcuVer,
+                        tp->MacMcuPageSize,
+                        tp->hw_mcu_patch_code_ver,
+                        tp->bin_mcu_patch_code_ver,
+#ifdef ENABLE_PTP_SUPPORT
+                        tp->tx_hwtstamp_timeouts,
+                        tp->tx_hwtstamp_skipped,
+#endif
+                        tp->random_mac,
+                        tp->org_mac_addr,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+                        dev->perm_addr,
+#endif
+                        dev->dev_addr);
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_tally_counter(char *page, char **start,
+                                  off_t offset, int count,
+                                  int *eof, void *data)
+{
+        struct net_device *dev = data;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct rtl8125_counters *counters;
+        dma_addr_t paddr;
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump Tally Counter\n");
+
+        rtnl_lock();
+
+        counters = tp->tally_vaddr;
+        paddr = tp->tally_paddr;
+        if (!counters) {
+                len += snprintf(page + len, count - len,
+                                "\nDump Tally Counter Fail\n");
+                goto out_unlock;
+        }
+
+        rtl8125_dump_tally_counter(tp, paddr);
+
+        len += snprintf(page + len, count - len,
+                        "Statistics\tValue\n----------\t-----\n");
+
+        len += snprintf(page + len, count - len,
+                        "tx_packets\t%lld\n"
+                        "rx_packets\t%lld\n"
+                        "tx_errors\t%lld\n"
+                        "rx_errors\t%d\n"
+                        "rx_missed\t%d\n"
+                        "align_errors\t%d\n"
+                        "tx_one_collision\t%d\n"
+                        "tx_multi_collision\t%d\n"
+                        "rx_unicast\t%lld\n"
+                        "rx_broadcast\t%lld\n"
+                        "rx_multicast\t%d\n"
+                        "tx_aborted\t%d\n"
+                        "tx_underrun\t%d\n"
+
+                        "tx_octets\t%lld\n"
+                        "rx_octets\t%lld\n"
+                        "rx_multicast64\t%lld\n"
+                        "tx_unicast64\t%lld\n"
+                        "tx_broadcast64\t%lld\n"
+                        "tx_multicast64\t%lld\n"
+                        "tx_pause_on\t%d\n"
+                        "tx_pause_off\t%d\n"
+                        "tx_pause_all\t%d\n"
+                        "tx_deferred\t%d\n"
+                        "tx_late_collision\t%d\n"
+                        "tx_all_collision\t%d\n"
+                        "tx_aborted32\t%d\n"
+                        "align_errors32\t%d\n"
+                        "rx_frame_too_long\t%d\n"
+                        "rx_runt\t%d\n"
+                        "rx_pause_on\t%d\n"
+                        "rx_pause_off\t%d\n"
+                        "rx_pause_all\t%d\n"
+                        "rx_unknown_opcode\t%d\n"
+                        "rx_mac_error\t%d\n"
+                        "tx_underrun32\t%d\n"
+                        "rx_mac_missed\t%d\n"
+                        "rx_tcam_dropped\t%d\n"
+                        "tdu\t%d\n"
+                        "rdu\t%d\n",
+                        le64_to_cpu(counters->tx_packets),
+                        le64_to_cpu(counters->rx_packets),
+                        le64_to_cpu(counters->tx_errors),
+                        le32_to_cpu(counters->rx_errors),
+                        le16_to_cpu(counters->rx_missed),
+                        le16_to_cpu(counters->align_errors),
+                        le32_to_cpu(counters->tx_one_collision),
+                        le32_to_cpu(counters->tx_multi_collision),
+                        le64_to_cpu(counters->rx_unicast),
+                        le64_to_cpu(counters->rx_broadcast),
+                        le32_to_cpu(counters->rx_multicast),
+                        le16_to_cpu(counters->tx_aborted),
+                        le16_to_cpu(counters->tx_underrun),
+
+                        le64_to_cpu(counters->tx_octets),
+                        le64_to_cpu(counters->rx_octets),
+                        le64_to_cpu(counters->rx_multicast64),
+                        le64_to_cpu(counters->tx_unicast64),
+                        le64_to_cpu(counters->tx_broadcast64),
+                        le64_to_cpu(counters->tx_multicast64),
+                        le32_to_cpu(counters->tx_pause_on),
+                        le32_to_cpu(counters->tx_pause_off),
+                        le32_to_cpu(counters->tx_pause_all),
+                        le32_to_cpu(counters->tx_deferred),
+                        le32_to_cpu(counters->tx_late_collision),
+                        le32_to_cpu(counters->tx_all_collision),
+                        le32_to_cpu(counters->tx_aborted32),
+                        le32_to_cpu(counters->align_errors32),
+                        le32_to_cpu(counters->rx_frame_too_long),
+                        le32_to_cpu(counters->rx_runt),
+                        le32_to_cpu(counters->rx_pause_on),
+                        le32_to_cpu(counters->rx_pause_off),
+                        le32_to_cpu(counters->rx_pause_all),
+                        le32_to_cpu(counters->rx_unknown_opcode),
+                        le32_to_cpu(counters->rx_mac_error),
+                        le32_to_cpu(counters->tx_underrun32),
+                        le32_to_cpu(counters->rx_mac_missed),
+                        le32_to_cpu(counters->rx_tcam_dropped),
+                        le32_to_cpu(counters->tdu),
+                        le32_to_cpu(counters->rdu));
+
+        len += snprintf(page + len, count - len, "\n");
+out_unlock:
+        rtnl_unlock();
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_registers(char *page, char **start,
+                              off_t offset, int count,
+                              int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8125_MAC_REGS_SIZE;
+        u8 byte_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump MAC Registers\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%04x:\t",
+                                n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        len += snprintf(page + len, count - len,
+                                        "%02x ",
+                                        byte_rd);
+                }
+        }
+
+        max = 0xB00;
+        for (n = 0xA00; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%04x:\t",
+                                n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        len += snprintf(page + len, count - len,
+                                        "%02x ",
+                                        byte_rd);
+                }
+        }
+
+        max = 0xD40;
+        for (n = 0xD00; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%04x:\t",
+                                n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        len += snprintf(page + len, count - len,
+                                        "%02x ",
+                                        byte_rd);
+                }
+        }
+
+        max = 0x2840;
+        for (n = 0x2800; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%04x:\t",
+                                n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        len += snprintf(page + len, count - len,
+                                        "%02x ",
+                                        byte_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_all_registers(char *page, char **start,
+                                  off_t offset, int count,
+                                  int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max;
+        u8 byte_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+        struct pci_dev *pdev = tp->pci_dev;
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump All MAC Registers\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        max = pci_resource_len(pdev, 2);
+        max = min(max, 0x8000);
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%04x:\t",
+                                n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        len += snprintf(page + len, count - len,
+                                        "%02x ",
+                                        byte_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\nTotal length:0x%X", max);
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_pcie_phy(char *page, char **start,
+                             off_t offset, int count,
+                             int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8125_EPHY_REGS_SIZE/2;
+        u16 word_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump PCIE PHY\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%02x:\t",
+                                n);
+
+                for (i = 0; i < 8 && n < max; i++, n++) {
+                        word_rd = rtl8125_ephy_read(tp, n);
+                        len += snprintf(page + len, count - len,
+                                        "%04x ",
+                                        word_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_eth_phy(char *page, char **start,
+                            off_t offset, int count,
+                            int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8125_PHY_REGS_SIZE/2;
+        u16 word_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long flags;
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump Ethernet PHY\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        len += snprintf(page + len, count - len,
+                        "\n####################page 0##################\n");
+        rtl8125_mdio_write(tp, 0x1f, 0x0000);
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%02x:\t",
+                                n);
+
+                for (i = 0; i < 8 && n < max; i++, n++) {
+                        word_rd = rtl8125_mdio_read(tp, n);
+                        len += snprintf(page + len, count - len,
+                                        "%04x ",
+                                        word_rd);
+                }
+        }
+
+        len += snprintf(page + len, count - len,
+                        "\n####################extra reg##################\n");
+        n = 0xA400;
+        len += snprintf(page + len, count - len,
+                        "\n0x%02x:\t",
+                        n);
+        for (i = 0; i < 8; i++, n+=2) {
+                word_rd = rtl8125_mdio_direct_read_phy_ocp(tp, n);
+                len += snprintf(page + len, count - len,
+                                "%04x ",
+                                word_rd);
+        }
+
+        n = 0xA410;
+        len += snprintf(page + len, count - len,
+                        "\n0x%02x:\t",
+                        n);
+        for (i = 0; i < 3; i++, n+=2) {
+                word_rd = rtl8125_mdio_direct_read_phy_ocp(tp, n);
+                len += snprintf(page + len, count - len,
+                                "%04x ",
+                                word_rd);
+        }
+
+        n = 0xA434;
+        len += snprintf(page + len, count - len,
+                        "\n0x%02x:\t",
+                        n);
+        word_rd = rtl8125_mdio_direct_read_phy_ocp(tp, n);
+        len += snprintf(page + len, count - len,
+                        "%04x ",
+                        word_rd);
+
+        n = 0xA5D0;
+        len += snprintf(page + len, count - len,
+                        "\n0x%02x:\t",
+                        n);
+        for (i = 0; i < 4; i++, n+=2) {
+                word_rd = rtl8125_mdio_direct_read_phy_ocp(tp, n);
+                len += snprintf(page + len, count - len,
+                                "%04x ",
+                                word_rd);
+        }
+
+        n = 0xA61A;
+        len += snprintf(page + len, count - len,
+                        "\n0x%02x:\t",
+                        n);
+        word_rd = rtl8125_mdio_direct_read_phy_ocp(tp, n);
+        len += snprintf(page + len, count - len,
+                        "%04x ",
+                        word_rd);
+
+        n = 0xA6D0;
+        len += snprintf(page + len, count - len,
+                        "\n0x%02x:\t",
+                        n);
+        for (i = 0; i < 3; i++, n+=2) {
+                word_rd = rtl8125_mdio_direct_read_phy_ocp(tp, n);
+                len += snprintf(page + len, count - len,
+                                "%04x ",
+                                word_rd);
+        }
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_extended_registers(char *page, char **start,
+                                       off_t offset, int count,
+                                       int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8125_ERI_REGS_SIZE;
+        u32 dword_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump Extended Registers\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%02x:\t",
+                                n);
+
+                for (i = 0; i < 4 && n < max; i++, n+=4) {
+                        dword_rd = rtl8125_eri_read(tp, n, 4, ERIAR_ExGMAC);
+                        len += snprintf(page + len, count - len,
+                                        "%08x ",
+                                        dword_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_pci_registers(char *page, char **start,
+                                  off_t offset, int count,
+                                  int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8125_PCI_REGS_SIZE;
+        u32 dword_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump PCI Registers\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%03x:\t",
+                                n);
+
+                for (i = 0; i < 4 && n < max; i++, n+=4) {
+                        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+                        len += snprintf(page + len, count - len,
+                                        "%08x ",
+                                        dword_rd);
+                }
+        }
+
+        n = 0x110;
+        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+        len += snprintf(page + len, count - len,
+                        "\n0x%03x:\t%08x ",
+                        n,
+                        dword_rd);
+        n = 0x70c;
+        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+        len += snprintf(page + len, count - len,
+                        "\n0x%03x:\t%08x ",
+                        n,
+                        dword_rd);
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_temperature(char *page, char **start,
+                                off_t offset, int count,
+                                int *eof, void *data)
+{
+        struct net_device *dev = data;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long flags;
+        int cel, fah;
+        int len = 0;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                len += snprintf(page + len, count - len,
+                                "\nChip Temperature\n");
+                break;
+        default:
+                return -EOPNOTSUPP;
+        }
+
+        rtnl_lock();
+
+        if (!rtl8125_sysfs_testmode_on(tp)) {
+                len += snprintf(page + len, count - len,
+                                "\nPlease turn on ""/sys/class/net/<iface>/rtk_adv/testmode"".\n\n");
+                goto out_unlock;
+        }
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+        cel = rtl8125_read_thermal_sensor(tp);
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        fah = rtl8125_cel_to_fah(cel);
+
+        len += snprintf(page + len, count - len,
+                        "Cel:%d\n",
+                        cel);
+        len += snprintf(page + len, count - len,
+                        "Fah:%d\n",
+                        fah);
+
+        len += snprintf(page + len, count - len, "\n");
+
+out_unlock:
+        rtnl_unlock();
+
+        *eof = 1;
+        return len;
+}
+
+static int _proc_get_cable_info(char *page, char **start,
+                                off_t offset, int count,
+                                int *eof, void *data,
+                                bool poe_mode)
+{
+        int i;
+        u32 status;
+        int len = 0;
+        struct net_device *dev = data;
+        int cp_status[RTL8125_CP_NUM] = {0};
+        int cp_len[RTL8125_CP_NUM] = {0};
+        struct rtl8125_private *tp = netdev_priv(dev);
+        const char *pair_str[RTL8125_CP_NUM] = {"1-2", "3-6", "4-5", "7-8"};
+        unsigned long flags;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2 ... CFG_METHOD_7:
+                /* support */
+                break;
+        default:
+                return -EOPNOTSUPP;
+        }
+
+        rtnl_lock();
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        if (!rtl8125_sysfs_testmode_on(tp)) {
+                len += snprintf(page + len, count - len,
+                                "\nPlease turn on ""/sys/class/net/<iface>/rtk_adv/testmode"".\n\n");
+                goto out_unlock;
+        }
+
+        status = rtl8125_get_phy_status(tp);
+        if (status & LinkStatus)
+                len += snprintf(page + len, count - len,
+                                "\nlink speed:%d",
+                                rtl8125_convert_link_speed(status));
+        else
+                len += snprintf(page + len, count - len,
+                                "\nlink status:off");
+
+        rtl8125_get_cp_len(tp, cp_len);
+
+        rtl8125_get_cp_status(tp, cp_status, poe_mode);
+
+        len += snprintf(page + len, count - len,
+                        "\npair\tlength\tstatus   \tpp\n");
+
+        for (i=0; i<RTL8125_CP_NUM; i++) {
+                if (cp_len[i] < 0)
+                        len += snprintf(page + len, count - len,
+                                        "%s\t%s\t%s\t",
+                                        pair_str[i], "none",
+                                        rtl8125_get_cp_status_string(cp_status[i]));
+                else
+                        len += snprintf(page + len, count - len,
+                                        "%s\t%d\t%s\t",
+                                        pair_str[i], cp_len[i],
+                                        rtl8125_get_cp_status_string(cp_status[i]));
+                if (cp_status[i] == rtl8125_cp_normal)
+                        len += snprintf(page + len, count - len, "none\n");
+                else
+                        len += snprintf(page + len, count - len, "%dm\n",
+                                        rtl8125_get_cp_pp(tp, i));
+        }
+
+        len += snprintf(page + len, count - len, "\n");
+
+out_unlock:
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        rtnl_unlock();
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_cable_info(char *page, char **start,
+                               off_t offset, int count,
+                               int *eof, void *data)
+{
+        return _proc_get_cable_info(page, start, offset, count, eof, data, 0);
+}
+
+static int proc_get_poe_cable_info(char *page, char **start,
+                                   off_t offset, int count,
+                                   int *eof, void *data)
+{
+        return _proc_get_cable_info(page, start, offset, count, eof, data, 1);
+}
+
+static void _proc_dump_desc(char *page, int *page_len, int *count, void *desc_base,
+                            u32 alloc_size)
+{
+        u32 *pdword;
+        int i, len;
+
+        if (desc_base == NULL ||
+            alloc_size == 0)
+                return;
+
+        len = *page_len;
+        pdword = (u32*)desc_base;
+        for (i=0; i<(alloc_size/4); i++) {
+                if (!(i % 4))
+                        len += snprintf(page + len, *count - len,
+                                        "\n%04x ",
+                                        i);
+                len += snprintf(page + len, *count - len,
+                                "%08x ",
+                                pdword[i]);
+        }
+
+        len += snprintf(page + len, *count - len, "\n");
+
+        *page_len = len;
+        return;
+}
+
+static int proc_dump_rx_desc(char *page, char **start,
+                             off_t offset, int count,
+                             int *eof, void *data)
+{
+        int i;
+        int len = 0;
+        struct net_device *dev = data;
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtnl_lock();
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
+
+                if (!ring)
+                        continue;
+
+                len += snprintf(page + len, count - len,
+                                "\ndump rx %d desc:%d",
+                                i, ring->num_rx_desc);
+
+                _proc_dump_desc(page, &len, &count,
+                                ring->RxDescArray,
+                                ring->RxDescAllocSize);
+        }
+
+#ifdef ENABLE_LIB_SUPPORT
+        if (rtl8125_num_lib_rx_rings(tp) > 0) {
+                for (i = 0; i < tp->HwSuppNumRxQueues; i++) {
+                        struct rtl8125_ring *lib_ring = &tp->lib_rx_ring[i];
+                        if (lib_ring->enabled) {
+                                len += snprintf(page + len, count - len,
+                                                "\ndump lib rx %d desc:%d",
+                                                i,
+                                                ring->ring_size);
+                                _proc_dump_desc(page, &len, &count,
+                                                (void*)lib_ring->desc_addr,
+                                                lib_ring->desc_size);
+                        }
+                }
+        }
+#endif //ENABLE_LIB_SUPPORT
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+
+        return len;
+}
+
+static int proc_dump_tx_desc(char *page, char **start,
+                             off_t offset, int count,
+                             int *eof, void *data)
+{
+        int len = 0;
+        struct net_device *dev = data;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        rtnl_lock();
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8125_tx_ring *ring = &tp->tx_ring[i];
+
+                if (!ring)
+                        continue;
+
+                len += snprintf(page + len, count - len,
+                                "\ndump tx desc:%d",
+                                ring->num_tx_desc);
+
+                _proc_dump_desc(page, &len, &count,
+                                ring->TxDescArray,
+                                ring->TxDescAllocSize);
+        }
+
+#ifdef ENABLE_LIB_SUPPORT
+        if (rtl8125_num_lib_tx_rings(tp) > 0) {
+                for (i = 0; i < tp->HwSuppNumTxQueues; i++) {
+                        struct rtl8125_ring *lib_ring = &tp->lib_tx_ring[i];
+                        if (lib_ring->enabled) {
+                                len += snprintf(page + len, count - len,
+                                                "\ndump lib tx %d desc:%d",
+                                                i,
+                                                ring->ring_size);
+                                _proc_dump_desc(page, &len, &count,
+                                                (void*)lib_ring->desc_addr,
+                                                lib_ring->desc_size);
+                        }
+                }
+        }
+#endif //ENABLE_LIB_SUPPORT
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+
+        return len;
+}
+
+static int proc_dump_msix_tbl(char *page, char **start,
+                              off_t offset, int count,
+                              int *eof, void *data)
+{
+        int i, j;
+        int len = 0;
+        void __iomem *ioaddr;
+        struct net_device *dev = data;
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        /* ioremap MMIO region */
+        ioaddr = ioremap(pci_resource_start(tp->pci_dev, 4), pci_resource_len(tp->pci_dev, 4));
+        if (!ioaddr)
+                return -EFAULT;
+
+        rtnl_lock();
+
+        len += snprintf(page + len, count - len,
+                        "\ndump MSI-X Table. Total Entry %d. \n",
+                        tp->hw_supp_irq_nvecs);
+
+        for (i=0; i<tp->hw_supp_irq_nvecs; i++) {
+                len += snprintf(page + len, count - len,
+                                "\n%04x ", i);
+                for (j=0; j<4; j++)
+                        len += snprintf(page + len, count - len, "%08x ",
+                                        readl(ioaddr + i*0x10 + 4*j));
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return 0;
+}
+
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+
+static void rtl8125_proc_module_init(void)
+{
+        //create /proc/net/r8125
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+        rtl8125_proc = proc_mkdir(MODULENAME, init_net.proc_net);
+#else
+        rtl8125_proc = proc_mkdir(MODULENAME, proc_net);
+#endif
+        if (!rtl8125_proc)
+                dprintk("cannot create %s proc entry \n", MODULENAME);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+/*
+ * seq_file wrappers for procfile show routines.
+ */
+static int rtl8125_proc_open(struct inode *inode, struct file *file)
+{
+        struct net_device *dev = proc_get_parent_data(inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+        int (*show)(struct seq_file *, void *) = pde_data(inode);
+#else
+        int (*show)(struct seq_file *, void *) = PDE_DATA(inode);
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+
+        return single_open(file, show, dev);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+static const struct proc_ops rtl8125_proc_fops = {
+        .proc_open           = rtl8125_proc_open,
+        .proc_read           = seq_read,
+        .proc_lseek          = seq_lseek,
+        .proc_release        = single_release,
+};
+#else
+static const struct file_operations rtl8125_proc_fops = {
+        .open           = rtl8125_proc_open,
+        .read           = seq_read,
+        .llseek         = seq_lseek,
+        .release        = single_release,
+};
+#endif
+
+#endif
+
+/*
+ * Table of proc files we need to create.
+ */
+struct rtl8125_proc_file {
+        char name[16];
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+        int (*show)(struct seq_file *, void *);
+#else
+        int (*show)(char *, char **, off_t, int, int *, void *);
+#endif
+};
+
+static const struct rtl8125_proc_file rtl8125_debug_proc_files[] = {
+        { "driver_var", &proc_get_driver_variable },
+        { "tally", &proc_get_tally_counter },
+        { "registers", &proc_get_registers },
+        { "registers2", &proc_get_all_registers },
+        { "pcie_phy", &proc_get_pcie_phy },
+        { "eth_phy", &proc_get_eth_phy },
+        { "ext_regs", &proc_get_extended_registers },
+        { "pci_regs", &proc_get_pci_registers },
+        { "tx_desc", &proc_dump_tx_desc },
+        { "rx_desc", &proc_dump_rx_desc },
+        { "msix_tbl", &proc_dump_msix_tbl },
+        { "", NULL }
+};
+
+static const struct rtl8125_proc_file rtl8125_test_proc_files[] = {
+        { "temp", &proc_get_temperature },
+        { "cdt", &proc_get_cable_info },
+        { "cdt_poe", &proc_get_poe_cable_info },
+        { "", NULL }
+};
+
+#define R8125_PROC_DEBUG_DIR "debug"
+#define R8125_PROC_TEST_DIR "test"
+
+static void rtl8125_proc_init(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        const struct rtl8125_proc_file *f;
+        struct proc_dir_entry *dir;
+
+        if (!rtl8125_proc)
+                return;
+
+        if (tp->proc_dir_debug || tp->proc_dir_test)
+                return;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+        dir = proc_mkdir_data(dev->name, 0, rtl8125_proc, dev);
+        if (!dir) {
+                printk("Unable to initialize /proc/net/%s/%s\n",
+                       MODULENAME, dev->name);
+                return;
+        }
+        tp->proc_dir = dir;
+        proc_init_num++;
+
+        /* create debug entry */
+        dir = proc_mkdir_data(R8125_PROC_DEBUG_DIR, 0, tp->proc_dir, dev);
+        if (!dir) {
+                printk("Unable to initialize /proc/net/%s/%s/%s\n",
+                       MODULENAME, dev->name, R8125_PROC_DEBUG_DIR);
+                return;
+        }
+
+        tp->proc_dir_debug = dir;
+        for (f = rtl8125_debug_proc_files; f->name[0]; f++) {
+                if (!proc_create_data(f->name, S_IFREG | S_IRUGO, dir,
+                                      &rtl8125_proc_fops, f->show)) {
+                        printk("Unable to initialize "
+                               "/proc/net/%s/%s/%s/%s\n",
+                               MODULENAME, dev->name, R8125_PROC_DEBUG_DIR,
+                               f->name);
+                        return;
+                }
+        }
+
+        /* create test entry */
+        dir = proc_mkdir_data(R8125_PROC_TEST_DIR, 0, tp->proc_dir, dev);
+        if (!dir) {
+                printk("Unable to initialize /proc/net/%s/%s/%s\n",
+                       MODULENAME, dev->name, R8125_PROC_TEST_DIR);
+                return;
+        }
+
+        tp->proc_dir_test = dir;
+        for (f = rtl8125_test_proc_files; f->name[0]; f++) {
+                if (!proc_create_data(f->name, S_IFREG | S_IRUGO, dir,
+                                      &rtl8125_proc_fops, f->show)) {
+                        printk("Unable to initialize "
+                               "/proc/net/%s/%s/%s/%s\n",
+                               MODULENAME, dev->name, R8125_PROC_TEST_DIR,
+                               f->name);
+                        return;
+                }
+        }
+#else
+        dir = proc_mkdir(dev->name, rtl8125_proc);
+        if (!dir) {
+                printk("Unable to initialize /proc/net/%s/%s\n",
+                       MODULENAME, dev->name);
+                return;
+        }
+
+        tp->proc_dir = dir;
+        proc_init_num++;
+
+        /* create debug entry */
+        dir = proc_mkdir(R8125_PROC_DEBUG_DIR, tp->proc_dir);
+        if (!dir) {
+                printk("Unable to initialize /proc/net/%s/%s/%s\n",
+                       MODULENAME, dev->name, R8125_PROC_DEBUG_DIR);
+                return;
+        }
+
+        tp->proc_dir_debug = dir;
+        for (f = rtl8125_debug_proc_files; f->name[0]; f++) {
+                if (!create_proc_read_entry(f->name, S_IFREG | S_IRUGO,
+                                            dir, f->show, dev)) {
+                        printk("Unable to initialize "
+                               "/proc/net/%s/%s/%s/%s\n",
+                               MODULENAME, dev->name, R8125_PROC_DEBUG_DIR,
+                               f->name);
+                        return;
+                }
+        }
+
+        /* create test entry */
+        dir = proc_mkdir(R8125_PROC_TEST_DIR, tp->proc_dir);
+        if (!dir) {
+                printk("Unable to initialize /proc/net/%s/%s/%s\n",
+                       MODULENAME, dev->name, R8125_PROC_TEST_DIR);
+                return;
+        }
+
+        tp->proc_dir_test = dir;
+        for (f = rtl8125_test_proc_files; f->name[0]; f++) {
+                if (!create_proc_read_entry(f->name, S_IFREG | S_IRUGO,
+                                            dir, f->show, dev)) {
+                        printk("Unable to initialize "
+                               "/proc/net/%s/%s/%s/%s\n",
+                               MODULENAME, dev->name, R8125_PROC_TEST_DIR,
+                               f->name);
+                        return;
+                }
+        }
+#endif
+}
+
+static void rtl8125_proc_remove(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->proc_dir) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+                remove_proc_subtree(dev->name, rtl8125_proc);
+#else
+                const struct rtl8125_proc_file *f;
+                struct rtl8125_private *tp = netdev_priv(dev);
+
+                if (tp->proc_dir_debug) {
+                        for (f = rtl8125_debug_proc_files; f->name[0]; f++)
+                                remove_proc_entry(f->name, tp->proc_dir_debug);
+                        remove_proc_entry(R8125_PROC_DEBUG_DIR, tp->proc_dir);
+                }
+
+                if (tp->proc_dir_test) {
+                        for (f = rtl8125_test_proc_files; f->name[0]; f++)
+                                remove_proc_entry(f->name, tp->proc_dir_test);
+                        remove_proc_entry(R8125_PROC_TEST_DIR, tp->proc_dir);
+                }
+
+                remove_proc_entry(dev->name, rtl8125_proc);
+#endif
+                proc_init_num--;
+
+                tp->proc_dir_debug = NULL;
+                tp->proc_dir_test = NULL;
+                tp->proc_dir = NULL;
+        }
+}
+
+#endif //ENABLE_R8125_PROCFS
+
+#ifdef ENABLE_R8125_SYSFS
+/****************************************************************************
+*   -----------------------------SYSFS STUFF-------------------------
+*****************************************************************************
+*/
+static ssize_t testmode_show(struct device *dev,
+                             struct device_attribute *attr, char *buf)
+{
+        struct net_device *netdev = to_net_dev(dev);
+        struct rtl8125_private *tp = netdev_priv(netdev);
+
+        sprintf(buf, "%u\n", tp->testmode);
+
+        return strlen(buf);
+}
+
+static ssize_t testmode_store(struct device *dev,
+                              struct device_attribute *attr,
+                              const char *buf, size_t count)
+{
+        struct net_device *netdev = to_net_dev(dev);
+        struct rtl8125_private *tp = netdev_priv(netdev);
+        u32 testmode;
+
+        if (sscanf(buf, "%u\n", &testmode) != 1)
+                return -EINVAL;
+
+        if (tp->testmode != testmode) {
+                rtnl_lock();
+                tp->testmode = testmode;
+                rtnl_unlock();
+        }
+
+        return count;
+}
+
+static DEVICE_ATTR_RW(testmode);
+
+static struct attribute *rtk_adv_attrs[] = {
+        &dev_attr_testmode.attr,
+        NULL
+};
+
+static struct attribute_group rtk_adv_grp = {
+        .name = "rtl_adv",
+        .attrs = rtk_adv_attrs,
+};
+
+static void rtl8125_sysfs_init(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ret;
+
+        /* init rtl_adv */
+#ifdef ENABLE_LIB_SUPPORT
+        tp->testmode = 0;
+#else
+        tp->testmode = 1;
+#endif //ENABLE_LIB_SUPPORT
+
+        ret = sysfs_create_group(&dev->dev.kobj, &rtk_adv_grp);
+        if (ret < 0)
+                netif_warn(tp, probe, dev, "create rtk_adv_grp fail\n");
+        else
+                set_bit(R8125_SYSFS_RTL_ADV, tp->sysfs_flag);
+}
+
+static void rtl8125_sysfs_remove(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (test_and_clear_bit(R8125_SYSFS_RTL_ADV, tp->sysfs_flag))
+                sysfs_remove_group(&dev->dev.kobj, &rtk_adv_grp);
+}
+#endif //ENABLE_R8125_SYSFS
+
+static inline u16 map_phy_ocp_addr(u16 PageNum, u8 RegNum)
+{
+        u16 OcpPageNum = 0;
+        u8 OcpRegNum = 0;
+        u16 OcpPhyAddress = 0;
+
+        if (PageNum == 0) {
+                OcpPageNum = OCP_STD_PHY_BASE_PAGE + (RegNum / 8);
+                OcpRegNum = 0x10 + (RegNum % 8);
+        } else {
+                OcpPageNum = PageNum;
+                OcpRegNum = RegNum;
+        }
+
+        OcpPageNum <<= 4;
+
+        if (OcpRegNum < 16) {
+                OcpPhyAddress = 0;
+        } else {
+                OcpRegNum -= 16;
+                OcpRegNum <<= 1;
+
+                OcpPhyAddress = OcpPageNum + OcpRegNum;
+        }
+
+
+        return OcpPhyAddress;
+}
+
+static void mdio_real_direct_write_phy_ocp(struct rtl8125_private *tp,
+                u16 RegAddr,
+                u16 value)
+{
+        u32 data32;
+        int i;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(RegAddr % 2);
+#endif
+        data32 = RegAddr/2;
+        data32 <<= OCPR_Addr_Reg_shift;
+        data32 |= OCPR_Write | value;
+
+        RTL_W32(tp, PHYOCP, data32);
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
+
+                if (!(RTL_R32(tp, PHYOCP) & OCPR_Flag))
+                        break;
+        }
+}
+
+void rtl8125_mdio_direct_write_phy_ocp(struct rtl8125_private *tp,
+                                       u16 RegAddr,
+                                       u16 value)
+{
+        if (tp->rtk_enable_diag)
+                return;
+
+        mdio_real_direct_write_phy_ocp(tp, RegAddr, value);
+}
+
+/*
+void rtl8125_mdio_write_phy_ocp(struct rtl8125_private *tp,
+                                       u16 PageNum,
+                                       u32 RegAddr,
+                                       u32 value)
+{
+        u16 ocp_addr;
+
+        ocp_addr = map_phy_ocp_addr(PageNum, RegAddr);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, ocp_addr, value);
+}
+*/
+
+static void rtl8125_mdio_real_write_phy_ocp(struct rtl8125_private *tp,
+                u16 PageNum,
+                u32 RegAddr,
+                u32 value)
+{
+        u16 ocp_addr;
+
+        ocp_addr = map_phy_ocp_addr(PageNum, RegAddr);
+
+        mdio_real_direct_write_phy_ocp(tp, ocp_addr, value);
+}
+
+static void mdio_real_write(struct rtl8125_private *tp,
+                            u16 RegAddr,
+                            u16 value)
+{
+        if (RegAddr == 0x1F) {
+                tp->cur_page = value;
+                return;
+        }
+        rtl8125_mdio_real_write_phy_ocp(tp, tp->cur_page, RegAddr, value);
+}
+
+void rtl8125_mdio_write(struct rtl8125_private *tp,
+                        u16 RegAddr,
+                        u16 value)
+{
+        if (tp->rtk_enable_diag)
+                return;
+
+        mdio_real_write(tp, RegAddr, value);
+}
+
+void rtl8125_mdio_prot_write(struct rtl8125_private *tp,
+                             u32 RegAddr,
+                             u32 value)
+{
+        mdio_real_write(tp, RegAddr, value);
+}
+
+void rtl8125_mdio_prot_direct_write_phy_ocp(struct rtl8125_private *tp,
+                u32 RegAddr,
+                u32 value)
+{
+        mdio_real_direct_write_phy_ocp(tp, RegAddr, value);
+}
+
+static u32 mdio_real_direct_read_phy_ocp(struct rtl8125_private *tp,
+                u16 RegAddr)
+{
+        u32 data32;
+        int i, value = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(RegAddr % 2);
+#endif
+        data32 = RegAddr/2;
+        data32 <<= OCPR_Addr_Reg_shift;
+
+        RTL_W32(tp, PHYOCP, data32);
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
+
+                if (RTL_R32(tp, PHYOCP) & OCPR_Flag)
+                        break;
+        }
+        value = RTL_R32(tp, PHYOCP) & OCPDR_Data_Mask;
+
+        return value;
+}
+
+u32 rtl8125_mdio_direct_read_phy_ocp(struct rtl8125_private *tp,
+                                     u16 RegAddr)
+{
+        if (tp->rtk_enable_diag)
+                return 0xffffffff;
+
+        return mdio_real_direct_read_phy_ocp(tp, RegAddr);
+}
+
+/*
+static u32 rtl8125_mdio_read_phy_ocp(struct rtl8125_private *tp,
+                                     u16 PageNum,
+                                     u32 RegAddr)
+{
+        u16 ocp_addr;
+
+        ocp_addr = map_phy_ocp_addr(PageNum, RegAddr);
+
+        return rtl8125_mdio_direct_read_phy_ocp(tp, ocp_addr);
+}
+*/
+
+static u32 rtl8125_mdio_real_read_phy_ocp(struct rtl8125_private *tp,
+                u16 PageNum,
+                u32 RegAddr)
+{
+        u16 ocp_addr;
+
+        ocp_addr = map_phy_ocp_addr(PageNum, RegAddr);
+
+        return mdio_real_direct_read_phy_ocp(tp, ocp_addr);
+}
+
+static u32 mdio_real_read(struct rtl8125_private *tp,
+                          u16 RegAddr)
+{
+        return rtl8125_mdio_real_read_phy_ocp(tp, tp->cur_page, RegAddr);
+}
+
+u32 rtl8125_mdio_read(struct rtl8125_private *tp,
+                      u16 RegAddr)
+{
+        if (tp->rtk_enable_diag)
+                return 0xffffffff;
+
+        return mdio_real_read(tp, RegAddr);
+}
+
+u32 rtl8125_mdio_prot_read(struct rtl8125_private *tp,
+                           u32 RegAddr)
+{
+        return mdio_real_read(tp, RegAddr);
+}
+
+u32 rtl8125_mdio_prot_direct_read_phy_ocp(struct rtl8125_private *tp,
+                u32 RegAddr)
+{
+        return mdio_real_direct_read_phy_ocp(tp, RegAddr);
+}
+
+static void rtl8125_clear_and_set_eth_phy_bit(struct rtl8125_private *tp, u8  addr, u16 clearmask, u16 setmask)
+{
+        u16 PhyRegValue;
+
+        PhyRegValue = rtl8125_mdio_read(tp, addr);
+        PhyRegValue &= ~clearmask;
+        PhyRegValue |= setmask;
+        rtl8125_mdio_write(tp, addr, PhyRegValue);
+}
+
+void rtl8125_clear_eth_phy_bit(struct rtl8125_private *tp, u8 addr, u16 mask)
+{
+        rtl8125_clear_and_set_eth_phy_bit(tp,
+                                          addr,
+                                          mask,
+                                          0);
+}
+
+void rtl8125_set_eth_phy_bit(struct rtl8125_private *tp,  u8  addr, u16  mask)
+{
+        rtl8125_clear_and_set_eth_phy_bit(tp,
+                                          addr,
+                                          0,
+                                          mask);
+}
+
+void rtl8125_clear_and_set_eth_phy_ocp_bit(struct rtl8125_private *tp, u16 addr, u16 clearmask, u16 setmask)
+{
+        u16 PhyRegValue;
+
+        PhyRegValue = rtl8125_mdio_direct_read_phy_ocp(tp, addr);
+        PhyRegValue &= ~clearmask;
+        PhyRegValue |= setmask;
+        rtl8125_mdio_direct_write_phy_ocp(tp, addr, PhyRegValue);
+}
+
+void rtl8125_clear_eth_phy_ocp_bit(struct rtl8125_private *tp, u16 addr, u16 mask)
+{
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              addr,
+                                              mask,
+                                              0);
+}
+
+void rtl8125_set_eth_phy_ocp_bit(struct rtl8125_private *tp,  u16 addr, u16 mask)
+{
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              addr,
+                                              0,
+                                              mask);
+}
+
+void rtl8125_mac_ocp_write(struct rtl8125_private *tp, u16 reg_addr, u16 value)
+{
+        u32 data32;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(reg_addr % 2);
+#endif
+
+        data32 = reg_addr/2;
+        data32 <<= OCPR_Addr_Reg_shift;
+        data32 += value;
+        data32 |= OCPR_Write;
+
+        RTL_W32(tp, MACOCP, data32);
+}
+
+u16 rtl8125_mac_ocp_read(struct rtl8125_private *tp, u16 reg_addr)
+{
+        u32 data32;
+        u16 data16 = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(reg_addr % 2);
+#endif
+
+        data32 = reg_addr/2;
+        data32 <<= OCPR_Addr_Reg_shift;
+
+        RTL_W32(tp, MACOCP, data32);
+        data16 = (u16)RTL_R32(tp, MACOCP);
+
+        return data16;
+}
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+static void mac_mcu_write(struct rtl8125_private *tp, u16 reg, u16 value)
+{
+        if (reg == 0x1f) {
+                tp->ocp_base = value << 4;
+                return;
+        }
+
+        rtl8125_mac_ocp_write(tp, tp->ocp_base + reg, value);
+}
+
+static u32 mac_mcu_read(struct rtl8125_private *tp, u16 reg)
+{
+        return rtl8125_mac_ocp_read(tp, tp->ocp_base + reg);
+}
+#endif
+
+static void
+rtl8125_clear_set_mac_ocp_bit(
+        struct rtl8125_private *tp,
+        u16   addr,
+        u16   clearmask,
+        u16   setmask
+)
+{
+        u16 PhyRegValue;
+
+        PhyRegValue = rtl8125_mac_ocp_read(tp, addr);
+        PhyRegValue &= ~clearmask;
+        PhyRegValue |= setmask;
+        rtl8125_mac_ocp_write(tp, addr, PhyRegValue);
+}
+
+void
+rtl8125_clear_mac_ocp_bit(
+        struct rtl8125_private *tp,
+        u16   addr,
+        u16   mask
+)
+{
+        rtl8125_clear_set_mac_ocp_bit(tp,
+                                      addr,
+                                      mask,
+                                      0);
+}
+
+void
+rtl8125_set_mac_ocp_bit(
+        struct rtl8125_private *tp,
+        u16   addr,
+        u16   mask
+)
+{
+        rtl8125_clear_set_mac_ocp_bit(tp,
+                                      addr,
+                                      0,
+                                      mask);
+}
+
+u32 rtl8125_ocp_read_with_oob_base_address(struct rtl8125_private *tp, u16 addr, u8 len, const u32 base_address)
+{
+        return rtl8125_eri_read_with_oob_base_address(tp, addr, len, ERIAR_OOB, base_address);
+}
+
+u32 rtl8125_ocp_read(struct rtl8125_private *tp, u16 addr, u8 len)
+{
+        if (!tp->AllowAccessDashOcp || tp->HwSuppOcpChannelVer != 2)
+                return 0xffffffff;
+
+        return rtl8125_ocp_read_with_oob_base_address(tp, addr, len,
+                        NO_BASE_ADDRESS);
+}
+
+u32 rtl8125_ocp_write_with_oob_base_address(struct rtl8125_private *tp, u16 addr, u8 len, u32 value, const u32 base_address)
+{
+        return rtl8125_eri_write_with_oob_base_address(tp, addr, len, value,
+                        ERIAR_OOB, base_address);
+}
+
+void rtl8125_ocp_write(struct rtl8125_private *tp, u16 addr, u8 len, u32 value)
+{
+        if (!tp->AllowAccessDashOcp || tp->HwSuppOcpChannelVer != 2)
+                return;
+
+        rtl8125_ocp_write_with_oob_base_address(tp, addr, len, value, NO_BASE_ADDRESS);
+}
+
+void rtl8125_oob_mutex_lock(struct rtl8125_private *tp)
+{
+        u8 reg_16, reg_a0;
+        u32 wait_cnt_0, wait_Cnt_1;
+        u16 ocp_reg_mutex_ib;
+        u16 ocp_reg_mutex_oob;
+        u16 ocp_reg_mutex_prio;
+
+        if (!HW_DASH_SUPPORT_DASH(tp))
+                return;
+
+        if (!tp->DASH)
+                return;
+
+        ocp_reg_mutex_oob = 0x110;
+        ocp_reg_mutex_ib = 0x114;
+        ocp_reg_mutex_prio = 0x11C;
+
+        rtl8125_ocp_write(tp, ocp_reg_mutex_ib, 1, BIT_0);
+        reg_16 = rtl8125_ocp_read(tp, ocp_reg_mutex_oob, 1);
+        wait_cnt_0 = 0;
+        while(reg_16) {
+                reg_a0 = rtl8125_ocp_read(tp, ocp_reg_mutex_prio, 1);
+                if (reg_a0) {
+                        rtl8125_ocp_write(tp, ocp_reg_mutex_ib, 1, 0x00);
+                        reg_a0 = rtl8125_ocp_read(tp, ocp_reg_mutex_prio, 1);
+                        wait_Cnt_1 = 0;
+                        while(reg_a0) {
+                                reg_a0 = rtl8125_ocp_read(tp, ocp_reg_mutex_prio, 1);
+
+                                wait_Cnt_1++;
+
+                                if (wait_Cnt_1 > 2000)
+                                        break;
+                        };
+                        rtl8125_ocp_write(tp, ocp_reg_mutex_ib, 1, BIT_0);
+
+                }
+                reg_16 = rtl8125_ocp_read(tp, ocp_reg_mutex_oob, 1);
+
+                wait_cnt_0++;
+
+                if (wait_cnt_0 > 2000)
+                        break;
+        };
+}
+
+void rtl8125_oob_mutex_unlock(struct rtl8125_private *tp)
+{
+        u16 ocp_reg_mutex_ib;
+        u16 ocp_reg_mutex_prio;
+
+        if (!HW_DASH_SUPPORT_DASH(tp))
+                return;
+
+        if (!tp->DASH)
+                return;
+
+        ocp_reg_mutex_ib = 0x114;
+        ocp_reg_mutex_prio = 0x11C;
+
+        rtl8125_ocp_write(tp, ocp_reg_mutex_prio, 1, BIT_0);
+        rtl8125_ocp_write(tp, ocp_reg_mutex_ib, 1, 0x00);
+}
+
+static bool rtl8125_is_allow_access_dash_ocp(struct rtl8125_private *tp)
+{
+        bool allow_access = false;
+        u16 mac_ocp_data;
+
+        if (!HW_DASH_SUPPORT_DASH(tp))
+                goto exit;
+
+        allow_access = true;
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xd460);
+                if (mac_ocp_data == 0xffff || !(mac_ocp_data & BIT_0))
+                        allow_access = false;
+                break;
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xd4c0);
+                if (mac_ocp_data == 0xffff || (mac_ocp_data & BIT_3))
+                        allow_access = false;
+                break;
+        default:
+                goto exit;
+        }
+exit:
+        return allow_access;
+}
+
+static u32 rtl8125_get_dash_fw_ver(struct rtl8125_private *tp)
+{
+        u32 ver = 0xffffffff;
+
+        if (FALSE == HW_DASH_SUPPORT_GET_FIRMWARE_VERSION(tp))
+                goto exit;
+
+        ver = rtl8125_ocp_read(tp, OCP_REG_FIRMWARE_MAJOR_VERSION, 4);
+
+exit:
+        return ver;
+}
+
+static int _rtl8125_check_dash(struct rtl8125_private *tp)
+{
+        if (!tp->AllowAccessDashOcp)
+                return 0;
+
+        if (!HW_DASH_SUPPORT_IPC2(tp))
+                return 0;
+
+        if (rtl8125_ocp_read(tp, 0x128, 1) & BIT_0)
+                return 1;
+
+        return 0;
+}
+
+static int rtl8125_check_dash(struct rtl8125_private *tp)
+{
+        if (HW_DASH_SUPPORT_DASH(tp) && _rtl8125_check_dash(tp)) {
+                u32 ver = rtl8125_get_dash_fw_ver(tp);
+                if (!(ver == 0 || ver == 0xffffffff))
+                        return 1;
+        }
+
+        return 0;
+}
+
+static int rtl8125_wait_dash_fw_ready(struct rtl8125_private *tp)
+{
+        int rc = -1;
+        int timeout;
+
+        if (!tp->DASH)
+                goto out;
+
+        for (timeout = 0; timeout < 10; timeout++) {
+                fsleep(10000);
+                if (rtl8125_ocp_read(tp, 0x124, 1) & BIT_0) {
+                        rc = 1;
+                        goto out;
+                }
+        }
+
+        rc = 0;
+
+out:
+        return rc;
+}
+
+static void
+rtl8125_notify_dash_oob_cmac(struct rtl8125_private *tp, u32 cmd)
+{
+        u32 val;
+
+        if (!HW_DASH_SUPPORT_CMAC(tp))
+                return;
+
+        rtl8125_ocp_write(tp, 0x180, 4, cmd);
+        val = rtl8125_ocp_read(tp, 0x30, 4);
+        val |= BIT_0;
+        rtl8125_ocp_write(tp, 0x30, 4, val);
+}
+
+static void
+rtl8125_notify_dash_oob_ipc2(struct rtl8125_private *tp, u32 cmd)
+{
+        if (!HW_DASH_SUPPORT_IPC2(tp))
+                return;
+
+        rtl8125_ocp_write(tp, IB2SOC_DATA, 4, cmd);
+        rtl8125_ocp_write(tp, IB2SOC_CMD, 4, 0x00);
+        rtl8125_ocp_write(tp, IB2SOC_SET, 4, 0x01);
+}
+
+static void
+rtl8125_notify_dash_oob(struct rtl8125_private *tp, u32 cmd)
+{
+        if (HW_DASH_SUPPORT_CMAC(tp))
+                return rtl8125_notify_dash_oob_cmac(tp, cmd);
+        else if (HW_DASH_SUPPORT_IPC2(tp))
+                return rtl8125_notify_dash_oob_ipc2(tp, cmd);
+        else
+                return;
+}
+
+static void rtl8125_driver_start(struct rtl8125_private *tp)
+{
+        if (!tp->AllowAccessDashOcp)
+                return;
+
+        rtl8125_notify_dash_oob(tp, OOB_CMD_DRIVER_START);
+
+        rtl8125_wait_dash_fw_ready(tp);
+}
+
+static void rtl8125_driver_stop(struct rtl8125_private *tp)
+{
+        if (!tp->AllowAccessDashOcp)
+                return;
+
+        rtl8125_notify_dash_oob(tp, OOB_CMD_DRIVER_STOP);
+
+        rtl8125_wait_dash_fw_ready(tp);
+}
+
+void rtl8125_ephy_write(struct rtl8125_private *tp, int RegAddr, int value)
+{
+        int i;
+
+        RTL_W32(tp, EPHYAR,
+                EPHYAR_Write |
+                (RegAddr & EPHYAR_Reg_Mask_v2) << EPHYAR_Reg_shift |
+                (value & EPHYAR_Data_Mask));
+
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
+
+                /* Check if the RTL8125 has completed EPHY write */
+                if (!(RTL_R32(tp, EPHYAR) & EPHYAR_Flag))
+                        break;
+        }
+
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
+}
+
+u16 rtl8125_ephy_read(struct rtl8125_private *tp, int RegAddr)
+{
+        int i;
+        u16 value = 0xffff;
+
+        RTL_W32(tp, EPHYAR,
+                EPHYAR_Read | (RegAddr & EPHYAR_Reg_Mask_v2) << EPHYAR_Reg_shift);
+
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
+
+                /* Check if the RTL8125 has completed EPHY read */
+                if (RTL_R32(tp, EPHYAR) & EPHYAR_Flag) {
+                        value = (u16) (RTL_R32(tp, EPHYAR) & EPHYAR_Data_Mask);
+                        break;
+                }
+        }
+
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
+
+        return value;
+}
+
+static void ClearAndSetPCIePhyBit(struct rtl8125_private *tp, u8 addr, u16 clearmask, u16 setmask)
+{
+        u16 EphyValue;
+
+        EphyValue = rtl8125_ephy_read(tp, addr);
+        EphyValue &= ~clearmask;
+        EphyValue |= setmask;
+        rtl8125_ephy_write(tp, addr, EphyValue);
+}
+
+static void ClearPCIePhyBit(struct rtl8125_private *tp, u8 addr, u16 mask)
+{
+        ClearAndSetPCIePhyBit(tp,
+                              addr,
+                              mask,
+                              0);
+}
+
+static void SetPCIePhyBit(struct rtl8125_private *tp, u8 addr, u16 mask)
+{
+        ClearAndSetPCIePhyBit(tp,
+                              addr,
+                              0,
+                              mask);
+}
+
+static u32
+rtl8125_csi_other_fun_read(struct rtl8125_private *tp,
+                           u8 multi_fun_sel_bit,
+                           u32 addr)
+{
+        u32 cmd;
+        int i;
+        u32 value = 0xffffffff;
+
+        cmd = CSIAR_Read | CSIAR_ByteEn << CSIAR_ByteEn_shift | (addr & CSIAR_Addr_Mask);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                multi_fun_sel_bit = 0;
+
+        if (multi_fun_sel_bit > 7)
+                goto exit;
+
+        cmd |= multi_fun_sel_bit << 16;
+
+        RTL_W32(tp, CSIAR, cmd);
+
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
+
+                /* Check if the RTL8125 has completed CSI read */
+                if (RTL_R32(tp, CSIAR) & CSIAR_Flag) {
+                        value = (u32)RTL_R32(tp, CSIDR);
+                        break;
+                }
+        }
+
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
+
+exit:
+        return value;
+}
+
+static void
+rtl8125_csi_other_fun_write(struct rtl8125_private *tp,
+                            u8 multi_fun_sel_bit,
+                            u32 addr,
+                            u32 value)
+{
+        u32 cmd;
+        int i;
+
+        RTL_W32(tp, CSIDR, value);
+        cmd = CSIAR_Write | CSIAR_ByteEn << CSIAR_ByteEn_shift | (addr & CSIAR_Addr_Mask);
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                multi_fun_sel_bit = 0;
+
+        if (multi_fun_sel_bit > 7)
+                return;
+
+        cmd |= multi_fun_sel_bit << 16;
+
+        RTL_W32(tp, CSIAR, cmd);
+
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
+
+                /* Check if the RTL8125 has completed CSI write */
+                if (!(RTL_R32(tp, CSIAR) & CSIAR_Flag))
+                        break;
+        }
+
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
+}
+
+static u32
+rtl8125_csi_read(struct rtl8125_private *tp,
+                 u32 addr)
+{
+        u8 multi_fun_sel_bit;
+
+        multi_fun_sel_bit = 0;
+
+        return rtl8125_csi_other_fun_read(tp, multi_fun_sel_bit, addr);
+}
+
+static void
+rtl8125_csi_write(struct rtl8125_private *tp,
+                  u32 addr,
+                  u32 value)
+{
+        u8 multi_fun_sel_bit;
+
+        multi_fun_sel_bit = 0;
+
+        rtl8125_csi_other_fun_write(tp, multi_fun_sel_bit, addr, value);
+}
+
+static u8
+rtl8125_csi_fun0_read_byte(struct rtl8125_private *tp,
+                           u32 addr)
+{
+        u8 RetVal = 0;
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT) {
+                struct pci_dev *pdev = tp->pci_dev;
+
+                pci_read_config_byte(pdev, addr, &RetVal);
+        } else {
+                u32 TmpUlong;
+                u16 RegAlignAddr;
+                u8 ShiftByte;
+
+                RegAlignAddr = addr & ~(0x3);
+                ShiftByte = addr & (0x3);
+                TmpUlong = rtl8125_csi_other_fun_read(tp, 0, RegAlignAddr);
+                TmpUlong >>= (8*ShiftByte);
+                RetVal = (u8)TmpUlong;
+        }
+
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
+
+        return RetVal;
+}
+
+static void
+rtl8125_csi_fun0_write_byte(struct rtl8125_private *tp,
+                            u32 addr,
+                            u8 value)
+{
+        if (tp->mcfg == CFG_METHOD_DEFAULT) {
+                struct pci_dev *pdev = tp->pci_dev;
+
+                pci_write_config_byte(pdev, addr, value);
+        } else {
+                u32 TmpUlong;
+                u16 RegAlignAddr;
+                u8 ShiftByte;
+
+                RegAlignAddr = addr & ~(0x3);
+                ShiftByte = addr & (0x3);
+                TmpUlong = rtl8125_csi_other_fun_read(tp, 0, RegAlignAddr);
+                TmpUlong &= ~(0xFF << (8*ShiftByte));
+                TmpUlong |= (value << (8*ShiftByte));
+                rtl8125_csi_other_fun_write(tp, 0, RegAlignAddr, TmpUlong);
+        }
+
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
+}
+
+u32 rtl8125_eri_read_with_oob_base_address(struct rtl8125_private *tp, int addr, int len, int type, const u32 base_address)
+{
+        int i, val_shift, shift = 0;
+        u32 value1 = 0, value2 = 0, mask;
+        u32 eri_cmd;
+        const u32 transformed_base_address = ((base_address & 0x00FFF000) << 6) | (base_address & 0x000FFF);
+
+        if (len > 4 || len <= 0)
+                return -1;
+
+        while (len > 0) {
+                val_shift = addr % ERIAR_Addr_Align;
+                addr = addr & ~0x3;
+
+                eri_cmd = ERIAR_Read |
+                          transformed_base_address |
+                          type << ERIAR_Type_shift |
+                          ERIAR_ByteEn << ERIAR_ByteEn_shift |
+                          (addr & 0x0FFF);
+                if (addr & 0xF000) {
+                        u32 tmp;
+
+                        tmp = addr & 0xF000;
+                        tmp >>= 12;
+                        eri_cmd |= (tmp << 20) & 0x00F00000;
+                }
+
+                RTL_W32(tp, ERIAR, eri_cmd);
+
+                for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                        udelay(R8125_CHANNEL_WAIT_TIME);
+
+                        /* Check if the RTL8125 has completed ERI read */
+                        if (RTL_R32(tp, ERIAR) & ERIAR_Flag)
+                                break;
+                }
+
+                if (len == 1)       mask = (0xFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else if (len == 2)  mask = (0xFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else if (len == 3)  mask = (0xFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else            mask = (0xFFFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+
+                value1 = RTL_R32(tp, ERIDR) & mask;
+                value2 |= (value1 >> val_shift * 8) << shift * 8;
+
+                if (len <= 4 - val_shift) {
+                        len = 0;
+                } else {
+                        len -= (4 - val_shift);
+                        shift = 4 - val_shift;
+                        addr += 4;
+                }
+        }
+
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
+
+        return value2;
+}
+
+u32 rtl8125_eri_read(struct rtl8125_private *tp, int addr, int len, int type)
+{
+        return rtl8125_eri_read_with_oob_base_address(tp, addr, len, type, 0);
+}
+
+int rtl8125_eri_write_with_oob_base_address(struct rtl8125_private *tp, int addr, int len, u32 value, int type, const u32 base_address)
+{
+        int i, val_shift, shift = 0;
+        u32 value1 = 0, mask;
+        u32 eri_cmd;
+        const u32 transformed_base_address = ((base_address & 0x00FFF000) << 6) | (base_address & 0x000FFF);
+
+        if (len > 4 || len <= 0)
+                return -1;
+
+        while (len > 0) {
+                val_shift = addr % ERIAR_Addr_Align;
+                addr = addr & ~0x3;
+
+                if (len == 1)       mask = (0xFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else if (len == 2)  mask = (0xFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else if (len == 3)  mask = (0xFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else            mask = (0xFFFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+
+                value1 = rtl8125_eri_read_with_oob_base_address(tp, addr, 4, type, base_address) & ~mask;
+                value1 |= ((value << val_shift * 8) >> shift * 8);
+
+                RTL_W32(tp, ERIDR, value1);
+
+                eri_cmd = ERIAR_Write |
+                          transformed_base_address |
+                          type << ERIAR_Type_shift |
+                          ERIAR_ByteEn << ERIAR_ByteEn_shift |
+                          (addr & 0x0FFF);
+                if (addr & 0xF000) {
+                        u32 tmp;
+
+                        tmp = addr & 0xF000;
+                        tmp >>= 12;
+                        eri_cmd |= (tmp << 20) & 0x00F00000;
+                }
+
+                RTL_W32(tp, ERIAR, eri_cmd);
+
+                for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                        udelay(R8125_CHANNEL_WAIT_TIME);
+
+                        /* Check if the RTL8125 has completed ERI write */
+                        if (!(RTL_R32(tp, ERIAR) & ERIAR_Flag))
+                                break;
+                }
+
+                if (len <= 4 - val_shift) {
+                        len = 0;
+                } else {
+                        len -= (4 - val_shift);
+                        shift = 4 - val_shift;
+                        addr += 4;
+                }
+        }
+
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
+
+        return 0;
+}
+
+int rtl8125_eri_write(struct rtl8125_private *tp, int addr, int len, u32 value, int type)
+{
+        return rtl8125_eri_write_with_oob_base_address(tp, addr, len, value, type, NO_BASE_ADDRESS);
+}
+
+static void
+rtl8125_enable_rxdvgate(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) | BIT_3);
+}
+
+static void
+rtl8125_disable_rxdvgate(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) & ~BIT_3);
+}
+
+static u8
+rtl8125_is_gpio_low(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u8 gpio_low = FALSE;
+
+        switch (tp->HwSuppCheckPhyDisableModeVer) {
+        case 3:
+                if (!(rtl8125_mac_ocp_read(tp, 0xDC04) & BIT_13))
+                        gpio_low = TRUE;
+                break;
+        }
+
+        if (gpio_low)
+                dprintk("gpio is low.\n");
+
+        return gpio_low;
+}
+
+static u8
+rtl8125_is_phy_disable_mode_enabled(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u8 phy_disable_mode_enabled = FALSE;
+
+        switch (tp->HwSuppCheckPhyDisableModeVer) {
+        case 3:
+                if (RTL_R8(tp, 0xF2) & BIT_5)
+                        phy_disable_mode_enabled = TRUE;
+                break;
+        }
+
+        if (phy_disable_mode_enabled)
+                dprintk("phy disable mode enabled.\n");
+
+        return phy_disable_mode_enabled;
+}
+
+static u8
+rtl8125_is_in_phy_disable_mode(struct net_device *dev)
+{
+        u8 in_phy_disable_mode = FALSE;
+
+        if (rtl8125_is_phy_disable_mode_enabled(dev) && rtl8125_is_gpio_low(dev))
+                in_phy_disable_mode = TRUE;
+
+        if (in_phy_disable_mode)
+                dprintk("Hardware is in phy disable mode.\n");
+
+        return in_phy_disable_mode;
+}
+
+static bool
+rtl8125_stop_all_request(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        RTL_W8(tp, ChipCmd, RTL_R8(tp, ChipCmd) | StopReq);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                for (i = 0; i < 20; i++) {
+                        udelay(10);
+                        if (!(RTL_R8(tp, ChipCmd) & StopReq))
+                                break;
+                }
+
+                if (i == 20)
+                        return false;
+                break;
+        default:
+                udelay(200);
+                break;
+        }
+
+        return true;
+}
+
+static void
+rtl8125_clear_stop_all_request(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        RTL_W8(tp, ChipCmd, RTL_R8(tp, ChipCmd) & (CmdTxEnb | CmdRxEnb));
+}
+
+void
+rtl8125_wait_txrx_fifo_empty(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        /* Txfifo_empty require StopReq been set */
+        for (i = 0; i < 3000; i++) {
+                udelay(50);
+                if ((RTL_R8(tp, MCUCmd_reg) & (Txfifo_empty | Rxfifo_empty)) == (Txfifo_empty | Rxfifo_empty))
+                        break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                for (i = 0; i < 3000; i++) {
+                        udelay(50);
+                        if ((RTL_R16(tp, IntrMitigate) & (BIT_0 | BIT_1 | BIT_8)) == (BIT_0 | BIT_1 | BIT_8))
+                                break;
+                }
+                break;
+        }
+}
+
+#ifdef ENABLE_DASH_SUPPORT
+
+static inline void
+rtl8125_enable_dash2_interrupt(struct rtl8125_private *tp)
+{
+        if (!HW_DASH_SUPPORT_IPC2(tp))
+                return;
+
+        if (!tp->DASH)
+                return;
+
+        rtl8125_set_ipc2_soc_imr_bit(tp, RISC_IPC2_INTR);
+}
+
+static inline void
+rtl8125_disable_dash2_interrupt(struct rtl8125_private *tp)
+{
+        if (!HW_DASH_SUPPORT_IPC2(tp))
+                return;
+
+        rtl8125_clear_ipc2_soc_imr_bit(tp, RISC_IPC2_INTR);
+}
+#endif
+
+void
+rtl8125_enable_hw_linkchg_interrupt(struct rtl8125_private *tp)
+{
+        switch (tp->HwCurrIsrVer) {
+        case 7:
+                RTL_W32(tp, IMR_V2_SET_REG_8125, ISRIMR_V7_LINKCHG);
+                break;
+        case 5:
+                RTL_W32(tp, IMR_V2_SET_REG_8125, ISRIMR_V5_LINKCHG);
+                break;
+        case 4:
+                RTL_W32(tp, IMR_V2_SET_REG_8125, ISRIMR_V4_LINKCHG);
+                break;
+        case 2:
+        case 3:
+                RTL_W32(tp, IMR_V2_SET_REG_8125, ISRIMR_V2_LINKCHG);
+                break;
+        case 1:
+                RTL_W32(tp, tp->imr_reg[0], LinkChg | RTL_R32(tp, tp->imr_reg[0]));
+                break;
+        }
+
+#ifdef ENABLE_DASH_SUPPORT
+        if (tp->DASH)
+                rtl8125_enable_dash2_interrupt(tp);
+#endif
+}
+
+static inline void
+rtl8125_enable_hw_interrupt(struct rtl8125_private *tp)
+{
+        switch (tp->HwCurrIsrVer) {
+        case 2:
+        case 3:
+        case 4:
+        case 5:
+        case 7:
+                RTL_W32(tp, IMR_V2_SET_REG_8125, tp->intr_mask);
+                break;
+        case 1:
+                RTL_W32(tp, tp->imr_reg[0], tp->intr_mask);
+
+                if (R8125_MULTI_RX_Q(tp)) {
+                        int i;
+                        for (i=1; i<tp->num_rx_rings; i++)
+                                RTL_W16(tp, tp->imr_reg[i], other_q_intr_mask);
+                }
+                break;
+        }
+
+#ifdef ENABLE_DASH_SUPPORT
+        if (tp->DASH)
+                rtl8125_enable_dash2_interrupt(tp);
+#endif
+}
+
+static inline void rtl8125_clear_hw_isr_v2(struct rtl8125_private *tp,
+                u32 message_id)
+{
+        RTL_W32(tp, ISR_V2_8125, BIT(message_id));
+}
+
+static inline void
+rtl8125_disable_hw_interrupt(struct rtl8125_private *tp)
+{
+        if (tp->HwCurrIsrVer > 1) {
+                RTL_W32(tp, IMR_V2_CLEAR_REG_8125, 0xFFFFFFFF);
+                if (tp->HwCurrIsrVer > 3)
+                        RTL_W32(tp, IMR_V4_L2_CLEAR_REG_8125, 0xFFFFFFFF);
+        } else {
+                RTL_W32(tp, tp->imr_reg[0], 0x0000);
+
+                if (R8125_MULTI_RX_Q(tp)) {
+                        int i;
+                        for (i=1; i<tp->num_rx_rings; i++)
+                                RTL_W16(tp, tp->imr_reg[i], 0);
+                }
+        }
+
+#ifdef ENABLE_DASH_SUPPORT
+        rtl8125_disable_dash2_interrupt(tp);
+#endif
+}
+
+static inline void
+rtl8125_switch_to_hw_interrupt(struct rtl8125_private *tp)
+{
+        RTL_W32(tp, TIMER_INT0_8125, 0x0000);
+
+        rtl8125_enable_hw_interrupt(tp);
+}
+
+static inline void
+rtl8125_switch_to_timer_interrupt(struct rtl8125_private *tp)
+{
+        if (tp->use_timer_interrupt) {
+                RTL_W32(tp, TIMER_INT0_8125, timer_count);
+                RTL_W32(tp, TCTR0_8125, timer_count);
+                RTL_W32(tp, tp->imr_reg[0], tp->timer_intr_mask);
+        } else {
+                rtl8125_switch_to_hw_interrupt(tp);
+        }
+}
+
+static void
+rtl8125_irq_mask_and_ack(struct rtl8125_private *tp)
+{
+        rtl8125_disable_hw_interrupt(tp);
+
+        if (tp->HwCurrIsrVer > 1) {
+                RTL_W32(tp, ISR_V2_8125, 0xFFFFFFFF);
+                if (tp->HwCurrIsrVer > 3)
+                        RTL_W32(tp, ISR_V4_L2_8125, 0xFFFFFFFF);
+        } else {
+                RTL_W32(tp, tp->isr_reg[0], RTL_R32(tp, tp->isr_reg[0]));
+
+                if (R8125_MULTI_RX_Q(tp)) {
+                        int i;
+                        for (i=1; i<tp->num_rx_rings; i++)
+                                RTL_W16(tp, tp->isr_reg[i], RTL_R16(tp, tp->isr_reg[i]));
+                }
+        }
+
+#ifdef ENABLE_DASH_SUPPORT
+        rtl8125_clear_ipc2_isr(tp);
+#endif
+}
+
+static void
+rtl8125_disable_rx_packet_filter(struct rtl8125_private *tp)
+{
+
+        RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) &
+                ~(AcceptErr | AcceptRunt |AcceptBroadcast | AcceptMulticast |
+                  AcceptMyPhys |  AcceptAllPhys));
+}
+
+static void
+rtl8125_nic_reset(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        rtl8125_disable_rx_packet_filter(tp);
+
+        rtl8125_enable_rxdvgate(dev);
+
+        rtl8125_stop_all_request(dev);
+
+        rtl8125_wait_txrx_fifo_empty(dev);
+
+        rtl8125_clear_stop_all_request(dev);
+
+        /* Soft reset the chip. */
+        RTL_W8(tp, ChipCmd, CmdReset);
+
+        /* Check that the chip has finished the reset. */
+        for (i = 100; i > 0; i--) {
+                udelay(100);
+                if ((RTL_R8(tp, ChipCmd) & CmdReset) == 0)
+                        break;
+        }
+
+        /* reset rcr */
+        RTL_W32(tp, RxConfig, (RX_DMA_BURST_512 << RxCfgDMAShift));
+}
+
+static void
+rtl8125_hw_set_interrupt_type(struct rtl8125_private *tp, u8 isr_ver)
+{
+        u8 tmp;
+
+        if (tp->HwSuppIsrVer < 2)
+                return;
+
+        tmp = RTL_R8(tp, INT_CFG0_8125);
+
+        switch (tp->HwSuppIsrVer) {
+        case 7:
+                tmp &= ~INT_CFG0_AVOID_MISS_INTR;
+                fallthrough;
+        case 4:
+        case 5:
+                if (tp->HwSuppIsrVer == 7)
+                        tmp &= ~INT_CFG0_AUTO_CLEAR_IMR;
+                else
+                        tmp &= ~INT_CFG0_MSIX_ENTRY_NUM_MODE;
+                fallthrough;
+        case 2:
+        case 3:
+                tmp &= ~(INT_CFG0_ENABLE_8125);
+                if (isr_ver > 1)
+                        tmp |= INT_CFG0_ENABLE_8125;
+                break;
+        default:
+                return;
+        }
+
+        RTL_W8(tp, INT_CFG0_8125, tmp);
+}
+
+static void
+rtl8125_hw_clear_timer_int(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        RTL_W32(tp, TIMER_INT0_8125, 0x0000);
+        RTL_W32(tp, TIMER_INT1_8125, 0x0000);
+        RTL_W32(tp, TIMER_INT2_8125, 0x0000);
+        RTL_W32(tp, TIMER_INT3_8125, 0x0000);
+}
+
+static void
+rtl8125_hw_clear_int_miti(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        switch (tp->HwSuppIntMitiVer) {
+        case 3:
+        case 6:
+                //IntMITI_0-IntMITI_31
+                for (i=0xA00; i<0xB00; i+=4)
+                        RTL_W32(tp, i, 0x0000);
+                break;
+        case 4:
+        case 5:
+                //IntMITI_0-IntMITI_15
+                for (i = 0xA00; i < 0xA80; i += 4)
+                        RTL_W32(tp, i, 0x0000);
+
+                if (tp->HwSuppIntMitiVer == 5)
+                        RTL_W8(tp, INT_CFG0_8125, RTL_R8(tp, INT_CFG0_8125) &
+                               ~(INT_CFG0_TIMEOUT0_BYPASS_8125 |
+                                 INT_CFG0_MITIGATION_BYPASS_8125 |
+                                 INT_CFG0_RDU_BYPASS_8126));
+                else
+                        RTL_W8(tp, INT_CFG0_8125, RTL_R8(tp, INT_CFG0_8125) &
+                               ~(INT_CFG0_TIMEOUT0_BYPASS_8125 | INT_CFG0_MITIGATION_BYPASS_8125));
+
+                RTL_W16(tp, INT_CFG1_8125, 0x0000);
+                break;
+        }
+}
+
+static bool
+rtl8125_vec_2_tx_q_num(
+        struct rtl8125_private *tp,
+        u32 messageId,
+        u32 *qnum
+)
+{
+        u32 whichQ = 0xffffffff;
+        bool rc = false;
+
+        switch (tp->HwSuppIsrVer) {
+        case 2:
+                if (messageId == 0x10)
+                        whichQ = 0;
+                else if (messageId == 0x12 && tp->num_tx_rings > 1)
+                        whichQ = 1;
+                break;
+        case 3:
+        case 4:
+                if (messageId == 0x00)
+                        whichQ = 0;
+                else if (messageId == 0x01 && tp->num_tx_rings > 1)
+                        whichQ = 1;
+                break;
+        case 5:
+                if (messageId == 0x10)
+                        whichQ = 0;
+                else if (messageId == 0x11 && tp->num_tx_rings > 1)
+                        whichQ = 1;
+                break;
+        case 6:
+                if (messageId == 0x08)
+                        whichQ = 0;
+                else if (messageId == 0x09 && tp->num_tx_rings > 1)
+                        whichQ = 1;
+                break;
+        case 7:
+                if (messageId == 0x1B)
+                        whichQ = 0;
+                else if (messageId == 0x1C && tp->num_tx_rings > 1)
+                        whichQ = 1;
+                break;
+        }
+
+        if (whichQ != 0xffffffff) {
+                *qnum = whichQ;
+                rc = true;
+        }
+
+        return rc;
+}
+
+static bool
+rtl8125_vec_2_rx_q_num(
+        struct rtl8125_private *tp,
+        u32 messageId,
+        u32 *qnum
+)
+{
+        u32 whichQ = 0xffffffff;
+        bool rc = false;
+
+        switch (tp->HwSuppIsrVer) {
+        case 2:
+        case 3:
+        case 4:
+        case 5:
+        case 6:
+        case 7:
+                if (messageId < tp->HwSuppNumRxQueues)
+                        whichQ = messageId;
+                break;
+        }
+
+        if (whichQ != 0xffffffff) {
+                *qnum = whichQ;
+                rc = true;
+        }
+
+        return rc;
+}
+
+void
+rtl8125_hw_set_timer_int(struct rtl8125_private *tp,
+                         u32 message_id,
+                         u8 timer_intmiti_val)
+{
+        u32 qnum;
+
+        switch (tp->HwSuppIntMitiVer) {
+        case 4:
+        case 5:
+        case 6:
+#ifdef ENABLE_LIB_SUPPORT
+                if (message_id < R8125_MAX_RX_QUEUES_VEC_V3)
+                        timer_intmiti_val = 0;
+#else
+                if ((tp->HwCurrIsrVer == 2) && (message_id < R8125_MAX_RX_QUEUES_VEC_V3))
+                        timer_intmiti_val = 0;
+#endif //ENABLE_LIB_SUPPORT
+                //ROK
+                if (rtl8125_vec_2_rx_q_num(tp, message_id, &qnum))
+                        RTL_W8(tp,INT_MITI_V2_0_RX + 8 * qnum, timer_intmiti_val);
+                //TOK
+                if (rtl8125_vec_2_tx_q_num(tp, message_id, &qnum))
+                        RTL_W8(tp,INT_MITI_V2_0_TX + 8 * qnum, timer_intmiti_val);
+                break;
+        }
+}
+
+void
+rtl8125_hw_reset(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_lib_reset_prepare(tp);
+
+        /* Disable interrupts */
+        rtl8125_irq_mask_and_ack(tp);
+
+        rtl8125_hw_clear_timer_int(dev);
+
+        rtl8125_nic_reset(dev);
+}
+
+static unsigned int
+rtl8125_xmii_reset_pending(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long flags;
+        unsigned int retval;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        rtl8125_mdio_write(tp, 0x1f, 0x0000);
+        retval = rtl8125_mdio_read(tp, MII_BMCR) & BMCR_RESET;
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        return retval;
+}
+
+static unsigned int
+_rtl8125_xmii_link_ok(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 status;
+
+        status = rtl8125_get_phy_status(tp);
+        if (status == UINT_MAX)
+                return 0;
+
+        return (status & LinkStatus) ? 1 : 0;
+}
+
+static unsigned int
+rtl8125_xmii_link_ok(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned int link_state;
+
+        link_state = _rtl8125_xmii_link_ok(dev);
+#ifdef ENABLE_FIBER_SUPPORT
+        if (HW_FIBER_MODE_ENABLED(tp) &&
+            link_state == R8125_LINK_STATE_ON)
+                return rtl8125_fiber_link_ok(dev);
+#else
+        (void)tp;
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        return link_state;
+}
+
+static int
+rtl8125_wait_phy_reset_complete(struct rtl8125_private *tp)
+{
+        int i, val;
+
+        for (i = 0; i < 2500; i++) {
+                val = rtl8125_mdio_read(tp, MII_BMCR) & BMCR_RESET;
+                if (!val)
+                        return 0;
+
+                mdelay(1);
+        }
+
+        return -1;
+}
+
+static void
+rtl8125_xmii_reset_enable(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long flags;
+        int ret;
+
+        if (rtl8125_is_in_phy_disable_mode(dev))
+                return;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        rtl8125_mdio_write(tp, 0x1f, 0x0000);
+        rtl8125_mdio_write(tp, MII_ADVERTISE, rtl8125_mdio_read(tp, MII_ADVERTISE) &
+                           ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
+                             ADVERTISE_100HALF | ADVERTISE_100FULL));
+        rtl8125_mdio_write(tp, MII_CTRL1000, rtl8125_mdio_read(tp, MII_CTRL1000) &
+                           ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL));
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA5D4, rtl8125_mdio_direct_read_phy_ocp(tp, 0xA5D4) &
+                                          ~RTK_ADVERTISE_2500FULL);
+        rtl8125_mdio_write(tp, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
+
+        ret = rtl8125_wait_phy_reset_complete(tp);
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        if (ret != 0 && netif_msg_link(tp))
+                printk(KERN_ERR "%s: PHY reset failed.\n", dev->name);
+}
+
+void
+rtl8125_init_ring_indexes(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->HwSuppNumTxQueues; i++) {
+                struct rtl8125_tx_ring *ring = &tp->tx_ring[i];
+                ring->dirty_tx = ring->cur_tx = 0;
+                ring->NextHwDesCloPtr = 0;
+                ring->BeginHwDesCloPtr = 0;
+                ring->index = i;
+                ring->priv = tp;
+                ring->netdev = tp->dev;
+
+                /* reset BQL for queue */
+                netdev_tx_reset_queue(txring_txq(ring));
+        }
+
+        for (i = 0; i < tp->HwSuppNumRxQueues; i++) {
+                struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
+                ring->dirty_rx = ring->cur_rx = 0;
+                ring->index = i;
+                ring->priv = tp;
+                ring->netdev = tp->dev;
+        }
+
+#ifdef ENABLE_LIB_SUPPORT
+        for (i = 0; i < tp->HwSuppNumTxQueues; i++) {
+                struct rtl8125_ring *ring = &tp->lib_tx_ring[i];
+                ring->direction = RTL8125_CH_DIR_TX;
+                ring->queue_num = i;
+                ring->private = tp;
+        }
+
+        for (i = 0; i < tp->HwSuppNumRxQueues; i++) {
+                struct rtl8125_ring *ring = &tp->lib_rx_ring[i];
+                ring->direction = RTL8125_CH_DIR_RX;
+                ring->queue_num = i;
+                ring->private = tp;
+        }
+#endif
+}
+
+static void
+rtl8125_issue_offset_99_event(struct rtl8125_private *tp)
+{
+        rtl8125_mac_ocp_write(tp, 0xE09A,  rtl8125_mac_ocp_read(tp, 0xE09A) | BIT_0);
+}
+
+#ifdef ENABLE_DASH_SUPPORT
+static void
+rtl8125_check_and_enable_dash_interrupt(struct rtl8125_private *tp)
+{
+        if (!HW_DASH_SUPPORT_IPC2(tp))
+                return;
+
+        if (!tp->DASH)
+                return;
+
+        //
+        // even disconnected, enable dash interrupt mask bits for in-band/out-band communication
+        //
+        rtl8125_enable_dash2_interrupt(tp);
+        if (tp->HwCurrIsrVer > 1) {
+                RTL_W32(tp, IMR_V2_SET_REG_8125, ISRIMR_V4_LAYER2_INTR_STS);
+                RTL_W32(tp, IMR_V4_L2_SET_REG_8125, ISRIMR_V4_L2_IPC2);
+        } else {
+                RTL_W16(tp, tp->imr_reg[0], ISRIMR_DASH_INTR_EN);
+        }
+}
+#endif
+
+static int rtl8125_enable_eee_plus(struct rtl8125_private *tp)
+{
+        rtl8125_mac_ocp_write(tp, 0xE080, rtl8125_mac_ocp_read(tp, 0xE080)|BIT_1);
+
+        return 0;
+}
+
+static int rtl8125_disable_eee_plus(struct rtl8125_private *tp)
+{
+        rtl8125_mac_ocp_write(tp, 0xE080, rtl8125_mac_ocp_read(tp, 0xE080)&~BIT_1);
+
+        return 0;
+}
+
+static void rtl8125_enable_double_vlan(struct rtl8125_private *tp)
+{
+        RTL_W16(tp, DOUBLE_VLAN_CONFIG, 0xf002);
+}
+
+static void rtl8125_disable_double_vlan(struct rtl8125_private *tp)
+{
+        RTL_W16(tp, DOUBLE_VLAN_CONFIG, 0);
+}
+
+static void
+rtl8125_set_pfm_patch(struct rtl8125_private *tp, bool enable)
+{
+        if (!tp->RequiredPfmPatch)
+                goto exit;
+
+        if (enable) {
+                rtl8125_set_mac_ocp_bit(tp, 0xD3F0, BIT_0);
+                rtl8125_set_mac_ocp_bit(tp, 0xD3F2, BIT_0);
+                rtl8125_set_mac_ocp_bit(tp, 0xE85A, BIT_6);
+        } else {
+                rtl8125_clear_mac_ocp_bit(tp, 0xD3F0, BIT_0);
+                rtl8125_clear_mac_ocp_bit(tp, 0xD3F2, BIT_0);
+                rtl8125_clear_mac_ocp_bit(tp, 0xE85A, BIT_6);
+        }
+
+exit:
+        return;
+}
+
+static void
+rtl8125_link_on_patch(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long flags;
+        u32 status;
+
+        rtl8125_hw_config(dev);
+
+        if ((tp->mcfg == CFG_METHOD_2) &&
+            netif_running(dev)) {
+                if (rtl8125_get_phy_status(tp)&FullDup)
+                        RTL_W32(tp, TxConfig, (RTL_R32(tp, TxConfig) | (BIT_24 | BIT_25)) & ~BIT_19);
+                else
+                        RTL_W32(tp, TxConfig, (RTL_R32(tp, TxConfig) | BIT_25) & ~(BIT_19 | BIT_24));
+        }
+
+        status = rtl8125_get_phy_status(tp);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_12:
+                if (status & _10bps)
+                        rtl8125_enable_eee_plus(tp);
+                break;
+        default:
+                break;
+        }
+
+        if (tp->RequiredPfmPatch)
+                rtl8125_set_pfm_patch(tp, (status & _10bps) ? 1 : 0);
+
+        rtl8125_hw_start(dev);
+
+        netif_carrier_on(dev);
+
+        netif_tx_wake_all_queues(dev);
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        tp->phy_reg_aner = rtl8125_mdio_read(tp, MII_EXPANSION);
+        tp->phy_reg_anlpar = rtl8125_mdio_read(tp, MII_LPA);
+        tp->phy_reg_gbsr = rtl8125_mdio_read(tp, MII_STAT1000);
+        tp->phy_reg_status_2500 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA5D6);
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+#ifdef ENABLE_PTP_SUPPORT
+        if (tp->HwSuppPtpVer == 3)
+                rtl8125_set_phy_local_time(tp);
+#endif // ENABLE_PTP_SUPPORT
+}
+
+static void
+rtl8125_link_down_patch(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long flags;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        tp->phy_reg_aner = 0;
+        tp->phy_reg_anlpar = 0;
+        tp->phy_reg_gbsr = 0;
+        tp->phy_reg_status_2500 = 0;
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_12:
+                rtl8125_disable_eee_plus(tp);
+                break;
+        default:
+                break;
+        }
+
+        if (tp->RequiredPfmPatch)
+                rtl8125_set_pfm_patch(tp, 1);
+
+        netif_carrier_off(dev);
+
+        netif_tx_disable(dev);
+
+        rtl8125_hw_reset(dev);
+
+        rtl8125_tx_clear(tp);
+
+        rtl8125_rx_clear(tp);
+
+        rtl8125_init_ring(dev);
+
+        rtl8125_enable_hw_linkchg_interrupt(tp);
+
+        //rtl8125_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+
+#ifdef ENABLE_DASH_SUPPORT
+        rtl8125_check_and_enable_dash_interrupt(tp);
+#endif
+}
+
+static void
+_rtl8125_check_link_status(struct net_device *dev, unsigned int link_state)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (link_state != R8125_LINK_STATE_OFF &&
+            link_state != R8125_LINK_STATE_ON)
+                link_state = tp->link_ok(dev);
+
+        if (link_state == R8125_LINK_STATE_ON) {
+                rtl8125_link_on_patch(dev);
+
+                if (netif_msg_ifup(tp))
+                        printk(KERN_INFO PFX "%s: link up\n", dev->name);
+        } else {
+                if (netif_msg_ifdown(tp))
+                        printk(KERN_INFO PFX "%s: link down\n", dev->name);
+
+                rtl8125_link_down_patch(dev);
+        }
+}
+
+static void
+rtl8125_check_link_status(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned int link_status_on;
+
+        tp->resume_not_chg_speed = 0;
+
+        link_status_on = tp->link_ok(dev);
+        if (netif_carrier_ok(dev) == link_status_on)
+                rtl8125_enable_hw_linkchg_interrupt(tp);
+        else
+                _rtl8125_check_link_status(dev, link_status_on);
+}
+
+static bool
+rtl8125_is_autoneg_mode_valid(u32 autoneg)
+{
+        switch(autoneg) {
+        case AUTONEG_ENABLE:
+        case AUTONEG_DISABLE:
+                return true;
+        default:
+                return false;
+        }
+}
+
+static bool
+rtl8125_is_speed_mode_valid(u32 speed)
+{
+        switch(speed) {
+        case SPEED_2500:
+        case SPEED_1000:
+        case SPEED_100:
+        case SPEED_10:
+                return true;
+        default:
+                return false;
+        }
+}
+
+static bool
+rtl8125_is_duplex_mode_valid(u8 duplex)
+{
+        switch(duplex) {
+        case DUPLEX_FULL:
+        case DUPLEX_HALF:
+                return true;
+        default:
+                return false;
+        }
+}
+
+static void
+rtl8125_set_link_option(struct rtl8125_private *tp,
+                        u8 autoneg,
+                        u32 speed,
+                        u8 duplex,
+                        enum rtl8125_fc_mode fc)
+{
+        u64 adv;
+
+        if (!rtl8125_is_speed_mode_valid(speed))
+                speed = SPEED_2500;
+
+        if (!rtl8125_is_duplex_mode_valid(duplex))
+                duplex = DUPLEX_FULL;
+
+        if (!rtl8125_is_autoneg_mode_valid(autoneg))
+                autoneg = AUTONEG_ENABLE;
+
+        speed = min(speed, tp->HwSuppMaxPhyLinkSpeed);
+
+        adv = 0;
+        switch(speed) {
+        case SPEED_2500:
+                adv |= ADVERTISED_2500baseX_Full;
+                fallthrough;
+        default:
+                adv |= (ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
+                        ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
+                        ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full);
+                break;
+        }
+
+        tp->autoneg = autoneg;
+        tp->speed = speed;
+        tp->duplex = duplex;
+        tp->advertising = adv;
+        tp->fcpause = fc;
+}
+
+/*
+static void
+rtl8125_enable_ocp_phy_power_saving(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 val;
+
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_6) {
+                val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xC416);
+                if (val != 0x0050) {
+                        rtl8125_set_phy_mcu_patch_request(tp);
+                        rtl8125_mdio_direct_write_phy_ocp(tp, 0xC416, 0x0000);
+                        rtl8125_mdio_direct_write_phy_ocp(tp, 0xC416, 0x0050);
+                        rtl8125_clear_phy_mcu_patch_request(tp);
+                }
+        }
+}
+*/
+
+static void
+rtl8125_disable_ocp_phy_power_saving(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 val;
+
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_6) {
+                val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xC416);
+                if (val != 0x0500) {
+                        rtl8125_set_phy_mcu_patch_request(tp);
+                        rtl8125_mdio_direct_write_phy_ocp(tp, 0xC416, 0x0000);
+                        rtl8125_mdio_direct_write_phy_ocp(tp, 0xC416, 0x0500);
+                        rtl8125_clear_phy_mcu_patch_request(tp);
+                }
+        }
+}
+
+static void
+rtl8125_wait_ll_share_fifo_ready(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        for (i = 0; i < 10; i++) {
+                udelay(100);
+                if (RTL_R16(tp, 0xD2) & BIT_9)
+                        break;
+        }
+}
+
+static void
+rtl8125_disable_pci_offset_99(struct rtl8125_private *tp)
+{
+        rtl8125_mac_ocp_write(tp, 0xE032,  rtl8125_mac_ocp_read(tp, 0xE032) & ~(BIT_0 | BIT_1));
+
+        rtl8125_csi_fun0_write_byte(tp, 0x99, 0x00);
+}
+
+static void
+rtl8125_enable_pci_offset_99(struct rtl8125_private *tp)
+{
+        u32 csi_tmp;
+
+        rtl8125_csi_fun0_write_byte(tp, 0x99, tp->org_pci_offset_99);
+
+        csi_tmp = rtl8125_mac_ocp_read(tp, 0xE032);
+        csi_tmp &= ~(BIT_0 | BIT_1);
+        if (tp->org_pci_offset_99 & (BIT_5 | BIT_6))
+                csi_tmp |= BIT_1;
+        if (tp->org_pci_offset_99 & BIT_2)
+                csi_tmp |= BIT_0;
+        rtl8125_mac_ocp_write(tp, 0xE032, csi_tmp);
+}
+
+static void
+rtl8125_init_pci_offset_99(struct rtl8125_private *tp)
+{
+        rtl8125_mac_ocp_write(tp, 0xCDD0, 0x9003);
+        rtl8125_set_mac_ocp_bit(tp, 0xE034, (BIT_15 | BIT_14));
+        rtl8125_mac_ocp_write(tp, 0xCDD2, 0x889C);
+        rtl8125_mac_ocp_write(tp, 0xCDD8, 0x9003);
+        rtl8125_mac_ocp_write(tp, 0xCDD4, 0x8C30);
+        rtl8125_mac_ocp_write(tp, 0xCDDA, 0x9003);
+        rtl8125_mac_ocp_write(tp, 0xCDD6, 0x9003);
+        rtl8125_mac_ocp_write(tp, 0xCDDC, 0x9003);
+        rtl8125_mac_ocp_write(tp, 0xCDE8, 0x883E);
+        rtl8125_mac_ocp_write(tp, 0xCDEA, 0x9003);
+        rtl8125_mac_ocp_write(tp, 0xCDEC, 0x889C);
+        rtl8125_mac_ocp_write(tp, 0xCDEE, 0x9003);
+        rtl8125_mac_ocp_write(tp, 0xCDF0, 0x8C09);
+        rtl8125_mac_ocp_write(tp, 0xCDF2, 0x9003);
+        rtl8125_set_mac_ocp_bit(tp, 0xE032, BIT_14);
+        rtl8125_set_mac_ocp_bit(tp, 0xE0A2, BIT_0);
+
+        rtl8125_enable_pci_offset_99(tp);
+}
+
+static void
+rtl8125_disable_pci_offset_180(struct rtl8125_private *tp)
+{
+        rtl8125_clear_mac_ocp_bit(tp, 0xE092, 0x00FF);
+}
+
+static void
+rtl8125_enable_pci_offset_180(struct rtl8125_private *tp)
+{
+        rtl8125_clear_mac_ocp_bit(tp, 0xE094, 0xFF00);
+
+        rtl8125_clear_set_mac_ocp_bit(tp, 0xE092, 0x00FF, BIT_2);
+}
+
+static void
+rtl8125_init_pci_offset_180(struct rtl8125_private *tp)
+{
+        rtl8125_enable_pci_offset_180(tp);
+}
+
+static void
+rtl8125_set_pci_99_exit_driver_para(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->org_pci_offset_99 & BIT_2)
+                rtl8125_issue_offset_99_event(tp);
+        rtl8125_disable_pci_offset_99(tp);
+}
+
+static void
+rtl8125_enable_cfg9346_write(struct rtl8125_private *tp)
+{
+        RTL_W8(tp, Cfg9346, RTL_R8(tp, Cfg9346) | Cfg9346_Unlock);
+}
+
+static void
+rtl8125_disable_cfg9346_write(struct rtl8125_private *tp)
+{
+        RTL_W8(tp, Cfg9346, RTL_R8(tp, Cfg9346) & ~Cfg9346_Unlock);
+}
+
+static void
+rtl8125_enable_exit_l1_mask(struct rtl8125_private *tp)
+{
+        //(1)ERI(0xD4)(OCP 0xC0AC).bit[7:12]=6'b111111, L1 Mask
+        rtl8125_set_mac_ocp_bit(tp, 0xC0AC, (BIT_7 | BIT_8 | BIT_9 | BIT_10 | BIT_11 | BIT_12));
+}
+
+static void
+rtl8125_disable_exit_l1_mask(struct rtl8125_private *tp)
+{
+        //(1)ERI(0xD4)(OCP 0xC0AC).bit[7:12]=6'b000000, L1 Mask
+        rtl8125_clear_mac_ocp_bit(tp, 0xC0AC, (BIT_7 | BIT_8 | BIT_9 | BIT_10 | BIT_11 | BIT_12));
+}
+
+static void
+rtl8125_enable_extend_tally_couter(struct rtl8125_private *tp)
+{
+        switch (tp->HwSuppExtendTallyCounterVer) {
+        case 1:
+                rtl8125_set_mac_ocp_bit(tp, 0xEA84, (BIT_1 | BIT_0));
+                break;
+        }
+}
+
+static void
+rtl8125_disable_extend_tally_couter(struct rtl8125_private *tp)
+{
+        switch (tp->HwSuppExtendTallyCounterVer) {
+        case 1:
+                rtl8125_clear_mac_ocp_bit(tp, 0xEA84, (BIT_1 | BIT_0));
+                break;
+        }
+}
+
+static void
+rtl8125_enable_force_clkreq(struct rtl8125_private *tp, bool enable)
+{
+        if (enable)
+                RTL_W8(tp, 0xF1, RTL_R8(tp, 0xF1) | BIT_7);
+        else
+                RTL_W8(tp, 0xF1, RTL_R8(tp, 0xF1) & ~BIT_7);
+}
+
+static void
+rtl8125_enable_aspm_clkreq_lock(struct rtl8125_private *tp, bool enable)
+{
+        bool unlock_cfg_wr;
+
+        if ((RTL_R8(tp, Cfg9346) & Cfg9346_EEM_MASK) == Cfg9346_Unlock)
+                unlock_cfg_wr = false;
+        else
+                unlock_cfg_wr = true;
+
+        if (unlock_cfg_wr)
+                rtl8125_enable_cfg9346_write(tp);
+
+        if (enable) {
+                RTL_W8(tp, Config2, RTL_R8(tp, Config2) | BIT_7);
+                RTL_W8(tp, Config5, RTL_R8(tp, Config5) | BIT_0);
+        } else {
+                RTL_W8(tp, Config2, RTL_R8(tp, Config2) & ~BIT_7);
+                RTL_W8(tp, Config5, RTL_R8(tp, Config5) & ~BIT_0);
+        }
+
+        if (unlock_cfg_wr)
+                rtl8125_disable_cfg9346_write(tp);
+}
+
+static void
+rtl8125_set_reg_oobs_en_sel(struct rtl8125_private *tp, bool enable)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                if (enable)
+                        rtl8125_set_mac_ocp_bit(tp, 0xD434, BIT_1);
+                else
+                        rtl8125_clear_mac_ocp_bit(tp, 0xD434, BIT_1);
+                break;
+        default:
+                break;
+        }
+}
+
+static void
+rtl8125_hw_d3_para(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        RTL_W16(tp, RxMaxSize, RX_BUF_SIZE);
+
+        rtl8125_enable_force_clkreq(tp, 0);
+        rtl8125_enable_aspm_clkreq_lock(tp, 0);
+
+        rtl8125_disable_exit_l1_mask(tp);
+
+#ifdef ENABLE_REALWOW_SUPPORT
+        rtl8125_set_realwow_d3_para(dev);
+#endif
+
+        rtl8125_set_pci_99_exit_driver_para(dev);
+
+        /*disable ocp phy power saving*/
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_6)
+                rtl8125_disable_ocp_phy_power_saving(dev);
+
+        rtl8125_disable_rxdvgate(dev);
+
+        rtl8125_disable_extend_tally_couter(tp);
+
+        rtl8125_set_reg_oobs_en_sel(tp, false);
+}
+
+static void
+rtl8125_enable_magic_packet(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppMagicPktVer) {
+        case WAKEUP_MAGIC_PACKET_V3:
+                rtl8125_mac_ocp_write(tp, 0xC0B6, rtl8125_mac_ocp_read(tp, 0xC0B6) | BIT_0);
+                break;
+        }
+}
+static void
+rtl8125_disable_magic_packet(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppMagicPktVer) {
+        case WAKEUP_MAGIC_PACKET_V3:
+                rtl8125_mac_ocp_write(tp, 0xC0B6, rtl8125_mac_ocp_read(tp, 0xC0B6) & ~BIT_0);
+                break;
+        }
+}
+
+static void
+rtl8125_enable_linkchg_wakeup(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppLinkChgWakeUpVer) {
+        case 3:
+                RTL_W8(tp, Config3, RTL_R8(tp, Config3) | LinkUp);
+                rtl8125_clear_set_mac_ocp_bit(tp, 0xE0C6, (BIT_5 | BIT_3 | BIT_2), (BIT_4 | BIT_1 | BIT_0));
+                break;
+        }
+}
+
+static void
+rtl8125_disable_linkchg_wakeup(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppLinkChgWakeUpVer) {
+        case 3:
+                RTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~LinkUp);
+                if (!(rtl8125_mac_ocp_read(tp, 0xE0C6) & BIT_0))
+                        rtl8125_clear_set_mac_ocp_bit(tp, 0xE0C6, (BIT_5 | BIT_3 | BIT_2 | BIT_1), BIT_4);
+                break;
+        }
+}
+
+#define WAKE_ANY (WAKE_PHY | WAKE_MAGIC | WAKE_UCAST | WAKE_BCAST | WAKE_MCAST)
+
+static u32
+rtl8125_get_hw_wol(struct rtl8125_private *tp)
+{
+        u8 options;
+        u32 csi_tmp;
+        u32 wol_opts = 0;
+
+        if (disable_wol_support)
+                goto out;
+
+        options = RTL_R8(tp, Config1);
+        if (!(options & PMEnable))
+                goto out;
+
+        options = RTL_R8(tp, Config3);
+        if (options & LinkUp)
+                wol_opts |= WAKE_PHY;
+
+        switch (tp->HwSuppMagicPktVer) {
+        case WAKEUP_MAGIC_PACKET_V3:
+                csi_tmp = rtl8125_mac_ocp_read(tp, 0xC0B6);
+                if (csi_tmp & BIT_0)
+                        wol_opts |= WAKE_MAGIC;
+                break;
+        }
+
+        options = RTL_R8(tp, Config5);
+        if (options & UWF)
+                wol_opts |= WAKE_UCAST;
+        if (options & BWF)
+                wol_opts |= WAKE_BCAST;
+        if (options & MWF)
+                wol_opts |= WAKE_MCAST;
+
+out:
+        return wol_opts;
+}
+
+static void
+rtl8125_enable_d0_speedup(struct rtl8125_private *tp)
+{
+        u16 clearmask;
+        u16 setmask;
+
+        if (FALSE == HW_SUPPORT_D0_SPEED_UP(tp))
+                return;
+
+        if (tp->D0SpeedUpSpeed == D0_SPEED_UP_SPEED_DISABLE)
+                return;
+
+        if (tp->HwSuppD0SpeedUpVer == 1 || tp->HwSuppD0SpeedUpVer == 2) {
+                //speed up speed
+                clearmask = (BIT_10 | BIT_9 | BIT_8 | BIT_7);
+                if (tp->D0SpeedUpSpeed == D0_SPEED_UP_SPEED_2500)
+                        setmask = BIT_7;
+                else
+                        setmask = 0;
+                rtl8125_clear_set_mac_ocp_bit(tp, 0xE10A, clearmask, setmask);
+
+                //speed up flowcontrol
+                clearmask = (BIT_15 | BIT_14);
+                if (tp->HwSuppD0SpeedUpVer == 2)
+                        clearmask |= BIT_13;
+
+                if (tp->fcpause == rtl8125_fc_full) {
+                        setmask = (BIT_15 | BIT_14);
+                        if (tp->HwSuppD0SpeedUpVer == 2)
+                                setmask |= BIT_13;
+                } else
+                        setmask = 0;
+                rtl8125_clear_set_mac_ocp_bit(tp, 0xE860, clearmask, setmask);
+        }
+
+        RTL_W8(tp, 0xD0, RTL_R8(tp, 0xD0) | BIT_3);
+}
+
+static void
+rtl8125_disable_d0_speedup(struct rtl8125_private *tp)
+{
+        if (FALSE == HW_SUPPORT_D0_SPEED_UP(tp))
+                return;
+
+        RTL_W8(tp, 0xD0, RTL_R8(tp, 0xD0) & ~BIT_3);
+}
+
+static void
+rtl8125_set_hw_wol(struct net_device *dev, u32 wolopts)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i,tmp;
+        static struct {
+                u32 opt;
+                u16 reg;
+                u8  mask;
+        } cfg[] = {
+                { WAKE_PHY,   Config3, LinkUp },
+                { WAKE_UCAST, Config5, UWF },
+                { WAKE_BCAST, Config5, BWF },
+                { WAKE_MCAST, Config5, MWF },
+                { WAKE_ANY,   Config5, LanWake },
+                { WAKE_MAGIC, Config3, MagicPacket },
+        };
+
+        switch (tp->HwSuppMagicPktVer) {
+        case WAKEUP_MAGIC_PACKET_V3:
+        default:
+                tmp = ARRAY_SIZE(cfg) - 1;
+
+                if (wolopts & WAKE_MAGIC)
+                        rtl8125_enable_magic_packet(dev);
+                else
+                        rtl8125_disable_magic_packet(dev);
+                break;
+        }
+
+        rtl8125_enable_cfg9346_write(tp);
+
+        for (i = 0; i < tmp; i++) {
+                u8 options = RTL_R8(tp, cfg[i].reg) & ~cfg[i].mask;
+                if (wolopts & cfg[i].opt)
+                        options |= cfg[i].mask;
+                RTL_W8(tp, cfg[i].reg, options);
+        }
+
+        switch (tp->HwSuppLinkChgWakeUpVer) {
+        case 3:
+                if (wolopts & WAKE_PHY)
+                        rtl8125_enable_linkchg_wakeup(dev);
+                else
+                        rtl8125_disable_linkchg_wakeup(dev);
+                break;
+        }
+
+        rtl8125_disable_cfg9346_write(tp);
+}
+
+static void
+rtl8125_phy_restart_nway(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (rtl8125_is_in_phy_disable_mode(dev))
+                return;
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        rtl8125_mdio_write(tp, MII_BMCR, BMCR_ANENABLE | BMCR_ANRESTART);
+}
+
+static void
+rtl8125_phy_setup_force_mode(struct net_device *dev, u32 speed, u8 duplex)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 bmcr_true_force = 0;
+
+        if (rtl8125_is_in_phy_disable_mode(dev))
+                return;
+
+        if ((speed == SPEED_10) && (duplex == DUPLEX_HALF)) {
+                bmcr_true_force = BMCR_SPEED10;
+        } else if ((speed == SPEED_10) && (duplex == DUPLEX_FULL)) {
+                bmcr_true_force = BMCR_SPEED10 | BMCR_FULLDPLX;
+        } else if ((speed == SPEED_100) && (duplex == DUPLEX_HALF)) {
+                bmcr_true_force = BMCR_SPEED100;
+        } else if ((speed == SPEED_100) && (duplex == DUPLEX_FULL)) {
+                bmcr_true_force = BMCR_SPEED100 | BMCR_FULLDPLX;
+        } else {
+                netif_err(tp, drv, dev, "Failed to set phy force mode!\n");
+                return;
+        }
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        rtl8125_mdio_write(tp, MII_BMCR, bmcr_true_force);
+}
+
+static void
+rtl8125_set_pci_pme(struct rtl8125_private *tp, int set)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+        u16 pmc;
+
+        if (!pdev->pm_cap)
+                return;
+
+        pci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &pmc);
+        pmc |= PCI_PM_CTRL_PME_STATUS;
+        if (set)
+                pmc |= PCI_PM_CTRL_PME_ENABLE;
+        else
+                pmc &= ~PCI_PM_CTRL_PME_ENABLE;
+        pci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, pmc);
+}
+
+static void
+rtl8125_enable_giga_lite(struct rtl8125_private *tp, u64 adv)
+{
+        if (adv & ADVERTISED_1000baseT_Full)
+                rtl8125_set_eth_phy_ocp_bit(tp, 0xA428, BIT_9);
+        else
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA428, BIT_9);
+
+        if (adv & ADVERTISED_2500baseX_Full)
+                rtl8125_set_eth_phy_ocp_bit(tp, 0xA5EA, BIT_0);
+        else
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA5EA, BIT_0);
+}
+
+static void
+rtl8125_disable_giga_lite(struct rtl8125_private *tp)
+{
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA428, BIT_9);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA5EA, BIT_0);
+}
+
+static int
+rtl8125_set_wol_link_speed(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long flags;
+        int auto_nego = 0;
+        int giga_ctrl;
+        int ctrl_2500;
+        u64 adv;
+        u16 anlpar;
+        u16 gbsr;
+        u16 status_2500;
+        u16 aner;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        if (tp->autoneg != AUTONEG_ENABLE)
+                goto exit;
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+
+        auto_nego = rtl8125_mdio_read(tp, MII_ADVERTISE);
+        auto_nego &= ~(ADVERTISE_10HALF | ADVERTISE_10FULL
+                       | ADVERTISE_100HALF | ADVERTISE_100FULL);
+
+        giga_ctrl = rtl8125_mdio_read(tp, MII_CTRL1000);
+        giga_ctrl &= ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL);
+
+        ctrl_2500 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA5D4);
+        ctrl_2500 &= ~RTK_ADVERTISE_2500FULL;
+
+        aner = tp->phy_reg_aner;
+        anlpar = tp->phy_reg_anlpar;
+        gbsr = tp->phy_reg_gbsr;
+        status_2500 = tp->phy_reg_status_2500;
+        if (tp->link_ok(dev)) {
+                aner = rtl8125_mdio_read(tp, MII_EXPANSION);
+                anlpar = rtl8125_mdio_read(tp, MII_LPA);
+                gbsr = rtl8125_mdio_read(tp, MII_STAT1000);
+                status_2500 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA5D6);
+        }
+
+        adv = tp->advertising;
+        if ((aner | anlpar | gbsr | status_2500) == 0) {
+                int auto_nego_tmp = 0;
+                if (adv & ADVERTISED_10baseT_Half)
+                        auto_nego_tmp |= ADVERTISE_10HALF;
+                if (adv & ADVERTISED_10baseT_Full)
+                        auto_nego_tmp |= ADVERTISE_10FULL;
+                if (adv & ADVERTISED_100baseT_Half)
+                        auto_nego_tmp |= ADVERTISE_100HALF;
+                if (adv & ADVERTISED_100baseT_Full)
+                        auto_nego_tmp |= ADVERTISE_100FULL;
+
+                if (auto_nego_tmp == 0)
+                        goto exit;
+
+                auto_nego |= auto_nego_tmp;
+                goto skip_check_lpa;
+        }
+        if (!(aner & EXPANSION_NWAY))
+                goto exit;
+
+        if ((adv & ADVERTISED_10baseT_Half) && (anlpar & LPA_10HALF))
+                auto_nego |= ADVERTISE_10HALF;
+        else if ((adv & ADVERTISED_10baseT_Full) && (anlpar & LPA_10FULL))
+                auto_nego |= ADVERTISE_10FULL;
+        else if ((adv & ADVERTISED_100baseT_Half) && (anlpar & LPA_100HALF))
+                auto_nego |= ADVERTISE_100HALF;
+        else if ((adv & ADVERTISED_100baseT_Full) && (anlpar & LPA_100FULL))
+                auto_nego |= ADVERTISE_100FULL;
+        else if (adv & ADVERTISED_1000baseT_Half && (gbsr & LPA_1000HALF))
+                giga_ctrl |= ADVERTISE_1000HALF;
+        else if (adv & ADVERTISED_1000baseT_Full && (gbsr & LPA_1000FULL))
+                giga_ctrl |= ADVERTISE_1000FULL;
+        else if (adv & ADVERTISED_2500baseX_Full && (status_2500 & RTK_LPA_ADVERTISE_2500FULL))
+                ctrl_2500 |= RTK_ADVERTISE_2500FULL;
+        else
+                goto exit;
+
+skip_check_lpa:
+        if (tp->DASH)
+                auto_nego |= (ADVERTISE_100FULL | ADVERTISE_100HALF | ADVERTISE_10HALF | ADVERTISE_10FULL);
+
+#ifdef CONFIG_DOWN_SPEED_100
+        auto_nego |= (ADVERTISE_100FULL | ADVERTISE_100HALF | ADVERTISE_10HALF | ADVERTISE_10FULL);
+#endif
+
+        rtl8125_mdio_write(tp, MII_ADVERTISE, auto_nego);
+        rtl8125_mdio_write(tp, MII_CTRL1000, giga_ctrl);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA5D4, ctrl_2500);
+
+        rtl8125_disable_giga_lite(tp);
+
+        rtl8125_phy_restart_nway(dev);
+
+exit:
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        return auto_nego;
+}
+
+static bool
+rtl8125_keep_wol_link_speed(struct net_device *dev, u8 from_suspend)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (from_suspend && tp->link_ok(dev) && (tp->wol_opts & WAKE_PHY))
+                return 1;
+
+        if (!from_suspend && tp->resume_not_chg_speed)
+                return 1;
+
+        return 0;
+}
+static void
+rtl8125_powerdown_pll(struct net_device *dev, u8 from_suspend)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        /* Reboot not set wol link speed */
+        if (system_state == SYSTEM_RESTART)
+                return;
+
+        tp->check_keep_link_speed = 0;
+        if (tp->wol_enabled == WOL_ENABLED || tp->DASH || tp->EnableKCPOffload) {
+                int auto_nego;
+
+                rtl8125_set_hw_wol(dev, tp->wol_opts);
+
+                rtl8125_enable_cfg9346_write(tp);
+                RTL_W8(tp, Config2, RTL_R8(tp, Config2) | PMSTS_En);
+                rtl8125_disable_cfg9346_write(tp);
+
+                /* Enable the PME and clear the status */
+                rtl8125_set_pci_pme(tp, 1);
+
+#ifdef ENABLE_FIBER_SUPPORT
+                if (HW_FIBER_MODE_ENABLED(tp))
+                        return;
+#endif /* ENABLE_FIBER_SUPPORT */
+
+                if (rtl8125_keep_wol_link_speed(dev, from_suspend)) {
+                        tp->check_keep_link_speed = 1;
+                } else {
+                        if (tp->D0SpeedUpSpeed != D0_SPEED_UP_SPEED_DISABLE) {
+                                rtl8125_enable_d0_speedup(tp);
+                                tp->check_keep_link_speed = 1;
+                        }
+
+                        auto_nego = rtl8125_set_wol_link_speed(dev);
+
+                        if (tp->RequiredPfmPatch)
+                                rtl8125_set_pfm_patch(tp,
+                                                      (auto_nego & (ADVERTISE_10HALF | ADVERTISE_10FULL)) ?
+                                                      1 : 0);
+                }
+
+                RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) | AcceptBroadcast | AcceptMulticast | AcceptMyPhys);
+
+                return;
+        }
+
+#ifdef ENABLE_FIBER_SUPPORT
+        if (HW_FIBER_MODE_ENABLED(tp))
+                return;
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        if (tp->DASH)
+                return;
+
+        rtl8125_phy_power_down(dev);
+
+        if (!tp->HwIcVerUnknown)
+                RTL_W8(tp, PMCH, RTL_R8(tp, PMCH) & ~BIT_7);
+
+        RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) & ~BIT_6);
+}
+
+static void rtl8125_powerup_pll(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        RTL_W8(tp, PMCH, RTL_R8(tp, PMCH) | BIT_7 | BIT_6);
+
+        if (tp->resume_not_chg_speed)
+                return;
+
+        rtl8125_phy_power_up(dev);
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static void
+rtl8125_get_wol(struct net_device *dev,
+                struct ethtool_wolinfo *wol)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u8 options;
+
+        wol->wolopts = 0;
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT || disable_wol_support) {
+                wol->supported = 0;
+                return;
+        } else {
+                wol->supported = WAKE_ANY;
+        }
+
+        options = RTL_R8(tp, Config1);
+        if (!(options & PMEnable))
+                return;
+
+        wol->wolopts = tp->wol_opts;
+}
+
+static int
+rtl8125_set_wol(struct net_device *dev,
+                struct ethtool_wolinfo *wol)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT || disable_wol_support)
+                return -EOPNOTSUPP;
+
+        tp->wol_opts = wol->wolopts;
+
+        tp->wol_enabled = (tp->wol_opts) ? WOL_ENABLED : WOL_DISABLED;
+
+        device_set_wakeup_enable(tp_to_dev(tp), wol->wolopts);
+
+        return 0;
+}
+
+static void
+rtl8125_get_drvinfo(struct net_device *dev,
+                    struct ethtool_drvinfo *info)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct rtl8125_fw *rtl_fw = tp->rtl_fw;
+
+        strscpy(info->driver, MODULENAME, sizeof(info->driver));
+        strscpy(info->version, RTL8125_VERSION, sizeof(info->version));
+        strscpy(info->bus_info, pci_name(tp->pci_dev), sizeof(info->bus_info));
+        info->regdump_len = R8125_REGS_DUMP_SIZE;
+        info->eedump_len = tp->eeprom_len;
+        BUILD_BUG_ON(sizeof(info->fw_version) < sizeof(rtl_fw->version));
+        if (rtl_fw)
+                strscpy(info->fw_version, rtl_fw->version,
+                        sizeof(info->fw_version));
+}
+
+static int
+rtl8125_get_regs_len(struct net_device *dev)
+{
+        return R8125_REGS_DUMP_SIZE;
+}
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+static void
+rtl8125_set_d0_speedup_speed(struct rtl8125_private *tp)
+{
+        if (FALSE == HW_SUPPORT_D0_SPEED_UP(tp))
+                return;
+
+        tp->D0SpeedUpSpeed = D0_SPEED_UP_SPEED_DISABLE;
+        if (tp->autoneg == AUTONEG_ENABLE) {
+                if (tp->speed == SPEED_2500)
+                        tp->D0SpeedUpSpeed = D0_SPEED_UP_SPEED_2500;
+                else if (tp->speed == SPEED_1000)
+                        tp->D0SpeedUpSpeed = D0_SPEED_UP_SPEED_1000;
+        }
+}
+
+static int
+rtl8125_set_speed_xmii(struct net_device *dev,
+                       u8 autoneg,
+                       u32 speed,
+                       u8 duplex,
+                       u64 adv)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int auto_nego = 0;
+        int giga_ctrl = 0;
+        int ctrl_2500 = 0;
+        int rc = -EINVAL;
+
+        if (!rtl8125_is_speed_mode_valid(speed)) {
+                speed = SPEED_2500;
+                duplex = DUPLEX_FULL;
+                adv |= tp->advertising;
+        }
+
+        if (eee_giga_lite && (autoneg == AUTONEG_ENABLE))
+                rtl8125_enable_giga_lite(tp, adv);
+        else
+                rtl8125_disable_giga_lite(tp);
+
+        giga_ctrl = rtl8125_mdio_read(tp, MII_CTRL1000);
+        giga_ctrl &= ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL);
+        ctrl_2500 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA5D4);
+        ctrl_2500 &= ~RTK_ADVERTISE_2500FULL;
+
+        if (autoneg == AUTONEG_ENABLE) {
+                /*n-way force*/
+                auto_nego = rtl8125_mdio_read(tp, MII_ADVERTISE);
+                auto_nego &= ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
+                               ADVERTISE_100HALF | ADVERTISE_100FULL |
+                               ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+
+                if (adv & ADVERTISED_10baseT_Half)
+                        auto_nego |= ADVERTISE_10HALF;
+                if (adv & ADVERTISED_10baseT_Full)
+                        auto_nego |= ADVERTISE_10FULL;
+                if (adv & ADVERTISED_100baseT_Half)
+                        auto_nego |= ADVERTISE_100HALF;
+                if (adv & ADVERTISED_100baseT_Full)
+                        auto_nego |= ADVERTISE_100FULL;
+                if (adv & ADVERTISED_1000baseT_Half)
+                        giga_ctrl |= ADVERTISE_1000HALF;
+                if (adv & ADVERTISED_1000baseT_Full)
+                        giga_ctrl |= ADVERTISE_1000FULL;
+                if (adv & ADVERTISED_2500baseX_Full)
+                        ctrl_2500 |= RTK_ADVERTISE_2500FULL;
+
+                //flow control
+                if (tp->fcpause == rtl8125_fc_full)
+                        auto_nego |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;
+
+                tp->phy_auto_nego_reg = auto_nego;
+                tp->phy_1000_ctrl_reg = giga_ctrl;
+
+                tp->phy_2500_ctrl_reg = ctrl_2500;
+
+                rtl8125_mdio_write(tp, 0x1f, 0x0000);
+                rtl8125_mdio_write(tp, MII_ADVERTISE, auto_nego);
+                rtl8125_mdio_write(tp, MII_CTRL1000, giga_ctrl);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA5D4, ctrl_2500);
+                rtl8125_phy_restart_nway(dev);
+        } else {
+                /*true force*/
+                if (speed == SPEED_10 || speed == SPEED_100)
+                        rtl8125_phy_setup_force_mode(dev, speed, duplex);
+                else
+                        goto out;
+        }
+
+        tp->autoneg = autoneg;
+        tp->speed = speed;
+        tp->duplex = duplex;
+        tp->advertising = adv;
+
+        rtl8125_set_d0_speedup_speed(tp);
+
+#ifdef ENABLE_FIBER_SUPPORT
+        rtl8125_hw_fiber_phy_config(tp);
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        rc = 0;
+out:
+        return rc;
+}
+
+static int
+rtl8125_set_speed(struct net_device *dev,
+                  u8 autoneg,
+                  u32 speed,
+                  u8 duplex,
+                  u64 adv)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ret;
+
+        if (tp->resume_not_chg_speed)
+                return 0;
+
+        ret = tp->set_speed(dev, autoneg, speed, duplex, adv);
+
+        return ret;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static int
+rtl8125_set_settings(struct net_device *dev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+                     struct ethtool_cmd *cmd
+#else
+                     const struct ethtool_link_ksettings *cmd
+#endif
+                    )
+{
+        int ret;
+        u8 autoneg;
+        u32 speed;
+        u8 duplex;
+        u64 supported = 0, advertising = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+        autoneg = cmd->autoneg;
+        speed = cmd->speed;
+        duplex = cmd->duplex;
+        supported = cmd->supported;
+        advertising = cmd->advertising;
+#else
+        const struct ethtool_link_settings *base = &cmd->base;
+        autoneg = base->autoneg;
+        speed = base->speed;
+        duplex = base->duplex;
+        ethtool_convert_link_mode_to_legacy_u32((u32*)&supported,
+                                                cmd->link_modes.supported);
+        ethtool_convert_link_mode_to_legacy_u32((u32*)&advertising,
+                                                cmd->link_modes.advertising);
+        if (test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                     cmd->link_modes.supported))
+                supported |= ADVERTISED_2500baseX_Full;
+        if (test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                     cmd->link_modes.advertising))
+                advertising |= ADVERTISED_2500baseX_Full;
+#endif
+        if (advertising & ~supported)
+                return -EINVAL;
+
+        ret = rtl8125_set_speed(dev, autoneg, speed, duplex, advertising);
+
+        return ret;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+static u32
+rtl8125_get_tx_csum(struct net_device *dev)
+{
+        u32 ret;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        ret = ((dev->features & NETIF_F_IP_CSUM) != 0);
+#else
+        ret = ((dev->features & (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM)) != 0);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+        return ret;
+}
+
+static u32
+rtl8125_get_rx_csum(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 ret;
+
+        ret = tp->cp_cmd & RxChkSum;
+
+        return ret;
+}
+
+static int
+rtl8125_set_tx_csum(struct net_device *dev,
+                    u32 data)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                return -EOPNOTSUPP;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        if (data)
+                dev->features |= NETIF_F_IP_CSUM;
+        else
+                dev->features &= ~NETIF_F_IP_CSUM;
+#else
+        if (data)
+                dev->features |= (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+        else
+                dev->features &= ~(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+        return 0;
+}
+
+static int
+rtl8125_set_rx_csum(struct net_device *dev,
+                    u32 data)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                return -EOPNOTSUPP;
+
+        if (data)
+                tp->cp_cmd |= RxChkSum;
+        else
+                tp->cp_cmd &= ~RxChkSum;
+
+        RTL_W16(tp, CPlusCmd, tp->cp_cmd);
+
+        return 0;
+}
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+static u32
+rtl8125_rx_desc_opts1(struct rtl8125_private *tp,
+                      struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                return READ_ONCE(((struct RxDescV3 *)desc)->RxDescNormalDDWord4.opts1);
+        case RX_DESC_RING_TYPE_4:
+                return READ_ONCE(((struct RxDescV4 *)desc)->RxDescNormalDDWord2.opts1);
+        default:
+                return READ_ONCE(desc->opts1);
+        }
+}
+
+static u32
+rtl8125_rx_desc_opts2(struct rtl8125_private *tp,
+                      struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                return ((struct RxDescV3 *)desc)->RxDescNormalDDWord4.opts2;
+        case RX_DESC_RING_TYPE_4:
+                return ((struct RxDescV4 *)desc)->RxDescNormalDDWord2.opts2;
+        default:
+                return desc->opts2;
+        }
+}
+
+#ifdef CONFIG_R8125_VLAN
+
+static void
+rtl8125_clear_rx_desc_opts2(struct rtl8125_private *tp,
+                            struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                ((struct RxDescV3 *)desc)->RxDescNormalDDWord4.opts2 = 0;
+                break;
+        case RX_DESC_RING_TYPE_4:
+                ((struct RxDescV4 *)desc)->RxDescNormalDDWord2.opts2 = 0;
+                break;
+        default:
+                desc->opts2 = 0;
+                break;
+        }
+}
+
+static inline u32
+rtl8125_tx_vlan_tag(struct rtl8125_private *tp,
+                    struct sk_buff *skb)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        return (tp->vlgrp && vlan_tx_tag_present(skb)) ?
+               TxVlanTag | swab16(vlan_tx_tag_get(skb)) : 0x00;
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+        return (vlan_tx_tag_present(skb)) ?
+               TxVlanTag | swab16(vlan_tx_tag_get(skb)) : 0x00;
+#else
+        return (skb_vlan_tag_present(skb)) ?
+               TxVlanTag | swab16(skb_vlan_tag_get(skb)) : 0x00;
+#endif
+
+        return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+static void
+rtl8125_vlan_rx_register(struct net_device *dev,
+                         struct vlan_group *grp)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        tp->vlgrp = grp;
+
+        if (tp->vlgrp) {
+                tp->rtl8125_rx_config |= (EnableInnerVlan | EnableOuterVlan);
+                RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) | (EnableInnerVlan | EnableOuterVlan))
+        } else {
+                tp->rtl8125_rx_config &= ~(EnableInnerVlan | EnableOuterVlan);
+                RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) & ~(EnableInnerVlan | EnableOuterVlan))
+        }
+}
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+static void
+rtl8125_vlan_rx_kill_vid(struct net_device *dev,
+                         unsigned short vid)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+        if (tp->vlgrp)
+                tp->vlgrp->vlan_devices[vid] = NULL;
+#else
+        vlan_group_set_device(tp->vlgrp, vid, NULL);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+}
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+
+static int
+rtl8125_rx_vlan_skb(struct rtl8125_private *tp,
+                    struct RxDesc *desc,
+                    struct sk_buff *skb)
+{
+        u32 opts2 = le32_to_cpu(rtl8125_rx_desc_opts2(tp, desc));
+        int ret = -1;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        if (tp->vlgrp && (opts2 & RxVlanTag)) {
+                rtl8125_rx_hwaccel_skb(skb, tp->vlgrp,
+                                       swab16(opts2 & 0xffff));
+                ret = 0;
+        }
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+        if (opts2 & RxVlanTag)
+                __vlan_hwaccel_put_tag(skb, swab16(opts2 & 0xffff));
+#else
+        if (opts2 & RxVlanTag)
+                __vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), swab16(opts2 & 0xffff));
+#endif
+
+        rtl8125_clear_rx_desc_opts2(tp, desc);
+        return ret;
+}
+
+#else /* !CONFIG_R8125_VLAN */
+
+static inline u32
+rtl8125_tx_vlan_tag(struct rtl8125_private *tp,
+                    struct sk_buff *skb)
+{
+        return 0;
+}
+
+static int
+rtl8125_rx_vlan_skb(struct rtl8125_private *tp,
+                    struct RxDesc *desc,
+                    struct sk_buff *skb)
+{
+        return -1;
+}
+
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+
+static netdev_features_t rtl8125_fix_features(struct net_device *dev,
+                netdev_features_t features)
+{
+        if (dev->mtu > MSS_MAX || dev->mtu > ETH_DATA_LEN)
+                features &= ~NETIF_F_ALL_TSO;
+#ifndef CONFIG_R8125_VLAN
+        features &= ~NETIF_F_ALL_CSUM;
+#endif
+
+        return features;
+}
+
+static int rtl8125_hw_set_features(struct net_device *dev,
+                                   netdev_features_t features)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 rx_config;
+
+        rx_config = RTL_R32(tp, RxConfig);
+        if (features & NETIF_F_RXALL) {
+                tp->rtl8125_rx_config |= (AcceptErr | AcceptRunt);
+                rx_config |= (AcceptErr | AcceptRunt);
+        } else {
+                tp->rtl8125_rx_config &= ~(AcceptErr | AcceptRunt);
+                rx_config &= ~(AcceptErr | AcceptRunt);
+        }
+
+        if (features & NETIF_F_HW_VLAN_RX) {
+                tp->rtl8125_rx_config |= (EnableInnerVlan | EnableOuterVlan);
+                rx_config |= (EnableInnerVlan | EnableOuterVlan);
+        } else {
+                tp->rtl8125_rx_config &= ~(EnableInnerVlan | EnableOuterVlan);
+                rx_config &= ~(EnableInnerVlan | EnableOuterVlan);
+        }
+
+        RTL_W32(tp, RxConfig, rx_config);
+
+        if (features & NETIF_F_RXCSUM)
+                tp->cp_cmd |= RxChkSum;
+        else
+                tp->cp_cmd &= ~RxChkSum;
+
+        RTL_W16(tp, CPlusCmd, tp->cp_cmd);
+        RTL_R16(tp, CPlusCmd);
+
+        return 0;
+}
+
+static int rtl8125_set_features(struct net_device *dev,
+                                netdev_features_t features)
+{
+        features &= NETIF_F_RXALL | NETIF_F_RXCSUM | NETIF_F_HW_VLAN_RX;
+
+        rtl8125_hw_set_features(dev, features);
+
+        return 0;
+}
+
+#endif
+
+static u8 rtl8125_get_mdi_status(struct rtl8125_private *tp)
+{
+        if (!tp->link_ok(tp->dev))
+                return ETH_TP_MDI_INVALID;
+
+        if (rtl8125_mdio_direct_read_phy_ocp(tp, 0xA444) & BIT_1)
+                return ETH_TP_MDI;
+        else
+                return ETH_TP_MDI_X;
+}
+
+static void rtl8125_gset_xmii(struct net_device *dev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+                              struct ethtool_cmd *cmd
+#else
+                              struct ethtool_link_ksettings *cmd
+#endif
+                             )
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 aner = tp->phy_reg_aner;
+        u16 anlpar = tp->phy_reg_anlpar;
+        u16 gbsr = tp->phy_reg_gbsr;
+        u16 status_2500 = tp->phy_reg_status_2500;
+        u64 lpa_adv = 0;
+        u32 status;
+        u8 autoneg, duplex;
+        u32 speed = 0;
+        u16 bmcr;
+        u64 supported, advertising;
+        unsigned long flags;
+        u8 report_lpa = 0;
+
+        supported = SUPPORTED_10baseT_Half |
+                    SUPPORTED_10baseT_Full |
+                    SUPPORTED_100baseT_Half |
+                    SUPPORTED_100baseT_Full |
+                    SUPPORTED_1000baseT_Full |
+                    SUPPORTED_2500baseX_Full |
+                    SUPPORTED_Autoneg |
+                    SUPPORTED_TP |
+                    SUPPORTED_Pause |
+                    SUPPORTED_Asym_Pause;
+
+        if (!HW_SUPP_PHY_LINK_SPEED_2500M(tp))
+                supported &= ~SUPPORTED_2500baseX_Full;
+
+        advertising = tp->advertising;
+        if (tp->phy_auto_nego_reg || tp->phy_1000_ctrl_reg ||
+            tp->phy_2500_ctrl_reg) {
+                advertising = 0;
+                if (tp->phy_auto_nego_reg & ADVERTISE_10HALF)
+                        advertising |= ADVERTISED_10baseT_Half;
+                if (tp->phy_auto_nego_reg & ADVERTISE_10FULL)
+                        advertising |= ADVERTISED_10baseT_Full;
+                if (tp->phy_auto_nego_reg & ADVERTISE_100HALF)
+                        advertising |= ADVERTISED_100baseT_Half;
+                if (tp->phy_auto_nego_reg & ADVERTISE_100FULL)
+                        advertising |= ADVERTISED_100baseT_Full;
+                if (tp->phy_1000_ctrl_reg & ADVERTISE_1000FULL)
+                        advertising |= ADVERTISED_1000baseT_Full;
+                if (tp->phy_2500_ctrl_reg & RTK_ADVERTISE_2500FULL)
+                        advertising |= ADVERTISED_2500baseX_Full;
+        }
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        bmcr = rtl8125_mdio_read(tp, MII_BMCR);
+        if (bmcr & BMCR_ANENABLE) {
+                autoneg = AUTONEG_ENABLE;
+                advertising |= ADVERTISED_Autoneg;
+        } else {
+                autoneg = AUTONEG_DISABLE;
+        }
+
+        advertising |= ADVERTISED_TP;
+
+        status = rtl8125_get_phy_status(tp);
+        if (netif_running(dev) && (status & LinkStatus))
+                report_lpa = 1;
+#ifdef ENABLE_FIBER_SUPPORT
+        if (HW_FIBER_MODE_ENABLED(tp) &&
+            rtl8125_fiber_link_ok(dev) != R8125_LINK_STATE_ON)
+                report_lpa = 0;
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        if (report_lpa) {
+                /*link on*/
+                speed = rtl8125_convert_link_speed(status);
+
+                if (status & TxFlowCtrl)
+                        advertising |= ADVERTISED_Asym_Pause;
+
+                if (status & RxFlowCtrl)
+                        advertising |= ADVERTISED_Pause;
+
+                duplex = ((status & (_1000bpsF | _2500bpsF)) ||
+                          (status & FullDup)) ?
+                         DUPLEX_FULL : DUPLEX_HALF;
+
+                /*link partner*/
+                if (aner & EXPANSION_NWAY)
+                        lpa_adv |= ADVERTISED_Autoneg;
+                if (anlpar & LPA_10HALF)
+                        lpa_adv |= ADVERTISED_10baseT_Half;
+                if (anlpar & LPA_10FULL)
+                        lpa_adv |= ADVERTISED_10baseT_Full;
+                if (anlpar & LPA_100HALF)
+                        lpa_adv |= ADVERTISED_100baseT_Half;
+                if (anlpar & LPA_100FULL)
+                        lpa_adv |= ADVERTISED_100baseT_Full;
+                if (anlpar & LPA_PAUSE_CAP)
+                        lpa_adv |= ADVERTISED_Pause;
+                if (anlpar & LPA_PAUSE_ASYM)
+                        lpa_adv |= ADVERTISED_Asym_Pause;
+                if (gbsr & LPA_1000HALF)
+                        lpa_adv |= ADVERTISED_1000baseT_Half;
+                if (gbsr & LPA_1000FULL)
+                        lpa_adv |= ADVERTISED_1000baseT_Full;
+                if (status_2500 & RTK_LPA_ADVERTISE_2500FULL)
+                        lpa_adv |= ADVERTISED_2500baseX_Full;
+        } else {
+                /*link down*/
+                speed = SPEED_UNKNOWN;
+                duplex = DUPLEX_UNKNOWN;
+                lpa_adv = 0;
+        }
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+        cmd->supported = (u32)supported;
+        cmd->advertising = (u32)advertising;
+        cmd->autoneg = autoneg;
+        cmd->speed = speed;
+        cmd->duplex = duplex;
+        cmd->port = PORT_TP;
+        cmd->lp_advertising = (u32)lpa_adv;
+        cmd->eth_tp_mdix = rtl8125_get_mdi_status(tp);
+#else
+        ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,
+                                                supported);
+        ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,
+                                                advertising);
+        ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.lp_advertising,
+                                                lpa_adv);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+        if (supported & SUPPORTED_2500baseX_Full) {
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT,
+                                 cmd->link_modes.supported, 0);
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                                 cmd->link_modes.supported, 1);
+        }
+        if (advertising & ADVERTISED_2500baseX_Full) {
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT,
+                                 cmd->link_modes.advertising, 0);
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                                 cmd->link_modes.advertising, 1);
+        }
+        if (report_lpa) {
+                if (lpa_adv & ADVERTISED_2500baseX_Full) {
+                        linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT,
+                                         cmd->link_modes.lp_advertising, 0);
+                        linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                                         cmd->link_modes.lp_advertising, 1);
+                }
+        }
+#endif
+        cmd->base.autoneg = autoneg;
+        cmd->base.speed = speed;
+        cmd->base.duplex = duplex;
+        cmd->base.port = PORT_TP;
+        cmd->base.eth_tp_mdix = rtl8125_get_mdi_status(tp);
+#endif
+        r8125_spin_unlock(&tp->phy_lock, flags);
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static int
+rtl8125_get_settings(struct net_device *dev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+                     struct ethtool_cmd *cmd
+#else
+                     struct ethtool_link_ksettings *cmd
+#endif
+                    )
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        tp->get_settings(dev, cmd);
+
+        return 0;
+}
+
+static void rtl8125_get_regs(struct net_device *dev, struct ethtool_regs *regs,
+                             void *p)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+        unsigned int i;
+        u8 *data = p;
+
+        if (regs->len < R8125_REGS_DUMP_SIZE)
+                return /* -EINVAL */;
+
+        memset(p, 0, regs->len);
+
+        for (i = 0; i < R8125_MAC_REGS_SIZE; i++)
+                *data++ = readb(ioaddr + i);
+        data = (u8*)p + 256;
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        for (i = 0; i < R8125_PHY_REGS_SIZE/2; i++) {
+                *(u16*)data = rtl8125_mdio_read(tp, i);
+                data += 2;
+        }
+        data = (u8*)p + 256 * 2;
+
+        for (i = 0; i < R8125_EPHY_REGS_SIZE/2; i++) {
+                *(u16*)data = rtl8125_ephy_read(tp, i);
+                data += 2;
+        }
+        data = (u8*)p + 256 * 3;
+
+        for (i = 0; i < R8125_ERI_REGS_SIZE; i+=4) {
+                *(u32*)data = rtl8125_eri_read(tp, i , 4, ERIAR_ExGMAC);
+                data += 4;
+        }
+}
+
+static void rtl8125_get_pauseparam(struct net_device *dev,
+                                   struct ethtool_pauseparam *pause)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        pause->autoneg = (tp->autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE);
+        if (tp->fcpause == rtl8125_fc_rx_pause)
+                pause->rx_pause = 1;
+        else if (tp->fcpause == rtl8125_fc_tx_pause)
+                pause->tx_pause = 1;
+        else if (tp->fcpause == rtl8125_fc_full) {
+                pause->rx_pause = 1;
+                pause->tx_pause = 1;
+        }
+}
+
+static int rtl8125_set_pauseparam(struct net_device *dev,
+                                  struct ethtool_pauseparam *pause)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        enum rtl8125_fc_mode newfc;
+
+        if (pause->tx_pause || pause->rx_pause)
+                newfc = rtl8125_fc_full;
+        else
+                newfc = rtl8125_fc_none;
+
+        if (tp->fcpause != newfc) {
+                tp->fcpause = newfc;
+
+                rtl8125_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+        }
+
+        return 0;
+}
+
+static u32
+rtl8125_get_msglevel(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        return tp->msg_enable;
+}
+
+static void
+rtl8125_set_msglevel(struct net_device *dev,
+                     u32 value)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        tp->msg_enable = value;
+}
+
+static const char rtl8125_gstrings[][ETH_GSTRING_LEN] = {
+        /* legacy */
+        "tx_packets",
+        "rx_packets",
+        "tx_errors",
+        "rx_errors",
+        "rx_missed",
+        "align_errors",
+        "tx_single_collisions",
+        "tx_multi_collisions",
+        "unicast",
+        "broadcast",
+        "multicast",
+        "tx_aborted",
+        "tx_underrun",
+
+        /* extended */
+        "tx_octets",
+        "rx_octets",
+        "rx_multicast64",
+        "tx_unicast64",
+        "tx_broadcast64",
+        "tx_multicast64",
+        "tx_pause_on",
+        "tx_pause_off",
+        "tx_pause_all",
+        "tx_deferred",
+        "tx_late_collision",
+        "tx_all_collision",
+        "tx_aborted32",
+        "align_errors32",
+        "rx_frame_too_long",
+        "rx_runt",
+        "rx_pause_on",
+        "rx_pause_off",
+        "rx_pause_all",
+        "rx_unknown_opcode",
+        "rx_mac_error",
+        "tx_underrun32",
+        "rx_mac_missed",
+        "rx_tcam_dropped",
+        "tdu",
+        "rdu",
+};
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static int rtl8125_get_stats_count(struct net_device *dev)
+{
+        return ARRAY_SIZE(rtl8125_gstrings);
+}
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+#else
+static int rtl8125_get_sset_count(struct net_device *dev, int sset)
+{
+        switch (sset) {
+        case ETH_SS_STATS:
+                return ARRAY_SIZE(rtl8125_gstrings);
+        default:
+                return -EOPNOTSUPP;
+        }
+}
+#endif
+
+static void
+rtl8125_set_ring_size(struct rtl8125_private *tp, u32 rx, u32 tx)
+{
+        int i;
+
+        for (i = 0; i < R8125_MAX_RX_QUEUES; i++)
+                tp->rx_ring[i].num_rx_desc = rx;
+
+        for (i = 0; i < R8125_MAX_TX_QUEUES; i++)
+                tp->tx_ring[i].num_tx_desc = tx;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+static void rtl8125_get_ringparam(struct net_device *dev,
+                                  struct ethtool_ringparam *ring,
+                                  struct kernel_ethtool_ringparam *kernel_ring,
+                                  struct netlink_ext_ack *extack)
+#else
+static void rtl8125_get_ringparam(struct net_device *dev,
+                                  struct ethtool_ringparam *ring)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        ring->rx_max_pending = MAX_NUM_TX_DESC;
+        ring->tx_max_pending = MAX_NUM_RX_DESC;
+        ring->rx_pending = tp->rx_ring[0].num_rx_desc;
+        ring->tx_pending = tp->tx_ring[0].num_tx_desc;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+static int rtl8125_set_ringparam(struct net_device *dev,
+                                 struct ethtool_ringparam *ring,
+                                 struct kernel_ethtool_ringparam *kernel_ring,
+                                 struct netlink_ext_ack *extack)
+#else
+static int rtl8125_set_ringparam(struct net_device *dev,
+                                 struct ethtool_ringparam *ring)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 new_rx_count, new_tx_count;
+        int rc = 0;
+
+        if ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))
+                return -EINVAL;
+
+        new_tx_count = clamp_t(u32, ring->tx_pending,
+                               MIN_NUM_TX_DESC, MAX_NUM_TX_DESC);
+
+        new_rx_count = clamp_t(u32, ring->rx_pending,
+                               MIN_NUM_RX_DESC, MAX_NUM_RX_DESC);
+
+        if ((new_rx_count == tp->rx_ring[0].num_rx_desc) &&
+            (new_tx_count == tp->tx_ring[0].num_tx_desc)) {
+                /* nothing to do */
+                return 0;
+        }
+
+        if (netif_running(dev)) {
+                rtl8125_wait_for_quiescence(dev);
+                rtl8125_close(dev);
+        }
+
+        rtl8125_set_ring_size(tp, new_rx_count, new_tx_count);
+
+        if (netif_running(dev))
+                rc = rtl8125_open(dev);
+
+        return rc;
+}
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static void
+rtl8125_get_ethtool_stats(struct net_device *dev,
+                          struct ethtool_stats *stats,
+                          u64 *data)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct rtl8125_counters *counters;
+        dma_addr_t paddr;
+
+        ASSERT_RTNL();
+
+        counters = tp->tally_vaddr;
+        paddr = tp->tally_paddr;
+        if (!counters)
+                return;
+
+        rtl8125_dump_tally_counter(tp, paddr);
+
+        data[0] = le64_to_cpu(counters->tx_packets);
+        data[1] = le64_to_cpu(counters->rx_packets);
+        data[2] = le64_to_cpu(counters->tx_errors);
+        data[3] = le32_to_cpu(counters->rx_errors);
+        data[4] = le16_to_cpu(counters->rx_missed);
+        data[5] = le16_to_cpu(counters->align_errors);
+        data[6] = le32_to_cpu(counters->tx_one_collision);
+        data[7] = le32_to_cpu(counters->tx_multi_collision);
+        data[8] = le64_to_cpu(counters->rx_unicast);
+        data[9] = le64_to_cpu(counters->rx_broadcast);
+        data[10] = le32_to_cpu(counters->rx_multicast);
+        data[11] = le16_to_cpu(counters->tx_aborted);
+        data[12] = le16_to_cpu(counters->tx_underrun);
+
+        data[13] = le64_to_cpu(counters->tx_octets);
+        data[14] = le64_to_cpu(counters->rx_octets);
+        data[15] = le64_to_cpu(counters->rx_multicast64);
+        data[16] = le64_to_cpu(counters->tx_unicast64);
+        data[17] = le64_to_cpu(counters->tx_broadcast64);
+        data[18] = le64_to_cpu(counters->tx_multicast64);
+        data[19] = le32_to_cpu(counters->tx_pause_on);
+        data[20] = le32_to_cpu(counters->tx_pause_off);
+        data[21] = le32_to_cpu(counters->tx_pause_all);
+        data[22] = le32_to_cpu(counters->tx_deferred);
+        data[23] = le32_to_cpu(counters->tx_late_collision);
+        data[24] = le32_to_cpu(counters->tx_all_collision);
+        data[25] = le32_to_cpu(counters->tx_aborted32);
+        data[26] = le32_to_cpu(counters->align_errors32);
+        data[27] = le32_to_cpu(counters->rx_frame_too_long);
+        data[28] = le32_to_cpu(counters->rx_runt);
+        data[29] = le32_to_cpu(counters->rx_pause_on);
+        data[30] = le32_to_cpu(counters->rx_pause_off);
+        data[31] = le32_to_cpu(counters->rx_pause_all);
+        data[32] = le32_to_cpu(counters->rx_unknown_opcode);
+        data[33] = le32_to_cpu(counters->rx_mac_error);
+        data[34] = le32_to_cpu(counters->tx_underrun32);
+        data[35] = le32_to_cpu(counters->rx_mac_missed);
+        data[36] = le32_to_cpu(counters->rx_tcam_dropped);
+        data[37] = le32_to_cpu(counters->tdu);
+        data[38] = le32_to_cpu(counters->rdu);
+}
+
+static void
+rtl8125_get_strings(struct net_device *dev,
+                    u32 stringset,
+                    u8 *data)
+{
+        switch (stringset) {
+        case ETH_SS_STATS:
+                memcpy(data, rtl8125_gstrings, sizeof(rtl8125_gstrings));
+                break;
+        }
+}
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+static int rtl_get_eeprom_len(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        return tp->eeprom_len;
+}
+
+static int rtl_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *buf)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i,j,ret;
+        int start_w, end_w;
+        int VPD_addr, VPD_data;
+        u32 *eeprom_buff;
+        u16 tmp;
+
+        if (tp->eeprom_type == EEPROM_TYPE_NONE) {
+                dev_printk(KERN_DEBUG, tp_to_dev(tp), "Detect none EEPROM\n");
+                return -EOPNOTSUPP;
+        } else if (eeprom->len == 0 || (eeprom->offset+eeprom->len) > tp->eeprom_len) {
+                dev_printk(KERN_DEBUG, tp_to_dev(tp), "Invalid parameter\n");
+                return -EINVAL;
+        }
+
+        VPD_addr = 0xD2;
+        VPD_data = 0xD4;
+
+        start_w = eeprom->offset >> 2;
+        end_w = (eeprom->offset + eeprom->len - 1) >> 2;
+
+        eeprom_buff = kmalloc(sizeof(u32)*(end_w - start_w + 1), GFP_KERNEL);
+        if (!eeprom_buff)
+                return -ENOMEM;
+
+        rtl8125_enable_cfg9346_write(tp);
+        ret = -EFAULT;
+        for (i=start_w; i<=end_w; i++) {
+                pci_write_config_word(tp->pci_dev, VPD_addr, (u16)i*4);
+                ret = -EFAULT;
+                for (j = 0; j < 10; j++) {
+                        udelay(400);
+                        pci_read_config_word(tp->pci_dev, VPD_addr, &tmp);
+                        if (tmp&0x8000) {
+                                ret = 0;
+                                break;
+                        }
+                }
+
+                if (ret)
+                        break;
+
+                pci_read_config_dword(tp->pci_dev, VPD_data, &eeprom_buff[i-start_w]);
+        }
+        rtl8125_disable_cfg9346_write(tp);
+
+        if (!ret)
+                memcpy(buf, (u8 *)eeprom_buff + (eeprom->offset & 3), eeprom->len);
+
+        kfree(eeprom_buff);
+
+        return ret;
+}
+
+#undef ethtool_op_get_link
+#define ethtool_op_get_link _kc_ethtool_op_get_link
+static u32 _kc_ethtool_op_get_link(struct net_device *dev)
+{
+        return netif_carrier_ok(dev) ? 1 : 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+#undef ethtool_op_get_sg
+#define ethtool_op_get_sg _kc_ethtool_op_get_sg
+static u32 _kc_ethtool_op_get_sg(struct net_device *dev)
+{
+#ifdef NETIF_F_SG
+        return (dev->features & NETIF_F_SG) != 0;
+#else
+        return 0;
+#endif
+}
+
+#undef ethtool_op_set_sg
+#define ethtool_op_set_sg _kc_ethtool_op_set_sg
+static int _kc_ethtool_op_set_sg(struct net_device *dev, u32 data)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                return -EOPNOTSUPP;
+
+#ifdef NETIF_F_SG
+        if (data)
+                dev->features |= NETIF_F_SG;
+        else
+                dev->features &= ~NETIF_F_SG;
+#endif
+
+        return 0;
+}
+#endif
+
+static void
+rtl8125_set_eee_lpi_timer(struct rtl8125_private *tp)
+{
+        u16 dev_lpi_timer;
+
+        dev_lpi_timer = tp->eee.tx_lpi_timer;
+
+        RTL_W16(tp, EEE_TXIDLE_TIMER_8125, dev_lpi_timer);
+}
+
+static bool rtl8125_is_adv_eee_enabled(struct rtl8125_private *tp)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        //case CFG_METHOD_10:
+        //case CFG_METHOD_11:
+        case CFG_METHOD_12:
+                //case CFG_METHOD_13:
+                if (rtl8125_mdio_direct_read_phy_ocp(tp, 0xA430) & BIT_15)
+                        return true;
+                break;
+        default:
+                break;
+        }
+
+        return false;
+}
+
+static void _rtl8125_disable_adv_eee(struct rtl8125_private *tp)
+{
+        bool lock;
+
+        if (rtl8125_is_adv_eee_enabled(tp))
+                lock = true;
+        else
+                lock = false;
+
+        if (lock)
+                rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_clear_mac_ocp_bit(tp, 0xE052, BIT_0);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA442, BIT_12 | BIT_13);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA430, BIT_15);
+
+        if (lock)
+                rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static void rtl8125_disable_adv_eee(struct rtl8125_private *tp)
+{
+        rtl8125_oob_mutex_lock(tp);
+
+        _rtl8125_disable_adv_eee(tp);
+
+        rtl8125_oob_mutex_unlock(tp);
+}
+
+static int rtl8125_enable_eee(struct rtl8125_private *tp)
+{
+        struct ethtool_keee *eee = &tp->eee;
+        u16 eee_adv_cap1_t = rtl8125_ethtool_adv_to_mmd_eee_adv_cap1_t(eee->advertised);
+        u16 eee_adv_cap2_t = rtl8125_ethtool_adv_to_mmd_eee_adv_cap2_t(eee->advertised);
+        int ret;
+
+        ret = 0;
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                rtl8125_set_mac_ocp_bit(tp, 0xE040, (BIT_1|BIT_0));
+                rtl8125_set_mac_ocp_bit(tp, 0xEB62, (BIT_2|BIT_1));
+
+                rtl8125_set_eth_phy_ocp_bit(tp, 0xA432, BIT_4);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xA5D0,
+                                                      MDIO_EEE_100TX | MDIO_EEE_1000T,
+                                                      eee_adv_cap1_t);
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA6D4, MDIO_EEE_2_5GT);
+
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA6D8, BIT_4);
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA428, BIT_7);
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA4A2, BIT_9);
+                break;
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                rtl8125_set_mac_ocp_bit(tp, 0xE040, (BIT_1|BIT_0));
+
+                rtl8125_set_eth_phy_ocp_bit(tp, 0xA432, BIT_4);
+
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xA5D0,
+                                                      MDIO_EEE_100TX | MDIO_EEE_1000T,
+                                                      eee_adv_cap1_t);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xA6D4,
+                                                      MDIO_EEE_2_5GT,
+                                                      eee_adv_cap2_t);
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA6D8, BIT_4);
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA428, BIT_7);
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA4A2, BIT_9);
+                break;
+        default:
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        /*Advanced EEE*/
+        rtl8125_disable_adv_eee(tp);
+
+        return ret;
+}
+
+static int rtl8125_disable_eee(struct rtl8125_private *tp)
+{
+        int ret;
+
+        ret = 0;
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                rtl8125_clear_mac_ocp_bit(tp, 0xE040, (BIT_1|BIT_0));
+                rtl8125_clear_mac_ocp_bit(tp, 0xEB62, (BIT_2|BIT_1));
+
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA432, BIT_4);
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA5D0, (MDIO_EEE_100TX | MDIO_EEE_1000T));
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA6D4, BIT_0);
+
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA6D8, BIT_4);
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA428, BIT_7);
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA4A2, BIT_9);
+                break;
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                rtl8125_clear_mac_ocp_bit(tp, 0xE040, (BIT_1|BIT_0));
+
+                rtl8125_set_eth_phy_ocp_bit(tp, 0xA432, BIT_4);
+
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA5D0, (MDIO_EEE_100TX | MDIO_EEE_1000T));
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA6D4, MDIO_EEE_2_5GT);
+
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA6D8, BIT_4);
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA428, BIT_7);
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA4A2, BIT_9);
+                break;
+        default:
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        /*Advanced EEE*/
+        rtl8125_disable_adv_eee(tp);
+
+        return ret;
+}
+
+static int rtl_nway_reset(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ret, bmcr;
+
+        if (unlikely(tp->rtk_enable_diag))
+                return -EBUSY;
+
+        /* if autoneg is off, it's an error */
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        bmcr = rtl8125_mdio_read(tp, MII_BMCR);
+
+        if (bmcr & BMCR_ANENABLE) {
+                bmcr |= BMCR_ANRESTART;
+                rtl8125_mdio_write(tp, MII_BMCR, bmcr);
+                ret = 0;
+        } else {
+                ret = -EINVAL;
+        }
+
+        return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+static u32
+rtl8125_device_lpi_t_to_ethtool_lpi_t(struct rtl8125_private *tp , u32 lpi_timer)
+{
+        u32 to_us;
+        u32 status;
+
+        to_us = lpi_timer * 80;
+        status = rtl8125_get_phy_status(tp);
+        if (status & LinkStatus) {
+                /*link on*/
+                //2.5G : lpi_timer * 3.2ns
+                //Giga: lpi_timer * 8ns
+                //100M : lpi_timer * 80ns
+                if (status & _2500bpsF)
+                        to_us = (lpi_timer * 32) / 10;
+                else if (status & _1000bpsF)
+                        to_us = lpi_timer * 8;
+        }
+
+        //ns to us
+        to_us /= 1000;
+
+        return to_us;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,9,0)
+static void
+rtl8125_adv_to_linkmode(unsigned long *mode, u64 adv)
+{
+        linkmode_zero(mode);
+
+        if (adv & ADVERTISED_10baseT_Half)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, mode);
+        if (adv & ADVERTISED_10baseT_Full)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, mode);
+        if (adv & ADVERTISED_100baseT_Half)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, mode);
+        if (adv & ADVERTISED_100baseT_Full)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, mode);
+        if (adv & ADVERTISED_1000baseT_Half)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT, mode);
+        if (adv & ADVERTISED_1000baseT_Full)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, mode);
+        if (adv & ADVERTISED_2500baseX_Full)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, mode);
+}
+
+static int
+rtl_ethtool_get_eee(struct net_device *net, struct ethtool_keee *edata)
+{
+        __ETHTOOL_DECLARE_LINK_MODE_MASK(common);
+        struct rtl8125_private *tp = netdev_priv(net);
+        struct ethtool_keee *eee = &tp->eee;
+        unsigned long flags;
+        u32 tx_lpi_timer;
+        u16 val;
+
+        if (unlikely(tp->rtk_enable_diag))
+                return -EBUSY;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        /* Get LP advertisement EEE */
+        val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA5D2);
+        mii_eee_cap1_mod_linkmode_t(edata->lp_advertised, val);
+        val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA6D0);
+        mii_eee_cap2_mod_linkmode_sup_t(edata->lp_advertised, val);
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        /* Get EEE Tx LPI timer*/
+        tx_lpi_timer = rtl8125_device_lpi_t_to_ethtool_lpi_t(tp, eee->tx_lpi_timer);
+
+        val = rtl8125_mac_ocp_read(tp, 0xE040);
+        val &= BIT_1 | BIT_0;
+
+        edata->eee_enabled = !!val;
+        linkmode_copy(edata->supported, eee->supported);
+        linkmode_copy(edata->advertised, eee->advertised);
+        edata->tx_lpi_enabled = edata->eee_enabled;
+        edata->tx_lpi_timer = tx_lpi_timer;
+        linkmode_and(common, edata->advertised, edata->lp_advertised);
+        edata->eee_active = !linkmode_empty(common);
+
+        return 0;
+}
+
+static int
+rtl_ethtool_set_eee(struct net_device *net, struct ethtool_keee *edata)
+{
+        __ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);
+        __ETHTOOL_DECLARE_LINK_MODE_MASK(tmp);
+        struct rtl8125_private *tp = netdev_priv(net);
+        struct ethtool_keee *eee = &tp->eee;
+        unsigned long flags;
+        int rc = 0;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        if (!HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp) ||
+            tp->DASH) {
+                rc = -EOPNOTSUPP;
+                goto out;
+        }
+
+        if (unlikely(tp->rtk_enable_diag)) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "Diag Enabled\n");
+                rc = -EBUSY;
+                goto out;
+        }
+
+        if (tp->autoneg != AUTONEG_ENABLE) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE requires autoneg\n");
+                rc = -EINVAL;
+                goto out;
+        }
+
+        /*
+        if (edata->tx_lpi_enabled) {
+        if (edata->tx_lpi_timer > tp->max_jumbo_frame_size ||
+            edata->tx_lpi_timer < ETH_MIN_MTU) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "Valid LPI timer range is %d to %d. \n",
+                           ETH_MIN_MTU, tp->max_jumbo_frame_size);
+                rc = -EINVAL;
+                goto out;
+        }
+        }
+        */
+
+        rtl8125_adv_to_linkmode(advertising, tp->advertising);
+        if (linkmode_empty(edata->advertised)) {
+                linkmode_and(edata->advertised, advertising, eee->supported);
+        } else if (linkmode_andnot(tmp, edata->advertised, advertising)) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE advertised must be a subset of autoneg advertised speeds\n");
+                rc = -EINVAL;
+                goto out;
+        }
+
+        if (linkmode_andnot(tmp, edata->advertised, eee->supported)) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE advertised must be a subset of support \n");
+                rc = -EINVAL;
+                goto out;
+        }
+
+        //tp->eee.eee_enabled = edata->eee_enabled;
+        //tp->eee_adv_t = rtl8125_ethtool_adv_to_mmd_eee_adv_cap1_t(edata->advertised);
+
+        linkmode_copy(eee->advertised, edata->advertised);
+        //eee->tx_lpi_enabled = edata->tx_lpi_enabled;
+        //eee->tx_lpi_timer = edata->tx_lpi_timer;
+        eee->eee_enabled = edata->eee_enabled;
+
+        if (eee->eee_enabled)
+                rtl8125_enable_eee(tp);
+        else
+                rtl8125_disable_eee(tp);
+
+        rtl_nway_reset(net);
+
+out:
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        return rc;
+}
+#else
+static int
+rtl_ethtool_get_eee(struct net_device *net, struct ethtool_eee *edata)
+{
+        struct rtl8125_private *tp = netdev_priv(net);
+        struct ethtool_eee *eee = &tp->eee;
+        u32 lp, adv, tx_lpi_timer, supported = 0;
+        unsigned long flags;
+        u16 val;
+
+        if (unlikely(tp->rtk_enable_diag))
+                return -EBUSY;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        /* Get Supported EEE */
+        //val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA5C4);
+        //supported = mmd_eee_cap_to_ethtool_sup_t(val);
+        supported = eee->supported;
+
+        /* Get advertisement EEE */
+        adv = eee->advertised;
+
+        /* Get LP advertisement EEE */
+        val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA5D2);
+        lp = mmd_eee_adv_to_ethtool_adv_t(val);
+        val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA6D0);
+        if (val & RTK_LPA_EEE_ADVERTISE_2500FULL)
+                lp |= ADVERTISED_2500baseX_Full;
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        /* Get EEE Tx LPI timer*/
+        tx_lpi_timer = rtl8125_device_lpi_t_to_ethtool_lpi_t(tp, eee->tx_lpi_timer);
+
+        val = rtl8125_mac_ocp_read(tp, 0xE040);
+        val &= BIT_1 | BIT_0;
+
+        edata->eee_enabled = !!val;
+        edata->eee_active = !!(supported & adv & lp);
+        edata->supported = supported;
+        edata->advertised = adv;
+        edata->lp_advertised = lp;
+        edata->tx_lpi_enabled = edata->eee_enabled;
+        edata->tx_lpi_timer = tx_lpi_timer;
+
+        return 0;
+}
+
+static int
+rtl_ethtool_set_eee(struct net_device *net, struct ethtool_eee *edata)
+{
+        struct rtl8125_private *tp = netdev_priv(net);
+        struct ethtool_eee *eee = &tp->eee;
+        unsigned long flags;
+        u64 advertising;
+        int rc = 0;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        if (!HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp) ||
+            tp->DASH) {
+                rc = -EOPNOTSUPP;
+                goto out;
+        }
+
+        if (unlikely(tp->rtk_enable_diag)) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "Diag Enabled\n");
+                rc = -EBUSY;
+                goto out;
+        }
+
+        if (tp->autoneg != AUTONEG_ENABLE) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE requires autoneg\n");
+                rc = -EINVAL;
+                goto out;
+        }
+
+        /*
+        if (edata->tx_lpi_enabled) {
+        if (edata->tx_lpi_timer > tp->max_jumbo_frame_size ||
+            edata->tx_lpi_timer < ETH_MIN_MTU) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "Valid LPI timer range is %d to %d. \n",
+                           ETH_MIN_MTU, tp->max_jumbo_frame_size);
+                rc = -EINVAL;
+                goto out;
+        }
+        }
+        */
+
+        advertising = tp->advertising;
+        if (!edata->advertised) {
+                edata->advertised = advertising & eee->supported;
+        } else if (edata->advertised & ~advertising) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE advertised %x must be a subset of autoneg advertised speeds %llu\n",
+                           edata->advertised, advertising);
+                rc = -EINVAL;
+                goto out;
+        }
+
+        if (edata->advertised & ~eee->supported) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE advertised %x must be a subset of support %x\n",
+                           edata->advertised, eee->supported);
+                rc = -EINVAL;
+                goto out;
+        }
+
+        //tp->eee.eee_enabled = edata->eee_enabled;
+        //tp->eee_adv_t = rtl8125_ethtool_adv_to_mmd_eee_adv_cap1_t(edata->advertised);
+
+        eee->advertised = edata->advertised;
+        //eee->tx_lpi_enabled = edata->tx_lpi_enabled;
+        //eee->tx_lpi_timer = edata->tx_lpi_timer;
+        eee->eee_enabled = edata->eee_enabled;
+
+        if (eee->eee_enabled)
+                rtl8125_enable_eee(tp);
+        else
+                rtl8125_disable_eee(tp);
+
+        rtl_nway_reset(net);
+
+out:
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        return rc;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,9,0) */
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+static void rtl8125_get_channels(struct net_device *dev,
+                                 struct ethtool_channels *channel)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        channel->max_rx = tp->HwSuppNumRxQueues;
+        channel->max_tx = tp->HwSuppNumTxQueues;
+        channel->rx_count = tp->num_rx_rings;
+        channel->tx_count = tp->num_tx_rings;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0) */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static const struct ethtool_ops rtl8125_ethtool_ops = {
+        .get_drvinfo        = rtl8125_get_drvinfo,
+        .get_regs_len       = rtl8125_get_regs_len,
+        .get_link       = ethtool_op_get_link,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        .get_ringparam      = rtl8125_get_ringparam,
+        .set_ringparam      = rtl8125_set_ringparam,
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+        .get_settings       = rtl8125_get_settings,
+        .set_settings       = rtl8125_set_settings,
+#else
+        .get_link_ksettings       = rtl8125_get_settings,
+        .set_link_ksettings       = rtl8125_set_settings,
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        .get_pauseparam     = rtl8125_get_pauseparam,
+        .set_pauseparam     = rtl8125_set_pauseparam,
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        .get_msglevel       = rtl8125_get_msglevel,
+        .set_msglevel       = rtl8125_set_msglevel,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+        .get_rx_csum        = rtl8125_get_rx_csum,
+        .set_rx_csum        = rtl8125_set_rx_csum,
+        .get_tx_csum        = rtl8125_get_tx_csum,
+        .set_tx_csum        = rtl8125_set_tx_csum,
+        .get_sg         = ethtool_op_get_sg,
+        .set_sg         = ethtool_op_set_sg,
+#ifdef NETIF_F_TSO
+        .get_tso        = ethtool_op_get_tso,
+        .set_tso        = ethtool_op_set_tso,
+#endif //NETIF_F_TSO
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+        .get_regs       = rtl8125_get_regs,
+        .get_wol        = rtl8125_get_wol,
+        .set_wol        = rtl8125_set_wol,
+        .get_strings        = rtl8125_get_strings,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+        .get_stats_count    = rtl8125_get_stats_count,
+#else
+        .get_sset_count     = rtl8125_get_sset_count,
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+        .get_ethtool_stats  = rtl8125_get_ethtool_stats,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+#ifdef ETHTOOL_GPERMADDR
+        .get_perm_addr      = ethtool_op_get_perm_addr,
+#endif //ETHTOOL_GPERMADDR
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+        .get_eeprom     = rtl_get_eeprom,
+        .get_eeprom_len     = rtl_get_eeprom_len,
+#ifdef ENABLE_RSS_SUPPORT
+        .get_rxnfc		= rtl8125_get_rxnfc,
+        .set_rxnfc		= rtl8125_set_rxnfc,
+        .get_rxfh_indir_size	= rtl8125_rss_indir_size,
+        .get_rxfh_key_size	= rtl8125_get_rxfh_key_size,
+        .get_rxfh		= rtl8125_get_rxfh,
+        .set_rxfh		= rtl8125_set_rxfh,
+#endif //ENABLE_RSS_SUPPORT
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+#ifdef ENABLE_PTP_SUPPORT
+        .get_ts_info        = rtl8125_get_ts_info,
+#else
+        .get_ts_info        = ethtool_op_get_ts_info,
+#endif //ENABLE_PTP_SUPPORT
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+        .get_eee = rtl_ethtool_get_eee,
+        .set_eee = rtl_ethtool_set_eee,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+        .get_channels		= rtl8125_get_channels,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0) */
+        .nway_reset = rtl_nway_reset,
+
+};
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+static void rtl8125_get_mac_version(struct rtl8125_private *tp)
+{
+        u32 reg,val32;
+        u32 ICVerID;
+        struct pci_dev *pdev = tp->pci_dev;
+
+        val32 = RTL_R32(tp, TxConfig);
+        reg = val32 & 0x7c800000;
+        ICVerID = val32 & 0x00700000;
+
+        switch (reg) {
+        case 0x60800000:
+                if (ICVerID == 0x00000000) {
+                        tp->mcfg = CFG_METHOD_2;
+                } else if (ICVerID == 0x100000) {
+                        tp->mcfg = CFG_METHOD_3;
+                } else {
+                        tp->mcfg = CFG_METHOD_3;
+                        tp->HwIcVerUnknown = TRUE;
+                }
+
+                tp->efuse_ver = EFUSE_SUPPORT_V4;
+                break;
+        case 0x64000000:
+                if (ICVerID == 0x00000000) {
+                        tp->mcfg = CFG_METHOD_4;
+                } else if (ICVerID == 0x100000) {
+                        tp->mcfg = CFG_METHOD_5;
+                } else {
+                        tp->mcfg = CFG_METHOD_5;
+                        tp->HwIcVerUnknown = TRUE;
+                }
+
+                tp->efuse_ver = EFUSE_SUPPORT_V4;
+                break;
+        case 0x68000000:
+                if (ICVerID == 0x00000000) {
+                        tp->mcfg = CFG_METHOD_8;
+                } else if (ICVerID == 0x100000) {
+                        tp->mcfg = CFG_METHOD_9;
+                } else {
+                        tp->mcfg = CFG_METHOD_9;
+                        tp->HwIcVerUnknown = TRUE;
+                }
+
+                tp->efuse_ver = EFUSE_SUPPORT_V4;
+                break;
+        case 0x68800000:
+                if (ICVerID == 0x00000000) {
+                        tp->mcfg = CFG_METHOD_10;
+                } else if (ICVerID == 0x100000) {
+                        tp->mcfg = CFG_METHOD_11;
+                } else {
+                        tp->mcfg = CFG_METHOD_11;
+                        tp->HwIcVerUnknown = TRUE;
+                }
+
+                tp->efuse_ver = EFUSE_SUPPORT_V4;
+                break;
+        case 0x70800000:
+                if (ICVerID == 0x00000000) {
+                        tp->mcfg = CFG_METHOD_12;
+                } else {
+                        tp->mcfg = CFG_METHOD_12;
+                        tp->HwIcVerUnknown = TRUE;
+                }
+
+                tp->efuse_ver = EFUSE_SUPPORT_V4;
+                break;
+        default:
+                printk("unknown chip version (%x)\n",reg);
+                tp->mcfg = CFG_METHOD_DEFAULT;
+                tp->HwIcVerUnknown = TRUE;
+                tp->efuse_ver = EFUSE_NOT_SUPPORT;
+                break;
+        }
+
+        if (pdev->device == 0x8162) {
+                if (tp->mcfg == CFG_METHOD_3)
+                        tp->mcfg = CFG_METHOD_6;
+                else if (tp->mcfg == CFG_METHOD_5)
+                        tp->mcfg = CFG_METHOD_7;
+                else if (tp->mcfg == CFG_METHOD_11)
+                        tp->mcfg = CFG_METHOD_13;
+        }
+}
+
+static void
+rtl8125_print_mac_version(struct rtl8125_private *tp)
+{
+        int i;
+        for (i = ARRAY_SIZE(rtl_chip_info) - 1; i >= 0; i--) {
+                if (tp->mcfg == rtl_chip_info[i].mcfg) {
+                        dprintk("Realtek %s Ethernet controller mcfg = %04d\n",
+                                MODULENAME, rtl_chip_info[i].mcfg);
+                        return;
+                }
+        }
+
+        dprintk("mac_version == Unknown\n");
+}
+
+static void
+rtl8125_tally_counter_addr_fill(struct rtl8125_private *tp)
+{
+        if (!tp->tally_paddr)
+                return;
+
+        RTL_W32(tp, CounterAddrHigh, (u64)tp->tally_paddr >> 32);
+        RTL_W32(tp, CounterAddrLow, (u64)tp->tally_paddr & (DMA_BIT_MASK(32)));
+}
+
+static void
+rtl8125_tally_counter_clear(struct rtl8125_private *tp)
+{
+        if (!tp->tally_paddr)
+                return;
+
+        RTL_W32(tp, CounterAddrHigh, (u64)tp->tally_paddr >> 32);
+        RTL_W32(tp, CounterAddrLow, ((u64)tp->tally_paddr & (DMA_BIT_MASK(32))) | CounterReset);
+}
+
+static void
+rtl8125_clear_phy_ups_reg(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xA466, BIT_0);
+                break;
+        };
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA468, BIT_3 | BIT_1);
+}
+
+static int
+rtl8125_is_ups_resume(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        return (rtl8125_mac_ocp_read(tp, 0xD42C) & BIT_8);
+}
+
+static void
+rtl8125_clear_ups_resume_bit(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_clear_mac_ocp_bit(tp, 0xD42C, BIT_8);
+}
+
+static u8
+rtl8125_get_phy_state(struct rtl8125_private *tp)
+{
+        return (rtl8125_mdio_direct_read_phy_ocp(tp, 0xA420) & 0x7);
+}
+
+static bool
+rtl8125_wait_phy_state_ready(struct rtl8125_private *tp, u16 state,
+                             u32 ms)
+{
+        u16 tmp_state;
+        u32 wait_cnt;
+        bool ready;
+        u32 i;
+
+        if (ms >= 1000)
+                wait_cnt = ms / 1000;
+        else
+                wait_cnt = 100;
+
+        i = 0;
+        do {
+                tmp_state = rtl8125_get_phy_state(tp);
+                mdelay(1);
+                i++;
+        } while ((i < wait_cnt) && (tmp_state != state));
+
+        ready = (i == wait_cnt && tmp_state != state) ? FALSE : TRUE;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(i == wait_cnt);
+#endif
+        return ready;
+}
+
+static void
+rtl8125_wait_phy_ups_resume(struct net_device *dev, u16 PhyState)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        for (i=0; i< 100; i++) {
+                if (rtl8125_get_phy_state(tp) == PhyState)
+                        break;
+                else
+                        mdelay(1);
+        }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(i == 100);
+#endif
+}
+
+static void
+rtl8125_set_mcu_d3_stack(struct rtl8125_private *tp)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                rtl8125_mac_ocp_write(tp, 0xD018, 0xD116);
+                rtl8125_mac_ocp_write(tp, 0xD116, 0x45E0);
+                break;
+        case CFG_METHOD_9:
+                rtl8125_mac_ocp_write(tp, 0xD018, 0xD116);
+                rtl8125_mac_ocp_write(tp, 0xD116, 0x4782);
+                break;
+        case CFG_METHOD_10:
+                rtl8125_mac_ocp_write(tp, 0xD018, 0xD116);
+                rtl8125_mac_ocp_write(tp, 0xD116, 0x4836);
+                break;
+        case CFG_METHOD_11:
+                rtl8125_mac_ocp_write(tp, 0xD018, 0xD116);
+                rtl8125_mac_ocp_write(tp, 0xD116, 0x4848);
+                break;
+        case CFG_METHOD_12:
+                rtl8125_mac_ocp_write(tp, 0xD018, 0xD116);
+                rtl8125_mac_ocp_write(tp, 0xD116, 0x4C76);
+                break;
+        default:
+                return;
+        }
+}
+
+static void
+_rtl8125_enable_now_is_oob(struct rtl8125_private *tp)
+{
+        if (tp->HwSuppNowIsOobVer == 1)
+                RTL_W8(tp, MCUCmd_reg, RTL_R8(tp, MCUCmd_reg) | Now_is_oob);
+}
+
+void
+rtl8125_enable_now_is_oob(struct rtl8125_private *tp)
+{
+        rtl8125_set_mcu_d3_stack(tp);
+        _rtl8125_enable_now_is_oob(tp);
+}
+
+void
+rtl8125_disable_now_is_oob(struct rtl8125_private *tp)
+{
+        if (tp->HwSuppNowIsOobVer == 1)
+                RTL_W8(tp, MCUCmd_reg, RTL_R8(tp, MCUCmd_reg) & ~Now_is_oob);
+}
+
+static void
+rtl8125_exit_oob(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 data16;
+
+        rtl8125_disable_rx_packet_filter(tp);
+
+        if (HW_DASH_SUPPORT_DASH(tp))
+                rtl8125_driver_start(tp);
+
+#ifdef ENABLE_REALWOW_SUPPORT
+        rtl8125_realwow_hw_init(dev);
+#else
+        //Disable realwow  function
+        rtl8125_mac_ocp_write(tp, 0xC0BC, 0x00FF);
+#endif //ENABLE_REALWOW_SUPPORT
+
+        rtl8125_nic_reset(dev);
+
+        rtl8125_disable_now_is_oob(tp);
+
+        data16 = rtl8125_mac_ocp_read(tp, 0xE8DE) & ~BIT_14;
+        rtl8125_mac_ocp_write(tp, 0xE8DE, data16);
+        rtl8125_wait_ll_share_fifo_ready(dev);
+
+        rtl8125_mac_ocp_write(tp, 0xC0AA, 0x07D0);
+#ifdef ENABLE_LIB_SUPPORT
+        rtl8125_mac_ocp_write(tp, 0xC0A6, 0x04E2);
+#else
+        rtl8125_mac_ocp_write(tp, 0xC0A6, 0x01B5);
+#endif
+        rtl8125_mac_ocp_write(tp, 0xC01E, 0x5555);
+
+        rtl8125_wait_ll_share_fifo_ready(dev);
+
+        //wait ups resume (phy state 2)
+        if (rtl8125_is_ups_resume(dev)) {
+                rtl8125_wait_phy_ups_resume(dev, 2);
+                rtl8125_clear_ups_resume_bit(dev);
+                rtl8125_clear_phy_ups_reg(dev);
+        }
+}
+
+void
+rtl8125_hw_disable_mac_mcu_bps(struct net_device *dev)
+{
+        u16 regAddr;
+
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_enable_aspm_clkreq_lock(tp, 0);
+
+        rtl8125_mac_ocp_write(tp, 0xFC48, 0x0000);
+
+        for (regAddr = 0xFC28; regAddr < 0xFC48; regAddr += 2) {
+                rtl8125_mac_ocp_write(tp, regAddr, 0x0000);
+        }
+
+        fsleep(3000);
+
+        rtl8125_mac_ocp_write(tp, 0xFC26, 0x0000);
+}
+
+#ifndef ENABLE_USE_FIRMWARE_FILE
+static void
+rtl8125_switch_mac_mcu_ram_code_page(struct rtl8125_private *tp, u16 page)
+{
+        u16 tmpUshort;
+
+        page &= (BIT_1 | BIT_0);
+        tmpUshort = rtl8125_mac_ocp_read(tp, 0xE446);
+        tmpUshort &= ~(BIT_1 | BIT_0);
+        tmpUshort |= page;
+        rtl8125_mac_ocp_write(tp, 0xE446, tmpUshort);
+}
+
+static void
+_rtl8125_set_hw_mcu_patch_code_ver(struct rtl8125_private *tp, u64 ver)
+{
+        int i;
+
+        /* Switch to page 2 */
+        rtl8125_switch_mac_mcu_ram_code_page(tp, 2);
+
+        for (i = 0; i < 8; i += 2) {
+                rtl8125_mac_ocp_write(tp, 0xF9F8 + 6 - i, (u16)ver);
+                ver >>= 16;
+        }
+
+        /* Switch back to page 0 */
+        rtl8125_switch_mac_mcu_ram_code_page(tp, 0);
+}
+
+static void
+rtl8125_set_hw_mcu_patch_code_ver(struct rtl8125_private *tp, u64 ver)
+{
+        _rtl8125_set_hw_mcu_patch_code_ver(tp, ver);
+
+        tp->hw_mcu_patch_code_ver = ver;
+}
+
+static u64
+rtl8125_get_hw_mcu_patch_code_ver(struct rtl8125_private *tp)
+{
+        u64 ver;
+        int i;
+
+        /* Switch to page 2 */
+        rtl8125_switch_mac_mcu_ram_code_page(tp, 2);
+
+        ver = 0;
+        for (i = 0; i < 8; i += 2) {
+                ver <<= 16;
+                ver |= rtl8125_mac_ocp_read(tp, 0xF9F8 + i);
+        }
+
+        /* Switch back to page 0 */
+        rtl8125_switch_mac_mcu_ram_code_page(tp, 0);
+
+        return ver;
+}
+
+static u64
+rtl8125_get_bin_mcu_patch_code_ver(const u16 *entry, u16 entry_cnt)
+{
+        u64 ver;
+        int i;
+
+        if (entry == NULL || entry_cnt == 0 || entry_cnt < 4)
+                return 0;
+
+        ver = 0;
+        for (i = 0; i < 4; i++) {
+                ver <<= 16;
+                ver |= entry[entry_cnt - 4 + i];
+        }
+
+        return ver;
+}
+
+static void
+_rtl8125_write_mac_mcu_ram_code(struct rtl8125_private *tp, const u16 *entry, u16 entry_cnt)
+{
+        u16 i;
+
+        for (i = 0; i < entry_cnt; i++)
+                rtl8125_mac_ocp_write(tp, 0xF800 + i * 2, entry[i]);
+}
+
+static void
+_rtl8125_write_mac_mcu_ram_code_with_page(struct rtl8125_private *tp, const u16 *entry, u16 entry_cnt, u16 page_size)
+{
+        u16 i;
+        u16 offset;
+
+        if (page_size == 0)
+                return;
+
+        for (i = 0; i < entry_cnt; i++) {
+                offset = i % page_size;
+                if (offset == 0) {
+                        u16 page = (i / page_size);
+                        rtl8125_switch_mac_mcu_ram_code_page(tp, page);
+                }
+                rtl8125_mac_ocp_write(tp, 0xF800 + offset * 2, entry[i]);
+        }
+}
+
+static void
+rtl8125_write_mac_mcu_ram_code(struct rtl8125_private *tp, const u16 *entry, u16 entry_cnt)
+{
+        if (FALSE == HW_SUPPORT_MAC_MCU(tp))
+                return;
+
+        if (entry == NULL || entry_cnt == 0)
+                return;
+
+        if (tp->MacMcuPageSize > 0)
+                _rtl8125_write_mac_mcu_ram_code_with_page(tp, entry, entry_cnt, tp->MacMcuPageSize);
+        else
+                _rtl8125_write_mac_mcu_ram_code(tp, entry, entry_cnt);
+
+        if (tp->bin_mcu_patch_code_ver > 0)
+                rtl8125_set_hw_mcu_patch_code_ver(tp, tp->bin_mcu_patch_code_ver);
+}
+
+static void
+rtl8125_set_mac_mcu_8125a_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        static const u16 mcu_patch_code[] = {
+                0xE010, 0xE062, 0xE072, 0xE074, 0xE079, 0xE07B, 0xE0E4, 0xE0ED, 0xE0EF,
+                0xE0FA, 0xE105, 0xE116, 0xE11C, 0xE121, 0xE126, 0xE12A, 0xB400, 0xB401,
+                0xB402, 0xB403, 0xB404, 0xB405, 0xC03F, 0x7206, 0x49AE, 0xF1FE, 0xC13C,
+                0x9904, 0xC13B, 0x9906, 0x7206, 0x49AE, 0xF1FE, 0x7200, 0x49A0, 0xF10D,
+                0xC534, 0xC133, 0xC238, 0xC338, 0xE817, 0xC337, 0xE815, 0xC336, 0xE813,
+                0xC335, 0xE811, 0xE01B, 0xC129, 0xC22D, 0xC528, 0xC32C, 0xE80B, 0xC526,
+                0xC32A, 0xE808, 0xC524, 0xC328, 0xE805, 0xC522, 0xC326, 0xE802, 0xE00C,
+                0x740E, 0x49CE, 0xF1FE, 0x9908, 0x9D0A, 0x9A0C, 0x9B0E, 0x740E, 0x49CE,
+                0xF1FE, 0xFF80, 0xB005, 0xB004, 0xB003, 0xB002, 0xB001, 0xB000, 0xC604,
+                0xC002, 0xB800, 0x3044, 0xE000, 0xE8E0, 0xF128, 0x0002, 0xFFFF, 0x10EC,
+                0x816A, 0x816F, 0x8164, 0x816D, 0xF000, 0x8001, 0x8002, 0x8003, 0x8004,
+                0xC60F, 0x73C4, 0x49B3, 0xF106, 0x73C2, 0xC608, 0xB406, 0xC609, 0xFF80,
+                0xC605, 0xB406, 0xC605, 0xFF80, 0x0544, 0x0568, 0xE906, 0xCDE8, 0xC602,
+                0xBE00, 0x0000, 0x48C1, 0x48C2, 0x9C46, 0xC402, 0xBC00, 0x0A12, 0xC602,
+                0xBE00, 0x0EBA, 0x1501, 0xF02A, 0x1500, 0xF15D, 0xC661, 0x75C8, 0x49D5,
+                0xF00A, 0x49D6, 0xF008, 0x49D7, 0xF006, 0x49D8, 0xF004, 0x75D2, 0x49D9,
+                0xF150, 0xC553, 0x77A0, 0x75C8, 0x4855, 0x4856, 0x4857, 0x4858, 0x48DA,
+                0x48DB, 0x49FE, 0xF002, 0x485A, 0x49FF, 0xF002, 0x485B, 0x9DC8, 0x75D2,
+                0x4859, 0x9DD2, 0xC643, 0x75C0, 0x49D4, 0xF033, 0x49D1, 0xF137, 0xE030,
+                0xC63A, 0x75C8, 0x49D5, 0xF00E, 0x49D6, 0xF00C, 0x49D7, 0xF00A, 0x49D8,
+                0xF008, 0x75D2, 0x49D9, 0xF005, 0xC62E, 0x75C0, 0x49D7, 0xF125, 0xC528,
+                0x77A0, 0xC627, 0x75C8, 0x4855, 0x4856, 0x4857, 0x4858, 0x48DA, 0x48DB,
+                0x49FE, 0xF002, 0x485A, 0x49FF, 0xF002, 0x485B, 0x9DC8, 0x75D2, 0x4859,
+                0x9DD2, 0xC616, 0x75C0, 0x4857, 0x9DC0, 0xC613, 0x75C0, 0x49DA, 0xF003,
+                0x49D1, 0xF107, 0xC60B, 0xC50E, 0x48D9, 0x9DC0, 0x4859, 0x9DC0, 0xC608,
+                0xC702, 0xBF00, 0x3AE0, 0xE860, 0xB400, 0xB5D4, 0xE908, 0xE86C, 0x1200,
+                0xC409, 0x6780, 0x48F1, 0x8F80, 0xC404, 0xC602, 0xBE00, 0x10AA, 0xC010,
+                0xEA7C, 0xC602, 0xBE00, 0x0000, 0x740A, 0x4846, 0x4847, 0x9C0A, 0xC607,
+                0x74C0, 0x48C6, 0x9CC0, 0xC602, 0xBE00, 0x13FE, 0xE054, 0x72CA, 0x4826,
+                0x4827, 0x9ACA, 0xC607, 0x72C0, 0x48A6, 0x9AC0, 0xC602, 0xBE00, 0x07DC,
+                0xE054, 0xC60F, 0x74C4, 0x49CC, 0xF109, 0xC60C, 0x74CA, 0x48C7, 0x9CCA,
+                0xC609, 0x74C0, 0x4846, 0x9CC0, 0xC602, 0xBE00, 0x2480, 0xE092, 0xE0C0,
+                0xE054, 0x7420, 0x48C0, 0x9C20, 0x7444, 0xC602, 0xBE00, 0x12F8, 0x1BFF,
+                0x46EB, 0x1BFF, 0xC102, 0xB900, 0x0D5A, 0x1BFF, 0x46EB, 0x1BFF, 0xC102,
+                0xB900, 0x0E2A, 0xC104, 0xC202, 0xBA00, 0x21DE, 0xD116, 0xC602, 0xBE00,
+                0x0000, 0x6486, 0x0119, 0x0606, 0x1327
+        };
+
+        /* Get BIN mac mcu patch code version */
+        tp->bin_mcu_patch_code_ver = rtl8125_get_bin_mcu_patch_code_ver(mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        if (tp->hw_mcu_patch_code_ver != tp->bin_mcu_patch_code_ver)
+                rtl8125_write_mac_mcu_ram_code(tp, mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        rtl8125_mac_ocp_write(tp, 0xFC26, 0x8000);
+
+        rtl8125_mac_ocp_write(tp, 0xFC2A, 0x0540);
+        rtl8125_mac_ocp_write(tp, 0xFC2E, 0x0A06);
+        rtl8125_mac_ocp_write(tp, 0xFC30, 0x0EB8);
+        rtl8125_mac_ocp_write(tp, 0xFC32, 0x3A5C);
+        rtl8125_mac_ocp_write(tp, 0xFC34, 0x10A8);
+        rtl8125_mac_ocp_write(tp, 0xFC40, 0x0D54);
+        rtl8125_mac_ocp_write(tp, 0xFC42, 0x0E24);
+
+        rtl8125_mac_ocp_write(tp, 0xFC48, 0x307A);
+}
+
+static void
+rtl8125_set_mac_mcu_8125b_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        static const u16 mcu_patch_code[] = {
+                0xE010, 0xE01B, 0xE026, 0xE037, 0xE03D, 0xE057, 0xE05B, 0xE060, 0xE0B6,
+                0xE103, 0xE14C, 0xE150, 0xE153, 0xE156, 0xE158, 0xE15A, 0x740A, 0x4846,
+                0x4847, 0x9C0A, 0xC607, 0x74C0, 0x48C6, 0x9CC0, 0xC602, 0xBE00, 0x13F0,
+                0xE054, 0x72CA, 0x4826, 0x4827, 0x9ACA, 0xC607, 0x72C0, 0x48A6, 0x9AC0,
+                0xC602, 0xBE00, 0x081C, 0xE054, 0xC60F, 0x74C4, 0x49CC, 0xF109, 0xC60C,
+                0x74CA, 0x48C7, 0x9CCA, 0xC609, 0x74C0, 0x4846, 0x9CC0, 0xC602, 0xBE00,
+                0x2494, 0xE092, 0xE0C0, 0xE054, 0x7420, 0x48C0, 0x9C20, 0x7444, 0xC602,
+                0xBE00, 0x12DC, 0x733A, 0x21B5, 0x25BC, 0x1304, 0xF111, 0x1B12, 0x1D2A,
+                0x3168, 0x3ADA, 0x31AB, 0x1A00, 0x9AC0, 0x1300, 0xF1FB, 0x7620, 0x236E,
+                0x276F, 0x1A3C, 0x22A1, 0x41B5, 0x9EE2, 0x76E4, 0x486F, 0x9EE4, 0xC602,
+                0xBE00, 0x4A26, 0x733A, 0x49BB, 0xC602, 0xBE00, 0x47A2, 0x48C1, 0x48C2,
+                0x9C46, 0xC402, 0xBC00, 0x0A52, 0xC74B, 0x76E2, 0xC54A, 0x402E, 0xF034,
+                0x76E0, 0x402E, 0xF006, 0xC703, 0xC403, 0xBC00, 0xC0BC, 0x0980, 0x76F0,
+                0x1601, 0xF023, 0xC741, 0x1E04, 0x9EE0, 0x1E40, 0x9EE4, 0xC63D, 0x9EE8,
+                0xC73D, 0x76E0, 0x4863, 0x9EE0, 0xC73A, 0x76E0, 0x48EA, 0x48EB, 0x9EE0,
+                0xC736, 0x1E01, 0x9EE2, 0xC72D, 0x76E0, 0x486F, 0x9EE0, 0xC72D, 0x76E0,
+                0x48E3, 0x9EE0, 0xC728, 0x1E0E, 0x9EE0, 0xC71D, 0x1E01, 0x9EE4, 0xE00D,
+                0x1E00, 0x9EF0, 0x1E05, 0xC715, 0x9EE0, 0xE00A, 0x1E00, 0x9EE2, 0xC614,
+                0x75CC, 0x48D2, 0x9DCC, 0x1E04, 0xC70B, 0x9EE0, 0xB000, 0xB001, 0xB002,
+                0xB003, 0xB004, 0xB005, 0xB006, 0xB007, 0xFFC0, 0xE428, 0xD3C0, 0xBEEF,
+                0x473E, 0xDC46, 0xE0CC, 0xE84E, 0xC0A2, 0x0100, 0xC010, 0xE85A, 0xE812,
+                0xC0B4, 0xC5F4, 0x74A0, 0xC6F3, 0x4026, 0xF107, 0x74A2, 0xC6EF, 0x4026,
+                0xF107, 0xC6ED, 0xBE00, 0x753A, 0xC602, 0xBE00, 0x462E, 0x7520, 0x49DE,
+                0xF102, 0xE7F9, 0xC6A1, 0x67C6, 0x7520, 0x22D2, 0x26DD, 0x1500, 0xF002,
+                0xE7F1, 0x7532, 0x26D5, 0x0530, 0x0D6C, 0xC42D, 0x308D, 0x7540, 0x4025,
+                0xF11E, 0x7542, 0x4025, 0xF11B, 0x7544, 0x4025, 0xF118, 0xC423, 0x7546,
+                0x4025, 0xF114, 0x7548, 0x4025, 0xF111, 0x754A, 0x4025, 0xF10E, 0xC5C0,
+                0xC4C0, 0x9CA2, 0xC6C0, 0x75CC, 0x4852, 0x9DCC, 0xC6B8, 0x1D7D, 0x9DC2,
+                0x1D01, 0x9DC0, 0xE7C9, 0xC40B, 0x7546, 0x4025, 0xF1FC, 0x7548, 0x4025,
+                0xF1F9, 0x754A, 0x4025, 0xF1F6, 0xE7C0, 0xFFFF, 0xEEEE, 0xC2A6, 0x7340,
+                0xC2A5, 0x4013, 0xF013, 0xC2AC, 0x7340, 0x4835, 0x9B40, 0xC240, 0x7358,
+                0x48B7, 0x48B2, 0x9B58, 0x7346, 0x48B7, 0x48B2, 0x9B46, 0x7340, 0x48B7,
+                0x48B2, 0x9B40, 0xE012, 0xC29A, 0x7340, 0x48B5, 0x9B40, 0xC22E, 0x7358,
+                0x4837, 0x4832, 0x9B58, 0x7346, 0x4837, 0x4832, 0x9B46, 0x7340, 0x4837,
+                0x4832, 0x9B40, 0xC283, 0x7340, 0x49BF, 0xF010, 0xC21B, 0x7344, 0x1300,
+                0xF104, 0x1B00, 0xC217, 0x9B40, 0x1B01, 0xC213, 0x9B44, 0xC213, 0x734C,
+                0x48B7, 0x9B4C, 0xE008, 0xC20C, 0x1B00, 0x9B44, 0xC20B, 0x734C, 0x4837,
+                0x9B4C, 0xC204, 0xC302, 0xBB00, 0x2230, 0xE092, 0xD3C0, 0xE428, 0xDC46,
+                0xC104, 0xC202, 0xBA00, 0x21F8, 0xD116, 0x49D1, 0xC602, 0xBE00, 0x3E7A,
+                0x49D1, 0xC602, 0xBE00, 0x3EDA, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00,
+                0x0000, 0xC602, 0xBE00, 0x0000, 0x6637, 0x0119, 0x0604, 0x1203
+        };
+
+        /* Get BIN mac mcu patch code version */
+        tp->bin_mcu_patch_code_ver = rtl8125_get_bin_mcu_patch_code_ver(mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        if (tp->hw_mcu_patch_code_ver != tp->bin_mcu_patch_code_ver)
+                rtl8125_write_mac_mcu_ram_code(tp, mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        rtl8125_mac_ocp_write(tp, 0xFC26, 0x8000);
+
+        rtl8125_mac_ocp_write(tp, 0xFC28, 0x13E6);
+        rtl8125_mac_ocp_write(tp, 0xFC2A, 0x0812);
+        rtl8125_mac_ocp_write(tp, 0xFC2C, 0x248C);
+        rtl8125_mac_ocp_write(tp, 0xFC2E, 0x12DA);
+        rtl8125_mac_ocp_write(tp, 0xFC30, 0x4A20);
+        rtl8125_mac_ocp_write(tp, 0xFC32, 0x47A0);
+        //rtl8125_mac_ocp_write(tp, 0xFC34, 0x0A46);
+        //rtl8125_mac_ocp_write(tp, 0xFC36, 0x097E);
+        //rtl8125_mac_ocp_write(tp, 0xFC38, 0x462C);
+        //rtl8125_mac_ocp_write(tp, 0xFC3A, 0x222E);
+        rtl8125_mac_ocp_write(tp, 0xFC3C, 0x21F6);
+        rtl8125_mac_ocp_write(tp, 0xFC3E, 0x3E78);
+        rtl8125_mac_ocp_write(tp, 0xFC40, 0x3ED8);
+
+        rtl8125_mac_ocp_write(tp, 0xFC48, 0x1C7B);
+}
+
+static void
+rtl8125_set_mac_mcu_8125bp_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        static const u16 mcu_patch_code[] = {
+                0xE010, 0xE014, 0xE027, 0xE04A, 0xE04D, 0xE050, 0xE052, 0xE054, 0xE056,
+                0xE058, 0xE05A, 0xE05C, 0xE05E, 0xE060, 0xE062, 0xE064, 0x1BC8, 0x46EB,
+                0xC302, 0xBB00, 0x0F14, 0xC211, 0x400A, 0xF00A, 0xC20F, 0x400A, 0xF007,
+                0x73A4, 0xC20C, 0x400A, 0xF102, 0x48B0, 0x9B20, 0x1B00, 0x9BA0, 0xC602,
+                0xBE00, 0x4364, 0xE6E0, 0xE6E2, 0xC01C, 0xB406, 0x1000, 0xF016, 0xC61F,
+                0x400E, 0xF012, 0x218E, 0x25BE, 0x1300, 0xF007, 0x7340, 0xC618, 0x400E,
+                0xF102, 0x48B0, 0x8320, 0xB400, 0x2402, 0x1000, 0xF003, 0x7342, 0x8322,
+                0xB000, 0xE007, 0x7322, 0x9B42, 0x7320, 0x9B40, 0x0300, 0x0300, 0xB006,
+                0xC302, 0xBB00, 0x413E, 0xE6E0, 0xC01C, 0x49D1, 0xC602, 0xBE00, 0x3F94,
+                0x49D1, 0xC602, 0xBE00, 0x4030, 0xC602, 0xBE00, 0x3FDA, 0xC102, 0xB900,
+                0x401A, 0xC102, 0xB900, 0x0000, 0xC002, 0xB800, 0x0000, 0xC602, 0xBE00,
+                0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00,
+                0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00,
+                0x0000, 0x6936, 0x0A18, 0x0C02, 0x0D21
+        };
+
+        /* Get BIN mac mcu patch code version */
+        tp->bin_mcu_patch_code_ver = rtl8125_get_bin_mcu_patch_code_ver(mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        if (tp->hw_mcu_patch_code_ver != tp->bin_mcu_patch_code_ver)
+                rtl8125_write_mac_mcu_ram_code(tp, mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        rtl8125_mac_ocp_write(tp, 0xFC26, 0x8000);
+
+        rtl8125_mac_ocp_write(tp, 0xFC28, 0x0f10);
+        rtl8125_mac_ocp_write(tp, 0xFC2A, 0x435c);
+        rtl8125_mac_ocp_write(tp, 0xFC2C, 0x4112);
+        rtl8125_mac_ocp_write(tp, 0xFC2E, 0x3F92);
+        rtl8125_mac_ocp_write(tp, 0xFC30, 0x402E);
+        rtl8125_mac_ocp_write(tp, 0xFC32, 0x3FD6);
+        rtl8125_mac_ocp_write(tp, 0xFC34, 0x4018);
+
+        rtl8125_mac_ocp_write(tp, 0xFC48, 0x007F);
+}
+
+static void
+rtl8125_set_mac_mcu_8125bp_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        static const u16 mcu_patch_code[] = {
+                0xE010, 0xE033, 0xE046, 0xE04A, 0xE04D, 0xE050, 0xE054, 0xE056, 0xE058,
+                0xE05A, 0xE05C, 0xE05E, 0xE060, 0xE062, 0xE064, 0xE066, 0xB406, 0x1000,
+                0xF016, 0xC61F, 0x400E, 0xF012, 0x218E, 0x25BE, 0x1300, 0xF007, 0x7340,
+                0xC618, 0x400E, 0xF102, 0x48B0, 0x8320, 0xB400, 0x2402, 0x1000, 0xF003,
+                0x7342, 0x8322, 0xB000, 0xE007, 0x7322, 0x9B42, 0x7320, 0x9B40, 0x0300,
+                0x0300, 0xB006, 0xC302, 0xBB00, 0x4168, 0xE6E0, 0xC01C, 0xC211, 0x400A,
+                0xF00A, 0xC20F, 0x400A, 0xF007, 0x73A4, 0xC20C, 0x400A, 0xF102, 0x48B0,
+                0x9B20, 0x1B00, 0x9BA0, 0xC602, 0xBE00, 0x4392, 0xE6E0, 0xE6E2, 0xC01C,
+                0x4166, 0x9CF6, 0xC002, 0xB800, 0x143C, 0x49D1, 0xC602, 0xBE00, 0x3FC4,
+                0x49D1, 0xC602, 0xBE00, 0x405A, 0xC104, 0xC202, 0xBA00, 0x22E6, 0xD116,
+                0xC602, 0xBE00, 0x0000, 0xC102, 0xB900, 0x0000, 0xC002, 0xB800, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0x6936, 0x0119, 0x030E, 0x0B18
+        };
+
+        /* Get BIN mac mcu patch code version */
+        tp->bin_mcu_patch_code_ver = rtl8125_get_bin_mcu_patch_code_ver(mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        if (tp->hw_mcu_patch_code_ver != tp->bin_mcu_patch_code_ver)
+                rtl8125_write_mac_mcu_ram_code(tp, mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        rtl8125_mac_ocp_write(tp, 0xFC26, 0x8000);
+
+        rtl8125_mac_ocp_write(tp, 0xFC28, 0x413C);
+        rtl8125_mac_ocp_write(tp, 0xFC2A, 0x438A);
+        rtl8125_mac_ocp_write(tp, 0xFC2C, 0x143A);
+        rtl8125_mac_ocp_write(tp, 0xFC2E, 0x3FC2);
+        rtl8125_mac_ocp_write(tp, 0xFC30, 0x4058);
+        rtl8125_mac_ocp_write(tp, 0xFC32, 0x22E4);
+
+        rtl8125_mac_ocp_write(tp, 0xFC48, 0x003F);
+}
+
+static void
+rtl8125_set_mac_mcu_8125d_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        static const u16 mcu_patch_code[] = {
+                0xE010, 0xE014, 0xE018, 0xE01A, 0xE01C, 0xE01E, 0xE020, 0xE022, 0xE024,
+                0xE026, 0xE028, 0xE02A, 0xE02C, 0xE02E, 0xE030, 0xE032, 0x4166, 0x9CF6,
+                0xC002, 0xB800, 0x14A4, 0xC104, 0xC202, 0xBA00, 0x2378, 0xD116, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6938,
+                0x0A19, 0x030E, 0x0B2B
+        };
+
+        /* Get BIN mac mcu patch code version */
+        tp->bin_mcu_patch_code_ver = rtl8125_get_bin_mcu_patch_code_ver(mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        if (tp->hw_mcu_patch_code_ver != tp->bin_mcu_patch_code_ver)
+                rtl8125_write_mac_mcu_ram_code(tp, mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        rtl8125_mac_ocp_write(tp, 0xFC26, 0x8000);
+
+        rtl8125_mac_ocp_write(tp, 0xFC28, 0x14A2);
+        rtl8125_mac_ocp_write(tp, 0xFC2A, 0x2376);
+
+        rtl8125_mac_ocp_write(tp, 0xFC48, 0x0003);
+}
+
+static void
+rtl8125_set_mac_mcu_8125d_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        static const u16 mcu_patch_code[] = {
+                0xE010, 0xE014, 0xE016, 0xE018, 0xE01A, 0xE01C, 0xE01E, 0xE020, 0xE022,
+                0xE024, 0xE026, 0xE028, 0xE02A, 0xE02C, 0xE02E, 0xE030, 0xC104, 0xC202,
+                0xBA00, 0x2384, 0xD116, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6938,
+                0x0A19, 0x030E, 0x0B2F
+        };
+
+        /* Get BIN mac mcu patch code version */
+        tp->bin_mcu_patch_code_ver = rtl8125_get_bin_mcu_patch_code_ver(mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        if (tp->hw_mcu_patch_code_ver != tp->bin_mcu_patch_code_ver)
+                rtl8125_write_mac_mcu_ram_code(tp, mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        rtl8125_mac_ocp_write(tp, 0xFC26, 0x8000);
+
+        rtl8125_mac_ocp_write(tp, 0xFC28, 0x2382);
+
+        rtl8125_mac_ocp_write(tp, 0xFC48, 0x0001);
+}
+
+
+static void
+rtl8125_set_mac_mcu_8125cp_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        static const u16 mcu_patch_code[] = {
+                0xE010, 0xE014, 0xE016, 0xE018, 0xE01A, 0xE01C, 0xE01E, 0xE020, 0xE022,
+                0xE024, 0xE026, 0xE028, 0xE02A, 0xE02C, 0xE02E, 0xE030, 0xC104, 0xC202,
+                0xBA00, 0x2438, 0xD116, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0x7023, 0x0019, 0x031A, 0x0E20
+        };
+
+        /* Get BIN mac mcu patch code version */
+        tp->bin_mcu_patch_code_ver = rtl8125_get_bin_mcu_patch_code_ver(mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        if (tp->hw_mcu_patch_code_ver != tp->bin_mcu_patch_code_ver)
+                rtl8125_write_mac_mcu_ram_code(tp, mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        rtl8125_mac_ocp_write(tp, 0xFC26, 0x8000);
+
+        rtl8125_mac_ocp_write(tp, 0xFC28, 0x2436);
+
+        rtl8125_mac_ocp_write(tp, 0xFC48, 0x0001);
+}
+
+static void
+rtl8125_hw_mac_mcu_config(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->NotWrMcuPatchCode == TRUE)
+                return;
+
+        rtl8125_hw_disable_mac_mcu_bps(dev);
+
+        /* Get H/W mac mcu patch code version */
+        tp->hw_mcu_patch_code_ver = rtl8125_get_hw_mcu_patch_code_ver(tp);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                rtl8125_set_mac_mcu_8125a_2(dev);
+                break;
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                rtl8125_set_mac_mcu_8125b_2(dev);
+                break;
+        case CFG_METHOD_8:
+                rtl8125_set_mac_mcu_8125bp_1(dev);
+                break;
+        case CFG_METHOD_9:
+                rtl8125_set_mac_mcu_8125bp_2(dev);
+                break;
+        case CFG_METHOD_10:
+                rtl8125_set_mac_mcu_8125d_1(dev);
+                break;
+        case CFG_METHOD_11:
+        case CFG_METHOD_13:
+                rtl8125_set_mac_mcu_8125d_2(dev);
+                break;
+        case CFG_METHOD_12:
+                rtl8125_set_mac_mcu_8125cp_1(dev);
+                break;
+        case CFG_METHOD_2:
+        case CFG_METHOD_4:
+                /* no mac mcu patch code */
+                break;
+        default:
+                break;
+        }
+}
+#endif
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+static void rtl8125_release_firmware(struct rtl8125_private *tp)
+{
+        if (tp->rtl_fw) {
+                rtl8125_fw_release_firmware(tp->rtl_fw);
+                kfree(tp->rtl_fw);
+                tp->rtl_fw = NULL;
+        }
+}
+
+static void rtl8125_apply_firmware(struct rtl8125_private *tp)
+{
+        unsigned long flags;
+
+        /* TODO: release firmware if rtl_fw_write_firmware signals failure. */
+        if (tp->rtl_fw) {
+                r8125_spin_lock(&tp->phy_lock, flags);
+
+                rtl8125_fw_write_firmware(tp, tp->rtl_fw);
+                /* At least one firmware doesn't reset tp->ocp_base. */
+                tp->ocp_base = OCP_STD_PHY_BASE;
+
+                /* PHY soft reset may still be in progress */
+                //phy_read_poll_timeout(tp->phydev, MII_BMCR, val,
+                //		      !(val & BMCR_RESET),
+                //		      50000, 600000, true);
+                rtl8125_wait_phy_reset_complete(tp);
+
+                tp->hw_ram_code_ver = rtl8125_get_hw_phy_mcu_code_ver(tp);
+                tp->sw_ram_code_ver = tp->hw_ram_code_ver;
+                tp->HwHasWrRamCodeToMicroP = TRUE;
+
+                r8125_spin_unlock(&tp->phy_lock, flags);
+        }
+}
+#endif
+
+static void
+rtl8125_hw_init(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 csi_tmp;
+
+        rtl8125_enable_aspm_clkreq_lock(tp, 0);
+        rtl8125_enable_force_clkreq(tp, 0);
+
+        rtl8125_set_reg_oobs_en_sel(tp, true);
+
+        //Disable UPS
+        rtl8125_mac_ocp_write(tp, 0xD40A, rtl8125_mac_ocp_read(tp, 0xD40A) & ~(BIT_4));
+
+#ifndef ENABLE_USE_FIRMWARE_FILE
+        if (!tp->rtl_fw)
+                rtl8125_hw_mac_mcu_config(dev);
+#endif
+
+        /*disable ocp phy power saving*/
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_6)
+                rtl8125_disable_ocp_phy_power_saving(dev);
+
+        //Set PCIE uncorrectable error status mask pcie 0x108
+        csi_tmp = rtl8125_csi_read(tp, 0x108);
+        csi_tmp |= BIT_20;
+        rtl8125_csi_write(tp, 0x108, csi_tmp);
+
+        rtl8125_enable_cfg9346_write(tp);
+        rtl8125_disable_linkchg_wakeup(dev);
+        rtl8125_disable_cfg9346_write(tp);
+        rtl8125_disable_magic_packet(dev);
+        rtl8125_disable_d0_speedup(tp);
+        rtl8125_set_pci_pme(tp, 0);
+        if (s0_magic_packet == 1)
+                rtl8125_enable_magic_packet(dev);
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+        if (tp->rtl_fw && !tp->resume_not_chg_speed)
+                rtl8125_apply_firmware(tp);
+#endif
+}
+
+static void
+rtl8125_hw_ephy_config(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+                rtl8125_ephy_write(tp, 0x01, 0xA812);
+                rtl8125_ephy_write(tp, 0x09, 0x520C);
+                rtl8125_ephy_write(tp, 0x04, 0xD000);
+                rtl8125_ephy_write(tp, 0x0D, 0xF702);
+                rtl8125_ephy_write(tp, 0x0A, 0x8653);
+                rtl8125_ephy_write(tp, 0x06, 0x001E);
+                rtl8125_ephy_write(tp, 0x08, 0x3595);
+                rtl8125_ephy_write(tp, 0x20, 0x9455);
+                rtl8125_ephy_write(tp, 0x21, 0x99FF);
+                rtl8125_ephy_write(tp, 0x02, 0x6046);
+                rtl8125_ephy_write(tp, 0x29, 0xFE00);
+                rtl8125_ephy_write(tp, 0x23, 0xAB62);
+
+                rtl8125_ephy_write(tp, 0x41, 0xA80C);
+                rtl8125_ephy_write(tp, 0x49, 0x520C);
+                rtl8125_ephy_write(tp, 0x44, 0xD000);
+                rtl8125_ephy_write(tp, 0x4D, 0xF702);
+                rtl8125_ephy_write(tp, 0x4A, 0x8653);
+                rtl8125_ephy_write(tp, 0x46, 0x001E);
+                rtl8125_ephy_write(tp, 0x48, 0x3595);
+                rtl8125_ephy_write(tp, 0x60, 0x9455);
+                rtl8125_ephy_write(tp, 0x61, 0x99FF);
+                rtl8125_ephy_write(tp, 0x42, 0x6046);
+                rtl8125_ephy_write(tp, 0x69, 0xFE00);
+                rtl8125_ephy_write(tp, 0x63, 0xAB62);
+                break;
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                rtl8125_ephy_write(tp, 0x04, 0xD000);
+                rtl8125_ephy_write(tp, 0x0A, 0x8653);
+                rtl8125_ephy_write(tp, 0x23, 0xAB66);
+                rtl8125_ephy_write(tp, 0x20, 0x9455);
+                rtl8125_ephy_write(tp, 0x21, 0x99FF);
+                rtl8125_ephy_write(tp, 0x29, 0xFE04);
+
+                rtl8125_ephy_write(tp, 0x44, 0xD000);
+                rtl8125_ephy_write(tp, 0x4A, 0x8653);
+                rtl8125_ephy_write(tp, 0x63, 0xAB66);
+                rtl8125_ephy_write(tp, 0x60, 0x9455);
+                rtl8125_ephy_write(tp, 0x61, 0x99FF);
+                rtl8125_ephy_write(tp, 0x69, 0xFE04);
+
+                ClearAndSetPCIePhyBit(tp,
+                                      0x2A,
+                                      (BIT_14 | BIT_13 | BIT_12),
+                                      (BIT_13 | BIT_12));
+                ClearPCIePhyBit(tp, 0x19, BIT_6);
+                SetPCIePhyBit(tp, 0x1B, (BIT_11 | BIT_10 | BIT_9));
+                ClearPCIePhyBit(tp, 0x1B, (BIT_14 | BIT_13 | BIT_12));
+                rtl8125_ephy_write(tp, 0x02, 0x6042);
+                rtl8125_ephy_write(tp, 0x06, 0x0014);
+
+                ClearAndSetPCIePhyBit(tp,
+                                      0x6A,
+                                      (BIT_14 | BIT_13 | BIT_12),
+                                      (BIT_13 | BIT_12));
+                ClearPCIePhyBit(tp, 0x59, BIT_6);
+                SetPCIePhyBit(tp, 0x5B, (BIT_11 | BIT_10 | BIT_9));
+                ClearPCIePhyBit(tp, 0x5B, (BIT_14 | BIT_13 | BIT_12));
+                rtl8125_ephy_write(tp, 0x42, 0x6042);
+                rtl8125_ephy_write(tp, 0x46, 0x0014);
+                break;
+        case CFG_METHOD_4:
+                rtl8125_ephy_write(tp, 0x06, 0x001F);
+                rtl8125_ephy_write(tp, 0x0A, 0xB66B);
+                rtl8125_ephy_write(tp, 0x01, 0xA852);
+                rtl8125_ephy_write(tp, 0x24, 0x0008);
+                rtl8125_ephy_write(tp, 0x2F, 0x6052);
+                rtl8125_ephy_write(tp, 0x0D, 0xF716);
+                rtl8125_ephy_write(tp, 0x20, 0xD477);
+                rtl8125_ephy_write(tp, 0x21, 0x4477);
+                rtl8125_ephy_write(tp, 0x22, 0x0013);
+                rtl8125_ephy_write(tp, 0x23, 0xBB66);
+                rtl8125_ephy_write(tp, 0x0B, 0xA909);
+                rtl8125_ephy_write(tp, 0x29, 0xFF04);
+                rtl8125_ephy_write(tp, 0x1B, 0x1EA0);
+
+                rtl8125_ephy_write(tp, 0x46, 0x001F);
+                rtl8125_ephy_write(tp, 0x4A, 0xB66B);
+                rtl8125_ephy_write(tp, 0x41, 0xA84A);
+                rtl8125_ephy_write(tp, 0x64, 0x000C);
+                rtl8125_ephy_write(tp, 0x6F, 0x604A);
+                rtl8125_ephy_write(tp, 0x4D, 0xF716);
+                rtl8125_ephy_write(tp, 0x60, 0xD477);
+                rtl8125_ephy_write(tp, 0x61, 0x4477);
+                rtl8125_ephy_write(tp, 0x62, 0x0013);
+                rtl8125_ephy_write(tp, 0x63, 0xBB66);
+                rtl8125_ephy_write(tp, 0x4B, 0xA909);
+                rtl8125_ephy_write(tp, 0x69, 0xFF04);
+                rtl8125_ephy_write(tp, 0x5B, 0x1EA0);
+                break;
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                rtl8125_ephy_write(tp, 0x0B, 0xA908);
+                rtl8125_ephy_write(tp, 0x1E, 0x20EB);
+                rtl8125_ephy_write(tp, 0x22, 0x0023);
+                rtl8125_ephy_write(tp, 0x02, 0x60C2);
+                rtl8125_ephy_write(tp, 0x29, 0xFF00);
+
+                rtl8125_ephy_write(tp, 0x4B, 0xA908);
+                rtl8125_ephy_write(tp, 0x5E, 0x28EB);
+                rtl8125_ephy_write(tp, 0x62, 0x0023);
+                rtl8125_ephy_write(tp, 0x42, 0x60C2);
+                rtl8125_ephy_write(tp, 0x69, 0xFF00);
+                break;
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                /* nothing to do */
+                break;
+        }
+}
+
+static u16
+rtl8125_get_hw_phy_mcu_code_ver(struct rtl8125_private *tp)
+{
+        u16 hw_ram_code_ver;
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x801E);
+        hw_ram_code_ver = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA438);
+
+        return hw_ram_code_ver;
+}
+
+static int
+rtl8125_check_hw_phy_mcu_code_ver(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        tp->hw_ram_code_ver = rtl8125_get_hw_phy_mcu_code_ver(tp);
+
+        if (tp->hw_ram_code_ver == tp->sw_ram_code_ver) {
+                tp->HwHasWrRamCodeToMicroP = TRUE;
+                return 1;
+        } else {
+                tp->HwHasWrRamCodeToMicroP = FALSE;
+                return 0;
+        }
+}
+
+bool
+rtl8125_set_phy_mcu_patch_request(struct rtl8125_private *tp)
+{
+        u16 gphy_val;
+        u16 WaitCount;
+        bool bSuccess = TRUE;
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xB820, BIT_4);
+
+        WaitCount = 0;
+        do {
+                gphy_val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xB800);
+                udelay(100);
+                WaitCount++;
+        } while (!(gphy_val & BIT_6) && (WaitCount < 1000));
+
+        if (!(gphy_val & BIT_6) && (WaitCount == 1000))
+                bSuccess = FALSE;
+
+        if (!bSuccess)
+                dprintk("rtl8125_set_phy_mcu_patch_request fail.\n");
+
+        return bSuccess;
+}
+
+bool
+rtl8125_clear_phy_mcu_patch_request(struct rtl8125_private *tp)
+{
+        u16 gphy_val;
+        u16 WaitCount;
+        bool bSuccess = TRUE;
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xB820, BIT_4);
+
+        WaitCount = 0;
+        do {
+                gphy_val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xB800);
+                udelay(100);
+                WaitCount++;
+        } while ((gphy_val & BIT_6) && (WaitCount < 1000));
+
+        if ((gphy_val & BIT_6) && (WaitCount == 1000))
+                bSuccess = FALSE;
+
+        if (!bSuccess)
+                dprintk("rtl8125_clear_phy_mcu_patch_request fail.\n");
+
+        return bSuccess;
+}
+
+#ifndef ENABLE_USE_FIRMWARE_FILE
+static void
+rtl8125_write_hw_phy_mcu_code_ver(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x801E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, tp->sw_ram_code_ver);
+        tp->hw_ram_code_ver = tp->sw_ram_code_ver;
+}
+
+static void
+rtl8125_acquire_phy_mcu_patch_key_lock(struct rtl8125_private *tp)
+{
+        u16 PatchKey;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+                PatchKey = 0x8600;
+                break;
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                PatchKey = 0x8601;
+                break;
+        case CFG_METHOD_4:
+                PatchKey = 0x3700;
+                break;
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                PatchKey = 0x3701;
+                break;
+        default:
+                return;
+        }
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8024);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, PatchKey);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xB82E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0001);
+}
+
+static void
+rtl8125_release_phy_mcu_patch_key_lock(struct rtl8125_private *tp)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x0000);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xB82E, BIT_0);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8024);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+                break;
+        default:
+                break;
+        }
+}
+
+static void
+rtl8125_set_phy_mcu_ram_code(struct net_device *dev, const u16 *ramcode, u16 codesize)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 i;
+        u16 addr;
+        u16 val;
+
+        if (ramcode == NULL || codesize % 2) {
+                goto out;
+        }
+
+        for (i = 0; i < codesize; i += 2) {
+                addr = ramcode[i];
+                val = ramcode[i + 1];
+                if (addr == 0xFFFF && val == 0xFFFF) {
+                        break;
+                }
+                rtl8125_mdio_direct_write_phy_ocp(tp, addr, val);
+        }
+
+out:
+        return;
+}
+
+static void
+rtl8125_enable_phy_disable_mode(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppCheckPhyDisableModeVer) {
+        case 3:
+                RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) | BIT_5);
+                break;
+        }
+
+        dprintk("enable phy disable mode.\n");
+}
+
+static void
+rtl8125_disable_phy_disable_mode(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppCheckPhyDisableModeVer) {
+        case 3:
+                RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) & ~BIT_5);
+                break;
+        }
+
+        mdelay(1);
+
+        dprintk("disable phy disable mode.\n");
+}
+
+static void
+rtl8125_set_hw_phy_before_init_phy_mcu(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 PhyRegValue;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xBF86, 0x9000);
+
+                rtl8125_set_eth_phy_ocp_bit(tp, 0xC402, BIT_10);
+                rtl8125_clear_eth_phy_ocp_bit(tp, 0xC402, BIT_10);
+
+                PhyRegValue = rtl8125_mdio_direct_read_phy_ocp(tp, 0xBF86);
+                PhyRegValue &= (BIT_1 | BIT_0);
+                if (PhyRegValue != 0)
+                        dprintk("PHY watch dog not clear, value = 0x%x \n", PhyRegValue);
+
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xBD86, 0x1010);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xBD88, 0x1010);
+
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xBD4E,
+                                                      BIT_11 | BIT_10,
+                                                      BIT_11);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xBF46,
+                                                      BIT_11 | BIT_10 | BIT_9 | BIT_8,
+                                                      BIT_10 | BIT_9 | BIT_8);
+                break;
+        }
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125a_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_acquire_phy_mcu_patch_key_lock(tp);
+
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xB820, BIT_7);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA016);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA012);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA014);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8013);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8021);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x802f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x803d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8042);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8051);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8051);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa088);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a50);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8008);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd014);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd1a3);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x401a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd707);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x40c2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x60a6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f8b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a86);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a6c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8080);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd019);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd1a2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x401a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd707);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x40c4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x60a6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f8b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a86);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a84);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd503);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8970);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c07);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0901);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xcf09);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd705);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xceff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf0a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1213);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8401);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8580);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1253);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd064);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd181);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4018);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xc50f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd706);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2c59);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x804d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xc60f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xc605);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xae02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x10fd);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA026);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA024);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA022);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x10f4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA020);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1252);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA006);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1206);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA004);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a78);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a60);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a4f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA008);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3f00);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA016);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA012);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA014);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8066);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x807c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8089);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x808e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x80a0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x80b2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x80c2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x62db);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x655c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd73e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x60e9);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x614a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x61ab);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0501);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0503);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0505);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0509);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x653c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd73e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x60e9);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x614a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x61ab);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0503);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0502);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0506);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x050a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd73e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x60e9);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x614a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x61ab);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0505);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0506);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0504);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x050c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd73e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x60e9);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x614a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x61ab);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0509);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x050a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x050c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0508);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd73e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x60e9);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x614a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x61ab);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0501);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0321);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0502);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0321);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0504);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0321);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0508);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0321);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0346);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8208);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x609d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa50f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x001a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0503);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x001a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x607d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00ab);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00ab);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x60fd);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa50f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xaa0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x017b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0503);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a05);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x017b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x60fd);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa50f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xaa0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x01e0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0503);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a05);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x01e0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x60fd);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa50f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xaa0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0231);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0503);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a05);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0231);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA08E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA08C);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0221);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA08A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x01ce);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA088);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0169);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA086);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00a6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA084);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x000d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA082);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0308);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA080);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x029f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA090);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x007f);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA016);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0020);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA012);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA014);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8017);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x801b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8029);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8054);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x805a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8064);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x80a7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x9430);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x9480);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb408);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd120);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd057);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x064b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xcb80);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x9906);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0567);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xcb94);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8190);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x82a0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x800a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8406);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8dff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa840);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0773);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xcb91);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4063);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd139);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd140);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd040);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb404);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07dc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa610);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa110);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa2a0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa404);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4045);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa180);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x405d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa720);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0742);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07ec);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f74);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0742);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd702);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7fb6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8190);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x82a0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8404);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8610);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07dc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x064b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07c0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5fa7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0481);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x94bc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x870c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa190);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa00a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa280);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa404);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8220);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x078e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xcb92);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa840);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4063);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd140);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd150);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd040);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd703);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x60a0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x6121);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x61a2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x6223);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf02f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d10);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf00f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d20);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf00a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d30);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf005);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d40);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa610);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa008);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4046);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x405d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa720);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0742);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07f7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f74);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0742);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd702);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7fb5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x800a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3ad4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0537);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8610);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8840);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x064b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8301);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x800a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8190);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x82a0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8404);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa70c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x9402);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x890c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8840);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x064b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA10E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0642);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA10C);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0686);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA10A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0788);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA108);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x047b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA106);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x065c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA104);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0769);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA102);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0565);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA100);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x06f9);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA110);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00ff);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb87c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8530);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb87e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf85);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3caf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8593);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf85);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x9caf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x85a5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd702);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5afb);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xe083);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfb0c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x020d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x021b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x10bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86d7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86da);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbe0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x83fc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1b10);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xda02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xdd02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5afb);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xe083);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfd0c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x020d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x021b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x10bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86dd);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86e0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbe0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x83fe);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1b10);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xe002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf2f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbd02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2cac);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0286);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x65af);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x212b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x022c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x6002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86b6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf21);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cd1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x03bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8710);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x870d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8719);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8716);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x871f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x871c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8728);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8725);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8707);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbad);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x281c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd100);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1302);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2202);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2b02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xae1a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd101);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1302);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2202);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2b02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd101);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3402);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3102);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3d02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3a02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4302);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4c02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4902);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd100);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2e02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3702);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4602);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4f02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf35);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7ff8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfaef);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x69bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86e3);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbbf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86fb);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86e6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbbf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86fe);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86e9);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbbf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8701);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86ec);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbbf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8704);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86ef);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0262);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7cbf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86f2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0262);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7cbf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86f5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0262);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7cbf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x86f8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0262);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7cef);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x96fe);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfc04);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf8fa);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xef69);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xef02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x6273);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf202);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x6273);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf502);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x6273);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf802);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x6273);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xef96);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfefc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0420);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb540);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x53b5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4086);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb540);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb9b5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x40c8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb03a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xc8b0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbac8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb13a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xc8b1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xba77);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbd26);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffbd);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2677);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbd28);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffbd);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2840);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbd26);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xc8bd);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2640);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbd28);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xc8bd);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x28bb);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa430);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x98b0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1eba);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb01e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xdcb0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1e98);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb09e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbab0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x9edc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb09e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x98b1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1eba);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb11e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xdcb1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1e98);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb19e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbab1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x9edc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb19e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x11b0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1e22);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb01e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x33b0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1e11);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb09e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x22b0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x9e33);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb09e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x11b1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1e22);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb11e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x33b1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1e11);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb19e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x22b1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x9e33);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb19e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb85e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2f71);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb860);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x20d9);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb862);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2109);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb864);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x34e7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb878);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x000f);
+
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xB820, BIT_7);
+
+
+        rtl8125_release_phy_mcu_patch_key_lock(tp);
+}
+
+static void
+rtl8125_set_phy_mcu_8125a_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125a_1(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125a_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_acquire_phy_mcu_patch_key_lock(tp);
+
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xB820, BIT_7);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA016);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA012);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA014);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x808b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x808f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8093);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8097);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x809d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x80a1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x80aa);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x607b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x40da);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf00e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x42da);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf01e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x615b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1456);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x14a4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x14bc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f2e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf01c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1456);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x14a4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x14bc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f2e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf024);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1456);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x14a4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x14bc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f2e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf02c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1456);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x14a4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x14bc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f2e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf034);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd719);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4118);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xac11);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa410);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4779);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xac0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xae01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1444);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf034);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd719);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4118);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xac22);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa420);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4559);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xac0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xae01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1444);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf023);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd719);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4118);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xac44);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa440);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4339);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xac0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xae01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1444);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf012);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd719);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4118);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xac88);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa480);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4119);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xac0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xae01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1444);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf001);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1456);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5fac);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xc48f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x141b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x121a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd0b4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd1bb);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0898);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd0b4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd1bb);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a0e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd064);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd18a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0b7e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x401c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa804);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8804);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x053b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa301);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0648);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xc520);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa201);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x252d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1646);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd708);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4006);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1646);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0308);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA026);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0307);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA024);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1645);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA022);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0647);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA020);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x053a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA006);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0b7c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA004);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a0c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0896);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x11a1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA008);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xff00);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA016);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA012);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA014);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8015);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x801a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x801a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x801a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x801a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x801a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x801a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xad02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x02d7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00ed);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0509);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xc100);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x008f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA08E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA08C);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA08A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA088);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA086);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA084);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA082);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x008d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA080);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00eb);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA090);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0103);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA016);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0020);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA012);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA014);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8014);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8018);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8024);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8051);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8055);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8072);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x80dc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfffd);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfffd);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8301);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x800a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8190);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x82a0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8404);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa70c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x9402);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x890c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8840);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa380);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x066e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xcb91);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4063);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd139);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd140);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd040);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb404);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa610);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa110);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa2a0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa404);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4085);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa180);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa404);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8280);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x405d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa720);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0743);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07f0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f74);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0743);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd702);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7fb6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8190);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x82a0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8404);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8610);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x066e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd158);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd04d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x03d4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x94bc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x870c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8380);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd10d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd040);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07c4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5fb4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa190);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa00a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa280);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa404);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa220);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd130);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd040);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07c4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5fb4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xbb80);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd1c4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd074);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa301);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x604b);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa90c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0556);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xcb92);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4063);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd116);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd119);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd040);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd703);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x60a0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x6241);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x63e2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x6583);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf054);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x611e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x40da);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d10);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf02f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d50);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf02a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x611e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x40da);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d20);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf021);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d60);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf01c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x611e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x40da);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d30);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf013);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d70);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf00e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x611e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x40da);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d40);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf005);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d80);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa610);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x405d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa720);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ff4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa008);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4046);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0743);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07fb);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd703);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7f6f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7f4e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7f2d);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7f0c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x800a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0743);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd702);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7fb5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3ad4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0556);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8610);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x066e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd1f5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xd049);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x01ec);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA10E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x01ea);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA10C);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x06a9);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA10A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x078a);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA108);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x03d2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA106);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x067f);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA104);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0665);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA102);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA100);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xA110);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00fc);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb87c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8530);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb87e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf85);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3caf);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8545);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf85);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x45af);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8545);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xee82);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf900);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0103);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf03);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7f8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xe0a6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00e1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa601);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xef01);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x58f0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa080);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x37a1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8402);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xae16);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa185);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x02ae);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x11a1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8702);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xae0c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xa188);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x02ae);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x07a1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8902);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xae02);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xae1c);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xe0b4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x62e1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb463);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x6901);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xe4b4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x62e5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb463);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xe0b4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x62e1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb463);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x6901);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xe4b4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x62e5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xb463);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xfc04);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb85e);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x03b3);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb860);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb862);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb864);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0xb878);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0001);
+
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xB820, BIT_7);
+
+
+        rtl8125_release_phy_mcu_patch_key_lock(tp);
+}
+
+static void
+rtl8125_set_phy_mcu_8125a_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125a_2(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static const u16 phy_mcu_ram_code_8125b_1[] = {
+        0xa436, 0x8024, 0xa438, 0x3700, 0xa436, 0xB82E, 0xa438, 0x0001,
+        0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x8025, 0xa438, 0x1800, 0xa438, 0x803a,
+        0xa438, 0x1800, 0xa438, 0x8044, 0xa438, 0x1800, 0xa438, 0x8083,
+        0xa438, 0x1800, 0xa438, 0x808d, 0xa438, 0x1800, 0xa438, 0x808d,
+        0xa438, 0x1800, 0xa438, 0x808d, 0xa438, 0xd712, 0xa438, 0x4077,
+        0xa438, 0xd71e, 0xa438, 0x4159, 0xa438, 0xd71e, 0xa438, 0x6099,
+        0xa438, 0x7f44, 0xa438, 0x1800, 0xa438, 0x1a14, 0xa438, 0x9040,
+        0xa438, 0x9201, 0xa438, 0x1800, 0xa438, 0x1b1a, 0xa438, 0xd71e,
+        0xa438, 0x2425, 0xa438, 0x1a14, 0xa438, 0xd71f, 0xa438, 0x3ce5,
+        0xa438, 0x1afb, 0xa438, 0x1800, 0xa438, 0x1b00, 0xa438, 0xd712,
+        0xa438, 0x4077, 0xa438, 0xd71e, 0xa438, 0x4159, 0xa438, 0xd71e,
+        0xa438, 0x60b9, 0xa438, 0x2421, 0xa438, 0x1c17, 0xa438, 0x1800,
+        0xa438, 0x1a14, 0xa438, 0x9040, 0xa438, 0x1800, 0xa438, 0x1c2c,
+        0xa438, 0xd71e, 0xa438, 0x2425, 0xa438, 0x1a14, 0xa438, 0xd71f,
+        0xa438, 0x3ce5, 0xa438, 0x1c0f, 0xa438, 0x1800, 0xa438, 0x1c13,
+        0xa438, 0xd702, 0xa438, 0xd501, 0xa438, 0x6072, 0xa438, 0x8401,
+        0xa438, 0xf002, 0xa438, 0xa401, 0xa438, 0x1000, 0xa438, 0x146e,
+        0xa438, 0x1800, 0xa438, 0x0b77, 0xa438, 0xd703, 0xa438, 0x665d,
+        0xa438, 0x653e, 0xa438, 0x641f, 0xa438, 0xd700, 0xa438, 0x62c4,
+        0xa438, 0x6185, 0xa438, 0x6066, 0xa438, 0x1800, 0xa438, 0x165a,
+        0xa438, 0xc101, 0xa438, 0xcb00, 0xa438, 0x1000, 0xa438, 0x1945,
+        0xa438, 0xd700, 0xa438, 0x7fa6, 0xa438, 0x1800, 0xa438, 0x807d,
+        0xa438, 0xc102, 0xa438, 0xcb00, 0xa438, 0x1000, 0xa438, 0x1945,
+        0xa438, 0xd700, 0xa438, 0x2569, 0xa438, 0x8058, 0xa438, 0x1800,
+        0xa438, 0x807d, 0xa438, 0xc104, 0xa438, 0xcb00, 0xa438, 0x1000,
+        0xa438, 0x1945, 0xa438, 0xd700, 0xa438, 0x7fa4, 0xa438, 0x1800,
+        0xa438, 0x807d, 0xa438, 0xc120, 0xa438, 0xcb00, 0xa438, 0x1000,
+        0xa438, 0x1945, 0xa438, 0xd703, 0xa438, 0x7fbf, 0xa438, 0x1800,
+        0xa438, 0x807d, 0xa438, 0xc140, 0xa438, 0xcb00, 0xa438, 0x1000,
+        0xa438, 0x1945, 0xa438, 0xd703, 0xa438, 0x7fbe, 0xa438, 0x1800,
+        0xa438, 0x807d, 0xa438, 0xc180, 0xa438, 0xcb00, 0xa438, 0x1000,
+        0xa438, 0x1945, 0xa438, 0xd703, 0xa438, 0x7fbd, 0xa438, 0xc100,
+        0xa438, 0xcb00, 0xa438, 0xd708, 0xa438, 0x6018, 0xa438, 0x1800,
+        0xa438, 0x165a, 0xa438, 0x1000, 0xa438, 0x14f6, 0xa438, 0xd014,
+        0xa438, 0xd1e3, 0xa438, 0x1000, 0xa438, 0x1356, 0xa438, 0xd705,
+        0xa438, 0x5fbe, 0xa438, 0x1800, 0xa438, 0x1559, 0xa436, 0xA026,
+        0xa438, 0xffff, 0xa436, 0xA024, 0xa438, 0xffff, 0xa436, 0xA022,
+        0xa438, 0xffff, 0xa436, 0xA020, 0xa438, 0x1557, 0xa436, 0xA006,
+        0xa438, 0x1677, 0xa436, 0xA004, 0xa438, 0x0b75, 0xa436, 0xA002,
+        0xa438, 0x1c17, 0xa436, 0xA000, 0xa438, 0x1b04, 0xa436, 0xA008,
+        0xa438, 0x1f00, 0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x817f, 0xa438, 0x1800, 0xa438, 0x82ab,
+        0xa438, 0x1800, 0xa438, 0x83f8, 0xa438, 0x1800, 0xa438, 0x8444,
+        0xa438, 0x1800, 0xa438, 0x8454, 0xa438, 0x1800, 0xa438, 0x8459,
+        0xa438, 0x1800, 0xa438, 0x8465, 0xa438, 0xcb11, 0xa438, 0xa50c,
+        0xa438, 0x8310, 0xa438, 0xd701, 0xa438, 0x4076, 0xa438, 0x0c03,
+        0xa438, 0x0903, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+        0xa438, 0x0d00, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d00,
+        0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0x1000, 0xa438, 0x0a4d,
+        0xa438, 0xcb12, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x5f84, 0xa438, 0xd102, 0xa438, 0xd040, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xd701,
+        0xa438, 0x60f3, 0xa438, 0xd413, 0xa438, 0x1000, 0xa438, 0x0a37,
+        0xa438, 0xd410, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xcb13,
+        0xa438, 0xa108, 0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8108,
+        0xa438, 0xa00a, 0xa438, 0xa910, 0xa438, 0xa780, 0xa438, 0xd14a,
+        0xa438, 0xd048, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd701,
+        0xa438, 0x6255, 0xa438, 0xd700, 0xa438, 0x5f74, 0xa438, 0x6326,
+        0xa438, 0xd702, 0xa438, 0x5f07, 0xa438, 0x800a, 0xa438, 0xa004,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004, 0xa438, 0xa001,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0x0c03,
+        0xa438, 0x0902, 0xa438, 0xffe2, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x5fab, 0xa438, 0xba08, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f8b, 0xa438, 0x9a08,
+        0xa438, 0x800a, 0xa438, 0xd702, 0xa438, 0x6535, 0xa438, 0xd40d,
+        0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xcb14, 0xa438, 0xa004,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004, 0xa438, 0xa001,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0xa00a,
+        0xa438, 0xa780, 0xa438, 0xd14a, 0xa438, 0xd048, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x6206,
+        0xa438, 0xd702, 0xa438, 0x5f47, 0xa438, 0x800a, 0xa438, 0xa004,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004, 0xa438, 0xa001,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0x0c03,
+        0xa438, 0x0902, 0xa438, 0x1800, 0xa438, 0x8064, 0xa438, 0x800a,
+        0xa438, 0xd40e, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xb920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+        0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x7f8c, 0xa438, 0xd701, 0xa438, 0x6073, 0xa438, 0xd701,
+        0xa438, 0x4216, 0xa438, 0xa004, 0xa438, 0x1000, 0xa438, 0x0a42,
+        0xa438, 0x8004, 0xa438, 0xa001, 0xa438, 0x1000, 0xa438, 0x0a42,
+        0xa438, 0x8001, 0xa438, 0xd120, 0xa438, 0xd040, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x8504,
+        0xa438, 0xcb21, 0xa438, 0xa301, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd700, 0xa438, 0x5f9f, 0xa438, 0x8301, 0xa438, 0xd704,
+        0xa438, 0x40e0, 0xa438, 0xd196, 0xa438, 0xd04d, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xcb22,
+        0xa438, 0x1000, 0xa438, 0x0a6d, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa640, 0xa438, 0x9503, 0xa438, 0x8910, 0xa438, 0x8720,
+        0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d01,
+        0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0x1000,
+        0xa438, 0x0a7d, 0xa438, 0x0c1f, 0xa438, 0x0f14, 0xa438, 0xcb23,
+        0xa438, 0x8fc0, 0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0xaf40,
+        0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0x0cc0, 0xa438, 0x0f80,
+        0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0xafc0, 0xa438, 0x1000,
+        0xa438, 0x0a25, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd701,
+        0xa438, 0x5dee, 0xa438, 0xcb24, 0xa438, 0x8f1f, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd701, 0xa438, 0x7f6e, 0xa438, 0xa111,
+        0xa438, 0xa215, 0xa438, 0xa401, 0xa438, 0x8404, 0xa438, 0xa720,
+        0xa438, 0xcb25, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8640,
+        0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x0b43, 0xa438, 0x1000,
+        0xa438, 0x0b86, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xb920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+        0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x7f8c, 0xa438, 0xcb26, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x5f82, 0xa438, 0x8111, 0xa438, 0x8205,
+        0xa438, 0x8404, 0xa438, 0xcb27, 0xa438, 0xd404, 0xa438, 0x1000,
+        0xa438, 0x0a37, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+        0xa438, 0x0d02, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+        0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0xa710, 0xa438, 0xa104,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8104, 0xa438, 0xa001,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0xa120,
+        0xa438, 0xaa0f, 0xa438, 0x8110, 0xa438, 0xa284, 0xa438, 0xa404,
+        0xa438, 0xa00a, 0xa438, 0xd193, 0xa438, 0xd046, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xcb28,
+        0xa438, 0xa110, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fa8, 0xa438, 0x8110, 0xa438, 0x8284, 0xa438, 0xa404,
+        0xa438, 0x800a, 0xa438, 0x8710, 0xa438, 0xb804, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f82, 0xa438, 0x9804,
+        0xa438, 0xcb29, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x5f85, 0xa438, 0xa710, 0xa438, 0xb820, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f65, 0xa438, 0x9820,
+        0xa438, 0xcb2a, 0xa438, 0xa190, 0xa438, 0xa284, 0xa438, 0xa404,
+        0xa438, 0xa00a, 0xa438, 0xd13d, 0xa438, 0xd04a, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x3444, 0xa438, 0x8149,
+        0xa438, 0xa220, 0xa438, 0xd1a0, 0xa438, 0xd040, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x3444, 0xa438, 0x8151,
+        0xa438, 0xd702, 0xa438, 0x5f51, 0xa438, 0xcb2f, 0xa438, 0xa302,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd708, 0xa438, 0x5f63,
+        0xa438, 0xd411, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0x8302,
+        0xa438, 0xd409, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xb920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+        0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x7f8c, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x5fa3, 0xa438, 0x8190, 0xa438, 0x82a4, 0xa438, 0x8404,
+        0xa438, 0x800a, 0xa438, 0xb808, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x7fa3, 0xa438, 0x9808, 0xa438, 0x1800,
+        0xa438, 0x0433, 0xa438, 0xcb15, 0xa438, 0xa508, 0xa438, 0xd700,
+        0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0xf003,
+        0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0x1000, 0xa438, 0x0a7d,
+        0xa438, 0x1000, 0xa438, 0x0a4d, 0xa438, 0xa301, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5f9f, 0xa438, 0x8301,
+        0xa438, 0xd704, 0xa438, 0x40e0, 0xa438, 0xd115, 0xa438, 0xd04f,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0xd413, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xcb16,
+        0xa438, 0x1000, 0xa438, 0x0a6d, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa640, 0xa438, 0x9503, 0xa438, 0x8720, 0xa438, 0xd17a,
+        0xa438, 0xd04c, 0xa438, 0x0c1f, 0xa438, 0x0f14, 0xa438, 0xcb17,
+        0xa438, 0x8fc0, 0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0xaf40,
+        0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0x0cc0, 0xa438, 0x0f80,
+        0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0xafc0, 0xa438, 0x1000,
+        0xa438, 0x0a25, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd701,
+        0xa438, 0x61ce, 0xa438, 0xd700, 0xa438, 0x5db4, 0xa438, 0xcb18,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8640, 0xa438, 0x9503,
+        0xa438, 0xa720, 0xa438, 0x1000, 0xa438, 0x0b43, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xffd6, 0xa438, 0x8f1f, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd701, 0xa438, 0x7f8e, 0xa438, 0xa131,
+        0xa438, 0xaa0f, 0xa438, 0xa2d5, 0xa438, 0xa407, 0xa438, 0xa720,
+        0xa438, 0x8310, 0xa438, 0xa308, 0xa438, 0x8308, 0xa438, 0xcb19,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8640, 0xa438, 0x9503,
+        0xa438, 0x1000, 0xa438, 0x0b43, 0xa438, 0x1000, 0xa438, 0x0b86,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xb920, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac, 0xa438, 0x9920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f8c,
+        0xa438, 0xcb1a, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x5f82, 0xa438, 0x8111, 0xa438, 0x82c5, 0xa438, 0xa404,
+        0xa438, 0x8402, 0xa438, 0xb804, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x7f82, 0xa438, 0x9804, 0xa438, 0xcb1b,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5f85,
+        0xa438, 0xa710, 0xa438, 0xb820, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x7f65, 0xa438, 0x9820, 0xa438, 0xcb1c,
+        0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+        0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02, 0xa438, 0x1000,
+        0xa438, 0x0a7d, 0xa438, 0xa110, 0xa438, 0xa284, 0xa438, 0xa404,
+        0xa438, 0x8402, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fa8, 0xa438, 0xcb1d, 0xa438, 0xa180, 0xa438, 0xa402,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fa8,
+        0xa438, 0xa220, 0xa438, 0xd1f5, 0xa438, 0xd049, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x3444, 0xa438, 0x8221,
+        0xa438, 0xd702, 0xa438, 0x5f51, 0xa438, 0xb920, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac, 0xa438, 0x9920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f8c,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fa3,
+        0xa438, 0xa504, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+        0xa438, 0x0d00, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d00,
+        0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0xa00a, 0xa438, 0x8190,
+        0xa438, 0x82a4, 0xa438, 0x8402, 0xa438, 0xa404, 0xa438, 0xb808,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7fa3,
+        0xa438, 0x9808, 0xa438, 0xcb2b, 0xa438, 0xcb2c, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5f84, 0xa438, 0xd14a,
+        0xa438, 0xd048, 0xa438, 0xa780, 0xa438, 0xcb2d, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5f94, 0xa438, 0x6208,
+        0xa438, 0xd702, 0xa438, 0x5f27, 0xa438, 0x800a, 0xa438, 0xa004,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004, 0xa438, 0xa001,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0x0c03,
+        0xa438, 0x0902, 0xa438, 0xa00a, 0xa438, 0xffe9, 0xa438, 0xcb2e,
+        0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+        0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02, 0xa438, 0x1000,
+        0xa438, 0x0a7d, 0xa438, 0xa190, 0xa438, 0xa284, 0xa438, 0xa406,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fa8,
+        0xa438, 0xa220, 0xa438, 0xd1a0, 0xa438, 0xd040, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x3444, 0xa438, 0x827d,
+        0xa438, 0xd702, 0xa438, 0x5f51, 0xa438, 0xcb2f, 0xa438, 0xa302,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd708, 0xa438, 0x5f63,
+        0xa438, 0xd411, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0x8302,
+        0xa438, 0xd409, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xb920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+        0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x7f8c, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x5fa3, 0xa438, 0x8190, 0xa438, 0x82a4, 0xa438, 0x8406,
+        0xa438, 0x800a, 0xa438, 0xb808, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x7fa3, 0xa438, 0x9808, 0xa438, 0x1800,
+        0xa438, 0x0433, 0xa438, 0xcb30, 0xa438, 0x8380, 0xa438, 0xcb31,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5f86,
+        0xa438, 0x9308, 0xa438, 0xb204, 0xa438, 0xb301, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd701, 0xa438, 0x5fa2, 0xa438, 0xb302,
+        0xa438, 0x9204, 0xa438, 0xcb32, 0xa438, 0xd408, 0xa438, 0x1000,
+        0xa438, 0x0a37, 0xa438, 0xd141, 0xa438, 0xd043, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xd704,
+        0xa438, 0x4ccc, 0xa438, 0xd700, 0xa438, 0x4c81, 0xa438, 0xd702,
+        0xa438, 0x609e, 0xa438, 0xd1e5, 0xa438, 0xd04d, 0xa438, 0xf003,
+        0xa438, 0xd1e5, 0xa438, 0xd04d, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xd700, 0xa438, 0x6083,
+        0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0xf003, 0xa438, 0x0c1f,
+        0xa438, 0x0d01, 0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0x8710,
+        0xa438, 0xa108, 0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8108,
+        0xa438, 0xa203, 0xa438, 0x8120, 0xa438, 0x8a0f, 0xa438, 0xa111,
+        0xa438, 0x8204, 0xa438, 0xa140, 0xa438, 0x1000, 0xa438, 0x0a42,
+        0xa438, 0x8140, 0xa438, 0xd17a, 0xa438, 0xd04b, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xa204,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fa7,
+        0xa438, 0xb920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x5fac, 0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x7f8c, 0xa438, 0xd404, 0xa438, 0x1000,
+        0xa438, 0x0a37, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+        0xa438, 0x0d02, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+        0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0xa710, 0xa438, 0x8101,
+        0xa438, 0x8201, 0xa438, 0xa104, 0xa438, 0x1000, 0xa438, 0x0a42,
+        0xa438, 0x8104, 0xa438, 0xa120, 0xa438, 0xaa0f, 0xa438, 0x8110,
+        0xa438, 0xa284, 0xa438, 0xa404, 0xa438, 0xa00a, 0xa438, 0xd193,
+        0xa438, 0xd047, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0xa110, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd700, 0xa438, 0x5fa8, 0xa438, 0xa180, 0xa438, 0xd13d,
+        0xa438, 0xd04a, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0xf024, 0xa438, 0xa710, 0xa438, 0xa00a,
+        0xa438, 0x8190, 0xa438, 0x8204, 0xa438, 0xa280, 0xa438, 0xa404,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fa7,
+        0xa438, 0x8710, 0xa438, 0xb920, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x5fac, 0xa438, 0x9920, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f8c, 0xa438, 0x800a,
+        0xa438, 0x8190, 0xa438, 0x8284, 0xa438, 0x8406, 0xa438, 0xd700,
+        0xa438, 0x4121, 0xa438, 0xd701, 0xa438, 0x60f3, 0xa438, 0xd1e5,
+        0xa438, 0xd04d, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0x8710, 0xa438, 0xa00a, 0xa438, 0x8190,
+        0xa438, 0x8204, 0xa438, 0xa280, 0xa438, 0xa404, 0xa438, 0xb920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+        0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x7f8c, 0xa438, 0xcb33, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x5f85, 0xa438, 0xa710, 0xa438, 0xb820,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f65,
+        0xa438, 0x9820, 0xa438, 0xcb34, 0xa438, 0xa00a, 0xa438, 0xa190,
+        0xa438, 0xa284, 0xa438, 0xa404, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd700, 0xa438, 0x5fa9, 0xa438, 0xd701, 0xa438, 0x6853,
+        0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d00,
+        0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d00, 0xa438, 0x1000,
+        0xa438, 0x0a7d, 0xa438, 0x8190, 0xa438, 0x8284, 0xa438, 0xcb35,
+        0xa438, 0xd407, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0x8110,
+        0xa438, 0x8204, 0xa438, 0xa280, 0xa438, 0xa00a, 0xa438, 0xd704,
+        0xa438, 0x4215, 0xa438, 0xa304, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd700, 0xa438, 0x5fb8, 0xa438, 0xd1c3, 0xa438, 0xd043,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0x8304, 0xa438, 0xd700, 0xa438, 0x4109, 0xa438, 0xf01e,
+        0xa438, 0xcb36, 0xa438, 0xd412, 0xa438, 0x1000, 0xa438, 0x0a37,
+        0xa438, 0xd700, 0xa438, 0x6309, 0xa438, 0xd702, 0xa438, 0x42c7,
+        0xa438, 0x800a, 0xa438, 0x8180, 0xa438, 0x8280, 0xa438, 0x8404,
+        0xa438, 0xa004, 0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004,
+        0xa438, 0xa001, 0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001,
+        0xa438, 0x0c03, 0xa438, 0x0902, 0xa438, 0xa00a, 0xa438, 0xd14a,
+        0xa438, 0xd048, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+        0xa438, 0x0d02, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+        0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0xcc55, 0xa438, 0xcb37,
+        0xa438, 0xa00a, 0xa438, 0xa190, 0xa438, 0xa2a4, 0xa438, 0xa404,
+        0xa438, 0xd700, 0xa438, 0x6041, 0xa438, 0xa402, 0xa438, 0xd13d,
+        0xa438, 0xd04a, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fa9, 0xa438, 0xd702, 0xa438, 0x5f71, 0xa438, 0xcb38,
+        0xa438, 0x8224, 0xa438, 0xa288, 0xa438, 0x8180, 0xa438, 0xa110,
+        0xa438, 0xa404, 0xa438, 0x800a, 0xa438, 0xd700, 0xa438, 0x6041,
+        0xa438, 0x8402, 0xa438, 0xd415, 0xa438, 0x1000, 0xa438, 0x0a37,
+        0xa438, 0xd13d, 0xa438, 0xd04a, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xcb39, 0xa438, 0xa00a,
+        0xa438, 0xa190, 0xa438, 0xa2a0, 0xa438, 0xa404, 0xa438, 0xd700,
+        0xa438, 0x6041, 0xa438, 0xa402, 0xa438, 0xd17a, 0xa438, 0xd047,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0x1800, 0xa438, 0x0560, 0xa438, 0xa111, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0xd3f5,
+        0xa438, 0xd219, 0xa438, 0x1000, 0xa438, 0x0c31, 0xa438, 0xd708,
+        0xa438, 0x5fa5, 0xa438, 0xa215, 0xa438, 0xd30e, 0xa438, 0xd21a,
+        0xa438, 0x1000, 0xa438, 0x0c31, 0xa438, 0xd708, 0xa438, 0x63e9,
+        0xa438, 0xd708, 0xa438, 0x5f65, 0xa438, 0xd708, 0xa438, 0x7f36,
+        0xa438, 0xa004, 0xa438, 0x1000, 0xa438, 0x0c35, 0xa438, 0x8004,
+        0xa438, 0xa001, 0xa438, 0x1000, 0xa438, 0x0c35, 0xa438, 0x8001,
+        0xa438, 0xd708, 0xa438, 0x4098, 0xa438, 0xd102, 0xa438, 0x9401,
+        0xa438, 0xf003, 0xa438, 0xd103, 0xa438, 0xb401, 0xa438, 0x1000,
+        0xa438, 0x0c27, 0xa438, 0xa108, 0xa438, 0x1000, 0xa438, 0x0c35,
+        0xa438, 0x8108, 0xa438, 0x8110, 0xa438, 0x8294, 0xa438, 0xa202,
+        0xa438, 0x1800, 0xa438, 0x0bdb, 0xa438, 0xd39c, 0xa438, 0xd210,
+        0xa438, 0x1000, 0xa438, 0x0c31, 0xa438, 0xd708, 0xa438, 0x5fa5,
+        0xa438, 0xd39c, 0xa438, 0xd210, 0xa438, 0x1000, 0xa438, 0x0c31,
+        0xa438, 0xd708, 0xa438, 0x5fa5, 0xa438, 0x1000, 0xa438, 0x0c31,
+        0xa438, 0xd708, 0xa438, 0x29b5, 0xa438, 0x840e, 0xa438, 0xd708,
+        0xa438, 0x5f4a, 0xa438, 0x0c1f, 0xa438, 0x1014, 0xa438, 0x1000,
+        0xa438, 0x0c31, 0xa438, 0xd709, 0xa438, 0x7fa4, 0xa438, 0x901f,
+        0xa438, 0x1800, 0xa438, 0x0c23, 0xa438, 0xcb43, 0xa438, 0xa508,
+        0xa438, 0xd701, 0xa438, 0x3699, 0xa438, 0x844a, 0xa438, 0xa504,
+        0xa438, 0xa190, 0xa438, 0xa2a0, 0xa438, 0xa404, 0xa438, 0xa00a,
+        0xa438, 0xd700, 0xa438, 0x2109, 0xa438, 0x05ea, 0xa438, 0xa402,
+        0xa438, 0x1800, 0xa438, 0x05ea, 0xa438, 0xcb90, 0xa438, 0x0cf0,
+        0xa438, 0x0ca0, 0xa438, 0x1800, 0xa438, 0x06db, 0xa438, 0xd1ff,
+        0xa438, 0xd052, 0xa438, 0xa508, 0xa438, 0x8718, 0xa438, 0xa00a,
+        0xa438, 0xa190, 0xa438, 0xa2a0, 0xa438, 0xa404, 0xa438, 0x0cf0,
+        0xa438, 0x0c50, 0xa438, 0x1800, 0xa438, 0x09ef, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd704, 0xa438, 0x2e70, 0xa438, 0x06da,
+        0xa438, 0xd700, 0xa438, 0x5f55, 0xa438, 0xa90c, 0xa438, 0x1800,
+        0xa438, 0x0645, 0xa436, 0xA10E, 0xa438, 0x0644, 0xa436, 0xA10C,
+        0xa438, 0x09e9, 0xa436, 0xA10A, 0xa438, 0x06da, 0xa436, 0xA108,
+        0xa438, 0x05e1, 0xa436, 0xA106, 0xa438, 0x0be4, 0xa436, 0xA104,
+        0xa438, 0x0435, 0xa436, 0xA102, 0xa438, 0x0141, 0xa436, 0xA100,
+        0xa438, 0x026d, 0xa436, 0xA110, 0xa438, 0x00ff, 0xa436, 0xb87c,
+        0xa438, 0x85fe, 0xa436, 0xb87e, 0xa438, 0xaf86, 0xa438, 0x16af,
+        0xa438, 0x8699, 0xa438, 0xaf86, 0xa438, 0xe5af, 0xa438, 0x86f9,
+        0xa438, 0xaf87, 0xa438, 0x7aaf, 0xa438, 0x883a, 0xa438, 0xaf88,
+        0xa438, 0x58af, 0xa438, 0x8b6c, 0xa438, 0xd48b, 0xa438, 0x7c02,
+        0xa438, 0x8644, 0xa438, 0x2c00, 0xa438, 0x503c, 0xa438, 0xffd6,
+        0xa438, 0xac27, 0xa438, 0x18e1, 0xa438, 0x82fe, 0xa438, 0xad28,
+        0xa438, 0x0cd4, 0xa438, 0x8b84, 0xa438, 0x0286, 0xa438, 0x442c,
+        0xa438, 0x003c, 0xa438, 0xac27, 0xa438, 0x06ee, 0xa438, 0x8299,
+        0xa438, 0x01ae, 0xa438, 0x04ee, 0xa438, 0x8299, 0xa438, 0x00af,
+        0xa438, 0x23dc, 0xa438, 0xf9fa, 0xa438, 0xcefa, 0xa438, 0xfbef,
+        0xa438, 0x79fb, 0xa438, 0xc4bf, 0xa438, 0x8b76, 0xa438, 0x026c,
+        0xa438, 0x6dac, 0xa438, 0x2804, 0xa438, 0xd203, 0xa438, 0xae02,
+        0xa438, 0xd201, 0xa438, 0xbdd8, 0xa438, 0x19d9, 0xa438, 0xef94,
+        0xa438, 0x026c, 0xa438, 0x6d78, 0xa438, 0x03ef, 0xa438, 0x648a,
+        0xa438, 0x0002, 0xa438, 0xbdd8, 0xa438, 0x19d9, 0xa438, 0xef94,
+        0xa438, 0x026c, 0xa438, 0x6d78, 0xa438, 0x03ef, 0xa438, 0x7402,
+        0xa438, 0x72cd, 0xa438, 0xac50, 0xa438, 0x02ef, 0xa438, 0x643a,
+        0xa438, 0x019f, 0xa438, 0xe4ef, 0xa438, 0x4678, 0xa438, 0x03ac,
+        0xa438, 0x2002, 0xa438, 0xae02, 0xa438, 0xd0ff, 0xa438, 0xffef,
+        0xa438, 0x97ff, 0xa438, 0xfec6, 0xa438, 0xfefd, 0xa438, 0x041f,
+        0xa438, 0x771f, 0xa438, 0x221c, 0xa438, 0x450d, 0xa438, 0x481f,
+        0xa438, 0x00ac, 0xa438, 0x7f04, 0xa438, 0x1a94, 0xa438, 0xae08,
+        0xa438, 0x1a94, 0xa438, 0xac7f, 0xa438, 0x03d7, 0xa438, 0x0100,
+        0xa438, 0xef46, 0xa438, 0x0d48, 0xa438, 0x1f00, 0xa438, 0x1c45,
+        0xa438, 0xef69, 0xa438, 0xef57, 0xa438, 0xef74, 0xa438, 0x0272,
+        0xa438, 0xe8a7, 0xa438, 0xffff, 0xa438, 0x0d1a, 0xa438, 0x941b,
+        0xa438, 0x979e, 0xa438, 0x072d, 0xa438, 0x0100, 0xa438, 0x1a64,
+        0xa438, 0xef76, 0xa438, 0xef97, 0xa438, 0x0d98, 0xa438, 0xd400,
+        0xa438, 0xff1d, 0xa438, 0x941a, 0xa438, 0x89cf, 0xa438, 0x1a75,
+        0xa438, 0xaf74, 0xa438, 0xf9bf, 0xa438, 0x8b79, 0xa438, 0x026c,
+        0xa438, 0x6da1, 0xa438, 0x0005, 0xa438, 0xe180, 0xa438, 0xa0ae,
+        0xa438, 0x03e1, 0xa438, 0x80a1, 0xa438, 0xaf26, 0xa438, 0x9aac,
+        0xa438, 0x284d, 0xa438, 0xe08f, 0xa438, 0xffef, 0xa438, 0x10c0,
+        0xa438, 0xe08f, 0xa438, 0xfe10, 0xa438, 0x1b08, 0xa438, 0xa000,
+        0xa438, 0x04c8, 0xa438, 0xaf40, 0xa438, 0x67c8, 0xa438, 0xbf8b,
+        0xa438, 0x8c02, 0xa438, 0x6c4e, 0xa438, 0xc4bf, 0xa438, 0x8b8f,
+        0xa438, 0x026c, 0xa438, 0x6def, 0xa438, 0x74e0, 0xa438, 0x830c,
+        0xa438, 0xad20, 0xa438, 0x0302, 0xa438, 0x74ac, 0xa438, 0xccef,
+        0xa438, 0x971b, 0xa438, 0x76ad, 0xa438, 0x5f02, 0xa438, 0xae13,
+        0xa438, 0xef69, 0xa438, 0xef30, 0xa438, 0x1b32, 0xa438, 0xc4ef,
+        0xa438, 0x46e4, 0xa438, 0x8ffb, 0xa438, 0xe58f, 0xa438, 0xfce7,
+        0xa438, 0x8ffd, 0xa438, 0xcc10, 0xa438, 0x11ae, 0xa438, 0xb8d1,
+        0xa438, 0x00a1, 0xa438, 0x1f03, 0xa438, 0xaf40, 0xa438, 0x4fbf,
+        0xa438, 0x8b8c, 0xa438, 0x026c, 0xa438, 0x4ec4, 0xa438, 0xbf8b,
+        0xa438, 0x8f02, 0xa438, 0x6c6d, 0xa438, 0xef74, 0xa438, 0xe083,
+        0xa438, 0x0cad, 0xa438, 0x2003, 0xa438, 0x0274, 0xa438, 0xaccc,
+        0xa438, 0xef97, 0xa438, 0x1b76, 0xa438, 0xad5f, 0xa438, 0x02ae,
+        0xa438, 0x04ef, 0xa438, 0x69ef, 0xa438, 0x3111, 0xa438, 0xaed1,
+        0xa438, 0x0287, 0xa438, 0x80af, 0xa438, 0x2293, 0xa438, 0xf8f9,
+        0xa438, 0xfafb, 0xa438, 0xef59, 0xa438, 0xe080, 0xa438, 0x13ad,
+        0xa438, 0x252f, 0xa438, 0xbf88, 0xa438, 0x2802, 0xa438, 0x6c6d,
+        0xa438, 0xef64, 0xa438, 0x1f44, 0xa438, 0xe18f, 0xa438, 0xb91b,
+        0xa438, 0x64ad, 0xa438, 0x4f1d, 0xa438, 0xd688, 0xa438, 0x2bd7,
+        0xa438, 0x882e, 0xa438, 0x0274, 0xa438, 0x73ad, 0xa438, 0x5008,
+        0xa438, 0xbf88, 0xa438, 0x3102, 0xa438, 0x737c, 0xa438, 0xae03,
+        0xa438, 0x0287, 0xa438, 0xd0bf, 0xa438, 0x882b, 0xa438, 0x0273,
+        0xa438, 0x73e0, 0xa438, 0x824c, 0xa438, 0xf621, 0xa438, 0xe482,
+        0xa438, 0x4cbf, 0xa438, 0x8834, 0xa438, 0x0273, 0xa438, 0x7cef,
+        0xa438, 0x95ff, 0xa438, 0xfefd, 0xa438, 0xfc04, 0xa438, 0xf8f9,
+        0xa438, 0xfafb, 0xa438, 0xef79, 0xa438, 0xbf88, 0xa438, 0x1f02,
+        0xa438, 0x737c, 0xa438, 0x1f22, 0xa438, 0xac32, 0xa438, 0x31ef,
+        0xa438, 0x12bf, 0xa438, 0x8822, 0xa438, 0x026c, 0xa438, 0x4ed6,
+        0xa438, 0x8fba, 0xa438, 0x1f33, 0xa438, 0xac3c, 0xa438, 0x1eef,
+        0xa438, 0x13bf, 0xa438, 0x8837, 0xa438, 0x026c, 0xa438, 0x4eef,
+        0xa438, 0x96d8, 0xa438, 0x19d9, 0xa438, 0xbf88, 0xa438, 0x2502,
+        0xa438, 0x6c4e, 0xa438, 0xbf88, 0xa438, 0x2502, 0xa438, 0x6c4e,
+        0xa438, 0x1616, 0xa438, 0x13ae, 0xa438, 0xdf12, 0xa438, 0xaecc,
+        0xa438, 0xbf88, 0xa438, 0x1f02, 0xa438, 0x7373, 0xa438, 0xef97,
+        0xa438, 0xfffe, 0xa438, 0xfdfc, 0xa438, 0x0466, 0xa438, 0xac88,
+        0xa438, 0x54ac, 0xa438, 0x88f0, 0xa438, 0xac8a, 0xa438, 0x92ac,
+        0xa438, 0xbadd, 0xa438, 0xac6c, 0xa438, 0xeeac, 0xa438, 0x6cff,
+        0xa438, 0xad02, 0xa438, 0x99ac, 0xa438, 0x0030, 0xa438, 0xac88,
+        0xa438, 0xd4c3, 0xa438, 0x5000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x00b4, 0xa438, 0xecee,
+        0xa438, 0x8298, 0xa438, 0x00af, 0xa438, 0x1412, 0xa438, 0xf8bf,
+        0xa438, 0x8b5d, 0xa438, 0x026c, 0xa438, 0x6d58, 0xa438, 0x03e1,
+        0xa438, 0x8fb8, 0xa438, 0x2901, 0xa438, 0xe58f, 0xa438, 0xb8a0,
+        0xa438, 0x0049, 0xa438, 0xef47, 0xa438, 0xe483, 0xa438, 0x02e5,
+        0xa438, 0x8303, 0xa438, 0xbfc2, 0xa438, 0x5f1a, 0xa438, 0x95f7,
+        0xa438, 0x05ee, 0xa438, 0xffd2, 0xa438, 0x00d8, 0xa438, 0xf605,
+        0xa438, 0x1f11, 0xa438, 0xef60, 0xa438, 0xbf8b, 0xa438, 0x3002,
+        0xa438, 0x6c4e, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c6d,
+        0xa438, 0xf728, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c4e,
+        0xa438, 0xf628, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c4e,
+        0xa438, 0x0c64, 0xa438, 0xef46, 0xa438, 0xbf8b, 0xa438, 0x6002,
+        0xa438, 0x6c4e, 0xa438, 0x0289, 0xa438, 0x9902, 0xa438, 0x3920,
+        0xa438, 0xaf89, 0xa438, 0x96a0, 0xa438, 0x0149, 0xa438, 0xef47,
+        0xa438, 0xe483, 0xa438, 0x04e5, 0xa438, 0x8305, 0xa438, 0xbfc2,
+        0xa438, 0x5f1a, 0xa438, 0x95f7, 0xa438, 0x05ee, 0xa438, 0xffd2,
+        0xa438, 0x00d8, 0xa438, 0xf605, 0xa438, 0x1f11, 0xa438, 0xef60,
+        0xa438, 0xbf8b, 0xa438, 0x3002, 0xa438, 0x6c4e, 0xa438, 0xbf8b,
+        0xa438, 0x3302, 0xa438, 0x6c6d, 0xa438, 0xf729, 0xa438, 0xbf8b,
+        0xa438, 0x3302, 0xa438, 0x6c4e, 0xa438, 0xf629, 0xa438, 0xbf8b,
+        0xa438, 0x3302, 0xa438, 0x6c4e, 0xa438, 0x0c64, 0xa438, 0xef46,
+        0xa438, 0xbf8b, 0xa438, 0x6302, 0xa438, 0x6c4e, 0xa438, 0x0289,
+        0xa438, 0x9902, 0xa438, 0x3920, 0xa438, 0xaf89, 0xa438, 0x96a0,
+        0xa438, 0x0249, 0xa438, 0xef47, 0xa438, 0xe483, 0xa438, 0x06e5,
+        0xa438, 0x8307, 0xa438, 0xbfc2, 0xa438, 0x5f1a, 0xa438, 0x95f7,
+        0xa438, 0x05ee, 0xa438, 0xffd2, 0xa438, 0x00d8, 0xa438, 0xf605,
+        0xa438, 0x1f11, 0xa438, 0xef60, 0xa438, 0xbf8b, 0xa438, 0x3002,
+        0xa438, 0x6c4e, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c6d,
+        0xa438, 0xf72a, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c4e,
+        0xa438, 0xf62a, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c4e,
+        0xa438, 0x0c64, 0xa438, 0xef46, 0xa438, 0xbf8b, 0xa438, 0x6602,
+        0xa438, 0x6c4e, 0xa438, 0x0289, 0xa438, 0x9902, 0xa438, 0x3920,
+        0xa438, 0xaf89, 0xa438, 0x96ef, 0xa438, 0x47e4, 0xa438, 0x8308,
+        0xa438, 0xe583, 0xa438, 0x09bf, 0xa438, 0xc25f, 0xa438, 0x1a95,
+        0xa438, 0xf705, 0xa438, 0xeeff, 0xa438, 0xd200, 0xa438, 0xd8f6,
+        0xa438, 0x051f, 0xa438, 0x11ef, 0xa438, 0x60bf, 0xa438, 0x8b30,
+        0xa438, 0x026c, 0xa438, 0x4ebf, 0xa438, 0x8b33, 0xa438, 0x026c,
+        0xa438, 0x6df7, 0xa438, 0x2bbf, 0xa438, 0x8b33, 0xa438, 0x026c,
+        0xa438, 0x4ef6, 0xa438, 0x2bbf, 0xa438, 0x8b33, 0xa438, 0x026c,
+        0xa438, 0x4e0c, 0xa438, 0x64ef, 0xa438, 0x46bf, 0xa438, 0x8b69,
+        0xa438, 0x026c, 0xa438, 0x4e02, 0xa438, 0x8999, 0xa438, 0x0239,
+        0xa438, 0x20af, 0xa438, 0x8996, 0xa438, 0xaf39, 0xa438, 0x1ef8,
+        0xa438, 0xf9fa, 0xa438, 0xe08f, 0xa438, 0xb838, 0xa438, 0x02ad,
+        0xa438, 0x2702, 0xa438, 0xae03, 0xa438, 0xaf8b, 0xa438, 0x201f,
+        0xa438, 0x66ef, 0xa438, 0x65bf, 0xa438, 0xc21f, 0xa438, 0x1a96,
+        0xa438, 0xf705, 0xa438, 0xeeff, 0xa438, 0xd200, 0xa438, 0xdaf6,
+        0xa438, 0x05bf, 0xa438, 0xc22f, 0xa438, 0x1a96, 0xa438, 0xf705,
+        0xa438, 0xeeff, 0xa438, 0xd200, 0xa438, 0xdbf6, 0xa438, 0x05ef,
+        0xa438, 0x021f, 0xa438, 0x110d, 0xa438, 0x42bf, 0xa438, 0x8b3c,
+        0xa438, 0x026c, 0xa438, 0x4eef, 0xa438, 0x021b, 0xa438, 0x031f,
+        0xa438, 0x110d, 0xa438, 0x42bf, 0xa438, 0x8b36, 0xa438, 0x026c,
+        0xa438, 0x4eef, 0xa438, 0x021a, 0xa438, 0x031f, 0xa438, 0x110d,
+        0xa438, 0x42bf, 0xa438, 0x8b39, 0xa438, 0x026c, 0xa438, 0x4ebf,
+        0xa438, 0xc23f, 0xa438, 0x1a96, 0xa438, 0xf705, 0xa438, 0xeeff,
+        0xa438, 0xd200, 0xa438, 0xdaf6, 0xa438, 0x05bf, 0xa438, 0xc24f,
+        0xa438, 0x1a96, 0xa438, 0xf705, 0xa438, 0xeeff, 0xa438, 0xd200,
+        0xa438, 0xdbf6, 0xa438, 0x05ef, 0xa438, 0x021f, 0xa438, 0x110d,
+        0xa438, 0x42bf, 0xa438, 0x8b45, 0xa438, 0x026c, 0xa438, 0x4eef,
+        0xa438, 0x021b, 0xa438, 0x031f, 0xa438, 0x110d, 0xa438, 0x42bf,
+        0xa438, 0x8b3f, 0xa438, 0x026c, 0xa438, 0x4eef, 0xa438, 0x021a,
+        0xa438, 0x031f, 0xa438, 0x110d, 0xa438, 0x42bf, 0xa438, 0x8b42,
+        0xa438, 0x026c, 0xa438, 0x4eef, 0xa438, 0x56d0, 0xa438, 0x201f,
+        0xa438, 0x11bf, 0xa438, 0x8b4e, 0xa438, 0x026c, 0xa438, 0x4ebf,
+        0xa438, 0x8b48, 0xa438, 0x026c, 0xa438, 0x4ebf, 0xa438, 0x8b4b,
+        0xa438, 0x026c, 0xa438, 0x4ee1, 0xa438, 0x8578, 0xa438, 0xef03,
+        0xa438, 0x480a, 0xa438, 0x2805, 0xa438, 0xef20, 0xa438, 0x1b01,
+        0xa438, 0xad27, 0xa438, 0x3f1f, 0xa438, 0x44e0, 0xa438, 0x8560,
+        0xa438, 0xe185, 0xa438, 0x61bf, 0xa438, 0x8b51, 0xa438, 0x026c,
+        0xa438, 0x4ee0, 0xa438, 0x8566, 0xa438, 0xe185, 0xa438, 0x67bf,
+        0xa438, 0x8b54, 0xa438, 0x026c, 0xa438, 0x4ee0, 0xa438, 0x856c,
+        0xa438, 0xe185, 0xa438, 0x6dbf, 0xa438, 0x8b57, 0xa438, 0x026c,
+        0xa438, 0x4ee0, 0xa438, 0x8572, 0xa438, 0xe185, 0xa438, 0x73bf,
+        0xa438, 0x8b5a, 0xa438, 0x026c, 0xa438, 0x4ee1, 0xa438, 0x8fb8,
+        0xa438, 0x5900, 0xa438, 0xf728, 0xa438, 0xe58f, 0xa438, 0xb8af,
+        0xa438, 0x8b2c, 0xa438, 0xe185, 0xa438, 0x791b, 0xa438, 0x21ad,
+        0xa438, 0x373e, 0xa438, 0x1f44, 0xa438, 0xe085, 0xa438, 0x62e1,
+        0xa438, 0x8563, 0xa438, 0xbf8b, 0xa438, 0x5102, 0xa438, 0x6c4e,
+        0xa438, 0xe085, 0xa438, 0x68e1, 0xa438, 0x8569, 0xa438, 0xbf8b,
+        0xa438, 0x5402, 0xa438, 0x6c4e, 0xa438, 0xe085, 0xa438, 0x6ee1,
+        0xa438, 0x856f, 0xa438, 0xbf8b, 0xa438, 0x5702, 0xa438, 0x6c4e,
+        0xa438, 0xe085, 0xa438, 0x74e1, 0xa438, 0x8575, 0xa438, 0xbf8b,
+        0xa438, 0x5a02, 0xa438, 0x6c4e, 0xa438, 0xe18f, 0xa438, 0xb859,
+        0xa438, 0x00f7, 0xa438, 0x28e5, 0xa438, 0x8fb8, 0xa438, 0xae4a,
+        0xa438, 0x1f44, 0xa438, 0xe085, 0xa438, 0x64e1, 0xa438, 0x8565,
+        0xa438, 0xbf8b, 0xa438, 0x5102, 0xa438, 0x6c4e, 0xa438, 0xe085,
+        0xa438, 0x6ae1, 0xa438, 0x856b, 0xa438, 0xbf8b, 0xa438, 0x5402,
+        0xa438, 0x6c4e, 0xa438, 0xe085, 0xa438, 0x70e1, 0xa438, 0x8571,
+        0xa438, 0xbf8b, 0xa438, 0x5702, 0xa438, 0x6c4e, 0xa438, 0xe085,
+        0xa438, 0x76e1, 0xa438, 0x8577, 0xa438, 0xbf8b, 0xa438, 0x5a02,
+        0xa438, 0x6c4e, 0xa438, 0xe18f, 0xa438, 0xb859, 0xa438, 0x00f7,
+        0xa438, 0x28e5, 0xa438, 0x8fb8, 0xa438, 0xae0c, 0xa438, 0xe18f,
+        0xa438, 0xb839, 0xa438, 0x04ac, 0xa438, 0x2f04, 0xa438, 0xee8f,
+        0xa438, 0xb800, 0xa438, 0xfefd, 0xa438, 0xfc04, 0xa438, 0xf0ac,
+        0xa438, 0x8efc, 0xa438, 0xac8c, 0xa438, 0xf0ac, 0xa438, 0xfaf0,
+        0xa438, 0xacf8, 0xa438, 0xf0ac, 0xa438, 0xf6f0, 0xa438, 0xad00,
+        0xa438, 0xf0ac, 0xa438, 0xfef0, 0xa438, 0xacfc, 0xa438, 0xf0ac,
+        0xa438, 0xf4f0, 0xa438, 0xacf2, 0xa438, 0xf0ac, 0xa438, 0xf0f0,
+        0xa438, 0xacb0, 0xa438, 0xf0ac, 0xa438, 0xaef0, 0xa438, 0xacac,
+        0xa438, 0xf0ac, 0xa438, 0xaaf0, 0xa438, 0xacee, 0xa438, 0xf0b0,
+        0xa438, 0x24f0, 0xa438, 0xb0a4, 0xa438, 0xf0b1, 0xa438, 0x24f0,
+        0xa438, 0xb1a4, 0xa438, 0xee8f, 0xa438, 0xb800, 0xa438, 0xd400,
+        0xa438, 0x00af, 0xa438, 0x3976, 0xa438, 0x66ac, 0xa438, 0xeabb,
+        0xa438, 0xa430, 0xa438, 0x6e50, 0xa438, 0x6e53, 0xa438, 0x6e56,
+        0xa438, 0x6e59, 0xa438, 0x6e5c, 0xa438, 0x6e5f, 0xa438, 0x6e62,
+        0xa438, 0x6e65, 0xa438, 0xd9ac, 0xa438, 0x70f0, 0xa438, 0xac6a,
+        0xa436, 0xb85e, 0xa438, 0x23b7, 0xa436, 0xb860, 0xa438, 0x74db,
+        0xa436, 0xb862, 0xa438, 0x268c, 0xa436, 0xb864, 0xa438, 0x3FE5,
+        0xa436, 0xb886, 0xa438, 0x2250, 0xa436, 0xb888, 0xa438, 0x140e,
+        0xa436, 0xb88a, 0xa438, 0x3696, 0xa436, 0xb88c, 0xa438, 0x3973,
+        0xa436, 0xb838, 0xa438, 0x00ff, 0xb820, 0x0010, 0xa436, 0x8464,
+        0xa438, 0xaf84, 0xa438, 0x7caf, 0xa438, 0x8485, 0xa438, 0xaf85,
+        0xa438, 0x13af, 0xa438, 0x851e, 0xa438, 0xaf85, 0xa438, 0xb9af,
+        0xa438, 0x8684, 0xa438, 0xaf87, 0xa438, 0x01af, 0xa438, 0x8701,
+        0xa438, 0xac38, 0xa438, 0x03af, 0xa438, 0x38bb, 0xa438, 0xaf38,
+        0xa438, 0xc302, 0xa438, 0x4618, 0xa438, 0xbf85, 0xa438, 0x0a02,
+        0xa438, 0x54b7, 0xa438, 0xbf85, 0xa438, 0x1002, 0xa438, 0x54c0,
+        0xa438, 0xd400, 0xa438, 0x0fbf, 0xa438, 0x8507, 0xa438, 0x024f,
+        0xa438, 0x48bf, 0xa438, 0x8504, 0xa438, 0x024f, 0xa438, 0x6759,
+        0xa438, 0xf0a1, 0xa438, 0x3008, 0xa438, 0xbf85, 0xa438, 0x0d02,
+        0xa438, 0x54c0, 0xa438, 0xae06, 0xa438, 0xbf85, 0xa438, 0x0d02,
+        0xa438, 0x54b7, 0xa438, 0xbf85, 0xa438, 0x0402, 0xa438, 0x4f67,
+        0xa438, 0xa183, 0xa438, 0x02ae, 0xa438, 0x15a1, 0xa438, 0x8502,
+        0xa438, 0xae10, 0xa438, 0x59f0, 0xa438, 0xa180, 0xa438, 0x16bf,
+        0xa438, 0x8501, 0xa438, 0x024f, 0xa438, 0x67a1, 0xa438, 0x381b,
+        0xa438, 0xae0b, 0xa438, 0xe18f, 0xa438, 0xffbf, 0xa438, 0x84fe,
+        0xa438, 0x024f, 0xa438, 0x48ae, 0xa438, 0x17bf, 0xa438, 0x84fe,
+        0xa438, 0x0254, 0xa438, 0xb7bf, 0xa438, 0x84fb, 0xa438, 0x0254,
+        0xa438, 0xb7ae, 0xa438, 0x09a1, 0xa438, 0x5006, 0xa438, 0xbf84,
+        0xa438, 0xfb02, 0xa438, 0x54c0, 0xa438, 0xaf04, 0xa438, 0x4700,
+        0xa438, 0xad34, 0xa438, 0xfdad, 0xa438, 0x0670, 0xa438, 0xae14,
+        0xa438, 0xf0a6, 0xa438, 0x00b8, 0xa438, 0xbd32, 0xa438, 0x30bd,
+        0xa438, 0x30aa, 0xa438, 0xbd2c, 0xa438, 0xccbd, 0xa438, 0x2ca1,
+        0xa438, 0x0705, 0xa438, 0xec80, 0xa438, 0xaf40, 0xa438, 0xf7af,
+        0xa438, 0x40f5, 0xa438, 0xd101, 0xa438, 0xbf85, 0xa438, 0xa402,
+        0xa438, 0x4f48, 0xa438, 0xbf85, 0xa438, 0xa702, 0xa438, 0x54c0,
+        0xa438, 0xd10f, 0xa438, 0xbf85, 0xa438, 0xaa02, 0xa438, 0x4f48,
+        0xa438, 0x024d, 0xa438, 0x6abf, 0xa438, 0x85ad, 0xa438, 0x024f,
+        0xa438, 0x67bf, 0xa438, 0x8ff7, 0xa438, 0xddbf, 0xa438, 0x85b0,
+        0xa438, 0x024f, 0xa438, 0x67bf, 0xa438, 0x8ff8, 0xa438, 0xddbf,
+        0xa438, 0x85b3, 0xa438, 0x024f, 0xa438, 0x67bf, 0xa438, 0x8ff9,
+        0xa438, 0xddbf, 0xa438, 0x85b6, 0xa438, 0x024f, 0xa438, 0x67bf,
+        0xa438, 0x8ffa, 0xa438, 0xddd1, 0xa438, 0x00bf, 0xa438, 0x85aa,
+        0xa438, 0x024f, 0xa438, 0x4802, 0xa438, 0x4d6a, 0xa438, 0xbf85,
+        0xa438, 0xad02, 0xa438, 0x4f67, 0xa438, 0xbf8f, 0xa438, 0xfbdd,
+        0xa438, 0xbf85, 0xa438, 0xb002, 0xa438, 0x4f67, 0xa438, 0xbf8f,
+        0xa438, 0xfcdd, 0xa438, 0xbf85, 0xa438, 0xb302, 0xa438, 0x4f67,
+        0xa438, 0xbf8f, 0xa438, 0xfddd, 0xa438, 0xbf85, 0xa438, 0xb602,
+        0xa438, 0x4f67, 0xa438, 0xbf8f, 0xa438, 0xfedd, 0xa438, 0xbf85,
+        0xa438, 0xa702, 0xa438, 0x54b7, 0xa438, 0xbf85, 0xa438, 0xa102,
+        0xa438, 0x54b7, 0xa438, 0xaf3c, 0xa438, 0x2066, 0xa438, 0xb800,
+        0xa438, 0xb8bd, 0xa438, 0x30ee, 0xa438, 0xbd2c, 0xa438, 0xb8bd,
+        0xa438, 0x7040, 0xa438, 0xbd86, 0xa438, 0xc8bd, 0xa438, 0x8640,
+        0xa438, 0xbd88, 0xa438, 0xc8bd, 0xa438, 0x8802, 0xa438, 0x1929,
+        0xa438, 0xa202, 0xa438, 0x02ae, 0xa438, 0x03a2, 0xa438, 0x032e,
+        0xa438, 0xd10f, 0xa438, 0xbf85, 0xa438, 0xaa02, 0xa438, 0x4f48,
+        0xa438, 0xe18f, 0xa438, 0xf7bf, 0xa438, 0x85ad, 0xa438, 0x024f,
+        0xa438, 0x48e1, 0xa438, 0x8ff8, 0xa438, 0xbf85, 0xa438, 0xb002,
+        0xa438, 0x4f48, 0xa438, 0xe18f, 0xa438, 0xf9bf, 0xa438, 0x85b3,
+        0xa438, 0x024f, 0xa438, 0x48e1, 0xa438, 0x8ffa, 0xa438, 0xbf85,
+        0xa438, 0xb602, 0xa438, 0x4f48, 0xa438, 0xae2c, 0xa438, 0xd100,
+        0xa438, 0xbf85, 0xa438, 0xaa02, 0xa438, 0x4f48, 0xa438, 0xe18f,
+        0xa438, 0xfbbf, 0xa438, 0x85ad, 0xa438, 0x024f, 0xa438, 0x48e1,
+        0xa438, 0x8ffc, 0xa438, 0xbf85, 0xa438, 0xb002, 0xa438, 0x4f48,
+        0xa438, 0xe18f, 0xa438, 0xfdbf, 0xa438, 0x85b3, 0xa438, 0x024f,
+        0xa438, 0x48e1, 0xa438, 0x8ffe, 0xa438, 0xbf85, 0xa438, 0xb602,
+        0xa438, 0x4f48, 0xa438, 0xbf86, 0xa438, 0x7e02, 0xa438, 0x4f67,
+        0xa438, 0xa100, 0xa438, 0x02ae, 0xa438, 0x25a1, 0xa438, 0x041d,
+        0xa438, 0xe18f, 0xa438, 0xf1bf, 0xa438, 0x8675, 0xa438, 0x024f,
+        0xa438, 0x48e1, 0xa438, 0x8ff2, 0xa438, 0xbf86, 0xa438, 0x7802,
+        0xa438, 0x4f48, 0xa438, 0xe18f, 0xa438, 0xf3bf, 0xa438, 0x867b,
+        0xa438, 0x024f, 0xa438, 0x48ae, 0xa438, 0x29a1, 0xa438, 0x070b,
+        0xa438, 0xae24, 0xa438, 0xbf86, 0xa438, 0x8102, 0xa438, 0x4f67,
+        0xa438, 0xad28, 0xa438, 0x1be1, 0xa438, 0x8ff4, 0xa438, 0xbf86,
+        0xa438, 0x7502, 0xa438, 0x4f48, 0xa438, 0xe18f, 0xa438, 0xf5bf,
+        0xa438, 0x8678, 0xa438, 0x024f, 0xa438, 0x48e1, 0xa438, 0x8ff6,
+        0xa438, 0xbf86, 0xa438, 0x7b02, 0xa438, 0x4f48, 0xa438, 0xaf09,
+        0xa438, 0x8420, 0xa438, 0xbc32, 0xa438, 0x20bc, 0xa438, 0x3e76,
+        0xa438, 0xbc08, 0xa438, 0xfda6, 0xa438, 0x1a00, 0xa438, 0xb64e,
+        0xa438, 0xd101, 0xa438, 0xbf85, 0xa438, 0xa402, 0xa438, 0x4f48,
+        0xa438, 0xbf85, 0xa438, 0xa702, 0xa438, 0x54c0, 0xa438, 0xd10f,
+        0xa438, 0xbf85, 0xa438, 0xaa02, 0xa438, 0x4f48, 0xa438, 0x024d,
+        0xa438, 0x6abf, 0xa438, 0x85ad, 0xa438, 0x024f, 0xa438, 0x67bf,
+        0xa438, 0x8ff7, 0xa438, 0xddbf, 0xa438, 0x85b0, 0xa438, 0x024f,
+        0xa438, 0x67bf, 0xa438, 0x8ff8, 0xa438, 0xddbf, 0xa438, 0x85b3,
+        0xa438, 0x024f, 0xa438, 0x67bf, 0xa438, 0x8ff9, 0xa438, 0xddbf,
+        0xa438, 0x85b6, 0xa438, 0x024f, 0xa438, 0x67bf, 0xa438, 0x8ffa,
+        0xa438, 0xddd1, 0xa438, 0x00bf, 0xa438, 0x85aa, 0xa438, 0x024f,
+        0xa438, 0x4802, 0xa438, 0x4d6a, 0xa438, 0xbf85, 0xa438, 0xad02,
+        0xa438, 0x4f67, 0xa438, 0xbf8f, 0xa438, 0xfbdd, 0xa438, 0xbf85,
+        0xa438, 0xb002, 0xa438, 0x4f67, 0xa438, 0xbf8f, 0xa438, 0xfcdd,
+        0xa438, 0xbf85, 0xa438, 0xb302, 0xa438, 0x4f67, 0xa438, 0xbf8f,
+        0xa438, 0xfddd, 0xa438, 0xbf85, 0xa438, 0xb602, 0xa438, 0x4f67,
+        0xa438, 0xbf8f, 0xa438, 0xfedd, 0xa438, 0xbf85, 0xa438, 0xa702,
+        0xa438, 0x54b7, 0xa438, 0xaf00, 0xa438, 0x8800, 0xa436, 0xb818,
+        0xa438, 0x38b8, 0xa436, 0xb81a, 0xa438, 0x0444, 0xa436, 0xb81c,
+        0xa438, 0x40ee, 0xa436, 0xb81e, 0xa438, 0x3C1A, 0xa436, 0xb850,
+        0xa438, 0x0981, 0xa436, 0xb852, 0xa438, 0x0085, 0xa436, 0xb878,
+        0xa438, 0xffff, 0xa436, 0xb884, 0xa438, 0xffff, 0xa436, 0xb832,
+        0xa438, 0x003f, 0xa436, 0x0000, 0xa438, 0x0000, 0xa436, 0xB82E,
+        0xa438, 0x0000, 0xa436, 0x8024, 0xa438, 0x0000, 0xb820, 0x0000,
+        0xa436, 0x801E, 0xa438, 0x0021, 0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8125b_2[] = {
+        0xa436, 0x8024, 0xa438, 0x3701, 0xa436, 0xB82E, 0xa438, 0x0001,
+        0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x801a, 0xa438, 0x1800, 0xa438, 0x803f,
+        0xa438, 0x1800, 0xa438, 0x8045, 0xa438, 0x1800, 0xa438, 0x8067,
+        0xa438, 0x1800, 0xa438, 0x806d, 0xa438, 0x1800, 0xa438, 0x8071,
+        0xa438, 0x1800, 0xa438, 0x80b1, 0xa438, 0xd093, 0xa438, 0xd1c4,
+        0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd704, 0xa438, 0x5fbc,
+        0xa438, 0xd504, 0xa438, 0xc9f1, 0xa438, 0x1800, 0xa438, 0x0fc9,
+        0xa438, 0xbb50, 0xa438, 0xd505, 0xa438, 0xa202, 0xa438, 0xd504,
+        0xa438, 0x8c0f, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1519,
+        0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd75e, 0xa438, 0x5fae,
+        0xa438, 0x9b50, 0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd75e,
+        0xa438, 0x7fae, 0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd707,
+        0xa438, 0x40a7, 0xa438, 0xd719, 0xa438, 0x4071, 0xa438, 0x1800,
+        0xa438, 0x1557, 0xa438, 0xd719, 0xa438, 0x2f70, 0xa438, 0x803b,
+        0xa438, 0x2f73, 0xa438, 0x156a, 0xa438, 0x5e70, 0xa438, 0x1800,
+        0xa438, 0x155d, 0xa438, 0xd505, 0xa438, 0xa202, 0xa438, 0xd500,
+        0xa438, 0xffed, 0xa438, 0xd709, 0xa438, 0x4054, 0xa438, 0xa788,
+        0xa438, 0xd70b, 0xa438, 0x1800, 0xa438, 0x172a, 0xa438, 0xc0c1,
+        0xa438, 0xc0c0, 0xa438, 0xd05a, 0xa438, 0xd1ba, 0xa438, 0xd701,
+        0xa438, 0x2529, 0xa438, 0x022a, 0xa438, 0xd0a7, 0xa438, 0xd1b9,
+        0xa438, 0xa208, 0xa438, 0x1000, 0xa438, 0x080e, 0xa438, 0xd701,
+        0xa438, 0x408b, 0xa438, 0x1000, 0xa438, 0x0a65, 0xa438, 0xf003,
+        0xa438, 0x1000, 0xa438, 0x0a6b, 0xa438, 0xd701, 0xa438, 0x1000,
+        0xa438, 0x0920, 0xa438, 0x1000, 0xa438, 0x0915, 0xa438, 0x1000,
+        0xa438, 0x0909, 0xa438, 0x228f, 0xa438, 0x804e, 0xa438, 0x9801,
+        0xa438, 0xd71e, 0xa438, 0x5d61, 0xa438, 0xd701, 0xa438, 0x1800,
+        0xa438, 0x022a, 0xa438, 0x2005, 0xa438, 0x091a, 0xa438, 0x3bd9,
+        0xa438, 0x0919, 0xa438, 0x1800, 0xa438, 0x0916, 0xa438, 0xd090,
+        0xa438, 0xd1c9, 0xa438, 0x1800, 0xa438, 0x1064, 0xa438, 0xd096,
+        0xa438, 0xd1a9, 0xa438, 0xd503, 0xa438, 0xa104, 0xa438, 0x0c07,
+        0xa438, 0x0902, 0xa438, 0xd500, 0xa438, 0xbc10, 0xa438, 0xd501,
+        0xa438, 0xce01, 0xa438, 0xa201, 0xa438, 0x8201, 0xa438, 0xce00,
+        0xa438, 0xd500, 0xa438, 0xc484, 0xa438, 0xd503, 0xa438, 0xcc02,
+        0xa438, 0xcd0d, 0xa438, 0xaf01, 0xa438, 0xd500, 0xa438, 0xd703,
+        0xa438, 0x4371, 0xa438, 0xbd08, 0xa438, 0x1000, 0xa438, 0x135c,
+        0xa438, 0xd75e, 0xa438, 0x5fb3, 0xa438, 0xd503, 0xa438, 0xd0f5,
+        0xa438, 0xd1c6, 0xa438, 0x0cf0, 0xa438, 0x0e50, 0xa438, 0xd704,
+        0xa438, 0x401c, 0xa438, 0xd0f5, 0xa438, 0xd1c6, 0xa438, 0x0cf0,
+        0xa438, 0x0ea0, 0xa438, 0x401c, 0xa438, 0xd07b, 0xa438, 0xd1c5,
+        0xa438, 0x8ef0, 0xa438, 0x401c, 0xa438, 0x9d08, 0xa438, 0x1000,
+        0xa438, 0x135c, 0xa438, 0xd75e, 0xa438, 0x7fb3, 0xa438, 0x1000,
+        0xa438, 0x135c, 0xa438, 0xd75e, 0xa438, 0x5fad, 0xa438, 0x1000,
+        0xa438, 0x14c5, 0xa438, 0xd703, 0xa438, 0x3181, 0xa438, 0x80af,
+        0xa438, 0x60ad, 0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd703,
+        0xa438, 0x5fba, 0xa438, 0x1800, 0xa438, 0x0cc7, 0xa438, 0xa802,
+        0xa438, 0xa301, 0xa438, 0xa801, 0xa438, 0xc004, 0xa438, 0xd710,
+        0xa438, 0x4000, 0xa438, 0x1800, 0xa438, 0x1e79, 0xa436, 0xA026,
+        0xa438, 0x1e78, 0xa436, 0xA024, 0xa438, 0x0c93, 0xa436, 0xA022,
+        0xa438, 0x1062, 0xa436, 0xA020, 0xa438, 0x0915, 0xa436, 0xA006,
+        0xa438, 0x020a, 0xa436, 0xA004, 0xa438, 0x1726, 0xa436, 0xA002,
+        0xa438, 0x1542, 0xa436, 0xA000, 0xa438, 0x0fc7, 0xa436, 0xA008,
+        0xa438, 0xff00, 0xa436, 0xA016, 0xa438, 0x0010, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x801d, 0xa438, 0x1800, 0xa438, 0x802c,
+        0xa438, 0x1800, 0xa438, 0x802c, 0xa438, 0x1800, 0xa438, 0x802c,
+        0xa438, 0x1800, 0xa438, 0x802c, 0xa438, 0x1800, 0xa438, 0x802c,
+        0xa438, 0x1800, 0xa438, 0x802c, 0xa438, 0xd700, 0xa438, 0x6090,
+        0xa438, 0x60d1, 0xa438, 0xc95c, 0xa438, 0xf007, 0xa438, 0x60b1,
+        0xa438, 0xc95a, 0xa438, 0xf004, 0xa438, 0xc956, 0xa438, 0xf002,
+        0xa438, 0xc94e, 0xa438, 0x1800, 0xa438, 0x00cd, 0xa438, 0xd700,
+        0xa438, 0x6090, 0xa438, 0x60d1, 0xa438, 0xc95c, 0xa438, 0xf007,
+        0xa438, 0x60b1, 0xa438, 0xc95a, 0xa438, 0xf004, 0xa438, 0xc956,
+        0xa438, 0xf002, 0xa438, 0xc94e, 0xa438, 0x1000, 0xa438, 0x022a,
+        0xa438, 0x1800, 0xa438, 0x0132, 0xa436, 0xA08E, 0xa438, 0xffff,
+        0xa436, 0xA08C, 0xa438, 0xffff, 0xa436, 0xA08A, 0xa438, 0xffff,
+        0xa436, 0xA088, 0xa438, 0xffff, 0xa436, 0xA086, 0xa438, 0xffff,
+        0xa436, 0xA084, 0xa438, 0xffff, 0xa436, 0xA082, 0xa438, 0x012f,
+        0xa436, 0xA080, 0xa438, 0x00cc, 0xa436, 0xA090, 0xa438, 0x0103,
+        0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x0000,
+        0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010, 0xa438, 0x1800,
+        0xa438, 0x8020, 0xa438, 0x1800, 0xa438, 0x802a, 0xa438, 0x1800,
+        0xa438, 0x8035, 0xa438, 0x1800, 0xa438, 0x803c, 0xa438, 0x1800,
+        0xa438, 0x803c, 0xa438, 0x1800, 0xa438, 0x803c, 0xa438, 0x1800,
+        0xa438, 0x803c, 0xa438, 0xd107, 0xa438, 0xd042, 0xa438, 0xa404,
+        0xa438, 0x1000, 0xa438, 0x09df, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0x8280, 0xa438, 0xd700, 0xa438, 0x6065, 0xa438, 0xd125,
+        0xa438, 0xf002, 0xa438, 0xd12b, 0xa438, 0xd040, 0xa438, 0x1800,
+        0xa438, 0x077f, 0xa438, 0x0cf0, 0xa438, 0x0c50, 0xa438, 0xd104,
+        0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x0aa8, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0x1800, 0xa438, 0x0a2e, 0xa438, 0xcb9b,
+        0xa438, 0xd110, 0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x0b7b,
+        0xa438, 0x1000, 0xa438, 0x09df, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0x1800, 0xa438, 0x081b, 0xa438, 0x1000, 0xa438, 0x09df,
+        0xa438, 0xd704, 0xa438, 0x7fb8, 0xa438, 0xa718, 0xa438, 0x1800,
+        0xa438, 0x074e, 0xa436, 0xA10E, 0xa438, 0xffff, 0xa436, 0xA10C,
+        0xa438, 0xffff, 0xa436, 0xA10A, 0xa438, 0xffff, 0xa436, 0xA108,
+        0xa438, 0xffff, 0xa436, 0xA106, 0xa438, 0x074d, 0xa436, 0xA104,
+        0xa438, 0x0818, 0xa436, 0xA102, 0xa438, 0x0a2c, 0xa436, 0xA100,
+        0xa438, 0x077e, 0xa436, 0xA110, 0xa438, 0x000f, 0xa436, 0xb87c,
+        0xa438, 0x8625, 0xa436, 0xb87e, 0xa438, 0xaf86, 0xa438, 0x3daf,
+        0xa438, 0x8689, 0xa438, 0xaf88, 0xa438, 0x69af, 0xa438, 0x8887,
+        0xa438, 0xaf88, 0xa438, 0x9caf, 0xa438, 0x88be, 0xa438, 0xaf88,
+        0xa438, 0xbeaf, 0xa438, 0x88be, 0xa438, 0xbf86, 0xa438, 0x49d7,
+        0xa438, 0x0040, 0xa438, 0x0277, 0xa438, 0x7daf, 0xa438, 0x2727,
+        0xa438, 0x0000, 0xa438, 0x7205, 0xa438, 0x0000, 0xa438, 0x7208,
+        0xa438, 0x0000, 0xa438, 0x71f3, 0xa438, 0x0000, 0xa438, 0x71f6,
+        0xa438, 0x0000, 0xa438, 0x7229, 0xa438, 0x0000, 0xa438, 0x722c,
+        0xa438, 0x0000, 0xa438, 0x7217, 0xa438, 0x0000, 0xa438, 0x721a,
+        0xa438, 0x0000, 0xa438, 0x721d, 0xa438, 0x0000, 0xa438, 0x7211,
+        0xa438, 0x0000, 0xa438, 0x7220, 0xa438, 0x0000, 0xa438, 0x7214,
+        0xa438, 0x0000, 0xa438, 0x722f, 0xa438, 0x0000, 0xa438, 0x7223,
+        0xa438, 0x0000, 0xa438, 0x7232, 0xa438, 0x0000, 0xa438, 0x7226,
+        0xa438, 0xf8f9, 0xa438, 0xfae0, 0xa438, 0x85b3, 0xa438, 0x3802,
+        0xa438, 0xad27, 0xa438, 0x02ae, 0xa438, 0x03af, 0xa438, 0x8830,
+        0xa438, 0x1f66, 0xa438, 0xef65, 0xa438, 0xbfc2, 0xa438, 0x1f1a,
+        0xa438, 0x96f7, 0xa438, 0x05ee, 0xa438, 0xffd2, 0xa438, 0x00da,
+        0xa438, 0xf605, 0xa438, 0xbfc2, 0xa438, 0x2f1a, 0xa438, 0x96f7,
+        0xa438, 0x05ee, 0xa438, 0xffd2, 0xa438, 0x00db, 0xa438, 0xf605,
+        0xa438, 0xef02, 0xa438, 0x1f11, 0xa438, 0x0d42, 0xa438, 0xbf88,
+        0xa438, 0x4202, 0xa438, 0x6e7d, 0xa438, 0xef02, 0xa438, 0x1b03,
+        0xa438, 0x1f11, 0xa438, 0x0d42, 0xa438, 0xbf88, 0xa438, 0x4502,
+        0xa438, 0x6e7d, 0xa438, 0xef02, 0xa438, 0x1a03, 0xa438, 0x1f11,
+        0xa438, 0x0d42, 0xa438, 0xbf88, 0xa438, 0x4802, 0xa438, 0x6e7d,
+        0xa438, 0xbfc2, 0xa438, 0x3f1a, 0xa438, 0x96f7, 0xa438, 0x05ee,
+        0xa438, 0xffd2, 0xa438, 0x00da, 0xa438, 0xf605, 0xa438, 0xbfc2,
+        0xa438, 0x4f1a, 0xa438, 0x96f7, 0xa438, 0x05ee, 0xa438, 0xffd2,
+        0xa438, 0x00db, 0xa438, 0xf605, 0xa438, 0xef02, 0xa438, 0x1f11,
+        0xa438, 0x0d42, 0xa438, 0xbf88, 0xa438, 0x4b02, 0xa438, 0x6e7d,
+        0xa438, 0xef02, 0xa438, 0x1b03, 0xa438, 0x1f11, 0xa438, 0x0d42,
+        0xa438, 0xbf88, 0xa438, 0x4e02, 0xa438, 0x6e7d, 0xa438, 0xef02,
+        0xa438, 0x1a03, 0xa438, 0x1f11, 0xa438, 0x0d42, 0xa438, 0xbf88,
+        0xa438, 0x5102, 0xa438, 0x6e7d, 0xa438, 0xef56, 0xa438, 0xd020,
+        0xa438, 0x1f11, 0xa438, 0xbf88, 0xa438, 0x5402, 0xa438, 0x6e7d,
+        0xa438, 0xbf88, 0xa438, 0x5702, 0xa438, 0x6e7d, 0xa438, 0xbf88,
+        0xa438, 0x5a02, 0xa438, 0x6e7d, 0xa438, 0xe185, 0xa438, 0xa0ef,
+        0xa438, 0x0348, 0xa438, 0x0a28, 0xa438, 0x05ef, 0xa438, 0x201b,
+        0xa438, 0x01ad, 0xa438, 0x2735, 0xa438, 0x1f44, 0xa438, 0xe085,
+        0xa438, 0x88e1, 0xa438, 0x8589, 0xa438, 0xbf88, 0xa438, 0x5d02,
+        0xa438, 0x6e7d, 0xa438, 0xe085, 0xa438, 0x8ee1, 0xa438, 0x858f,
+        0xa438, 0xbf88, 0xa438, 0x6002, 0xa438, 0x6e7d, 0xa438, 0xe085,
+        0xa438, 0x94e1, 0xa438, 0x8595, 0xa438, 0xbf88, 0xa438, 0x6302,
+        0xa438, 0x6e7d, 0xa438, 0xe085, 0xa438, 0x9ae1, 0xa438, 0x859b,
+        0xa438, 0xbf88, 0xa438, 0x6602, 0xa438, 0x6e7d, 0xa438, 0xaf88,
+        0xa438, 0x3cbf, 0xa438, 0x883f, 0xa438, 0x026e, 0xa438, 0x9cad,
+        0xa438, 0x2835, 0xa438, 0x1f44, 0xa438, 0xe08f, 0xa438, 0xf8e1,
+        0xa438, 0x8ff9, 0xa438, 0xbf88, 0xa438, 0x5d02, 0xa438, 0x6e7d,
+        0xa438, 0xe08f, 0xa438, 0xfae1, 0xa438, 0x8ffb, 0xa438, 0xbf88,
+        0xa438, 0x6002, 0xa438, 0x6e7d, 0xa438, 0xe08f, 0xa438, 0xfce1,
+        0xa438, 0x8ffd, 0xa438, 0xbf88, 0xa438, 0x6302, 0xa438, 0x6e7d,
+        0xa438, 0xe08f, 0xa438, 0xfee1, 0xa438, 0x8fff, 0xa438, 0xbf88,
+        0xa438, 0x6602, 0xa438, 0x6e7d, 0xa438, 0xaf88, 0xa438, 0x3ce1,
+        0xa438, 0x85a1, 0xa438, 0x1b21, 0xa438, 0xad37, 0xa438, 0x341f,
+        0xa438, 0x44e0, 0xa438, 0x858a, 0xa438, 0xe185, 0xa438, 0x8bbf,
+        0xa438, 0x885d, 0xa438, 0x026e, 0xa438, 0x7de0, 0xa438, 0x8590,
+        0xa438, 0xe185, 0xa438, 0x91bf, 0xa438, 0x8860, 0xa438, 0x026e,
+        0xa438, 0x7de0, 0xa438, 0x8596, 0xa438, 0xe185, 0xa438, 0x97bf,
+        0xa438, 0x8863, 0xa438, 0x026e, 0xa438, 0x7de0, 0xa438, 0x859c,
+        0xa438, 0xe185, 0xa438, 0x9dbf, 0xa438, 0x8866, 0xa438, 0x026e,
+        0xa438, 0x7dae, 0xa438, 0x401f, 0xa438, 0x44e0, 0xa438, 0x858c,
+        0xa438, 0xe185, 0xa438, 0x8dbf, 0xa438, 0x885d, 0xa438, 0x026e,
+        0xa438, 0x7de0, 0xa438, 0x8592, 0xa438, 0xe185, 0xa438, 0x93bf,
+        0xa438, 0x8860, 0xa438, 0x026e, 0xa438, 0x7de0, 0xa438, 0x8598,
+        0xa438, 0xe185, 0xa438, 0x99bf, 0xa438, 0x8863, 0xa438, 0x026e,
+        0xa438, 0x7de0, 0xa438, 0x859e, 0xa438, 0xe185, 0xa438, 0x9fbf,
+        0xa438, 0x8866, 0xa438, 0x026e, 0xa438, 0x7dae, 0xa438, 0x0ce1,
+        0xa438, 0x85b3, 0xa438, 0x3904, 0xa438, 0xac2f, 0xa438, 0x04ee,
+        0xa438, 0x85b3, 0xa438, 0x00af, 0xa438, 0x39d9, 0xa438, 0x22ac,
+        0xa438, 0xeaf0, 0xa438, 0xacf6, 0xa438, 0xf0ac, 0xa438, 0xfaf0,
+        0xa438, 0xacf8, 0xa438, 0xf0ac, 0xa438, 0xfcf0, 0xa438, 0xad00,
+        0xa438, 0xf0ac, 0xa438, 0xfef0, 0xa438, 0xacf0, 0xa438, 0xf0ac,
+        0xa438, 0xf4f0, 0xa438, 0xacf2, 0xa438, 0xf0ac, 0xa438, 0xb0f0,
+        0xa438, 0xacae, 0xa438, 0xf0ac, 0xa438, 0xacf0, 0xa438, 0xacaa,
+        0xa438, 0xa100, 0xa438, 0x0ce1, 0xa438, 0x8ff7, 0xa438, 0xbf88,
+        0xa438, 0x8402, 0xa438, 0x6e7d, 0xa438, 0xaf26, 0xa438, 0xe9e1,
+        0xa438, 0x8ff6, 0xa438, 0xbf88, 0xa438, 0x8402, 0xa438, 0x6e7d,
+        0xa438, 0xaf26, 0xa438, 0xf520, 0xa438, 0xac86, 0xa438, 0xbf88,
+        0xa438, 0x3f02, 0xa438, 0x6e9c, 0xa438, 0xad28, 0xa438, 0x03af,
+        0xa438, 0x3324, 0xa438, 0xad38, 0xa438, 0x03af, 0xa438, 0x32e6,
+        0xa438, 0xaf32, 0xa438, 0xfbee, 0xa438, 0x826a, 0xa438, 0x0002,
+        0xa438, 0x88a6, 0xa438, 0xaf04, 0xa438, 0x78f8, 0xa438, 0xfaef,
+        0xa438, 0x69e0, 0xa438, 0x8015, 0xa438, 0xad20, 0xa438, 0x06bf,
+        0xa438, 0x88bb, 0xa438, 0x0275, 0xa438, 0xb1ef, 0xa438, 0x96fe,
+        0xa438, 0xfc04, 0xa438, 0x00b8, 0xa438, 0x7a00, 0xa436, 0xb87c,
+        0xa438, 0x8ff6, 0xa436, 0xb87e, 0xa438, 0x0705, 0xa436, 0xb87c,
+        0xa438, 0x8ff8, 0xa436, 0xb87e, 0xa438, 0x19cc, 0xa436, 0xb87c,
+        0xa438, 0x8ffa, 0xa436, 0xb87e, 0xa438, 0x28e3, 0xa436, 0xb87c,
+        0xa438, 0x8ffc, 0xa436, 0xb87e, 0xa438, 0x1047, 0xa436, 0xb87c,
+        0xa438, 0x8ffe, 0xa436, 0xb87e, 0xa438, 0x0a45, 0xa436, 0xb85e,
+        0xa438, 0x271E, 0xa436, 0xb860, 0xa438, 0x3846, 0xa436, 0xb862,
+        0xa438, 0x26E6, 0xa436, 0xb864, 0xa438, 0x32E3, 0xa436, 0xb886,
+        0xa438, 0x0474, 0xa436, 0xb888, 0xa438, 0xffff, 0xa436, 0xb88a,
+        0xa438, 0xffff, 0xa436, 0xb88c, 0xa438, 0xffff, 0xa436, 0xb838,
+        0xa438, 0x001f, 0xb820, 0x0010, 0xa436, 0x846e, 0xa438, 0xaf84,
+        0xa438, 0x86af, 0xa438, 0x8690, 0xa438, 0xaf86, 0xa438, 0xa4af,
+        0xa438, 0x8934, 0xa438, 0xaf89, 0xa438, 0x60af, 0xa438, 0x897e,
+        0xa438, 0xaf89, 0xa438, 0xa9af, 0xa438, 0x89a9, 0xa438, 0xee82,
+        0xa438, 0x5f00, 0xa438, 0x0284, 0xa438, 0x90af, 0xa438, 0x0441,
+        0xa438, 0xf8e0, 0xa438, 0x8ff3, 0xa438, 0xa000, 0xa438, 0x0502,
+        0xa438, 0x84a4, 0xa438, 0xae06, 0xa438, 0xa001, 0xa438, 0x0302,
+        0xa438, 0x84c8, 0xa438, 0xfc04, 0xa438, 0xf8f9, 0xa438, 0xef59,
+        0xa438, 0xe080, 0xa438, 0x15ad, 0xa438, 0x2702, 0xa438, 0xae03,
+        0xa438, 0xaf84, 0xa438, 0xc3bf, 0xa438, 0x53ca, 0xa438, 0x0252,
+        0xa438, 0xc8ad, 0xa438, 0x2807, 0xa438, 0x0285, 0xa438, 0x2cee,
+        0xa438, 0x8ff3, 0xa438, 0x01ef, 0xa438, 0x95fd, 0xa438, 0xfc04,
+        0xa438, 0xf8f9, 0xa438, 0xfaef, 0xa438, 0x69bf, 0xa438, 0x53ca,
+        0xa438, 0x0252, 0xa438, 0xc8ac, 0xa438, 0x2822, 0xa438, 0xd480,
+        0xa438, 0x00bf, 0xa438, 0x8684, 0xa438, 0x0252, 0xa438, 0xa9bf,
+        0xa438, 0x8687, 0xa438, 0x0252, 0xa438, 0xa9bf, 0xa438, 0x868a,
+        0xa438, 0x0252, 0xa438, 0xa9bf, 0xa438, 0x868d, 0xa438, 0x0252,
+        0xa438, 0xa9ee, 0xa438, 0x8ff3, 0xa438, 0x00af, 0xa438, 0x8526,
+        0xa438, 0xe08f, 0xa438, 0xf4e1, 0xa438, 0x8ff5, 0xa438, 0xe28f,
+        0xa438, 0xf6e3, 0xa438, 0x8ff7, 0xa438, 0x1b45, 0xa438, 0xac27,
+        0xa438, 0x0eee, 0xa438, 0x8ff4, 0xa438, 0x00ee, 0xa438, 0x8ff5,
+        0xa438, 0x0002, 0xa438, 0x852c, 0xa438, 0xaf85, 0xa438, 0x26e0,
+        0xa438, 0x8ff4, 0xa438, 0xe18f, 0xa438, 0xf52c, 0xa438, 0x0001,
+        0xa438, 0xe48f, 0xa438, 0xf4e5, 0xa438, 0x8ff5, 0xa438, 0xef96,
+        0xa438, 0xfefd, 0xa438, 0xfc04, 0xa438, 0xf8f9, 0xa438, 0xef59,
+        0xa438, 0xbf53, 0xa438, 0x2202, 0xa438, 0x52c8, 0xa438, 0xa18b,
+        0xa438, 0x02ae, 0xa438, 0x03af, 0xa438, 0x85da, 0xa438, 0xbf57,
+        0xa438, 0x7202, 0xa438, 0x52c8, 0xa438, 0xe48f, 0xa438, 0xf8e5,
+        0xa438, 0x8ff9, 0xa438, 0xbf57, 0xa438, 0x7502, 0xa438, 0x52c8,
+        0xa438, 0xe48f, 0xa438, 0xfae5, 0xa438, 0x8ffb, 0xa438, 0xbf57,
+        0xa438, 0x7802, 0xa438, 0x52c8, 0xa438, 0xe48f, 0xa438, 0xfce5,
+        0xa438, 0x8ffd, 0xa438, 0xbf57, 0xa438, 0x7b02, 0xa438, 0x52c8,
+        0xa438, 0xe48f, 0xa438, 0xfee5, 0xa438, 0x8fff, 0xa438, 0xbf57,
+        0xa438, 0x6c02, 0xa438, 0x52c8, 0xa438, 0xa102, 0xa438, 0x13ee,
+        0xa438, 0x8ffc, 0xa438, 0x80ee, 0xa438, 0x8ffd, 0xa438, 0x00ee,
+        0xa438, 0x8ffe, 0xa438, 0x80ee, 0xa438, 0x8fff, 0xa438, 0x00af,
+        0xa438, 0x8599, 0xa438, 0xa101, 0xa438, 0x0cbf, 0xa438, 0x534c,
+        0xa438, 0x0252, 0xa438, 0xc8a1, 0xa438, 0x0303, 0xa438, 0xaf85,
+        0xa438, 0x77bf, 0xa438, 0x5322, 0xa438, 0x0252, 0xa438, 0xc8a1,
+        0xa438, 0x8b02, 0xa438, 0xae03, 0xa438, 0xaf86, 0xa438, 0x64e0,
+        0xa438, 0x8ff8, 0xa438, 0xe18f, 0xa438, 0xf9bf, 0xa438, 0x8684,
+        0xa438, 0x0252, 0xa438, 0xa9e0, 0xa438, 0x8ffa, 0xa438, 0xe18f,
+        0xa438, 0xfbbf, 0xa438, 0x8687, 0xa438, 0x0252, 0xa438, 0xa9e0,
+        0xa438, 0x8ffc, 0xa438, 0xe18f, 0xa438, 0xfdbf, 0xa438, 0x868a,
+        0xa438, 0x0252, 0xa438, 0xa9e0, 0xa438, 0x8ffe, 0xa438, 0xe18f,
+        0xa438, 0xffbf, 0xa438, 0x868d, 0xa438, 0x0252, 0xa438, 0xa9af,
+        0xa438, 0x867f, 0xa438, 0xbf53, 0xa438, 0x2202, 0xa438, 0x52c8,
+        0xa438, 0xa144, 0xa438, 0x3cbf, 0xa438, 0x547b, 0xa438, 0x0252,
+        0xa438, 0xc8e4, 0xa438, 0x8ff8, 0xa438, 0xe58f, 0xa438, 0xf9bf,
+        0xa438, 0x547e, 0xa438, 0x0252, 0xa438, 0xc8e4, 0xa438, 0x8ffa,
+        0xa438, 0xe58f, 0xa438, 0xfbbf, 0xa438, 0x5481, 0xa438, 0x0252,
+        0xa438, 0xc8e4, 0xa438, 0x8ffc, 0xa438, 0xe58f, 0xa438, 0xfdbf,
+        0xa438, 0x5484, 0xa438, 0x0252, 0xa438, 0xc8e4, 0xa438, 0x8ffe,
+        0xa438, 0xe58f, 0xa438, 0xffbf, 0xa438, 0x5322, 0xa438, 0x0252,
+        0xa438, 0xc8a1, 0xa438, 0x4448, 0xa438, 0xaf85, 0xa438, 0xa7bf,
+        0xa438, 0x5322, 0xa438, 0x0252, 0xa438, 0xc8a1, 0xa438, 0x313c,
+        0xa438, 0xbf54, 0xa438, 0x7b02, 0xa438, 0x52c8, 0xa438, 0xe48f,
+        0xa438, 0xf8e5, 0xa438, 0x8ff9, 0xa438, 0xbf54, 0xa438, 0x7e02,
+        0xa438, 0x52c8, 0xa438, 0xe48f, 0xa438, 0xfae5, 0xa438, 0x8ffb,
+        0xa438, 0xbf54, 0xa438, 0x8102, 0xa438, 0x52c8, 0xa438, 0xe48f,
+        0xa438, 0xfce5, 0xa438, 0x8ffd, 0xa438, 0xbf54, 0xa438, 0x8402,
+        0xa438, 0x52c8, 0xa438, 0xe48f, 0xa438, 0xfee5, 0xa438, 0x8fff,
+        0xa438, 0xbf53, 0xa438, 0x2202, 0xa438, 0x52c8, 0xa438, 0xa131,
+        0xa438, 0x03af, 0xa438, 0x85a7, 0xa438, 0xd480, 0xa438, 0x00bf,
+        0xa438, 0x8684, 0xa438, 0x0252, 0xa438, 0xa9bf, 0xa438, 0x8687,
+        0xa438, 0x0252, 0xa438, 0xa9bf, 0xa438, 0x868a, 0xa438, 0x0252,
+        0xa438, 0xa9bf, 0xa438, 0x868d, 0xa438, 0x0252, 0xa438, 0xa9ef,
+        0xa438, 0x95fd, 0xa438, 0xfc04, 0xa438, 0xf0d1, 0xa438, 0x2af0,
+        0xa438, 0xd12c, 0xa438, 0xf0d1, 0xa438, 0x44f0, 0xa438, 0xd146,
+        0xa438, 0xbf86, 0xa438, 0xa102, 0xa438, 0x52c8, 0xa438, 0xbf86,
+        0xa438, 0xa102, 0xa438, 0x52c8, 0xa438, 0xd101, 0xa438, 0xaf06,
+        0xa438, 0xa570, 0xa438, 0xce42, 0xa438, 0xee83, 0xa438, 0xc800,
+        0xa438, 0x0286, 0xa438, 0xba02, 0xa438, 0x8728, 0xa438, 0x0287,
+        0xa438, 0xbe02, 0xa438, 0x87f9, 0xa438, 0x0288, 0xa438, 0xc3af,
+        0xa438, 0x4771, 0xa438, 0xf8f9, 0xa438, 0xfafb, 0xa438, 0xef69,
+        0xa438, 0xfae0, 0xa438, 0x8015, 0xa438, 0xad25, 0xa438, 0x45d2,
+        0xa438, 0x0002, 0xa438, 0x8714, 0xa438, 0xac4f, 0xa438, 0x02ae,
+        0xa438, 0x0bef, 0xa438, 0x46f6, 0xa438, 0x273c, 0xa438, 0x0400,
+        0xa438, 0xab26, 0xa438, 0xae30, 0xa438, 0xe08f, 0xa438, 0xe9e1,
+        0xa438, 0x8fea, 0xa438, 0x1b46, 0xa438, 0xab26, 0xa438, 0xef32,
+        0xa438, 0x0c31, 0xa438, 0xbf8f, 0xa438, 0xe91a, 0xa438, 0x93d8,
+        0xa438, 0x19d9, 0xa438, 0x1b46, 0xa438, 0xab0a, 0xa438, 0x19d8,
+        0xa438, 0x19d9, 0xa438, 0x1b46, 0xa438, 0xaa02, 0xa438, 0xae0c,
+        0xa438, 0xbf57, 0xa438, 0x1202, 0xa438, 0x58b1, 0xa438, 0xbf57,
+        0xa438, 0x1202, 0xa438, 0x58a8, 0xa438, 0xfeef, 0xa438, 0x96ff,
+        0xa438, 0xfefd, 0xa438, 0xfc04, 0xa438, 0xf8fb, 0xa438, 0xef79,
+        0xa438, 0xa200, 0xa438, 0x08bf, 0xa438, 0x892e, 0xa438, 0x0252,
+        0xa438, 0xc8ef, 0xa438, 0x64ef, 0xa438, 0x97ff, 0xa438, 0xfc04,
+        0xa438, 0xf8f9, 0xa438, 0xfafb, 0xa438, 0xef69, 0xa438, 0xfae0,
+        0xa438, 0x8015, 0xa438, 0xad25, 0xa438, 0x50d2, 0xa438, 0x0002,
+        0xa438, 0x878d, 0xa438, 0xac4f, 0xa438, 0x02ae, 0xa438, 0x0bef,
+        0xa438, 0x46f6, 0xa438, 0x273c, 0xa438, 0x1000, 0xa438, 0xab31,
+        0xa438, 0xae29, 0xa438, 0xe08f, 0xa438, 0xede1, 0xa438, 0x8fee,
+        0xa438, 0x1b46, 0xa438, 0xab1f, 0xa438, 0xa200, 0xa438, 0x04ef,
+        0xa438, 0x32ae, 0xa438, 0x02d3, 0xa438, 0x010c, 0xa438, 0x31bf,
+        0xa438, 0x8fed, 0xa438, 0x1a93, 0xa438, 0xd819, 0xa438, 0xd91b,
+        0xa438, 0x46ab, 0xa438, 0x0e19, 0xa438, 0xd819, 0xa438, 0xd91b,
+        0xa438, 0x46aa, 0xa438, 0x0612, 0xa438, 0xa205, 0xa438, 0xc0ae,
+        0xa438, 0x0cbf, 0xa438, 0x5712, 0xa438, 0x0258, 0xa438, 0xb1bf,
+        0xa438, 0x5712, 0xa438, 0x0258, 0xa438, 0xa8fe, 0xa438, 0xef96,
+        0xa438, 0xfffe, 0xa438, 0xfdfc, 0xa438, 0x04f8, 0xa438, 0xfbef,
+        0xa438, 0x79a2, 0xa438, 0x0005, 0xa438, 0xbf89, 0xa438, 0x1fae,
+        0xa438, 0x1ba2, 0xa438, 0x0105, 0xa438, 0xbf89, 0xa438, 0x22ae,
+        0xa438, 0x13a2, 0xa438, 0x0205, 0xa438, 0xbf89, 0xa438, 0x25ae,
+        0xa438, 0x0ba2, 0xa438, 0x0305, 0xa438, 0xbf89, 0xa438, 0x28ae,
+        0xa438, 0x03bf, 0xa438, 0x892b, 0xa438, 0x0252, 0xa438, 0xc8ef,
+        0xa438, 0x64ef, 0xa438, 0x97ff, 0xa438, 0xfc04, 0xa438, 0xf8f9,
+        0xa438, 0xfaef, 0xa438, 0x69fa, 0xa438, 0xe080, 0xa438, 0x15ad,
+        0xa438, 0x2628, 0xa438, 0xe081, 0xa438, 0xabe1, 0xa438, 0x81ac,
+        0xa438, 0xef64, 0xa438, 0xbf57, 0xa438, 0x1802, 0xa438, 0x52c8,
+        0xa438, 0x1b46, 0xa438, 0xaa0a, 0xa438, 0xbf57, 0xa438, 0x1b02,
+        0xa438, 0x52c8, 0xa438, 0x1b46, 0xa438, 0xab0c, 0xa438, 0xbf57,
+        0xa438, 0x1502, 0xa438, 0x58b1, 0xa438, 0xbf57, 0xa438, 0x1502,
+        0xa438, 0x58a8, 0xa438, 0xfeef, 0xa438, 0x96fe, 0xa438, 0xfdfc,
+        0xa438, 0x04f8, 0xa438, 0xf9ef, 0xa438, 0x59f9, 0xa438, 0xe080,
+        0xa438, 0x15ad, 0xa438, 0x2622, 0xa438, 0xbf53, 0xa438, 0x2202,
+        0xa438, 0x52c8, 0xa438, 0x3972, 0xa438, 0x9e10, 0xa438, 0xe083,
+        0xa438, 0xc9ac, 0xa438, 0x2605, 0xa438, 0x0288, 0xa438, 0x2cae,
+        0xa438, 0x0d02, 0xa438, 0x8870, 0xa438, 0xae08, 0xa438, 0xe283,
+        0xa438, 0xc9f6, 0xa438, 0x36e6, 0xa438, 0x83c9, 0xa438, 0xfdef,
+        0xa438, 0x95fd, 0xa438, 0xfc04, 0xa438, 0xf8f9, 0xa438, 0xfafb,
+        0xa438, 0xef79, 0xa438, 0xfbbf, 0xa438, 0x5718, 0xa438, 0x0252,
+        0xa438, 0xc8ef, 0xa438, 0x64e2, 0xa438, 0x8fe5, 0xa438, 0xe38f,
+        0xa438, 0xe61b, 0xa438, 0x659e, 0xa438, 0x10e4, 0xa438, 0x8fe5,
+        0xa438, 0xe58f, 0xa438, 0xe6e2, 0xa438, 0x83c9, 0xa438, 0xf636,
+        0xa438, 0xe683, 0xa438, 0xc9ae, 0xa438, 0x13e2, 0xa438, 0x83c9,
+        0xa438, 0xf736, 0xa438, 0xe683, 0xa438, 0xc902, 0xa438, 0x5820,
+        0xa438, 0xef57, 0xa438, 0xe68f, 0xa438, 0xe7e7, 0xa438, 0x8fe8,
+        0xa438, 0xffef, 0xa438, 0x97ff, 0xa438, 0xfefd, 0xa438, 0xfc04,
+        0xa438, 0xf8f9, 0xa438, 0xfafb, 0xa438, 0xef79, 0xa438, 0xfbe2,
+        0xa438, 0x8fe7, 0xa438, 0xe38f, 0xa438, 0xe8ef, 0xa438, 0x65e2,
+        0xa438, 0x81b8, 0xa438, 0xe381, 0xa438, 0xb9ef, 0xa438, 0x7502,
+        0xa438, 0x583b, 0xa438, 0xac50, 0xa438, 0x1abf, 0xa438, 0x5718,
+        0xa438, 0x0252, 0xa438, 0xc8ef, 0xa438, 0x64e2, 0xa438, 0x8fe5,
+        0xa438, 0xe38f, 0xa438, 0xe61b, 0xa438, 0x659e, 0xa438, 0x1ce4,
+        0xa438, 0x8fe5, 0xa438, 0xe58f, 0xa438, 0xe6ae, 0xa438, 0x0cbf,
+        0xa438, 0x5715, 0xa438, 0x0258, 0xa438, 0xb1bf, 0xa438, 0x5715,
+        0xa438, 0x0258, 0xa438, 0xa8e2, 0xa438, 0x83c9, 0xa438, 0xf636,
+        0xa438, 0xe683, 0xa438, 0xc9ff, 0xa438, 0xef97, 0xa438, 0xfffe,
+        0xa438, 0xfdfc, 0xa438, 0x04f8, 0xa438, 0xf9fa, 0xa438, 0xef69,
+        0xa438, 0xe080, 0xa438, 0x15ad, 0xa438, 0x264b, 0xa438, 0xbf53,
+        0xa438, 0xca02, 0xa438, 0x52c8, 0xa438, 0xad28, 0xa438, 0x42bf,
+        0xa438, 0x8931, 0xa438, 0x0252, 0xa438, 0xc8ef, 0xa438, 0x54bf,
+        0xa438, 0x576c, 0xa438, 0x0252, 0xa438, 0xc8a1, 0xa438, 0x001b,
+        0xa438, 0xbf53, 0xa438, 0x4c02, 0xa438, 0x52c8, 0xa438, 0xac29,
+        0xa438, 0x0dac, 0xa438, 0x2805, 0xa438, 0xa302, 0xa438, 0x16ae,
+        0xa438, 0x20a3, 0xa438, 0x0311, 0xa438, 0xae1b, 0xa438, 0xa304,
+        0xa438, 0x0cae, 0xa438, 0x16a3, 0xa438, 0x0802, 0xa438, 0xae11,
+        0xa438, 0xa309, 0xa438, 0x02ae, 0xa438, 0x0cbf, 0xa438, 0x5715,
+        0xa438, 0x0258, 0xa438, 0xb1bf, 0xa438, 0x5715, 0xa438, 0x0258,
+        0xa438, 0xa8ef, 0xa438, 0x96fe, 0xa438, 0xfdfc, 0xa438, 0x04f0,
+        0xa438, 0xa300, 0xa438, 0xf0a3, 0xa438, 0x02f0, 0xa438, 0xa304,
+        0xa438, 0xf0a3, 0xa438, 0x06f0, 0xa438, 0xa308, 0xa438, 0xf0a2,
+        0xa438, 0x8074, 0xa438, 0xa600, 0xa438, 0xac4f, 0xa438, 0x02ae,
+        0xa438, 0x0bef, 0xa438, 0x46f6, 0xa438, 0x273c, 0xa438, 0x1000,
+        0xa438, 0xab1b, 0xa438, 0xae16, 0xa438, 0xe081, 0xa438, 0xabe1,
+        0xa438, 0x81ac, 0xa438, 0x1b46, 0xa438, 0xab0c, 0xa438, 0xac32,
+        0xa438, 0x04ef, 0xa438, 0x32ae, 0xa438, 0x02d3, 0xa438, 0x04af,
+        0xa438, 0x486c, 0xa438, 0xaf48, 0xa438, 0x82af, 0xa438, 0x4888,
+        0xa438, 0xe081, 0xa438, 0x9be1, 0xa438, 0x819c, 0xa438, 0xe28f,
+        0xa438, 0xe3ad, 0xa438, 0x3009, 0xa438, 0x1f55, 0xa438, 0xe38f,
+        0xa438, 0xe20c, 0xa438, 0x581a, 0xa438, 0x45e4, 0xa438, 0x83a6,
+        0xa438, 0xe583, 0xa438, 0xa7af, 0xa438, 0x2a75, 0xa438, 0xe08f,
+        0xa438, 0xe3ad, 0xa438, 0x201c, 0xa438, 0x1f44, 0xa438, 0xe18f,
+        0xa438, 0xe10c, 0xa438, 0x44ef, 0xa438, 0x64e0, 0xa438, 0x8232,
+        0xa438, 0xe182, 0xa438, 0x331b, 0xa438, 0x649f, 0xa438, 0x091f,
+        0xa438, 0x44e1, 0xa438, 0x8fe2, 0xa438, 0x0c48, 0xa438, 0x1b54,
+        0xa438, 0xe683, 0xa438, 0xa6e7, 0xa438, 0x83a7, 0xa438, 0xaf2b,
+        0xa438, 0xd900, 0xa436, 0xb818, 0xa438, 0x043d, 0xa436, 0xb81a,
+        0xa438, 0x06a3, 0xa436, 0xb81c, 0xa438, 0x476d, 0xa436, 0xb81e,
+        0xa438, 0x4852, 0xa436, 0xb850, 0xa438, 0x2A69, 0xa436, 0xb852,
+        0xa438, 0x2BD3, 0xa436, 0xb878, 0xa438, 0xffff, 0xa436, 0xb884,
+        0xa438, 0xffff, 0xa436, 0xb832, 0xa438, 0x003f, 0xb844, 0xffff,
+        0xa436, 0x8fe9, 0xa438, 0x0000, 0xa436, 0x8feb, 0xa438, 0x02fe,
+        0xa436, 0x8fed, 0xa438, 0x0019, 0xa436, 0x8fef, 0xa438, 0x0bdb,
+        0xa436, 0x8ff1, 0xa438, 0x0ca4, 0xa436, 0x0000, 0xa438, 0x0000,
+        0xa436, 0xB82E, 0xa438, 0x0000, 0xa436, 0x8024, 0xa438, 0x0000,
+        0xa436, 0x801E, 0xa438, 0x0024, 0xb820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static const u16  phy_mcu_ram_code_8125d_1_1[] = {
+        0xa436, 0x8023, 0xa438, 0x3800, 0xa436, 0xB82E, 0xa438, 0x0001,
+        0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x8018, 0xa438, 0x1800, 0xa438, 0x8021,
+        0xa438, 0x1800, 0xa438, 0x8029, 0xa438, 0x1800, 0xa438, 0x8031,
+        0xa438, 0x1800, 0xa438, 0x8035, 0xa438, 0x1800, 0xa438, 0x819c,
+        0xa438, 0x1800, 0xa438, 0x81e9, 0xa438, 0xd711, 0xa438, 0x6081,
+        0xa438, 0x8904, 0xa438, 0x1800, 0xa438, 0x2021, 0xa438, 0xa904,
+        0xa438, 0x1800, 0xa438, 0x2021, 0xa438, 0xd75f, 0xa438, 0x4083,
+        0xa438, 0xd503, 0xa438, 0xa908, 0xa438, 0x87f0, 0xa438, 0x1000,
+        0xa438, 0x17e0, 0xa438, 0x1800, 0xa438, 0x13c3, 0xa438, 0xd707,
+        0xa438, 0x2005, 0xa438, 0x8027, 0xa438, 0xd75e, 0xa438, 0x1800,
+        0xa438, 0x1434, 0xa438, 0x1800, 0xa438, 0x14a5, 0xa438, 0xc504,
+        0xa438, 0xce20, 0xa438, 0xcf01, 0xa438, 0xd70a, 0xa438, 0x4005,
+        0xa438, 0xcf02, 0xa438, 0x1800, 0xa438, 0x1c50, 0xa438, 0xa980,
+        0xa438, 0xd500, 0xa438, 0x1800, 0xa438, 0x14f3, 0xa438, 0xd75e,
+        0xa438, 0x67b1, 0xa438, 0xd504, 0xa438, 0xd71e, 0xa438, 0x65bb,
+        0xa438, 0x63da, 0xa438, 0x61f9, 0xa438, 0x0cf0, 0xa438, 0x0c10,
+        0xa438, 0xd505, 0xa438, 0x0c0f, 0xa438, 0x0808, 0xa438, 0xd501,
+        0xa438, 0xce01, 0xa438, 0x0cf0, 0xa438, 0x0470, 0xa438, 0x0cf0,
+        0xa438, 0x0430, 0xa438, 0x0cf0, 0xa438, 0x0410, 0xa438, 0xf02a,
+        0xa438, 0x0cf0, 0xa438, 0x0c20, 0xa438, 0xd505, 0xa438, 0x0c0f,
+        0xa438, 0x0804, 0xa438, 0xd501, 0xa438, 0xce01, 0xa438, 0x0cf0,
+        0xa438, 0x0470, 0xa438, 0x0cf0, 0xa438, 0x0430, 0xa438, 0x0cf0,
+        0xa438, 0x0420, 0xa438, 0xf01c, 0xa438, 0x0cf0, 0xa438, 0x0c40,
+        0xa438, 0xd505, 0xa438, 0x0c0f, 0xa438, 0x0802, 0xa438, 0xd501,
+        0xa438, 0xce01, 0xa438, 0x0cf0, 0xa438, 0x0470, 0xa438, 0x0cf0,
+        0xa438, 0x0450, 0xa438, 0x0cf0, 0xa438, 0x0440, 0xa438, 0xf00e,
+        0xa438, 0x0cf0, 0xa438, 0x0c80, 0xa438, 0xd505, 0xa438, 0x0c0f,
+        0xa438, 0x0801, 0xa438, 0xd501, 0xa438, 0xce01, 0xa438, 0x0cf0,
+        0xa438, 0x04b0, 0xa438, 0x0cf0, 0xa438, 0x0490, 0xa438, 0x0cf0,
+        0xa438, 0x0480, 0xa438, 0xd501, 0xa438, 0xce00, 0xa438, 0xd500,
+        0xa438, 0xc48e, 0xa438, 0x1000, 0xa438, 0x1a41, 0xa438, 0xd718,
+        0xa438, 0x5faf, 0xa438, 0xd504, 0xa438, 0x8e01, 0xa438, 0x8c0f,
+        0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x17e0, 0xa438, 0xd504,
+        0xa438, 0xd718, 0xa438, 0x4074, 0xa438, 0x6195, 0xa438, 0xf005,
+        0xa438, 0x60f5, 0xa438, 0x0c03, 0xa438, 0x0d00, 0xa438, 0xf009,
+        0xa438, 0x0c03, 0xa438, 0x0d01, 0xa438, 0xf006, 0xa438, 0x0c03,
+        0xa438, 0x0d02, 0xa438, 0xf003, 0xa438, 0x0c03, 0xa438, 0x0d03,
+        0xa438, 0xd500, 0xa438, 0xd706, 0xa438, 0x2529, 0xa438, 0x809c,
+        0xa438, 0xd718, 0xa438, 0x607b, 0xa438, 0x40da, 0xa438, 0xf00f,
+        0xa438, 0x431a, 0xa438, 0xf021, 0xa438, 0xd718, 0xa438, 0x617b,
+        0xa438, 0x1000, 0xa438, 0x1a41, 0xa438, 0x1000, 0xa438, 0x1ad1,
+        0xa438, 0xd718, 0xa438, 0x608e, 0xa438, 0xd73e, 0xa438, 0x5f34,
+        0xa438, 0xf020, 0xa438, 0xf053, 0xa438, 0x1000, 0xa438, 0x1a41,
+        0xa438, 0x1000, 0xa438, 0x1ad1, 0xa438, 0xd718, 0xa438, 0x608e,
+        0xa438, 0xd73e, 0xa438, 0x5f34, 0xa438, 0xf023, 0xa438, 0xf067,
+        0xa438, 0x1000, 0xa438, 0x1a41, 0xa438, 0x1000, 0xa438, 0x1ad1,
+        0xa438, 0xd718, 0xa438, 0x608e, 0xa438, 0xd73e, 0xa438, 0x5f34,
+        0xa438, 0xf026, 0xa438, 0xf07b, 0xa438, 0x1000, 0xa438, 0x1a41,
+        0xa438, 0x1000, 0xa438, 0x1ad1, 0xa438, 0xd718, 0xa438, 0x608e,
+        0xa438, 0xd73e, 0xa438, 0x5f34, 0xa438, 0xf029, 0xa438, 0xf08f,
+        0xa438, 0x1000, 0xa438, 0x8173, 0xa438, 0x1000, 0xa438, 0x1a41,
+        0xa438, 0xd73e, 0xa438, 0x7fb4, 0xa438, 0x1000, 0xa438, 0x8188,
+        0xa438, 0x1000, 0xa438, 0x1a41, 0xa438, 0xd718, 0xa438, 0x5fae,
+        0xa438, 0xf028, 0xa438, 0x1000, 0xa438, 0x8173, 0xa438, 0x1000,
+        0xa438, 0x1a41, 0xa438, 0xd73e, 0xa438, 0x7fb4, 0xa438, 0x1000,
+        0xa438, 0x8188, 0xa438, 0x1000, 0xa438, 0x1a41, 0xa438, 0xd718,
+        0xa438, 0x5fae, 0xa438, 0xf039, 0xa438, 0x1000, 0xa438, 0x8173,
+        0xa438, 0x1000, 0xa438, 0x1a41, 0xa438, 0xd73e, 0xa438, 0x7fb4,
+        0xa438, 0x1000, 0xa438, 0x8188, 0xa438, 0x1000, 0xa438, 0x1a41,
+        0xa438, 0xd718, 0xa438, 0x5fae, 0xa438, 0xf04a, 0xa438, 0x1000,
+        0xa438, 0x8173, 0xa438, 0x1000, 0xa438, 0x1a41, 0xa438, 0xd73e,
+        0xa438, 0x7fb4, 0xa438, 0x1000, 0xa438, 0x8188, 0xa438, 0x1000,
+        0xa438, 0x1a41, 0xa438, 0xd718, 0xa438, 0x5fae, 0xa438, 0xf05b,
+        0xa438, 0xd719, 0xa438, 0x4119, 0xa438, 0xd504, 0xa438, 0xac01,
+        0xa438, 0xae01, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1a2f,
+        0xa438, 0xf00a, 0xa438, 0xd719, 0xa438, 0x4118, 0xa438, 0xd504,
+        0xa438, 0xac11, 0xa438, 0xd501, 0xa438, 0xce01, 0xa438, 0xa410,
+        0xa438, 0xce00, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1a41,
+        0xa438, 0xd718, 0xa438, 0x5fb0, 0xa438, 0xd505, 0xa438, 0xd719,
+        0xa438, 0x4079, 0xa438, 0xa80f, 0xa438, 0xf05d, 0xa438, 0x4b98,
+        0xa438, 0xa808, 0xa438, 0xf05a, 0xa438, 0xd719, 0xa438, 0x4119,
+        0xa438, 0xd504, 0xa438, 0xac02, 0xa438, 0xae01, 0xa438, 0xd500,
+        0xa438, 0x1000, 0xa438, 0x1a2f, 0xa438, 0xf00a, 0xa438, 0xd719,
+        0xa438, 0x4118, 0xa438, 0xd504, 0xa438, 0xac22, 0xa438, 0xd501,
+        0xa438, 0xce01, 0xa438, 0xa420, 0xa438, 0xce00, 0xa438, 0xd500,
+        0xa438, 0x1000, 0xa438, 0x1a41, 0xa438, 0xd718, 0xa438, 0x5fb0,
+        0xa438, 0xd505, 0xa438, 0xd719, 0xa438, 0x4079, 0xa438, 0xa80f,
+        0xa438, 0xf03f, 0xa438, 0x47d8, 0xa438, 0xa804, 0xa438, 0xf03c,
+        0xa438, 0xd719, 0xa438, 0x4119, 0xa438, 0xd504, 0xa438, 0xac04,
+        0xa438, 0xae01, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1a2f,
+        0xa438, 0xf00a, 0xa438, 0xd719, 0xa438, 0x4118, 0xa438, 0xd504,
+        0xa438, 0xac44, 0xa438, 0xd501, 0xa438, 0xce01, 0xa438, 0xa440,
+        0xa438, 0xce00, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1a41,
+        0xa438, 0xd718, 0xa438, 0x5fb0, 0xa438, 0xd505, 0xa438, 0xd719,
+        0xa438, 0x4079, 0xa438, 0xa80f, 0xa438, 0xf021, 0xa438, 0x4418,
+        0xa438, 0xa802, 0xa438, 0xf01e, 0xa438, 0xd719, 0xa438, 0x4119,
+        0xa438, 0xd504, 0xa438, 0xac08, 0xa438, 0xae01, 0xa438, 0xd500,
+        0xa438, 0x1000, 0xa438, 0x1a2f, 0xa438, 0xf00a, 0xa438, 0xd719,
+        0xa438, 0x4118, 0xa438, 0xd504, 0xa438, 0xac88, 0xa438, 0xd501,
+        0xa438, 0xce01, 0xa438, 0xa480, 0xa438, 0xce00, 0xa438, 0xd500,
+        0xa438, 0x1000, 0xa438, 0x1a41, 0xa438, 0xd718, 0xa438, 0x5fb0,
+        0xa438, 0xd505, 0xa438, 0xd719, 0xa438, 0x4079, 0xa438, 0xa80f,
+        0xa438, 0xf003, 0xa438, 0x4058, 0xa438, 0xa801, 0xa438, 0x1800,
+        0xa438, 0x16ed, 0xa438, 0xd73e, 0xa438, 0xd505, 0xa438, 0x3088,
+        0xa438, 0x817a, 0xa438, 0x6193, 0xa438, 0x6132, 0xa438, 0x60d1,
+        0xa438, 0x3298, 0xa438, 0x8185, 0xa438, 0xf00a, 0xa438, 0xa808,
+        0xa438, 0xf008, 0xa438, 0xa804, 0xa438, 0xf006, 0xa438, 0xa802,
+        0xa438, 0xf004, 0xa438, 0xa801, 0xa438, 0xf002, 0xa438, 0xa80f,
+        0xa438, 0xd500, 0xa438, 0x0800, 0xa438, 0xd505, 0xa438, 0xd75e,
+        0xa438, 0x6211, 0xa438, 0xd71e, 0xa438, 0x619b, 0xa438, 0x611a,
+        0xa438, 0x6099, 0xa438, 0x0c0f, 0xa438, 0x0808, 0xa438, 0xf009,
+        0xa438, 0x0c0f, 0xa438, 0x0804, 0xa438, 0xf006, 0xa438, 0x0c0f,
+        0xa438, 0x0802, 0xa438, 0xf003, 0xa438, 0x0c0f, 0xa438, 0x0801,
+        0xa438, 0xd500, 0xa438, 0x0800, 0xa438, 0xd500, 0xa438, 0xc48d,
+        0xa438, 0xd504, 0xa438, 0x8d03, 0xa438, 0xd701, 0xa438, 0x4045,
+        0xa438, 0xad02, 0xa438, 0xd504, 0xa438, 0xd706, 0xa438, 0x2529,
+        0xa438, 0x81ad, 0xa438, 0xd718, 0xa438, 0x607b, 0xa438, 0x40da,
+        0xa438, 0xf013, 0xa438, 0x441a, 0xa438, 0xf02d, 0xa438, 0xd718,
+        0xa438, 0x61fb, 0xa438, 0xbb01, 0xa438, 0xd75e, 0xa438, 0x6171,
+        0xa438, 0x0cf0, 0xa438, 0x0c10, 0xa438, 0xd501, 0xa438, 0xce01,
+        0xa438, 0x0cf0, 0xa438, 0x0410, 0xa438, 0xce00, 0xa438, 0xd505,
+        0xa438, 0x0c0f, 0xa438, 0x0808, 0xa438, 0xf02a, 0xa438, 0xbb02,
+        0xa438, 0xd75e, 0xa438, 0x6171, 0xa438, 0x0cf0, 0xa438, 0x0c20,
+        0xa438, 0xd501, 0xa438, 0xce01, 0xa438, 0x0cf0, 0xa438, 0x0420,
+        0xa438, 0xce00, 0xa438, 0xd505, 0xa438, 0x0c0f, 0xa438, 0x0804,
+        0xa438, 0xf01c, 0xa438, 0xbb04, 0xa438, 0xd75e, 0xa438, 0x6171,
+        0xa438, 0x0cf0, 0xa438, 0x0c40, 0xa438, 0xd501, 0xa438, 0xce01,
+        0xa438, 0x0cf0, 0xa438, 0x0440, 0xa438, 0xce00, 0xa438, 0xd505,
+        0xa438, 0x0c0f, 0xa438, 0x0802, 0xa438, 0xf00e, 0xa438, 0xbb08,
+        0xa438, 0xd75e, 0xa438, 0x6171, 0xa438, 0x0cf0, 0xa438, 0x0c80,
+        0xa438, 0xd501, 0xa438, 0xce01, 0xa438, 0x0cf0, 0xa438, 0x0480,
+        0xa438, 0xce00, 0xa438, 0xd505, 0xa438, 0x0c0f, 0xa438, 0x0801,
+        0xa438, 0xd500, 0xa438, 0x1800, 0xa438, 0x1616, 0xa436, 0xA026,
+        0xa438, 0xffff, 0xa436, 0xA024, 0xa438, 0x15d8, 0xa436, 0xA022,
+        0xa438, 0x161f, 0xa436, 0xA020, 0xa438, 0x14f2, 0xa436, 0xA006,
+        0xa438, 0x1c4f, 0xa436, 0xA004, 0xa438, 0x1433, 0xa436, 0xA002,
+        0xa438, 0x13c1, 0xa436, 0xA000, 0xa438, 0x2020, 0xa436, 0xA008,
+        0xa438, 0x7f00, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+        0xa438, 0x07f8, 0xa436, 0xA014, 0xa438, 0xd04d, 0xa438, 0x8904,
+        0xa438, 0x813C, 0xa438, 0xA13D, 0xa438, 0xcc01, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa436, 0xA152, 0xa438, 0x1384,
+        0xa436, 0xA154, 0xa438, 0x1fa8, 0xa436, 0xA156, 0xa438, 0x218B,
+        0xa436, 0xA158, 0xa438, 0x21B8, 0xa436, 0xA15A, 0xa438, 0x021c,
+        0xa436, 0xA15C, 0xa438, 0x3fff, 0xa436, 0xA15E, 0xa438, 0x3fff,
+        0xa436, 0xA160, 0xa438, 0x3fff, 0xa436, 0xA150, 0xa438, 0x001f,
+        0xa436, 0xA016, 0xa438, 0x0010, 0xa436, 0xA012, 0xa438, 0x0000,
+        0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010, 0xa438, 0x1800,
+        0xa438, 0x8013, 0xa438, 0x1800, 0xa438, 0x803a, 0xa438, 0x1800,
+        0xa438, 0x8045, 0xa438, 0x1800, 0xa438, 0x8049, 0xa438, 0x1800,
+        0xa438, 0x804d, 0xa438, 0x1800, 0xa438, 0x8059, 0xa438, 0x1800,
+        0xa438, 0x805d, 0xa438, 0xc2ff, 0xa438, 0x1800, 0xa438, 0x0042,
+        0xa438, 0x1000, 0xa438, 0x02e5, 0xa438, 0x1000, 0xa438, 0x02b4,
+        0xa438, 0xd701, 0xa438, 0x40e3, 0xa438, 0xd700, 0xa438, 0x5f6c,
+        0xa438, 0x1000, 0xa438, 0x8021, 0xa438, 0x1800, 0xa438, 0x0073,
+        0xa438, 0x1800, 0xa438, 0x0084, 0xa438, 0xd701, 0xa438, 0x4061,
+        0xa438, 0xba0f, 0xa438, 0xf004, 0xa438, 0x4060, 0xa438, 0x1000,
+        0xa438, 0x802a, 0xa438, 0xba10, 0xa438, 0x0800, 0xa438, 0xd700,
+        0xa438, 0x60bb, 0xa438, 0x611c, 0xa438, 0x0c0f, 0xa438, 0x1a01,
+        0xa438, 0xf00a, 0xa438, 0x60fc, 0xa438, 0x0c0f, 0xa438, 0x1a02,
+        0xa438, 0xf006, 0xa438, 0x0c0f, 0xa438, 0x1a04, 0xa438, 0xf003,
+        0xa438, 0x0c0f, 0xa438, 0x1a08, 0xa438, 0x0800, 0xa438, 0x0c0f,
+        0xa438, 0x0504, 0xa438, 0xad02, 0xa438, 0x1000, 0xa438, 0x02c0,
+        0xa438, 0xd700, 0xa438, 0x5fac, 0xa438, 0x1000, 0xa438, 0x8021,
+        0xa438, 0x1800, 0xa438, 0x0139, 0xa438, 0x9a1f, 0xa438, 0x8bf0,
+        0xa438, 0x1800, 0xa438, 0x02df, 0xa438, 0x9a1f, 0xa438, 0x9910,
+        0xa438, 0x1800, 0xa438, 0x02d7, 0xa438, 0xad02, 0xa438, 0x8d01,
+        0xa438, 0x9a1f, 0xa438, 0x9910, 0xa438, 0x9860, 0xa438, 0xcb00,
+        0xa438, 0xd501, 0xa438, 0xce01, 0xa438, 0x85f0, 0xa438, 0xd500,
+        0xa438, 0x1800, 0xa438, 0x015c, 0xa438, 0x8580, 0xa438, 0x8d02,
+        0xa438, 0x1800, 0xa438, 0x018f, 0xa438, 0x0c0f, 0xa438, 0x0503,
+        0xa438, 0xad02, 0xa438, 0x1800, 0xa438, 0x00dd, 0xa436, 0xA08E,
+        0xa438, 0x00db, 0xa436, 0xA08C, 0xa438, 0x018e, 0xa436, 0xA08A,
+        0xa438, 0x015a, 0xa436, 0xA088, 0xa438, 0x02d6, 0xa436, 0xA086,
+        0xa438, 0x02de, 0xa436, 0xA084, 0xa438, 0x0137, 0xa436, 0xA082,
+        0xa438, 0x0071, 0xa436, 0xA080, 0xa438, 0x0041, 0xa436, 0xA090,
+        0xa438, 0x00ff, 0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012,
+        0xa438, 0x1ff8, 0xa436, 0xA014, 0xa438, 0x001c, 0xa438, 0xce15,
+        0xa438, 0xd105, 0xa438, 0xa410, 0xa438, 0x8320, 0xa438, 0xFFD7,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa436, 0xA164, 0xa438, 0x0260,
+        0xa436, 0xA166, 0xa438, 0x0add, 0xa436, 0xA168, 0xa438, 0x05CC,
+        0xa436, 0xA16A, 0xa438, 0x05C5, 0xa436, 0xA16C, 0xa438, 0x0429,
+        0xa436, 0xA16E, 0xa438, 0x07B6, 0xa436, 0xA170, 0xa438, 0x0259,
+        0xa436, 0xA172, 0xa438, 0x3fff, 0xa436, 0xA162, 0xa438, 0x003f,
+        0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x0000,
+        0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010, 0xa438, 0x1800,
+        0xa438, 0x8023, 0xa438, 0x1800, 0xa438, 0x814c, 0xa438, 0x1800,
+        0xa438, 0x8156, 0xa438, 0x1800, 0xa438, 0x815e, 0xa438, 0x1800,
+        0xa438, 0x8210, 0xa438, 0x1800, 0xa438, 0x8221, 0xa438, 0x1800,
+        0xa438, 0x822f, 0xa438, 0xa801, 0xa438, 0x9308, 0xa438, 0xb201,
+        0xa438, 0xb301, 0xa438, 0xd701, 0xa438, 0x4000, 0xa438, 0xd2ff,
+        0xa438, 0xb302, 0xa438, 0xd200, 0xa438, 0xb201, 0xa438, 0xb309,
+        0xa438, 0xd701, 0xa438, 0x4000, 0xa438, 0xd2ff, 0xa438, 0xb302,
+        0xa438, 0xd200, 0xa438, 0xa800, 0xa438, 0x1800, 0xa438, 0x0031,
+        0xa438, 0xd700, 0xa438, 0x4543, 0xa438, 0xd71f, 0xa438, 0x40fe,
+        0xa438, 0xd1b7, 0xa438, 0xd049, 0xa438, 0x1000, 0xa438, 0x109e,
+        0xa438, 0xd700, 0xa438, 0x5fbb, 0xa438, 0xa220, 0xa438, 0x8501,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0c70, 0xa438, 0x0b00,
+        0xa438, 0x0c07, 0xa438, 0x0604, 0xa438, 0x9503, 0xa438, 0xa510,
+        0xa438, 0xce49, 0xa438, 0x1000, 0xa438, 0x10be, 0xa438, 0x8520,
+        0xa438, 0xa520, 0xa438, 0xa501, 0xa438, 0xd105, 0xa438, 0xd047,
+        0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd707, 0xa438, 0x6087,
+        0xa438, 0xd700, 0xa438, 0x5f7b, 0xa438, 0xffe9, 0xa438, 0x1000,
+        0xa438, 0x109e, 0xa438, 0x8501, 0xa438, 0xd707, 0xa438, 0x5e08,
+        0xa438, 0x8530, 0xa438, 0xba20, 0xa438, 0xf00c, 0xa438, 0xd700,
+        0xa438, 0x4098, 0xa438, 0xd1ef, 0xa438, 0xd047, 0xa438, 0xf003,
+        0xa438, 0xd1db, 0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x109e,
+        0xa438, 0xd700, 0xa438, 0x5fbb, 0xa438, 0x8980, 0xa438, 0xd702,
+        0xa438, 0x6126, 0xa438, 0xd704, 0xa438, 0x4063, 0xa438, 0xd702,
+        0xa438, 0x6060, 0xa438, 0xd702, 0xa438, 0x6077, 0xa438, 0x8410,
+        0xa438, 0xf002, 0xa438, 0xa410, 0xa438, 0xce02, 0xa438, 0x1000,
+        0xa438, 0x10be, 0xa438, 0xcd81, 0xa438, 0xd412, 0xa438, 0x1000,
+        0xa438, 0x1069, 0xa438, 0xcd82, 0xa438, 0xd40e, 0xa438, 0x1000,
+        0xa438, 0x1069, 0xa438, 0xcd83, 0xa438, 0x1000, 0xa438, 0x109e,
+        0xa438, 0xd71f, 0xa438, 0x5fb4, 0xa438, 0xd702, 0xa438, 0x6c26,
+        0xa438, 0xd704, 0xa438, 0x4063, 0xa438, 0xd702, 0xa438, 0x6060,
+        0xa438, 0xd702, 0xa438, 0x6b77, 0xa438, 0xa340, 0xa438, 0x0c06,
+        0xa438, 0x0102, 0xa438, 0xce01, 0xa438, 0x1000, 0xa438, 0x10be,
+        0xa438, 0xa240, 0xa438, 0xa902, 0xa438, 0xa204, 0xa438, 0xa280,
+        0xa438, 0xa364, 0xa438, 0xab02, 0xa438, 0x8380, 0xa438, 0xa00a,
+        0xa438, 0xcd8d, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd706,
+        0xa438, 0x5fb5, 0xa438, 0xb920, 0xa438, 0x1000, 0xa438, 0x109e,
+        0xa438, 0xd71f, 0xa438, 0x7fb4, 0xa438, 0x9920, 0xa438, 0x1000,
+        0xa438, 0x109e, 0xa438, 0xd71f, 0xa438, 0x6065, 0xa438, 0x7c74,
+        0xa438, 0xfffb, 0xa438, 0xb820, 0xa438, 0x1000, 0xa438, 0x109e,
+        0xa438, 0xd71f, 0xa438, 0x7fa5, 0xa438, 0x9820, 0xa438, 0xa410,
+        0xa438, 0x8902, 0xa438, 0xa120, 0xa438, 0xa380, 0xa438, 0xce02,
+        0xa438, 0x1000, 0xa438, 0x10be, 0xa438, 0x8280, 0xa438, 0xa324,
+        0xa438, 0xab02, 0xa438, 0xa00a, 0xa438, 0x8118, 0xa438, 0x863f,
+        0xa438, 0x87fb, 0xa438, 0xcd8e, 0xa438, 0xd193, 0xa438, 0xd047,
+        0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0x1000, 0xa438, 0x10a3,
+        0xa438, 0xd700, 0xa438, 0x5f7b, 0xa438, 0xa280, 0xa438, 0x1000,
+        0xa438, 0x109e, 0xa438, 0x1000, 0xa438, 0x10a3, 0xa438, 0xd706,
+        0xa438, 0x5f78, 0xa438, 0xa210, 0xa438, 0xd700, 0xa438, 0x6083,
+        0xa438, 0xd101, 0xa438, 0xd047, 0xa438, 0xf003, 0xa438, 0xd160,
+        0xa438, 0xd04b, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0x1000,
+        0xa438, 0x10a3, 0xa438, 0xd700, 0xa438, 0x5f7b, 0xa438, 0x1000,
+        0xa438, 0x109e, 0xa438, 0x1000, 0xa438, 0x10a3, 0xa438, 0xd706,
+        0xa438, 0x5f79, 0xa438, 0x8120, 0xa438, 0xbb20, 0xa438, 0xf04c,
+        0xa438, 0xa00a, 0xa438, 0xa340, 0xa438, 0x0c06, 0xa438, 0x0102,
+        0xa438, 0xa240, 0xa438, 0xa290, 0xa438, 0xa324, 0xa438, 0xab02,
+        0xa438, 0xd13e, 0xa438, 0xd05a, 0xa438, 0xd13e, 0xa438, 0xd06b,
+        0xa438, 0xcd84, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd706,
+        0xa438, 0x6079, 0xa438, 0xd700, 0xa438, 0x5f5c, 0xa438, 0xcd8a,
+        0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd706, 0xa438, 0x6079,
+        0xa438, 0xd700, 0xa438, 0x5f5d, 0xa438, 0xcd8b, 0xa438, 0x1000,
+        0xa438, 0x109e, 0xa438, 0xcd8c, 0xa438, 0xd700, 0xa438, 0x6050,
+        0xa438, 0xab04, 0xa438, 0xd700, 0xa438, 0x4083, 0xa438, 0xd160,
+        0xa438, 0xd04b, 0xa438, 0xf003, 0xa438, 0xd193, 0xa438, 0xd047,
+        0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd700, 0xa438, 0x5fbb,
+        0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0x8410, 0xa438, 0xd71f,
+        0xa438, 0x5f94, 0xa438, 0xb920, 0xa438, 0x1000, 0xa438, 0x109e,
+        0xa438, 0xd71f, 0xa438, 0x7fb4, 0xa438, 0x9920, 0xa438, 0x1000,
+        0xa438, 0x109e, 0xa438, 0xd71f, 0xa438, 0x6105, 0xa438, 0x6054,
+        0xa438, 0xfffb, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd706,
+        0xa438, 0x5fb9, 0xa438, 0xfff0, 0xa438, 0xa410, 0xa438, 0xb820,
+        0xa438, 0xcd85, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd71f,
+        0xa438, 0x7fa5, 0xa438, 0x9820, 0xa438, 0xbb20, 0xa438, 0xd105,
+        0xa438, 0xd042, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd706,
+        0xa438, 0x5fbb, 0xa438, 0x5f85, 0xa438, 0xd700, 0xa438, 0x5f5b,
+        0xa438, 0xd700, 0xa438, 0x6090, 0xa438, 0xd700, 0xa438, 0x4043,
+        0xa438, 0xaa20, 0xa438, 0xcd86, 0xa438, 0xd700, 0xa438, 0x6083,
+        0xa438, 0xd1c7, 0xa438, 0xd045, 0xa438, 0xf003, 0xa438, 0xd17a,
+        0xa438, 0xd04b, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd700,
+        0xa438, 0x5fbb, 0xa438, 0x0c18, 0xa438, 0x0108, 0xa438, 0x0c3f,
+        0xa438, 0x0609, 0xa438, 0x0cfb, 0xa438, 0x0729, 0xa438, 0xa308,
+        0xa438, 0x8320, 0xa438, 0xd105, 0xa438, 0xd042, 0xa438, 0x1000,
+        0xa438, 0x109e, 0xa438, 0xd700, 0xa438, 0x5fbb, 0xa438, 0x1800,
+        0xa438, 0x08f7, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0x1000,
+        0xa438, 0x10a3, 0xa438, 0xd700, 0xa438, 0x607b, 0xa438, 0xd700,
+        0xa438, 0x5f2b, 0xa438, 0x1800, 0xa438, 0x0a81, 0xa438, 0xd700,
+        0xa438, 0x40bd, 0xa438, 0xd707, 0xa438, 0x4065, 0xa438, 0x1800,
+        0xa438, 0x1121, 0xa438, 0x1800, 0xa438, 0x1124, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8f80, 0xa438, 0x9503, 0xa438, 0xd705,
+        0xa438, 0x641d, 0xa438, 0xd704, 0xa438, 0x62b2, 0xa438, 0xd702,
+        0xa438, 0x4116, 0xa438, 0xce15, 0xa438, 0x1000, 0xa438, 0x10be,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8f40, 0xa438, 0x9503,
+        0xa438, 0xa00a, 0xa438, 0xd704, 0xa438, 0x4247, 0xa438, 0xd700,
+        0xa438, 0x3691, 0xa438, 0x8183, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa570, 0xa438, 0x9503, 0xa438, 0xf00a, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xaf40, 0xa438, 0x9503, 0xa438, 0x800a,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8570, 0xa438, 0x9503,
+        0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0x1000, 0xa438, 0x1108,
+        0xa438, 0xcd64, 0xa438, 0xd704, 0xa438, 0x3398, 0xa438, 0x8203,
+        0xa438, 0xd71f, 0xa438, 0x620e, 0xa438, 0xd704, 0xa438, 0x6096,
+        0xa438, 0xd705, 0xa438, 0x6051, 0xa438, 0xf004, 0xa438, 0xd705,
+        0xa438, 0x605d, 0xa438, 0xf008, 0xa438, 0xd706, 0xa438, 0x609d,
+        0xa438, 0xd705, 0xa438, 0x405f, 0xa438, 0xf003, 0xa438, 0xd700,
+        0xa438, 0x58fb, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xc7aa,
+        0xa438, 0x9503, 0xa438, 0xd71f, 0xa438, 0x6d2e, 0xa438, 0xd704,
+        0xa438, 0x6096, 0xa438, 0xd705, 0xa438, 0x6051, 0xa438, 0xf005,
+        0xa438, 0xd705, 0xa438, 0x607d, 0xa438, 0x1800, 0xa438, 0x0cc7,
+        0xa438, 0xd706, 0xa438, 0x60bd, 0xa438, 0xd705, 0xa438, 0x407f,
+        0xa438, 0x1800, 0xa438, 0x0e42, 0xa438, 0xd702, 0xa438, 0x40a4,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8e20, 0xa438, 0x9503,
+        0xa438, 0xd702, 0xa438, 0x40a5, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8e40, 0xa438, 0x9503, 0xa438, 0xd705, 0xa438, 0x659d,
+        0xa438, 0xd704, 0xa438, 0x62b2, 0xa438, 0xd702, 0xa438, 0x4116,
+        0xa438, 0xce15, 0xa438, 0x1000, 0xa438, 0x10be, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8f40, 0xa438, 0x9503, 0xa438, 0xa00a,
+        0xa438, 0xd704, 0xa438, 0x4247, 0xa438, 0xd700, 0xa438, 0x3691,
+        0xa438, 0x81de, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa570,
+        0xa438, 0x9503, 0xa438, 0xf00a, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xaf40, 0xa438, 0x9503, 0xa438, 0x800a, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8570, 0xa438, 0x9503, 0xa438, 0xd706,
+        0xa438, 0x60e4, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0cf0,
+        0xa438, 0x07a0, 0xa438, 0x9503, 0xa438, 0xf005, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x87f0, 0xa438, 0x9503, 0xa438, 0x1000,
+        0xa438, 0x109e, 0xa438, 0x1000, 0xa438, 0x1108, 0xa438, 0xcd61,
+        0xa438, 0xd704, 0xa438, 0x3398, 0xa438, 0x8203, 0xa438, 0xd704,
+        0xa438, 0x6096, 0xa438, 0xd705, 0xa438, 0x6051, 0xa438, 0xf005,
+        0xa438, 0xd705, 0xa438, 0x607d, 0xa438, 0x1800, 0xa438, 0x0cc7,
+        0xa438, 0xd71f, 0xa438, 0x61ce, 0xa438, 0xd706, 0xa438, 0x767d,
+        0xa438, 0xd705, 0xa438, 0x563f, 0xa438, 0x1800, 0xa438, 0x0e42,
+        0xa438, 0x800a, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xae40,
+        0xa438, 0x9503, 0xa438, 0x1800, 0xa438, 0x0c47, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xaf80, 0xa438, 0x9503, 0xa438, 0x1800,
+        0xa438, 0x0b5f, 0xa438, 0x607c, 0xa438, 0x1800, 0xa438, 0x027a,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xae01, 0xa438, 0x9503,
+        0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd702, 0xa438, 0x5fa3,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8e01, 0xa438, 0x9503,
+        0xa438, 0x1800, 0xa438, 0x027d, 0xa438, 0x1000, 0xa438, 0x10be,
+        0xa438, 0xd702, 0xa438, 0x40a5, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8e40, 0xa438, 0x9503, 0xa438, 0xd73e, 0xa438, 0x6065,
+        0xa438, 0x1800, 0xa438, 0x0cea, 0xa438, 0x1800, 0xa438, 0x0cf4,
+        0xa438, 0xd701, 0xa438, 0x6fd1, 0xa438, 0xd71f, 0xa438, 0x6eee,
+        0xa438, 0xd707, 0xa438, 0x4d0f, 0xa438, 0xd73e, 0xa438, 0x4cc5,
+        0xa438, 0xd705, 0xa438, 0x4c99, 0xa438, 0xd704, 0xa438, 0x6c57,
+        0xa438, 0xd702, 0xa438, 0x6c11, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8c20, 0xa438, 0xa608, 0xa438, 0x9503, 0xa438, 0xa201,
+        0xa438, 0xa804, 0xa438, 0xd704, 0xa438, 0x40a7, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xa620, 0xa438, 0x9503, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xac40, 0xa438, 0x9503, 0xa438, 0x800a,
+        0xa438, 0x8290, 0xa438, 0x8306, 0xa438, 0x8b02, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8570, 0xa438, 0x9503, 0xa438, 0xce00,
+        0xa438, 0x1000, 0xa438, 0x10be, 0xa438, 0xcd99, 0xa438, 0x1000,
+        0xa438, 0x109e, 0xa438, 0x1000, 0xa438, 0x10cc, 0xa438, 0xd701,
+        0xa438, 0x69f1, 0xa438, 0xd71f, 0xa438, 0x690e, 0xa438, 0xd73e,
+        0xa438, 0x5ee6, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x87f0,
+        0xa438, 0x9503, 0xa438, 0xce46, 0xa438, 0x1000, 0xa438, 0x10be,
+        0xa438, 0xa00a, 0xa438, 0xd704, 0xa438, 0x40a7, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xa570, 0xa438, 0x9503, 0xa438, 0xcd9a,
+        0xa438, 0xd700, 0xa438, 0x6078, 0xa438, 0xd700, 0xa438, 0x609a,
+        0xa438, 0xd109, 0xa438, 0xd074, 0xa438, 0xf003, 0xa438, 0xd109,
+        0xa438, 0xd075, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0x1000,
+        0xa438, 0x10cc, 0xa438, 0xd701, 0xa438, 0x65b1, 0xa438, 0xd71f,
+        0xa438, 0x64ce, 0xa438, 0xd700, 0xa438, 0x5efe, 0xa438, 0xce00,
+        0xa438, 0x1000, 0xa438, 0x10be, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8608, 0xa438, 0x8c40, 0xa438, 0x9503, 0xa438, 0x8201,
+        0xa438, 0x800a, 0xa438, 0x8290, 0xa438, 0x8306, 0xa438, 0x8b02,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xc7aa, 0xa438, 0x8570,
+        0xa438, 0x8d08, 0xa438, 0x9503, 0xa438, 0xcd9b, 0xa438, 0x1800,
+        0xa438, 0x0c8b, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd705,
+        0xa438, 0x61d9, 0xa438, 0xd704, 0xa438, 0x4193, 0xa438, 0x800a,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xae40, 0xa438, 0x9503,
+        0xa438, 0x1800, 0xa438, 0x0c47, 0xa438, 0x1800, 0xa438, 0x0df8,
+        0xa438, 0x1800, 0xa438, 0x8339, 0xa438, 0x0800, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8d08, 0xa438, 0x8f02, 0xa438, 0x8c40,
+        0xa438, 0x9503, 0xa438, 0x8201, 0xa438, 0xa804, 0xa438, 0xd704,
+        0xa438, 0x40a7, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa620,
+        0xa438, 0x9503, 0xa438, 0x800a, 0xa438, 0x8290, 0xa438, 0x8306,
+        0xa438, 0x8b02, 0xa438, 0x8010, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8570, 0xa438, 0x9503, 0xa438, 0xaa03, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xac20, 0xa438, 0xa608, 0xa438, 0x9503,
+        0xa438, 0xce00, 0xa438, 0x1000, 0xa438, 0x10be, 0xa438, 0xcd95,
+        0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd701, 0xa438, 0x7b91,
+        0xa438, 0xd71f, 0xa438, 0x7aae, 0xa438, 0xd701, 0xa438, 0x7ab0,
+        0xa438, 0xd704, 0xa438, 0x7ef3, 0xa438, 0xd701, 0xa438, 0x5eb3,
+        0xa438, 0x84b0, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa608,
+        0xa438, 0xc700, 0xa438, 0x9503, 0xa438, 0xce54, 0xa438, 0x1000,
+        0xa438, 0x10be, 0xa438, 0xa290, 0xa438, 0xa304, 0xa438, 0xab02,
+        0xa438, 0xd700, 0xa438, 0x6050, 0xa438, 0xab04, 0xa438, 0x0c38,
+        0xa438, 0x0608, 0xa438, 0xaa0b, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8d01, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xae40,
+        0xa438, 0x9503, 0xa438, 0xd702, 0xa438, 0x40a4, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8e20, 0xa438, 0x9503, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8c20, 0xa438, 0x9503, 0xa438, 0xd700,
+        0xa438, 0x6078, 0xa438, 0xd700, 0xa438, 0x609a, 0xa438, 0xd109,
+        0xa438, 0xd074, 0xa438, 0xf003, 0xa438, 0xd109, 0xa438, 0xd075,
+        0xa438, 0xd704, 0xa438, 0x62b2, 0xa438, 0xd702, 0xa438, 0x4116,
+        0xa438, 0xce54, 0xa438, 0x1000, 0xa438, 0x10be, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8f40, 0xa438, 0x9503, 0xa438, 0xa00a,
+        0xa438, 0xd704, 0xa438, 0x4247, 0xa438, 0xd700, 0xa438, 0x3691,
+        0xa438, 0x8326, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa570,
+        0xa438, 0x9503, 0xa438, 0xf00a, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xaf40, 0xa438, 0x9503, 0xa438, 0x800a, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8570, 0xa438, 0x9503, 0xa438, 0x1000,
+        0xa438, 0x109e, 0xa438, 0xd704, 0xa438, 0x60f3, 0xa438, 0xd71f,
+        0xa438, 0x618e, 0xa438, 0xd700, 0xa438, 0x5b5e, 0xa438, 0x1800,
+        0xa438, 0x0deb, 0xa438, 0x800a, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xae40, 0xa438, 0x9503, 0xa438, 0x1800, 0xa438, 0x0c47,
+        0xa438, 0x1800, 0xa438, 0x0df8, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8608, 0xa438, 0x9503, 0xa438, 0x1800, 0xa438, 0x0e2b,
+        0xa436, 0xA10E, 0xa438, 0x0d14, 0xa436, 0xA10C, 0xa438, 0x0ce8,
+        0xa436, 0xA10A, 0xa438, 0x0279, 0xa436, 0xA108, 0xa438, 0x0b19,
+        0xa436, 0xA106, 0xa438, 0x111f, 0xa436, 0xA104, 0xa438, 0x0a7b,
+        0xa436, 0xA102, 0xa438, 0x0ba3, 0xa436, 0xA100, 0xa438, 0x0022,
+        0xa436, 0xA110, 0xa438, 0x00ff, 0xa436, 0xb87c, 0xa438, 0x859b,
+        0xa436, 0xb87e, 0xa438, 0xaf85, 0xa438, 0xb3af, 0xa438, 0x863b,
+        0xa438, 0xaf86, 0xa438, 0x4caf, 0xa438, 0x8688, 0xa438, 0xaf86,
+        0xa438, 0xceaf, 0xa438, 0x8744, 0xa438, 0xaf87, 0xa438, 0x68af,
+        0xa438, 0x8781, 0xa438, 0xbf5e, 0xa438, 0x7202, 0xa438, 0x5f7e,
+        0xa438, 0xac28, 0xa438, 0x68e1, 0xa438, 0x84e6, 0xa438, 0xad28,
+        0xa438, 0x09bf, 0xa438, 0x5e75, 0xa438, 0x025f, 0xa438, 0x7eac,
+        0xa438, 0x2d59, 0xa438, 0xe18f, 0xa438, 0xebad, 0xa438, 0x2809,
+        0xa438, 0xbf5e, 0xa438, 0x7502, 0xa438, 0x5f7e, 0xa438, 0xac2e,
+        0xa438, 0x50e1, 0xa438, 0x84e6, 0xa438, 0xac28, 0xa438, 0x08bf,
+        0xa438, 0x873e, 0xa438, 0x025f, 0xa438, 0x3cae, 0xa438, 0x06bf,
+        0xa438, 0x873e, 0xa438, 0x025f, 0xa438, 0x33bf, 0xa438, 0x8741,
+        0xa438, 0x025f, 0xa438, 0x33ee, 0xa438, 0x8fea, 0xa438, 0x02e1,
+        0xa438, 0x84e4, 0xa438, 0xad28, 0xa438, 0x14e1, 0xa438, 0x8fe8,
+        0xa438, 0xad28, 0xa438, 0x17e1, 0xa438, 0x84e5, 0xa438, 0x11e5,
+        0xa438, 0x84e5, 0xa438, 0xa10c, 0xa438, 0x04ee, 0xa438, 0x84e5,
+        0xa438, 0x0002, 0xa438, 0x4977, 0xa438, 0xee84, 0xa438, 0xdc03,
+        0xa438, 0xae1d, 0xa438, 0xe18f, 0xa438, 0xe811, 0xa438, 0xe58f,
+        0xa438, 0xe8ae, 0xa438, 0x14bf, 0xa438, 0x873e, 0xa438, 0x025f,
+        0xa438, 0x3cbf, 0xa438, 0x8741, 0xa438, 0x025f, 0xa438, 0x3cee,
+        0xa438, 0x8fea, 0xa438, 0x01ee, 0xa438, 0x84e4, 0xa438, 0x00af,
+        0xa438, 0x50c1, 0xa438, 0x1f00, 0xa438, 0xbf5a, 0xa438, 0x6102,
+        0xa438, 0x5f5f, 0xa438, 0xbf5a, 0xa438, 0x5e02, 0xa438, 0x5f3c,
+        0xa438, 0xaf45, 0xa438, 0x7be0, 0xa438, 0x8012, 0xa438, 0xad23,
+        0xa438, 0x141f, 0xa438, 0x001f, 0xa438, 0x22d1, 0xa438, 0x00bf,
+        0xa438, 0x3fcf, 0xa438, 0x0261, 0xa438, 0x3412, 0xa438, 0xa204,
+        0xa438, 0xf6ee, 0xa438, 0x8317, 0xa438, 0x00e0, 0xa438, 0x8012,
+        0xa438, 0xad24, 0xa438, 0x141f, 0xa438, 0x001f, 0xa438, 0x22d1,
+        0xa438, 0x00bf, 0xa438, 0x3fd7, 0xa438, 0x0261, 0xa438, 0x3412,
+        0xa438, 0xa204, 0xa438, 0xf6ee, 0xa438, 0x8317, 0xa438, 0x00ef,
+        0xa438, 0x96fe, 0xa438, 0xfdfc, 0xa438, 0xaf42, 0xa438, 0x9802,
+        0xa438, 0x56ec, 0xa438, 0xf70b, 0xa438, 0xac13, 0xa438, 0x0fbf,
+        0xa438, 0x5e75, 0xa438, 0x025f, 0xa438, 0x7eac, 0xa438, 0x280c,
+        0xa438, 0xe2ff, 0xa438, 0xcfad, 0xa438, 0x32ee, 0xa438, 0x0257,
+        0xa438, 0x05af, 0xa438, 0x00a4, 0xa438, 0x0286, 0xa438, 0xaaae,
+        0xa438, 0xeff8, 0xa438, 0xf9ef, 0xa438, 0x5902, 0xa438, 0x1fe1,
+        0xa438, 0xbf59, 0xa438, 0x4d02, 0xa438, 0x5f3c, 0xa438, 0xac13,
+        0xa438, 0x09bf, 0xa438, 0x5e75, 0xa438, 0x025f, 0xa438, 0x7ea1,
+        0xa438, 0x00f4, 0xa438, 0xbf59, 0xa438, 0x4d02, 0xa438, 0x5f33,
+        0xa438, 0xef95, 0xa438, 0xfdfc, 0xa438, 0x04bf, 0xa438, 0x5e72,
+        0xa438, 0x025f, 0xa438, 0x7eac, 0xa438, 0x284a, 0xa438, 0xe184,
+        0xa438, 0xe6ad, 0xa438, 0x2809, 0xa438, 0xbf5e, 0xa438, 0x7502,
+        0xa438, 0x5f7e, 0xa438, 0xac2d, 0xa438, 0x3be1, 0xa438, 0x8feb,
+        0xa438, 0xad28, 0xa438, 0x09bf, 0xa438, 0x5e75, 0xa438, 0x025f,
+        0xa438, 0x7eac, 0xa438, 0x2e32, 0xa438, 0xe184, 0xa438, 0xe6ac,
+        0xa438, 0x2808, 0xa438, 0xbf87, 0xa438, 0x3e02, 0xa438, 0x5f3c,
+        0xa438, 0xae06, 0xa438, 0xbf87, 0xa438, 0x3e02, 0xa438, 0x5f33,
+        0xa438, 0xbf87, 0xa438, 0x4102, 0xa438, 0x5f33, 0xa438, 0xee8f,
+        0xa438, 0xea04, 0xa438, 0xbf5e, 0xa438, 0x4e02, 0xa438, 0x5f7e,
+        0xa438, 0xad28, 0xa438, 0x1f02, 0xa438, 0x4b12, 0xa438, 0xae1a,
+        0xa438, 0xbf87, 0xa438, 0x3e02, 0xa438, 0x5f3c, 0xa438, 0xbf87,
+        0xa438, 0x4102, 0xa438, 0x5f3c, 0xa438, 0xee8f, 0xa438, 0xea03,
+        0xa438, 0xbf5e, 0xa438, 0x2a02, 0xa438, 0x5f33, 0xa438, 0xee84,
+        0xa438, 0xe701, 0xa438, 0xaf4a, 0xa438, 0x7444, 0xa438, 0xac0e,
+        0xa438, 0x55ac, 0xa438, 0x0ebf, 0xa438, 0x5e75, 0xa438, 0x025f,
+        0xa438, 0x7ead, 0xa438, 0x2d0b, 0xa438, 0xbf5e, 0xa438, 0x36e1,
+        0xa438, 0x8fe9, 0xa438, 0x025f, 0xa438, 0x5fae, 0xa438, 0x09bf,
+        0xa438, 0x5e36, 0xa438, 0xe184, 0xa438, 0xe102, 0xa438, 0x5f5f,
+        0xa438, 0xee8f, 0xa438, 0xe800, 0xa438, 0xaf49, 0xa438, 0xcdbf,
+        0xa438, 0x595c, 0xa438, 0x025f, 0xa438, 0x7ea1, 0xa438, 0x0203,
+        0xa438, 0xaf87, 0xa438, 0x79d1, 0xa438, 0x00af, 0xa438, 0x877c,
+        0xa438, 0xe181, 0xa438, 0x941f, 0xa438, 0x00af, 0xa438, 0x3ff7,
+        0xa438, 0xac4e, 0xa438, 0x06ac, 0xa438, 0x4003, 0xa438, 0xaf24,
+        0xa438, 0x97af, 0xa438, 0x2467, 0xa436, 0xb85e, 0xa438, 0x5082,
+        0xa436, 0xb860, 0xa438, 0x4575, 0xa436, 0xb862, 0xa438, 0x425F,
+        0xa436, 0xb864, 0xa438, 0x0096, 0xa436, 0xb886, 0xa438, 0x4A44,
+        0xa436, 0xb888, 0xa438, 0x49c4, 0xa436, 0xb88a, 0xa438, 0x3FF2,
+        0xa436, 0xb88c, 0xa438, 0x245C, 0xa436, 0xb838, 0xa438, 0x00ff,
+        0xb820, 0x0010, 0xa436, 0x843d, 0xa438, 0xaf84, 0xa438, 0xa6af,
+        0xa438, 0x8540, 0xa438, 0xaf85, 0xa438, 0xaeaf, 0xa438, 0x85b5,
+        0xa438, 0xaf87, 0xa438, 0x7daf, 0xa438, 0x8784, 0xa438, 0xaf87,
+        0xa438, 0x87af, 0xa438, 0x87e5, 0xa438, 0x0066, 0xa438, 0x0a03,
+        0xa438, 0x6607, 0xa438, 0x2666, 0xa438, 0x1c00, 0xa438, 0x660d,
+        0xa438, 0x0166, 0xa438, 0x1004, 0xa438, 0x6616, 0xa438, 0x0566,
+        0xa438, 0x1f06, 0xa438, 0x6a5d, 0xa438, 0x2766, 0xa438, 0x1900,
+        0xa438, 0x6625, 0xa438, 0x2466, 0xa438, 0x2820, 0xa438, 0x662b,
+        0xa438, 0x2466, 0xa438, 0x4600, 0xa438, 0x664c, 0xa438, 0x0166,
+        0xa438, 0x4902, 0xa438, 0x8861, 0xa438, 0x0388, 0xa438, 0x5e05,
+        0xa438, 0x886d, 0xa438, 0x0588, 0xa438, 0x7005, 0xa438, 0x8873,
+        0xa438, 0x0588, 0xa438, 0x7605, 0xa438, 0x8879, 0xa438, 0x0588,
+        0xa438, 0x7c05, 0xa438, 0x887f, 0xa438, 0x0588, 0xa438, 0x8205,
+        0xa438, 0x8885, 0xa438, 0x0588, 0xa438, 0x881e, 0xa438, 0x13ad,
+        0xa438, 0x2841, 0xa438, 0xbf64, 0xa438, 0xf102, 0xa438, 0x6b9d,
+        0xa438, 0xad28, 0xa438, 0x03af, 0xa438, 0x15fc, 0xa438, 0xbf65,
+        0xa438, 0xcb02, 0xa438, 0x6b9d, 0xa438, 0x0d11, 0xa438, 0xf62f,
+        0xa438, 0xef31, 0xa438, 0xd202, 0xa438, 0xbf88, 0xa438, 0x6402,
+        0xa438, 0x6b52, 0xa438, 0xe082, 0xa438, 0x020d, 0xa438, 0x01f6,
+        0xa438, 0x271b, 0xa438, 0x03aa, 0xa438, 0x0182, 0xa438, 0xe082,
+        0xa438, 0x010d, 0xa438, 0x01f6, 0xa438, 0x271b, 0xa438, 0x03aa,
+        0xa438, 0x0782, 0xa438, 0xbf88, 0xa438, 0x6402, 0xa438, 0x6b5b,
+        0xa438, 0xaf15, 0xa438, 0xf9bf, 0xa438, 0x65cb, 0xa438, 0x026b,
+        0xa438, 0x9d0d, 0xa438, 0x11f6, 0xa438, 0x2fef, 0xa438, 0x31e0,
+        0xa438, 0x8ff7, 0xa438, 0x0d01, 0xa438, 0xf627, 0xa438, 0x1b03,
+        0xa438, 0xaa20, 0xa438, 0xe18f, 0xa438, 0xf4d0, 0xa438, 0x00bf,
+        0xa438, 0x6587, 0xa438, 0x026b, 0xa438, 0x7ee1, 0xa438, 0x8ff5,
+        0xa438, 0xbf65, 0xa438, 0x8a02, 0xa438, 0x6b7e, 0xa438, 0xe18f,
+        0xa438, 0xf6bf, 0xa438, 0x6584, 0xa438, 0x026b, 0xa438, 0x7eaf,
+        0xa438, 0x15fc, 0xa438, 0xe18f, 0xa438, 0xf1d0, 0xa438, 0x00bf,
+        0xa438, 0x6587, 0xa438, 0x026b, 0xa438, 0x7ee1, 0xa438, 0x8ff2,
+        0xa438, 0xbf65, 0xa438, 0x8a02, 0xa438, 0x6b7e, 0xa438, 0xe18f,
+        0xa438, 0xf3bf, 0xa438, 0x6584, 0xa438, 0xaf15, 0xa438, 0xfcd1,
+        0xa438, 0x07bf, 0xa438, 0x65ce, 0xa438, 0x026b, 0xa438, 0x7ed1,
+        0xa438, 0x0cbf, 0xa438, 0x65d1, 0xa438, 0x026b, 0xa438, 0x7ed1,
+        0xa438, 0x03bf, 0xa438, 0x885e, 0xa438, 0x026b, 0xa438, 0x7ed1,
+        0xa438, 0x05bf, 0xa438, 0x8867, 0xa438, 0x026b, 0xa438, 0x7ed1,
+        0xa438, 0x07bf, 0xa438, 0x886a, 0xa438, 0x026b, 0xa438, 0x7ebf,
+        0xa438, 0x6a6c, 0xa438, 0x026b, 0xa438, 0x5b02, 0xa438, 0x62b5,
+        0xa438, 0xbf6a, 0xa438, 0x0002, 0xa438, 0x6b5b, 0xa438, 0xbf64,
+        0xa438, 0x4e02, 0xa438, 0x6b9d, 0xa438, 0xac28, 0xa438, 0x0bbf,
+        0xa438, 0x6412, 0xa438, 0x026b, 0xa438, 0x9da1, 0xa438, 0x0502,
+        0xa438, 0xaeec, 0xa438, 0xd104, 0xa438, 0xbf65, 0xa438, 0xce02,
+        0xa438, 0x6b7e, 0xa438, 0xd104, 0xa438, 0xbf65, 0xa438, 0xd102,
+        0xa438, 0x6b7e, 0xa438, 0xd102, 0xa438, 0xbf88, 0xa438, 0x6702,
+        0xa438, 0x6b7e, 0xa438, 0xd104, 0xa438, 0xbf88, 0xa438, 0x6a02,
+        0xa438, 0x6b7e, 0xa438, 0xaf62, 0xa438, 0x72f6, 0xa438, 0x0af6,
+        0xa438, 0x09af, 0xa438, 0x34e3, 0xa438, 0x0285, 0xa438, 0xbe02,
+        0xa438, 0x106c, 0xa438, 0xaf10, 0xa438, 0x6bf8, 0xa438, 0xfaef,
+        0xa438, 0x69e0, 0xa438, 0x804c, 0xa438, 0xac25, 0xa438, 0x17e0,
+        0xa438, 0x8040, 0xa438, 0xad25, 0xa438, 0x1a02, 0xa438, 0x85ed,
+        0xa438, 0xe080, 0xa438, 0x40ac, 0xa438, 0x2511, 0xa438, 0xbf87,
+        0xa438, 0x6502, 0xa438, 0x6b5b, 0xa438, 0xae09, 0xa438, 0x0287,
+        0xa438, 0x2402, 0xa438, 0x875a, 0xa438, 0x0287, 0xa438, 0x4fef,
+        0xa438, 0x96fe, 0xa438, 0xfc04, 0xa438, 0xf8e0, 0xa438, 0x8019,
+        0xa438, 0xad20, 0xa438, 0x11e0, 0xa438, 0x8fe3, 0xa438, 0xac20,
+        0xa438, 0x0502, 0xa438, 0x860a, 0xa438, 0xae03, 0xa438, 0x0286,
+        0xa438, 0x7802, 0xa438, 0x86c1, 0xa438, 0x0287, 0xa438, 0x4ffc,
+        0xa438, 0x04f8, 0xa438, 0xf9ef, 0xa438, 0x79fb, 0xa438, 0xbf87,
+        0xa438, 0x6802, 0xa438, 0x6b9d, 0xa438, 0x5c20, 0xa438, 0x000d,
+        0xa438, 0x4da1, 0xa438, 0x0151, 0xa438, 0xbf87, 0xa438, 0x6802,
+        0xa438, 0x6b9d, 0xa438, 0x5c07, 0xa438, 0xffe3, 0xa438, 0x8fe4,
+        0xa438, 0x1b31, 0xa438, 0x9f41, 0xa438, 0x0d48, 0xa438, 0xe38f,
+        0xa438, 0xe51b, 0xa438, 0x319f, 0xa438, 0x38bf, 0xa438, 0x876b,
+        0xa438, 0x026b, 0xa438, 0x9d5c, 0xa438, 0x07ff, 0xa438, 0xe38f,
+        0xa438, 0xe61b, 0xa438, 0x319f, 0xa438, 0x280d, 0xa438, 0x48e3,
+        0xa438, 0x8fe7, 0xa438, 0x1b31, 0xa438, 0x9f1f, 0xa438, 0xbf87,
+        0xa438, 0x6e02, 0xa438, 0x6b9d, 0xa438, 0x5c07, 0xa438, 0xffe3,
+        0xa438, 0x8fe8, 0xa438, 0x1b31, 0xa438, 0x9f0f, 0xa438, 0x0d48,
+        0xa438, 0xe38f, 0xa438, 0xe91b, 0xa438, 0x319f, 0xa438, 0x06ee,
+        0xa438, 0x8fe3, 0xa438, 0x01ae, 0xa438, 0x04ee, 0xa438, 0x8fe3,
+        0xa438, 0x00ff, 0xa438, 0xef97, 0xa438, 0xfdfc, 0xa438, 0x04f8,
+        0xa438, 0xf9ef, 0xa438, 0x79fb, 0xa438, 0xbf87, 0xa438, 0x6802,
+        0xa438, 0x6b9d, 0xa438, 0x5c20, 0xa438, 0x000d, 0xa438, 0x4da1,
+        0xa438, 0x0020, 0xa438, 0xbf87, 0xa438, 0x6802, 0xa438, 0x6b9d,
+        0xa438, 0x5c06, 0xa438, 0x000d, 0xa438, 0x49e3, 0xa438, 0x8fea,
+        0xa438, 0x1b31, 0xa438, 0x9f0e, 0xa438, 0xbf87, 0xa438, 0x7102,
+        0xa438, 0x6b5b, 0xa438, 0xbf87, 0xa438, 0x7702, 0xa438, 0x6b5b,
+        0xa438, 0xae0c, 0xa438, 0xbf87, 0xa438, 0x7102, 0xa438, 0x6b52,
+        0xa438, 0xbf87, 0xa438, 0x7702, 0xa438, 0x6b52, 0xa438, 0xee8f,
+        0xa438, 0xe300, 0xa438, 0xffef, 0xa438, 0x97fd, 0xa438, 0xfc04,
+        0xa438, 0xf8f9, 0xa438, 0xef79, 0xa438, 0xfbbf, 0xa438, 0x8768,
+        0xa438, 0x026b, 0xa438, 0x9d5c, 0xa438, 0x2000, 0xa438, 0x0d4d,
+        0xa438, 0xa101, 0xa438, 0x4abf, 0xa438, 0x8768, 0xa438, 0x026b,
+        0xa438, 0x9d5c, 0xa438, 0x07ff, 0xa438, 0xe38f, 0xa438, 0xeb1b,
+        0xa438, 0x319f, 0xa438, 0x3a0d, 0xa438, 0x48e3, 0xa438, 0x8fec,
+        0xa438, 0x1b31, 0xa438, 0x9f31, 0xa438, 0xbf87, 0xa438, 0x6b02,
+        0xa438, 0x6b9d, 0xa438, 0xe38f, 0xa438, 0xed1b, 0xa438, 0x319f,
+        0xa438, 0x240d, 0xa438, 0x48e3, 0xa438, 0x8fee, 0xa438, 0x1b31,
+        0xa438, 0x9f1b, 0xa438, 0xbf87, 0xa438, 0x6e02, 0xa438, 0x6b9d,
+        0xa438, 0xe38f, 0xa438, 0xef1b, 0xa438, 0x319f, 0xa438, 0x0ebf,
+        0xa438, 0x8774, 0xa438, 0x026b, 0xa438, 0x5bbf, 0xa438, 0x877a,
+        0xa438, 0x026b, 0xa438, 0x5bae, 0xa438, 0x00ff, 0xa438, 0xef97,
+        0xa438, 0xfdfc, 0xa438, 0x04f8, 0xa438, 0xef79, 0xa438, 0xfbe0,
+        0xa438, 0x8019, 0xa438, 0xad20, 0xa438, 0x1cee, 0xa438, 0x8fe3,
+        0xa438, 0x00bf, 0xa438, 0x8771, 0xa438, 0x026b, 0xa438, 0x52bf,
+        0xa438, 0x8777, 0xa438, 0x026b, 0xa438, 0x52bf, 0xa438, 0x8774,
+        0xa438, 0x026b, 0xa438, 0x52bf, 0xa438, 0x877a, 0xa438, 0x026b,
+        0xa438, 0x52ff, 0xa438, 0xef97, 0xa438, 0xfc04, 0xa438, 0xf8e0,
+        0xa438, 0x8040, 0xa438, 0xf625, 0xa438, 0xe480, 0xa438, 0x40fc,
+        0xa438, 0x04f8, 0xa438, 0xe080, 0xa438, 0x4cf6, 0xa438, 0x25e4,
+        0xa438, 0x804c, 0xa438, 0xfc04, 0xa438, 0x55a4, 0xa438, 0xbaf0,
+        0xa438, 0xa64a, 0xa438, 0xf0a6, 0xa438, 0x4cf0, 0xa438, 0xa64e,
+        0xa438, 0x66a4, 0xa438, 0xb655, 0xa438, 0xa4b6, 0xa438, 0x00ac,
+        0xa438, 0x0e66, 0xa438, 0xac0e, 0xa438, 0xee80, 0xa438, 0x4c3a,
+        0xa438, 0xaf07, 0xa438, 0xd0af, 0xa438, 0x26d0, 0xa438, 0xa201,
+        0xa438, 0x0ebf, 0xa438, 0x663d, 0xa438, 0x026b, 0xa438, 0x52bf,
+        0xa438, 0x6643, 0xa438, 0x026b, 0xa438, 0x52ae, 0xa438, 0x11bf,
+        0xa438, 0x6643, 0xa438, 0x026b, 0xa438, 0x5bd4, 0xa438, 0x0054,
+        0xa438, 0xb4fe, 0xa438, 0xbf66, 0xa438, 0x3d02, 0xa438, 0x6b5b,
+        0xa438, 0xd300, 0xa438, 0x020d, 0xa438, 0xf6a2, 0xa438, 0x0405,
+        0xa438, 0xe081, 0xa438, 0x47ae, 0xa438, 0x03e0, 0xa438, 0x8148,
+        0xa438, 0xac23, 0xa438, 0x02ae, 0xa438, 0x0268, 0xa438, 0xf01a,
+        0xa438, 0x10ad, 0xa438, 0x2f04, 0xa438, 0xd100, 0xa438, 0xae05,
+        0xa438, 0xad2c, 0xa438, 0x02d1, 0xa438, 0x0f1f, 0xa438, 0x00a2,
+        0xa438, 0x0407, 0xa438, 0x3908, 0xa438, 0xad2f, 0xa438, 0x02d1,
+        0xa438, 0x0002, 0xa438, 0x0e1c, 0xa438, 0x2b01, 0xa438, 0xad3a,
+        0xa438, 0xc9af, 0xa438, 0x0dee, 0xa438, 0xa000, 0xa438, 0x2702,
+        0xa438, 0x1beb, 0xa438, 0xe18f, 0xa438, 0xe1ac, 0xa438, 0x2819,
+        0xa438, 0xee8f, 0xa438, 0xe101, 0xa438, 0x1f44, 0xa438, 0xbf65,
+        0xa438, 0x9302, 0xa438, 0x6b9d, 0xa438, 0xe58f, 0xa438, 0xe21f,
+        0xa438, 0x44d1, 0xa438, 0x02bf, 0xa438, 0x6593, 0xa438, 0x026b,
+        0xa438, 0x7ee0, 0xa438, 0x82b1, 0xa438, 0xae49, 0xa438, 0xa001,
+        0xa438, 0x0502, 0xa438, 0x1c4d, 0xa438, 0xae41, 0xa438, 0xa002,
+        0xa438, 0x0502, 0xa438, 0x1c90, 0xa438, 0xae39, 0xa438, 0xa003,
+        0xa438, 0x0502, 0xa438, 0x1c9d, 0xa438, 0xae31, 0xa438, 0xa004,
+        0xa438, 0x0502, 0xa438, 0x1cbc, 0xa438, 0xae29, 0xa438, 0xa005,
+        0xa438, 0x1e02, 0xa438, 0x1cc9, 0xa438, 0xe080, 0xa438, 0xdfac,
+        0xa438, 0x2013, 0xa438, 0xac21, 0xa438, 0x10ac, 0xa438, 0x220d,
+        0xa438, 0xe18f, 0xa438, 0xe2bf, 0xa438, 0x6593, 0xa438, 0x026b,
+        0xa438, 0x7eee, 0xa438, 0x8fe1, 0xa438, 0x00ae, 0xa438, 0x08a0,
+        0xa438, 0x0605, 0xa438, 0x021d, 0xa438, 0x07ae, 0xa438, 0x00e0,
+        0xa438, 0x82b1, 0xa438, 0xaf1b, 0xa438, 0xe910, 0xa438, 0xbf4a,
+        0xa438, 0x99bf, 0xa438, 0x4a00, 0xa438, 0xa86a, 0xa438, 0xfdad,
+        0xa438, 0x5eca, 0xa438, 0xad5e, 0xa438, 0x88bd, 0xa438, 0x2c99,
+        0xa438, 0xbd2c, 0xa438, 0x33bd, 0xa438, 0x3222, 0xa438, 0xbd32,
+        0xa438, 0x11bd, 0xa438, 0x3200, 0xa438, 0xbd32, 0xa438, 0x77bd,
+        0xa438, 0x3266, 0xa438, 0xbd32, 0xa438, 0x55bd, 0xa438, 0x3244,
+        0xa438, 0xbd32, 0xa436, 0xb818, 0xa438, 0x15c5, 0xa436, 0xb81a,
+        0xa438, 0x6255, 0xa436, 0xb81c, 0xa438, 0x34e1, 0xa436, 0xb81e,
+        0xa438, 0x1068, 0xa436, 0xb850, 0xa438, 0x07cc, 0xa436, 0xb852,
+        0xa438, 0x26ca, 0xa436, 0xb878, 0xa438, 0x0dbf, 0xa436, 0xb884,
+        0xa438, 0x1BB1, 0xa436, 0xb832, 0xa438, 0x00ff, 0xa436, 0x0000,
+        0xa438, 0x0000, 0xB82E, 0x0000, 0xa436, 0x8023, 0xa438, 0x0000,
+        0xa436, 0x801E, 0xa438, 0x0031, 0xB820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static const u16  phy_mcu_ram_code_8125d_1_2[] = {
+        0xb892, 0x0000, 0xB88E, 0xC28F, 0xB890, 0x252D, 0xB88E, 0xC290,
+        0xB890, 0xC924, 0xB88E, 0xC291, 0xB890, 0xC92E, 0xB88E, 0xC292,
+        0xB890, 0xF626, 0xB88E, 0xC293, 0xB890, 0xF630, 0xB88E, 0xC294,
+        0xB890, 0xA328, 0xB88E, 0xC295, 0xB890, 0xA332, 0xB88E, 0xC296,
+        0xB890, 0xD72B, 0xB88E, 0xC297, 0xB890, 0xD735, 0xB88E, 0xC298,
+        0xB890, 0x8A2E, 0xB88E, 0xC299, 0xB890, 0x8A38, 0xB88E, 0xC29A,
+        0xB890, 0xBE32, 0xB88E, 0xC29B, 0xB890, 0xBE3C, 0xB88E, 0xC29C,
+        0xB890, 0x7436, 0xB88E, 0xC29D, 0xB890, 0x7440, 0xB88E, 0xC29E,
+        0xB890, 0xAD3B, 0xB88E, 0xC29F, 0xB890, 0xAD45, 0xB88E, 0xC2A0,
+        0xB890, 0x6640, 0xB88E, 0xC2A1, 0xB890, 0x664A, 0xB88E, 0xC2A2,
+        0xB890, 0xA646, 0xB88E, 0xC2A3, 0xB890, 0xA650, 0xB88E, 0xC2A4,
+        0xB890, 0x624C, 0xB88E, 0xC2A5, 0xB890, 0x6256, 0xB88E, 0xC2A6,
+        0xB890, 0xA453, 0xB88E, 0xC2A7, 0xB890, 0xA45D, 0xB88E, 0xC2A8,
+        0xB890, 0x665A, 0xB88E, 0xC2A9, 0xB890, 0x6664, 0xB88E, 0xC2AA,
+        0xB890, 0xAC62, 0xB88E, 0xC2AB, 0xB890, 0xAC6C, 0xB88E, 0xC2AC,
+        0xB890, 0x746A, 0xB88E, 0xC2AD, 0xB890, 0x7474, 0xB88E, 0xC2AE,
+        0xB890, 0xBCFA, 0xB88E, 0xC2AF, 0xB890, 0xBCFD, 0xB88E, 0xC2B0,
+        0xB890, 0x79FF, 0xB88E, 0xC2B1, 0xB890, 0x7901, 0xB88E, 0xC2B2,
+        0xB890, 0xF703, 0xB88E, 0xC2B3, 0xB890, 0xF706, 0xB88E, 0xC2B4,
+        0xB890, 0x7408, 0xB88E, 0xC2B5, 0xB890, 0x740A, 0xB88E, 0xC2B6,
+        0xB890, 0xF10C, 0xB88E, 0xC2B7, 0xB890, 0xF10F, 0xB88E, 0xC2B8,
+        0xB890, 0x6F10, 0xB88E, 0xC2B9, 0xB890, 0x6F13, 0xB88E, 0xC2BA,
+        0xB890, 0xEC15, 0xB88E, 0xC2BB, 0xB890, 0xEC18, 0xB88E, 0xC2BC,
+        0xB890, 0x6A1A, 0xB88E, 0xC2BD, 0xB890, 0x6A1C, 0xB88E, 0xC2BE,
+        0xB890, 0xE71E, 0xB88E, 0xC2BF, 0xB890, 0xE721, 0xB88E, 0xC2C0,
+        0xB890, 0x6424, 0xB88E, 0xC2C1, 0xB890, 0x6425, 0xB88E, 0xC2C2,
+        0xB890, 0xE228, 0xB88E, 0xC2C3, 0xB890, 0xE22A, 0xB88E, 0xC2C4,
+        0xB890, 0x5F2B, 0xB88E, 0xC2C5, 0xB890, 0x5F2E, 0xB88E, 0xC2C6,
+        0xB890, 0xDC31, 0xB88E, 0xC2C7, 0xB890, 0xDC33, 0xB88E, 0xC2C8,
+        0xB890, 0x2035, 0xB88E, 0xC2C9, 0xB890, 0x2036, 0xB88E, 0xC2CA,
+        0xB890, 0x9F3A, 0xB88E, 0xC2CB, 0xB890, 0x9F3A, 0xB88E, 0xC2CC,
+        0xB890, 0x4430, 0xFFFF, 0xFFFF
+};
+
+static const u16  phy_mcu_ram_code_8125d_1_3[] = {
+        0xa436, 0xacca, 0xa438, 0x0104, 0xa436, 0xaccc, 0xa438, 0x8000,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x0fff,
+        0xa436, 0xacce, 0xa438, 0xfd47, 0xa436, 0xacd0, 0xa438, 0x0fff,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xe56f, 0xa436, 0xacd0, 0xa438, 0x01c0,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xed97, 0xa436, 0xacd0, 0xa438, 0x01c8,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xf5bf, 0xa436, 0xacd0, 0xa438, 0x01d0,
+        0xa436, 0xacce, 0xa438, 0xfb07, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb0f, 0xa436, 0xacd0, 0xa438, 0x01d8,
+        0xa436, 0xacce, 0xa438, 0xa087, 0xa436, 0xacd0, 0xa438, 0x0180,
+        0xa436, 0xacce, 0xa438, 0xa00f, 0xa436, 0xacd0, 0xa438, 0x0108,
+        0xa436, 0xacce, 0xa438, 0xa807, 0xa436, 0xacd0, 0xa438, 0x0100,
+        0xa436, 0xacce, 0xa438, 0xa88f, 0xa436, 0xacd0, 0xa438, 0x0188,
+        0xa436, 0xacce, 0xa438, 0xb027, 0xa436, 0xacd0, 0xa438, 0x0120,
+        0xa436, 0xacce, 0xa438, 0xb02f, 0xa436, 0xacd0, 0xa438, 0x0128,
+        0xa436, 0xacce, 0xa438, 0xb847, 0xa436, 0xacd0, 0xa438, 0x0140,
+        0xa436, 0xacce, 0xa438, 0xb84f, 0xa436, 0xacd0, 0xa438, 0x0148,
+        0xa436, 0xacce, 0xa438, 0xfb17, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb1f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xa017, 0xa436, 0xacd0, 0xa438, 0x0110,
+        0xa436, 0xacce, 0xa438, 0xa01f, 0xa436, 0xacd0, 0xa438, 0x0118,
+        0xa436, 0xacce, 0xa438, 0xa837, 0xa436, 0xacd0, 0xa438, 0x0130,
+        0xa436, 0xacce, 0xa438, 0xa83f, 0xa436, 0xacd0, 0xa438, 0x0138,
+        0xa436, 0xacce, 0xa438, 0xb097, 0xa436, 0xacd0, 0xa438, 0x0190,
+        0xa436, 0xacce, 0xa438, 0xb05f, 0xa436, 0xacd0, 0xa438, 0x0158,
+        0xa436, 0xacce, 0xa438, 0xb857, 0xa436, 0xacd0, 0xa438, 0x0150,
+        0xa436, 0xacce, 0xa438, 0xb89f, 0xa436, 0xacd0, 0xa438, 0x0198,
+        0xa436, 0xacce, 0xa438, 0xfb27, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb2f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x8087, 0xa436, 0xacd0, 0xa438, 0x0180,
+        0xa436, 0xacce, 0xa438, 0x800f, 0xa436, 0xacd0, 0xa438, 0x0108,
+        0xa436, 0xacce, 0xa438, 0x8807, 0xa436, 0xacd0, 0xa438, 0x0100,
+        0xa436, 0xacce, 0xa438, 0x888f, 0xa436, 0xacd0, 0xa438, 0x0188,
+        0xa436, 0xacce, 0xa438, 0x9027, 0xa436, 0xacd0, 0xa438, 0x0120,
+        0xa436, 0xacce, 0xa438, 0x902f, 0xa436, 0xacd0, 0xa438, 0x0128,
+        0xa436, 0xacce, 0xa438, 0x9847, 0xa436, 0xacd0, 0xa438, 0x0140,
+        0xa436, 0xacce, 0xa438, 0x984f, 0xa436, 0xacd0, 0xa438, 0x0148,
+        0xa436, 0xacce, 0xa438, 0xa0a7, 0xa436, 0xacd0, 0xa438, 0x01a0,
+        0xa436, 0xacce, 0xa438, 0xa8af, 0xa436, 0xacd0, 0xa438, 0x01a8,
+        0xa436, 0xacce, 0xa438, 0xa067, 0xa436, 0xacd0, 0xa438, 0x0161,
+        0xa436, 0xacce, 0xa438, 0xa86f, 0xa436, 0xacd0, 0xa438, 0x0169,
+        0xa436, 0xacce, 0xa438, 0xfb37, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb3f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x8017, 0xa436, 0xacd0, 0xa438, 0x0110,
+        0xa436, 0xacce, 0xa438, 0x801f, 0xa436, 0xacd0, 0xa438, 0x0118,
+        0xa436, 0xacce, 0xa438, 0x8837, 0xa436, 0xacd0, 0xa438, 0x0130,
+        0xa436, 0xacce, 0xa438, 0x883f, 0xa436, 0xacd0, 0xa438, 0x0138,
+        0xa436, 0xacce, 0xa438, 0x9097, 0xa436, 0xacd0, 0xa438, 0x0190,
+        0xa436, 0xacce, 0xa438, 0x905f, 0xa436, 0xacd0, 0xa438, 0x0158,
+        0xa436, 0xacce, 0xa438, 0x9857, 0xa436, 0xacd0, 0xa438, 0x0150,
+        0xa436, 0xacce, 0xa438, 0x989f, 0xa436, 0xacd0, 0xa438, 0x0198,
+        0xa436, 0xacce, 0xa438, 0xb0b7, 0xa436, 0xacd0, 0xa438, 0x01b0,
+        0xa436, 0xacce, 0xa438, 0xb8bf, 0xa436, 0xacd0, 0xa438, 0x01b8,
+        0xa436, 0xacce, 0xa438, 0xb077, 0xa436, 0xacd0, 0xa438, 0x0171,
+        0xa436, 0xacce, 0xa438, 0xb87f, 0xa436, 0xacd0, 0xa438, 0x0179,
+        0xa436, 0xacce, 0xa438, 0xfb47, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb4f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x6087, 0xa436, 0xacd0, 0xa438, 0x0180,
+        0xa436, 0xacce, 0xa438, 0x600f, 0xa436, 0xacd0, 0xa438, 0x0108,
+        0xa436, 0xacce, 0xa438, 0x6807, 0xa436, 0xacd0, 0xa438, 0x0100,
+        0xa436, 0xacce, 0xa438, 0x688f, 0xa436, 0xacd0, 0xa438, 0x0188,
+        0xa436, 0xacce, 0xa438, 0x7027, 0xa436, 0xacd0, 0xa438, 0x0120,
+        0xa436, 0xacce, 0xa438, 0x702f, 0xa436, 0xacd0, 0xa438, 0x0128,
+        0xa436, 0xacce, 0xa438, 0x7847, 0xa436, 0xacd0, 0xa438, 0x0140,
+        0xa436, 0xacce, 0xa438, 0x784f, 0xa436, 0xacd0, 0xa438, 0x0148,
+        0xa436, 0xacce, 0xa438, 0x80a7, 0xa436, 0xacd0, 0xa438, 0x01a0,
+        0xa436, 0xacce, 0xa438, 0x88af, 0xa436, 0xacd0, 0xa438, 0x01a8,
+        0xa436, 0xacce, 0xa438, 0x8067, 0xa436, 0xacd0, 0xa438, 0x0161,
+        0xa436, 0xacce, 0xa438, 0x886f, 0xa436, 0xacd0, 0xa438, 0x0169,
+        0xa436, 0xacce, 0xa438, 0xfb57, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb5f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x6017, 0xa436, 0xacd0, 0xa438, 0x0110,
+        0xa436, 0xacce, 0xa438, 0x601f, 0xa436, 0xacd0, 0xa438, 0x0118,
+        0xa436, 0xacce, 0xa438, 0x6837, 0xa436, 0xacd0, 0xa438, 0x0130,
+        0xa436, 0xacce, 0xa438, 0x683f, 0xa436, 0xacd0, 0xa438, 0x0138,
+        0xa436, 0xacce, 0xa438, 0x7097, 0xa436, 0xacd0, 0xa438, 0x0190,
+        0xa436, 0xacce, 0xa438, 0x705f, 0xa436, 0xacd0, 0xa438, 0x0158,
+        0xa436, 0xacce, 0xa438, 0x7857, 0xa436, 0xacd0, 0xa438, 0x0150,
+        0xa436, 0xacce, 0xa438, 0x789f, 0xa436, 0xacd0, 0xa438, 0x0198,
+        0xa436, 0xacce, 0xa438, 0x90b7, 0xa436, 0xacd0, 0xa438, 0x01b0,
+        0xa436, 0xacce, 0xa438, 0x98bf, 0xa436, 0xacd0, 0xa438, 0x01b8,
+        0xa436, 0xacce, 0xa438, 0x9077, 0xa436, 0xacd0, 0xa438, 0x0171,
+        0xa436, 0xacce, 0xa438, 0x987f, 0xa436, 0xacd0, 0xa438, 0x0179,
+        0xa436, 0xacce, 0xa438, 0xfb67, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb6f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x4087, 0xa436, 0xacd0, 0xa438, 0x0180,
+        0xa436, 0xacce, 0xa438, 0x400f, 0xa436, 0xacd0, 0xa438, 0x0108,
+        0xa436, 0xacce, 0xa438, 0x4807, 0xa436, 0xacd0, 0xa438, 0x0100,
+        0xa436, 0xacce, 0xa438, 0x488f, 0xa436, 0xacd0, 0xa438, 0x0188,
+        0xa436, 0xacce, 0xa438, 0x5027, 0xa436, 0xacd0, 0xa438, 0x0120,
+        0xa436, 0xacce, 0xa438, 0x502f, 0xa436, 0xacd0, 0xa438, 0x0128,
+        0xa436, 0xacce, 0xa438, 0x5847, 0xa436, 0xacd0, 0xa438, 0x0140,
+        0xa436, 0xacce, 0xa438, 0x584f, 0xa436, 0xacd0, 0xa438, 0x0148,
+        0xa436, 0xacce, 0xa438, 0x60a7, 0xa436, 0xacd0, 0xa438, 0x01a0,
+        0xa436, 0xacce, 0xa438, 0x68af, 0xa436, 0xacd0, 0xa438, 0x01a8,
+        0xa436, 0xacce, 0xa438, 0x6067, 0xa436, 0xacd0, 0xa438, 0x0161,
+        0xa436, 0xacce, 0xa438, 0x686f, 0xa436, 0xacd0, 0xa438, 0x0169,
+        0xa436, 0xacce, 0xa438, 0xfb77, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb7f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x4017, 0xa436, 0xacd0, 0xa438, 0x0110,
+        0xa436, 0xacce, 0xa438, 0x401f, 0xa436, 0xacd0, 0xa438, 0x0118,
+        0xa436, 0xacce, 0xa438, 0x4837, 0xa436, 0xacd0, 0xa438, 0x0130,
+        0xa436, 0xacce, 0xa438, 0x483f, 0xa436, 0xacd0, 0xa438, 0x0138,
+        0xa436, 0xacce, 0xa438, 0x5097, 0xa436, 0xacd0, 0xa438, 0x0190,
+        0xa436, 0xacce, 0xa438, 0x505f, 0xa436, 0xacd0, 0xa438, 0x0158,
+        0xa436, 0xacce, 0xa438, 0x5857, 0xa436, 0xacd0, 0xa438, 0x0150,
+        0xa436, 0xacce, 0xa438, 0x589f, 0xa436, 0xacd0, 0xa438, 0x0198,
+        0xa436, 0xacce, 0xa438, 0x70b7, 0xa436, 0xacd0, 0xa438, 0x01b0,
+        0xa436, 0xacce, 0xa438, 0x78bf, 0xa436, 0xacd0, 0xa438, 0x01b8,
+        0xa436, 0xacce, 0xa438, 0x7077, 0xa436, 0xacd0, 0xa438, 0x0171,
+        0xa436, 0xacce, 0xa438, 0x787f, 0xa436, 0xacd0, 0xa438, 0x0179,
+        0xa436, 0xacce, 0xa438, 0xfb87, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb8f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x40a7, 0xa436, 0xacd0, 0xa438, 0x01a0,
+        0xa436, 0xacce, 0xa438, 0x48af, 0xa436, 0xacd0, 0xa438, 0x01a8,
+        0xa436, 0xacce, 0xa438, 0x4067, 0xa436, 0xacd0, 0xa438, 0x0161,
+        0xa436, 0xacce, 0xa438, 0x486f, 0xa436, 0xacd0, 0xa438, 0x0169,
+        0xa436, 0xacce, 0xa438, 0xfb97, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb9f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x50b7, 0xa436, 0xacd0, 0xa438, 0x01b0,
+        0xa436, 0xacce, 0xa438, 0x58bf, 0xa436, 0xacd0, 0xa438, 0x01b8,
+        0xa436, 0xacce, 0xa438, 0x5077, 0xa436, 0xacd0, 0xa438, 0x0171,
+        0xa436, 0xacce, 0xa438, 0x587f, 0xa436, 0xacd0, 0xa438, 0x0179,
+        0xa436, 0xacce, 0xa438, 0xfba7, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfbaf, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x2067, 0xa436, 0xacd0, 0xa438, 0x0161,
+        0xa436, 0xacce, 0xa438, 0x286f, 0xa436, 0xacd0, 0xa438, 0x0169,
+        0xa436, 0xacce, 0xa438, 0xfbb7, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfbbf, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x3077, 0xa436, 0xacd0, 0xa438, 0x0171,
+        0xa436, 0xacce, 0xa438, 0x387f, 0xa436, 0xacd0, 0xa438, 0x0179,
+        0xa436, 0xacce, 0xa438, 0xfff9, 0xa436, 0xacd0, 0xa438, 0x17ff,
+        0xa436, 0xacce, 0xa438, 0xfff9, 0xa436, 0xacd0, 0xa438, 0x17ff,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x0fff,
+        0xa436, 0xacce, 0xa438, 0xfff8, 0xa436, 0xacd0, 0xa438, 0x0fff,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb47, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb4f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x6087, 0xa436, 0xacd0, 0xa438, 0x0180,
+        0xa436, 0xacce, 0xa438, 0x600f, 0xa436, 0xacd0, 0xa438, 0x0108,
+        0xa436, 0xacce, 0xa438, 0x6807, 0xa436, 0xacd0, 0xa438, 0x0100,
+        0xa436, 0xacce, 0xa438, 0x688f, 0xa436, 0xacd0, 0xa438, 0x0188,
+        0xa436, 0xacce, 0xa438, 0x7027, 0xa436, 0xacd0, 0xa438, 0x0120,
+        0xa436, 0xacce, 0xa438, 0x702f, 0xa436, 0xacd0, 0xa438, 0x0128,
+        0xa436, 0xacce, 0xa438, 0x7847, 0xa436, 0xacd0, 0xa438, 0x0140,
+        0xa436, 0xacce, 0xa438, 0x784f, 0xa436, 0xacd0, 0xa438, 0x0148,
+        0xa436, 0xacce, 0xa438, 0x80a7, 0xa436, 0xacd0, 0xa438, 0x01a0,
+        0xa436, 0xacce, 0xa438, 0x88af, 0xa436, 0xacd0, 0xa438, 0x01a8,
+        0xa436, 0xacce, 0xa438, 0x8067, 0xa436, 0xacd0, 0xa438, 0x0161,
+        0xa436, 0xacce, 0xa438, 0x886f, 0xa436, 0xacd0, 0xa438, 0x0169,
+        0xa436, 0xacce, 0xa438, 0xfb57, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb5f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x6017, 0xa436, 0xacd0, 0xa438, 0x0110,
+        0xa436, 0xacce, 0xa438, 0x601f, 0xa436, 0xacd0, 0xa438, 0x0118,
+        0xa436, 0xacce, 0xa438, 0x6837, 0xa436, 0xacd0, 0xa438, 0x0130,
+        0xa436, 0xacce, 0xa438, 0x683f, 0xa436, 0xacd0, 0xa438, 0x0138,
+        0xa436, 0xacce, 0xa438, 0x7097, 0xa436, 0xacd0, 0xa438, 0x0190,
+        0xa436, 0xacce, 0xa438, 0x705f, 0xa436, 0xacd0, 0xa438, 0x0158,
+        0xa436, 0xacce, 0xa438, 0x7857, 0xa436, 0xacd0, 0xa438, 0x0150,
+        0xa436, 0xacce, 0xa438, 0x789f, 0xa436, 0xacd0, 0xa438, 0x0198,
+        0xa436, 0xacce, 0xa438, 0x90b7, 0xa436, 0xacd0, 0xa438, 0x01b0,
+        0xa436, 0xacce, 0xa438, 0x98bf, 0xa436, 0xacd0, 0xa438, 0x01b8,
+        0xa436, 0xacce, 0xa438, 0x9077, 0xa436, 0xacd0, 0xa438, 0x1171,
+        0xa436, 0xacce, 0xa438, 0x987f, 0xa436, 0xacd0, 0xa438, 0x1179,
+        0xa436, 0xacca, 0xa438, 0x0004, 0xa436, 0xacc6, 0xa438, 0x0008,
+        0xa436, 0xacc8, 0xa438, 0xc000, 0xa436, 0xacc6, 0xa438, 0x0015,
+        0xa436, 0xacc8, 0xa438, 0xc043, 0xa436, 0xacc8, 0xa438, 0x0000,
+        0xB820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8125d_1_efuse[] = {
+        0xB87C, 0x8014, 0xB87E, 0x90C0, 0xa436, 0x8023, 0xa438, 0x3800,
+        0xa436, 0xB82E, 0xa438, 0x0001, 0xb820, 0x0010, 0xa436, 0x843d,
+        0xa438, 0xaf84, 0xa438, 0x55af, 0xa438, 0x8458, 0xa438, 0xaf84,
+        0xa438, 0x58af, 0xa438, 0x8458, 0xa438, 0xaf84, 0xa438, 0x58af,
+        0xa438, 0x8458, 0xa438, 0xaf84, 0xa438, 0x58af, 0xa438, 0x8458,
+        0xa438, 0xaf26, 0xa438, 0xd000, 0xa436, 0xb818, 0xa438, 0x26ca,
+        0xa436, 0xb81a, 0xa438, 0xffff, 0xa436, 0xb81c, 0xa438, 0xffff,
+        0xa436, 0xb81e, 0xa438, 0xffff, 0xa436, 0xb850, 0xa438, 0xffff,
+        0xa436, 0xb852, 0xa438, 0xffff, 0xa436, 0xb878, 0xa438, 0xffff,
+        0xa436, 0xb884, 0xa438, 0xffff, 0xa436, 0xb832, 0xa438, 0x0001,
+        0xa436, 0x0000, 0xa438, 0x0000, 0xB82E, 0x0000, 0xa436, 0x8023,
+        0xa438, 0x0000, 0xB820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static const u16  phy_mcu_ram_code_8125d_2_1[] = {
+        0xa436, 0x8023, 0xa438, 0x3801, 0xa436, 0xB82E, 0xa438, 0x0001,
+        0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x808e, 0xa438, 0x1800, 0xa438, 0x80d6,
+        0xa438, 0x1800, 0xa438, 0x81e2, 0xa438, 0x1800, 0xa438, 0x81e2,
+        0xa438, 0x1800, 0xa438, 0x81e2, 0xa438, 0x1800, 0xa438, 0x81e2,
+        0xa438, 0x1800, 0xa438, 0x81e2, 0xa438, 0xd500, 0xa438, 0xc48d,
+        0xa438, 0xd504, 0xa438, 0x8d03, 0xa438, 0xd701, 0xa438, 0x4045,
+        0xa438, 0xad02, 0xa438, 0xd504, 0xa438, 0xd706, 0xa438, 0x2529,
+        0xa438, 0x8021, 0xa438, 0xd718, 0xa438, 0x607b, 0xa438, 0x40da,
+        0xa438, 0xf019, 0xa438, 0x459a, 0xa438, 0xf03f, 0xa438, 0xd718,
+        0xa438, 0x62bb, 0xa438, 0xbb01, 0xa438, 0xd75e, 0xa438, 0x6231,
+        0xa438, 0x0cf0, 0xa438, 0x0c10, 0xa438, 0xd501, 0xa438, 0xce01,
+        0xa438, 0xd70c, 0xa438, 0x6147, 0xa438, 0x8480, 0xa438, 0x8440,
+        0xa438, 0x8420, 0xa438, 0xa410, 0xa438, 0xce00, 0xa438, 0xd505,
+        0xa438, 0x0c0f, 0xa438, 0x0808, 0xa438, 0xf002, 0xa438, 0xa4f0,
+        0xa438, 0xf03c, 0xa438, 0xbb02, 0xa438, 0xd75e, 0xa438, 0x6231,
+        0xa438, 0x0cf0, 0xa438, 0x0c20, 0xa438, 0xd501, 0xa438, 0xce01,
+        0xa438, 0xd70c, 0xa438, 0x6147, 0xa438, 0x8480, 0xa438, 0x8440,
+        0xa438, 0xa420, 0xa438, 0x8410, 0xa438, 0xce00, 0xa438, 0xd505,
+        0xa438, 0x0c0f, 0xa438, 0x0804, 0xa438, 0xf002, 0xa438, 0xa4f0,
+        0xa438, 0xf028, 0xa438, 0xbb04, 0xa438, 0xd75e, 0xa438, 0x6231,
+        0xa438, 0x0cf0, 0xa438, 0x0c40, 0xa438, 0xd501, 0xa438, 0xce01,
+        0xa438, 0xd70c, 0xa438, 0x6147, 0xa438, 0x8480, 0xa438, 0xa440,
+        0xa438, 0x8420, 0xa438, 0x8410, 0xa438, 0xce00, 0xa438, 0xd505,
+        0xa438, 0x0c0f, 0xa438, 0x0802, 0xa438, 0xf002, 0xa438, 0xa4f0,
+        0xa438, 0xf014, 0xa438, 0xbb08, 0xa438, 0xd75e, 0xa438, 0x6231,
+        0xa438, 0x0cf0, 0xa438, 0x0c80, 0xa438, 0xd501, 0xa438, 0xce01,
+        0xa438, 0xd70c, 0xa438, 0x6147, 0xa438, 0xa480, 0xa438, 0x8440,
+        0xa438, 0x8420, 0xa438, 0x8410, 0xa438, 0xce00, 0xa438, 0xd505,
+        0xa438, 0x0c0f, 0xa438, 0x0801, 0xa438, 0xf002, 0xa438, 0xa4f0,
+        0xa438, 0xce00, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1a8a,
+        0xa438, 0x1000, 0xa438, 0x1829, 0xa438, 0xd73e, 0xa438, 0x6074,
+        0xa438, 0xd718, 0xa438, 0x5f2d, 0xa438, 0x1000, 0xa438, 0x81b7,
+        0xa438, 0x1000, 0xa438, 0x1a8a, 0xa438, 0x1000, 0xa438, 0x1829,
+        0xa438, 0xd73e, 0xa438, 0x7f74, 0xa438, 0x1000, 0xa438, 0x81ce,
+        0xa438, 0x1000, 0xa438, 0x1a8a, 0xa438, 0x1000, 0xa438, 0x1829,
+        0xa438, 0xd718, 0xa438, 0x5f6d, 0xa438, 0x1800, 0xa438, 0x1660,
+        0xa438, 0xd75e, 0xa438, 0x68b1, 0xa438, 0xd504, 0xa438, 0xd71e,
+        0xa438, 0x667b, 0xa438, 0x645a, 0xa438, 0x6239, 0xa438, 0x0cf0,
+        0xa438, 0x0c10, 0xa438, 0xd505, 0xa438, 0x0c0f, 0xa438, 0x0808,
+        0xa438, 0xd501, 0xa438, 0xce01, 0xa438, 0xd70c, 0xa438, 0x60c7,
+        0xa438, 0x8480, 0xa438, 0x8440, 0xa438, 0x8420, 0xa438, 0xa410,
+        0xa438, 0xf032, 0xa438, 0xa4f0, 0xa438, 0xf030, 0xa438, 0x0cf0,
+        0xa438, 0x0c20, 0xa438, 0xd505, 0xa438, 0x0c0f, 0xa438, 0x0804,
+        0xa438, 0xd501, 0xa438, 0xce01, 0xa438, 0xd70c, 0xa438, 0x60c7,
+        0xa438, 0x8480, 0xa438, 0x8440, 0xa438, 0xa420, 0xa438, 0x8410,
+        0xa438, 0xf022, 0xa438, 0xa4f0, 0xa438, 0xf020, 0xa438, 0x0cf0,
+        0xa438, 0x0c40, 0xa438, 0xd505, 0xa438, 0x0c0f, 0xa438, 0x0802,
+        0xa438, 0xd501, 0xa438, 0xce01, 0xa438, 0xd70c, 0xa438, 0x60c7,
+        0xa438, 0x8480, 0xa438, 0xa440, 0xa438, 0x8420, 0xa438, 0x8410,
+        0xa438, 0xf012, 0xa438, 0xa4f0, 0xa438, 0xf010, 0xa438, 0x0cf0,
+        0xa438, 0x0c80, 0xa438, 0xd505, 0xa438, 0x0c0f, 0xa438, 0x0801,
+        0xa438, 0xd501, 0xa438, 0xce01, 0xa438, 0xd70c, 0xa438, 0x60c7,
+        0xa438, 0xa480, 0xa438, 0x8440, 0xa438, 0x8420, 0xa438, 0x8410,
+        0xa438, 0xf002, 0xa438, 0xa4f0, 0xa438, 0x1800, 0xa438, 0x168c,
+        0xa438, 0xd500, 0xa438, 0xd706, 0xa438, 0x2529, 0xa438, 0x80e0,
+        0xa438, 0xd718, 0xa438, 0x607b, 0xa438, 0x40da, 0xa438, 0xf00f,
+        0xa438, 0x431a, 0xa438, 0xf021, 0xa438, 0xd718, 0xa438, 0x617b,
+        0xa438, 0x1000, 0xa438, 0x1a8a, 0xa438, 0x1000, 0xa438, 0x1b1a,
+        0xa438, 0xd718, 0xa438, 0x608e, 0xa438, 0xd73e, 0xa438, 0x5f34,
+        0xa438, 0xf020, 0xa438, 0xf053, 0xa438, 0x1000, 0xa438, 0x1a8a,
+        0xa438, 0x1000, 0xa438, 0x1b1a, 0xa438, 0xd718, 0xa438, 0x608e,
+        0xa438, 0xd73e, 0xa438, 0x5f34, 0xa438, 0xf023, 0xa438, 0xf067,
+        0xa438, 0x1000, 0xa438, 0x1a8a, 0xa438, 0x1000, 0xa438, 0x1b1a,
+        0xa438, 0xd718, 0xa438, 0x608e, 0xa438, 0xd73e, 0xa438, 0x5f34,
+        0xa438, 0xf026, 0xa438, 0xf07b, 0xa438, 0x1000, 0xa438, 0x1a8a,
+        0xa438, 0x1000, 0xa438, 0x1b1a, 0xa438, 0xd718, 0xa438, 0x608e,
+        0xa438, 0xd73e, 0xa438, 0x5f34, 0xa438, 0xf029, 0xa438, 0xf08f,
+        0xa438, 0x1000, 0xa438, 0x81b7, 0xa438, 0x1000, 0xa438, 0x1a8a,
+        0xa438, 0xd73e, 0xa438, 0x7fb4, 0xa438, 0x1000, 0xa438, 0x81ce,
+        0xa438, 0x1000, 0xa438, 0x1a8a, 0xa438, 0xd718, 0xa438, 0x5fae,
+        0xa438, 0xf028, 0xa438, 0x1000, 0xa438, 0x81b7, 0xa438, 0x1000,
+        0xa438, 0x1a8a, 0xa438, 0xd73e, 0xa438, 0x7fb4, 0xa438, 0x1000,
+        0xa438, 0x81ce, 0xa438, 0x1000, 0xa438, 0x1a8a, 0xa438, 0xd718,
+        0xa438, 0x5fae, 0xa438, 0xf039, 0xa438, 0x1000, 0xa438, 0x81b7,
+        0xa438, 0x1000, 0xa438, 0x1a8a, 0xa438, 0xd73e, 0xa438, 0x7fb4,
+        0xa438, 0x1000, 0xa438, 0x81ce, 0xa438, 0x1000, 0xa438, 0x1a8a,
+        0xa438, 0xd718, 0xa438, 0x5fae, 0xa438, 0xf04a, 0xa438, 0x1000,
+        0xa438, 0x81b7, 0xa438, 0x1000, 0xa438, 0x1a8a, 0xa438, 0xd73e,
+        0xa438, 0x7fb4, 0xa438, 0x1000, 0xa438, 0x81ce, 0xa438, 0x1000,
+        0xa438, 0x1a8a, 0xa438, 0xd718, 0xa438, 0x5fae, 0xa438, 0xf05b,
+        0xa438, 0xd719, 0xa438, 0x4119, 0xa438, 0xd504, 0xa438, 0xac01,
+        0xa438, 0xae01, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1a78,
+        0xa438, 0xf00a, 0xa438, 0xd719, 0xa438, 0x4118, 0xa438, 0xd504,
+        0xa438, 0xac11, 0xa438, 0xd501, 0xa438, 0xce01, 0xa438, 0xa410,
+        0xa438, 0xce00, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1a8a,
+        0xa438, 0xd718, 0xa438, 0x5fb0, 0xa438, 0xd505, 0xa438, 0xd719,
+        0xa438, 0x4079, 0xa438, 0xa80f, 0xa438, 0xf05d, 0xa438, 0x4b98,
+        0xa438, 0xa808, 0xa438, 0xf05a, 0xa438, 0xd719, 0xa438, 0x4119,
+        0xa438, 0xd504, 0xa438, 0xac02, 0xa438, 0xae01, 0xa438, 0xd500,
+        0xa438, 0x1000, 0xa438, 0x1a78, 0xa438, 0xf00a, 0xa438, 0xd719,
+        0xa438, 0x4118, 0xa438, 0xd504, 0xa438, 0xac22, 0xa438, 0xd501,
+        0xa438, 0xce01, 0xa438, 0xa420, 0xa438, 0xce00, 0xa438, 0xd500,
+        0xa438, 0x1000, 0xa438, 0x1a8a, 0xa438, 0xd718, 0xa438, 0x5fb0,
+        0xa438, 0xd505, 0xa438, 0xd719, 0xa438, 0x4079, 0xa438, 0xa80f,
+        0xa438, 0xf03f, 0xa438, 0x47d8, 0xa438, 0xa804, 0xa438, 0xf03c,
+        0xa438, 0xd719, 0xa438, 0x4119, 0xa438, 0xd504, 0xa438, 0xac04,
+        0xa438, 0xae01, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1a78,
+        0xa438, 0xf00a, 0xa438, 0xd719, 0xa438, 0x4118, 0xa438, 0xd504,
+        0xa438, 0xac44, 0xa438, 0xd501, 0xa438, 0xce01, 0xa438, 0xa440,
+        0xa438, 0xce00, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1a8a,
+        0xa438, 0xd718, 0xa438, 0x5fb0, 0xa438, 0xd505, 0xa438, 0xd719,
+        0xa438, 0x4079, 0xa438, 0xa80f, 0xa438, 0xf021, 0xa438, 0x4418,
+        0xa438, 0xa802, 0xa438, 0xf01e, 0xa438, 0xd719, 0xa438, 0x4119,
+        0xa438, 0xd504, 0xa438, 0xac08, 0xa438, 0xae01, 0xa438, 0xd500,
+        0xa438, 0x1000, 0xa438, 0x1a78, 0xa438, 0xf00a, 0xa438, 0xd719,
+        0xa438, 0x4118, 0xa438, 0xd504, 0xa438, 0xac88, 0xa438, 0xd501,
+        0xa438, 0xce01, 0xa438, 0xa480, 0xa438, 0xce00, 0xa438, 0xd500,
+        0xa438, 0x1000, 0xa438, 0x1a8a, 0xa438, 0xd718, 0xa438, 0x5fb0,
+        0xa438, 0xd505, 0xa438, 0xd719, 0xa438, 0x4079, 0xa438, 0xa80f,
+        0xa438, 0xf003, 0xa438, 0x4058, 0xa438, 0xa801, 0xa438, 0x1800,
+        0xa438, 0x1736, 0xa438, 0xd73e, 0xa438, 0xd505, 0xa438, 0x3088,
+        0xa438, 0x81c0, 0xa438, 0x61d3, 0xa438, 0x6172, 0xa438, 0x6111,
+        0xa438, 0x60b0, 0xa438, 0xf00d, 0xa438, 0x3298, 0xa438, 0x81cb,
+        0xa438, 0xf00a, 0xa438, 0xa808, 0xa438, 0xf008, 0xa438, 0xa804,
+        0xa438, 0xf006, 0xa438, 0xa802, 0xa438, 0xf004, 0xa438, 0xa801,
+        0xa438, 0xf002, 0xa438, 0xa80f, 0xa438, 0xd500, 0xa438, 0x0800,
+        0xa438, 0xd505, 0xa438, 0xd75e, 0xa438, 0x6211, 0xa438, 0xd71e,
+        0xa438, 0x619b, 0xa438, 0x611a, 0xa438, 0x6099, 0xa438, 0x0c0f,
+        0xa438, 0x0808, 0xa438, 0xf009, 0xa438, 0x0c0f, 0xa438, 0x0804,
+        0xa438, 0xf006, 0xa438, 0x0c0f, 0xa438, 0x0802, 0xa438, 0xf003,
+        0xa438, 0x0c0f, 0xa438, 0x0801, 0xa438, 0xd500, 0xa438, 0x0800,
+        0xa436, 0xA026, 0xa438, 0xffff, 0xa436, 0xA024, 0xa438, 0xffff,
+        0xa436, 0xA022, 0xa438, 0xffff, 0xa436, 0xA020, 0xa438, 0xffff,
+        0xa436, 0xA006, 0xa438, 0xffff, 0xa436, 0xA004, 0xa438, 0x16ab,
+        0xa436, 0xA002, 0xa438, 0x1663, 0xa436, 0xA000, 0xa438, 0x1608,
+        0xa436, 0xA008, 0xa438, 0x0700, 0xa436, 0xA016, 0xa438, 0x0000,
+        0xa436, 0xA012, 0xa438, 0x07f8, 0xa436, 0xA014, 0xa438, 0xcc01,
+        0xa438, 0x20f6, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa436, 0xA152,
+        0xa438, 0x021c, 0xa436, 0xA154, 0xa438, 0x2100, 0xa436, 0xA156,
+        0xa438, 0x3fff, 0xa436, 0xA158, 0xa438, 0x3fff, 0xa436, 0xA15A,
+        0xa438, 0x3fff, 0xa436, 0xA15C, 0xa438, 0x3fff, 0xa436, 0xA15E,
+        0xa438, 0x3fff, 0xa436, 0xA160, 0xa438, 0x3fff, 0xa436, 0xA150,
+        0xa438, 0x0003, 0xa436, 0xA016, 0xa438, 0x0010, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x8014, 0xa438, 0x1800, 0xa438, 0x803d,
+        0xa438, 0x1800, 0xa438, 0x804a, 0xa438, 0x1800, 0xa438, 0x804e,
+        0xa438, 0x1800, 0xa438, 0x8052, 0xa438, 0x1800, 0xa438, 0x8092,
+        0xa438, 0x1800, 0xa438, 0x80a0, 0xa438, 0xc2ff, 0xa438, 0x9a40,
+        0xa438, 0x1800, 0xa438, 0x0042, 0xa438, 0x1000, 0xa438, 0x02e5,
+        0xa438, 0xba20, 0xa438, 0x1000, 0xa438, 0x02b4, 0xa438, 0xd701,
+        0xa438, 0x4103, 0xa438, 0xd700, 0xa438, 0x5f6c, 0xa438, 0x1000,
+        0xa438, 0x8024, 0xa438, 0x9a20, 0xa438, 0x1800, 0xa438, 0x0073,
+        0xa438, 0x1800, 0xa438, 0x0084, 0xa438, 0xd701, 0xa438, 0x4061,
+        0xa438, 0xba0f, 0xa438, 0xf004, 0xa438, 0x4060, 0xa438, 0x1000,
+        0xa438, 0x802d, 0xa438, 0xba10, 0xa438, 0x0800, 0xa438, 0xd700,
+        0xa438, 0x60bb, 0xa438, 0x611c, 0xa438, 0x0c0f, 0xa438, 0x1a01,
+        0xa438, 0xf00a, 0xa438, 0x60fc, 0xa438, 0x0c0f, 0xa438, 0x1a02,
+        0xa438, 0xf006, 0xa438, 0x0c0f, 0xa438, 0x1a04, 0xa438, 0xf003,
+        0xa438, 0x0c0f, 0xa438, 0x1a08, 0xa438, 0x0800, 0xa438, 0x0c0f,
+        0xa438, 0x0504, 0xa438, 0xad02, 0xa438, 0xd73e, 0xa438, 0x40f6,
+        0xa438, 0x1000, 0xa438, 0x02c0, 0xa438, 0xd700, 0xa438, 0x5fac,
+        0xa438, 0x1000, 0xa438, 0x8024, 0xa438, 0x1800, 0xa438, 0x0139,
+        0xa438, 0x9a3f, 0xa438, 0x8bf0, 0xa438, 0x1800, 0xa438, 0x02df,
+        0xa438, 0x9a3f, 0xa438, 0x9910, 0xa438, 0x1800, 0xa438, 0x02d7,
+        0xa438, 0xad02, 0xa438, 0x8d01, 0xa438, 0x9a7f, 0xa438, 0x9910,
+        0xa438, 0x9860, 0xa438, 0xcb00, 0xa438, 0xd501, 0xa438, 0xce01,
+        0xa438, 0x85f0, 0xa438, 0xd500, 0xa438, 0x0c0f, 0xa438, 0x0505,
+        0xa438, 0xb820, 0xa438, 0xc000, 0xa438, 0xc100, 0xa438, 0xc628,
+        0xa438, 0xc700, 0xa438, 0xc801, 0xa438, 0xc91e, 0xa438, 0xc001,
+        0xa438, 0x4019, 0xa438, 0xc6f8, 0xa438, 0xc702, 0xa438, 0xc809,
+        0xa438, 0xc940, 0xa438, 0xc002, 0xa438, 0x4019, 0xa438, 0x1000,
+        0xa438, 0x02cc, 0xa438, 0xd700, 0xa438, 0x5fa7, 0xa438, 0xc010,
+        0xa438, 0x1000, 0xa438, 0x02cc, 0xa438, 0xd700, 0xa438, 0x5fa0,
+        0xa438, 0xc020, 0xa438, 0x1000, 0xa438, 0x02cc, 0xa438, 0xd700,
+        0xa438, 0x5fa1, 0xa438, 0x0c0f, 0xa438, 0x0506, 0xa438, 0xb840,
+        0xa438, 0xc6ca, 0xa438, 0xc701, 0xa438, 0xc809, 0xa438, 0xc900,
+        0xa438, 0xc001, 0xa438, 0x4019, 0xa438, 0xc6b8, 0xa438, 0xc700,
+        0xa438, 0xc800, 0xa438, 0xc900, 0xa438, 0xc008, 0xa438, 0x4019,
+        0xa438, 0x1000, 0xa438, 0x02cc, 0xa438, 0xd700, 0xa438, 0x5fa5,
+        0xa438, 0x8580, 0xa438, 0x8d02, 0xa438, 0x1800, 0xa438, 0x018f,
+        0xa438, 0x1000, 0xa438, 0x02cc, 0xa438, 0xd700, 0xa438, 0x6124,
+        0xa438, 0xd73e, 0xa438, 0x5f75, 0xa438, 0xd700, 0xa438, 0x5f2c,
+        0xa438, 0x1000, 0xa438, 0x8024, 0xa438, 0x9a20, 0xa438, 0xfff5,
+        0xa438, 0x1800, 0xa438, 0x00b8, 0xa438, 0x0c0f, 0xa438, 0x0503,
+        0xa438, 0xad02, 0xa438, 0x68c8, 0xa438, 0x1000, 0xa438, 0x02c0,
+        0xa438, 0xd700, 0xa438, 0x6848, 0xa438, 0x604d, 0xa438, 0xfffb,
+        0xa438, 0xd73e, 0xa438, 0x6082, 0xa438, 0x1000, 0xa438, 0x02a1,
+        0xa438, 0x8a0f, 0xa438, 0x1000, 0xa438, 0x02c0, 0xa438, 0xd700,
+        0xa438, 0x5fae, 0xa438, 0x1000, 0xa438, 0x02de, 0xa438, 0x1000,
+        0xa438, 0x02c0, 0xa438, 0xd700, 0xa438, 0x5faf, 0xa438, 0x8d01,
+        0xa438, 0x8b0f, 0xa438, 0x1000, 0xa438, 0x02c0, 0xa438, 0xd700,
+        0xa438, 0x2a58, 0xa438, 0x80c5, 0xa438, 0x2a5b, 0xa438, 0x80cd,
+        0xa438, 0x2b53, 0xa438, 0x80d9, 0xa438, 0xfff7, 0xa438, 0x1000,
+        0xa438, 0x022a, 0xa438, 0x1000, 0xa438, 0x02e5, 0xa438, 0xba40,
+        0xa438, 0x1000, 0xa438, 0x02fd, 0xa438, 0xf018, 0xa438, 0x1000,
+        0xa438, 0x022a, 0xa438, 0x1000, 0xa438, 0x02e5, 0xa438, 0xba40,
+        0xa438, 0x1000, 0xa438, 0x02c0, 0xa438, 0xd700, 0xa438, 0x5faa,
+        0xa438, 0x1000, 0xa438, 0x02fd, 0xa438, 0xf00c, 0xa438, 0x1000,
+        0xa438, 0x022a, 0xa438, 0x1000, 0xa438, 0x02fd, 0xa438, 0x1000,
+        0xa438, 0x02c0, 0xa438, 0xd700, 0xa438, 0x5fab, 0xa438, 0x1000,
+        0xa438, 0x02e5, 0xa438, 0xba40, 0xa438, 0x1000, 0xa438, 0x02c0,
+        0xa438, 0xd700, 0xa438, 0x6088, 0xa438, 0xfffc, 0xa438, 0x1800,
+        0xa438, 0x0120, 0xa438, 0x1800, 0xa438, 0x0122, 0xa436, 0xA08E,
+        0xa438, 0x00db, 0xa436, 0xA08C, 0xa438, 0x00b4, 0xa436, 0xA08A,
+        0xa438, 0x015a, 0xa436, 0xA088, 0xa438, 0x02d6, 0xa436, 0xA086,
+        0xa438, 0x02de, 0xa436, 0xA084, 0xa438, 0x0137, 0xa436, 0xA082,
+        0xa438, 0x0071, 0xa436, 0xA080, 0xa438, 0x0041, 0xa436, 0xA090,
+        0xa438, 0x00ff, 0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x801d, 0xa438, 0x1800, 0xa438, 0x808a,
+        0xa438, 0x1800, 0xa438, 0x80a5, 0xa438, 0x1800, 0xa438, 0x80b8,
+        0xa438, 0x1800, 0xa438, 0x8108, 0xa438, 0x1800, 0xa438, 0x810f,
+        0xa438, 0x1800, 0xa438, 0x811b, 0xa438, 0x8980, 0xa438, 0xd702,
+        0xa438, 0x6126, 0xa438, 0xd704, 0xa438, 0x4063, 0xa438, 0xd702,
+        0xa438, 0x6060, 0xa438, 0xd702, 0xa438, 0x6077, 0xa438, 0x1800,
+        0xa438, 0x0c29, 0xa438, 0x1800, 0xa438, 0x0c2b, 0xa438, 0x1000,
+        0xa438, 0x115a, 0xa438, 0xd71f, 0xa438, 0x5fb4, 0xa438, 0xd702,
+        0xa438, 0x6c46, 0xa438, 0xd704, 0xa438, 0x4063, 0xa438, 0xd702,
+        0xa438, 0x6060, 0xa438, 0xd702, 0xa438, 0x6b97, 0xa438, 0xa340,
+        0xa438, 0x0c06, 0xa438, 0x0102, 0xa438, 0xce01, 0xa438, 0x1000,
+        0xa438, 0x117a, 0xa438, 0xa240, 0xa438, 0xa902, 0xa438, 0xa204,
+        0xa438, 0xa280, 0xa438, 0xa364, 0xa438, 0xab02, 0xa438, 0x8380,
+        0xa438, 0xa00a, 0xa438, 0xcd8d, 0xa438, 0x1000, 0xa438, 0x115a,
+        0xa438, 0xd706, 0xa438, 0x5fb5, 0xa438, 0xb920, 0xa438, 0x1000,
+        0xa438, 0x115a, 0xa438, 0xd71f, 0xa438, 0x7fb4, 0xa438, 0x9920,
+        0xa438, 0x1000, 0xa438, 0x115a, 0xa438, 0xd71f, 0xa438, 0x6065,
+        0xa438, 0x7c74, 0xa438, 0xfffb, 0xa438, 0xb820, 0xa438, 0x1000,
+        0xa438, 0x115a, 0xa438, 0xd71f, 0xa438, 0x7fa5, 0xa438, 0x9820,
+        0xa438, 0xa410, 0xa438, 0x8902, 0xa438, 0xa120, 0xa438, 0xa380,
+        0xa438, 0xce02, 0xa438, 0x1000, 0xa438, 0x117a, 0xa438, 0x8280,
+        0xa438, 0xa324, 0xa438, 0xab02, 0xa438, 0xa00a, 0xa438, 0x8118,
+        0xa438, 0x863f, 0xa438, 0x87fb, 0xa438, 0xcd8e, 0xa438, 0xd193,
+        0xa438, 0xd047, 0xa438, 0x1000, 0xa438, 0x115a, 0xa438, 0x1000,
+        0xa438, 0x115f, 0xa438, 0xd700, 0xa438, 0x5f7b, 0xa438, 0xa280,
+        0xa438, 0x1000, 0xa438, 0x115a, 0xa438, 0x1000, 0xa438, 0x115f,
+        0xa438, 0xd706, 0xa438, 0x5f78, 0xa438, 0xa210, 0xa438, 0xd700,
+        0xa438, 0x6083, 0xa438, 0xd101, 0xa438, 0xd047, 0xa438, 0xf003,
+        0xa438, 0xd160, 0xa438, 0xd04b, 0xa438, 0x1000, 0xa438, 0x115a,
+        0xa438, 0x1000, 0xa438, 0x115f, 0xa438, 0xd700, 0xa438, 0x5f7b,
+        0xa438, 0x1000, 0xa438, 0x115a, 0xa438, 0x1000, 0xa438, 0x115f,
+        0xa438, 0xd706, 0xa438, 0x5f79, 0xa438, 0x8120, 0xa438, 0xbb20,
+        0xa438, 0x1800, 0xa438, 0x0c8b, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8f80, 0xa438, 0x9503, 0xa438, 0x1800, 0xa438, 0x0c3c,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa608, 0xa438, 0x9503,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8f80, 0xa438, 0x9503,
+        0xa438, 0xd704, 0xa438, 0x6192, 0xa438, 0xd702, 0xa438, 0x4116,
+        0xa438, 0xce04, 0xa438, 0x1000, 0xa438, 0x117a, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8f40, 0xa438, 0x9503, 0xa438, 0x1800,
+        0xa438, 0x0b3d, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xaf40,
+        0xa438, 0x9503, 0xa438, 0x1800, 0xa438, 0x0b48, 0xa438, 0xd704,
+        0xa438, 0x6192, 0xa438, 0xd702, 0xa438, 0x4116, 0xa438, 0xce04,
+        0xa438, 0x1000, 0xa438, 0x117a, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8f40, 0xa438, 0x9503, 0xa438, 0x1800, 0xa438, 0x1269,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xaf40, 0xa438, 0x9503,
+        0xa438, 0x1800, 0xa438, 0x1274, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa608, 0xa438, 0xc700, 0xa438, 0x9503, 0xa438, 0xce54,
+        0xa438, 0x1000, 0xa438, 0x117a, 0xa438, 0xa290, 0xa438, 0xa304,
+        0xa438, 0xab02, 0xa438, 0xd700, 0xa438, 0x6050, 0xa438, 0xab04,
+        0xa438, 0x0c38, 0xa438, 0x0608, 0xa438, 0xaa0b, 0xa438, 0xd702,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8d01, 0xa438, 0xae40,
+        0xa438, 0x4044, 0xa438, 0x8e20, 0xa438, 0x9503, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8c20, 0xa438, 0x9503, 0xa438, 0xd700,
+        0xa438, 0x6078, 0xa438, 0xd700, 0xa438, 0x609a, 0xa438, 0xd109,
+        0xa438, 0xd074, 0xa438, 0xf003, 0xa438, 0xd109, 0xa438, 0xd075,
+        0xa438, 0x1000, 0xa438, 0x115a, 0xa438, 0xd704, 0xa438, 0x6252,
+        0xa438, 0xd702, 0xa438, 0x4116, 0xa438, 0xce54, 0xa438, 0x1000,
+        0xa438, 0x117a, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8f40,
+        0xa438, 0x9503, 0xa438, 0xa00a, 0xa438, 0xd704, 0xa438, 0x41e7,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa570, 0xa438, 0x9503,
+        0xa438, 0xf00a, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xaf40,
+        0xa438, 0x9503, 0xa438, 0x800a, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8570, 0xa438, 0x9503, 0xa438, 0xd704, 0xa438, 0x60f3,
+        0xa438, 0xd71f, 0xa438, 0x60ee, 0xa438, 0xd700, 0xa438, 0x5bbe,
+        0xa438, 0x1800, 0xa438, 0x0e71, 0xa438, 0x1800, 0xa438, 0x0e7c,
+        0xa438, 0x1800, 0xa438, 0x0e7e, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xaf80, 0xa438, 0x9503, 0xa438, 0xcd62, 0xa438, 0x1800,
+        0xa438, 0x0bd2, 0xa438, 0x800a, 0xa438, 0x8530, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8d10, 0xa438, 0x9503, 0xa438, 0xd700,
+        0xa438, 0x6050, 0xa438, 0xaa20, 0xa438, 0x8306, 0xa438, 0x1800,
+        0xa438, 0x0cb6, 0xa438, 0xd105, 0xa438, 0xd040, 0xa438, 0x1000,
+        0xa438, 0x0d8f, 0xa438, 0xd700, 0xa438, 0x5fbb, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8608, 0xa438, 0x9503, 0xa438, 0x1000,
+        0xa438, 0x0d8f, 0xa438, 0xd704, 0xa438, 0x7fb6, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x87f0, 0xa438, 0x9503, 0xa438, 0xce88,
+        0xa438, 0x1000, 0xa438, 0x117a, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa608, 0xa438, 0x9503, 0xa438, 0xd73e, 0xa438, 0x60a5,
+        0xa438, 0xd705, 0xa438, 0x4071, 0xa438, 0x1800, 0xa438, 0x0d65,
+        0xa438, 0x1800, 0xa438, 0x0d6f, 0xa436, 0xA10E, 0xa438, 0x0d58,
+        0xa436, 0xA10C, 0xa438, 0x0cb5, 0xa436, 0xA10A, 0xa438, 0x0bd1,
+        0xa436, 0xA108, 0xa438, 0x0e37, 0xa436, 0xA106, 0xa438, 0x1267,
+        0xa436, 0xA104, 0xa438, 0x0b3b, 0xa436, 0xA102, 0xa438, 0x0c38,
+        0xa436, 0xA100, 0xa438, 0x0c24, 0xa436, 0xA110, 0xa438, 0x00ff,
+        0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x1ff8,
+        0xa436, 0xA014, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa436, 0xA164, 0xa438, 0x0ceb, 0xa436, 0xA166,
+        0xa438, 0x0e73, 0xa436, 0xA168, 0xa438, 0x0deb, 0xa436, 0xA16A,
+        0xa438, 0x3fff, 0xa436, 0xA16C, 0xa438, 0x3fff, 0xa436, 0xA16E,
+        0xa438, 0x3fff, 0xa436, 0xA170, 0xa438, 0x3fff, 0xa436, 0xA172,
+        0xa438, 0x3fff, 0xa436, 0xA162, 0xa438, 0x0007, 0xa436, 0xb87c,
+        0xa438, 0x85bf, 0xa436, 0xb87e, 0xa438, 0xaf85, 0xa438, 0xd7af,
+        0xa438, 0x85fb, 0xa438, 0xaf86, 0xa438, 0x10af, 0xa438, 0x8638,
+        0xa438, 0xaf86, 0xa438, 0x47af, 0xa438, 0x8647, 0xa438, 0xaf86,
+        0xa438, 0x47af, 0xa438, 0x8647, 0xa438, 0xbf85, 0xa438, 0xf802,
+        0xa438, 0x627f, 0xa438, 0xbf61, 0xa438, 0xc702, 0xa438, 0x627f,
+        0xa438, 0xae0c, 0xa438, 0xbf85, 0xa438, 0xf802, 0xa438, 0x6276,
+        0xa438, 0xbf61, 0xa438, 0xc702, 0xa438, 0x6276, 0xa438, 0xee85,
+        0xa438, 0x4200, 0xa438, 0xaf1b, 0xa438, 0x2333, 0xa438, 0xa484,
+        0xa438, 0xbf86, 0xa438, 0x0a02, 0xa438, 0x627f, 0xa438, 0xbf86,
+        0xa438, 0x0d02, 0xa438, 0x627f, 0xa438, 0xaf1b, 0xa438, 0x8422,
+        0xa438, 0xa484, 0xa438, 0x66ac, 0xa438, 0x0ef8, 0xa438, 0xfbef,
+        0xa438, 0x79fb, 0xa438, 0xe080, 0xa438, 0x16ad, 0xa438, 0x230f,
+        0xa438, 0xee85, 0xa438, 0x4200, 0xa438, 0x1f44, 0xa438, 0xbf86,
+        0xa438, 0x30d7, 0xa438, 0x0008, 0xa438, 0x0264, 0xa438, 0xa3ff,
+        0xa438, 0xef97, 0xa438, 0xfffc, 0xa438, 0x0485, 0xa438, 0xf861,
+        0xa438, 0xc786, 0xa438, 0x0a86, 0xa438, 0x0de1, 0xa438, 0x8feb,
+        0xa438, 0xe583, 0xa438, 0x20e1, 0xa438, 0x8fea, 0xa438, 0xe583,
+        0xa438, 0x21af, 0xa438, 0x41a7, 0xa436, 0xb85e, 0xa438, 0x1b05,
+        0xa436, 0xb860, 0xa438, 0x1b78, 0xa436, 0xb862, 0xa438, 0x1a08,
+        0xa436, 0xb864, 0xa438, 0x419F, 0xa436, 0xb886, 0xa438, 0xffff,
+        0xa436, 0xb888, 0xa438, 0xffff, 0xa436, 0xb88a, 0xa438, 0xffff,
+        0xa436, 0xb88c, 0xa438, 0xffff, 0xa436, 0xb838, 0xa438, 0x000f,
+        0xb820, 0x0010, 0xa436, 0x0000, 0xa438, 0x0000, 0xB82E, 0x0000,
+        0xa436, 0x8023, 0xa438, 0x0000, 0xa436, 0x801E, 0xa438, 0x0013,
+        0xB820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static const u16  phy_mcu_ram_code_8125d_2_2[] = {
+        0xa436, 0xacca, 0xa438, 0x0104, 0xa436, 0xaccc, 0xa438, 0x8000,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x0fff,
+        0xa436, 0xacce, 0xa438, 0xfd47, 0xa436, 0xacd0, 0xa438, 0x0fff,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xe56f, 0xa436, 0xacd0, 0xa438, 0x01c0,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xed97, 0xa436, 0xacd0, 0xa438, 0x01c8,
+        0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xf5bf, 0xa436, 0xacd0, 0xa438, 0x01d0,
+        0xa436, 0xacce, 0xa438, 0xfb07, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb0f, 0xa436, 0xacd0, 0xa438, 0x01d8,
+        0xa436, 0xacce, 0xa438, 0xa087, 0xa436, 0xacd0, 0xa438, 0x0180,
+        0xa436, 0xacce, 0xa438, 0xa00f, 0xa436, 0xacd0, 0xa438, 0x0108,
+        0xa436, 0xacce, 0xa438, 0xa807, 0xa436, 0xacd0, 0xa438, 0x0100,
+        0xa436, 0xacce, 0xa438, 0xa88f, 0xa436, 0xacd0, 0xa438, 0x0188,
+        0xa436, 0xacce, 0xa438, 0xb027, 0xa436, 0xacd0, 0xa438, 0x0120,
+        0xa436, 0xacce, 0xa438, 0xb02f, 0xa436, 0xacd0, 0xa438, 0x0128,
+        0xa436, 0xacce, 0xa438, 0xb847, 0xa436, 0xacd0, 0xa438, 0x0140,
+        0xa436, 0xacce, 0xa438, 0xb84f, 0xa436, 0xacd0, 0xa438, 0x0148,
+        0xa436, 0xacce, 0xa438, 0xfb17, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb1f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xa017, 0xa436, 0xacd0, 0xa438, 0x0110,
+        0xa436, 0xacce, 0xa438, 0xa01f, 0xa436, 0xacd0, 0xa438, 0x0118,
+        0xa436, 0xacce, 0xa438, 0xa837, 0xa436, 0xacd0, 0xa438, 0x0130,
+        0xa436, 0xacce, 0xa438, 0xa83f, 0xa436, 0xacd0, 0xa438, 0x0138,
+        0xa436, 0xacce, 0xa438, 0xb097, 0xa436, 0xacd0, 0xa438, 0x0190,
+        0xa436, 0xacce, 0xa438, 0xb05f, 0xa436, 0xacd0, 0xa438, 0x0158,
+        0xa436, 0xacce, 0xa438, 0xb857, 0xa436, 0xacd0, 0xa438, 0x0150,
+        0xa436, 0xacce, 0xa438, 0xb89f, 0xa436, 0xacd0, 0xa438, 0x0198,
+        0xa436, 0xacce, 0xa438, 0xfb27, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb2f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x8087, 0xa436, 0xacd0, 0xa438, 0x0180,
+        0xa436, 0xacce, 0xa438, 0x800f, 0xa436, 0xacd0, 0xa438, 0x0108,
+        0xa436, 0xacce, 0xa438, 0x8807, 0xa436, 0xacd0, 0xa438, 0x0100,
+        0xa436, 0xacce, 0xa438, 0x888f, 0xa436, 0xacd0, 0xa438, 0x0188,
+        0xa436, 0xacce, 0xa438, 0x9027, 0xa436, 0xacd0, 0xa438, 0x0120,
+        0xa436, 0xacce, 0xa438, 0x902f, 0xa436, 0xacd0, 0xa438, 0x0128,
+        0xa436, 0xacce, 0xa438, 0x9847, 0xa436, 0xacd0, 0xa438, 0x0140,
+        0xa436, 0xacce, 0xa438, 0x984f, 0xa436, 0xacd0, 0xa438, 0x0148,
+        0xa436, 0xacce, 0xa438, 0xa0a7, 0xa436, 0xacd0, 0xa438, 0x01a0,
+        0xa436, 0xacce, 0xa438, 0xa8af, 0xa436, 0xacd0, 0xa438, 0x01a8,
+        0xa436, 0xacce, 0xa438, 0xa067, 0xa436, 0xacd0, 0xa438, 0x0161,
+        0xa436, 0xacce, 0xa438, 0xa86f, 0xa436, 0xacd0, 0xa438, 0x0169,
+        0xa436, 0xacce, 0xa438, 0xfb37, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb3f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x8017, 0xa436, 0xacd0, 0xa438, 0x0110,
+        0xa436, 0xacce, 0xa438, 0x801f, 0xa436, 0xacd0, 0xa438, 0x0118,
+        0xa436, 0xacce, 0xa438, 0x8837, 0xa436, 0xacd0, 0xa438, 0x0130,
+        0xa436, 0xacce, 0xa438, 0x883f, 0xa436, 0xacd0, 0xa438, 0x0138,
+        0xa436, 0xacce, 0xa438, 0x9097, 0xa436, 0xacd0, 0xa438, 0x0190,
+        0xa436, 0xacce, 0xa438, 0x905f, 0xa436, 0xacd0, 0xa438, 0x0158,
+        0xa436, 0xacce, 0xa438, 0x9857, 0xa436, 0xacd0, 0xa438, 0x0150,
+        0xa436, 0xacce, 0xa438, 0x989f, 0xa436, 0xacd0, 0xa438, 0x0198,
+        0xa436, 0xacce, 0xa438, 0xb0b7, 0xa436, 0xacd0, 0xa438, 0x01b0,
+        0xa436, 0xacce, 0xa438, 0xb8bf, 0xa436, 0xacd0, 0xa438, 0x01b8,
+        0xa436, 0xacce, 0xa438, 0xb077, 0xa436, 0xacd0, 0xa438, 0x0171,
+        0xa436, 0xacce, 0xa438, 0xb87f, 0xa436, 0xacd0, 0xa438, 0x0179,
+        0xa436, 0xacce, 0xa438, 0xfb47, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb4f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x6087, 0xa436, 0xacd0, 0xa438, 0x0180,
+        0xa436, 0xacce, 0xa438, 0x600f, 0xa436, 0xacd0, 0xa438, 0x0108,
+        0xa436, 0xacce, 0xa438, 0x6807, 0xa436, 0xacd0, 0xa438, 0x0100,
+        0xa436, 0xacce, 0xa438, 0x688f, 0xa436, 0xacd0, 0xa438, 0x0188,
+        0xa436, 0xacce, 0xa438, 0x7027, 0xa436, 0xacd0, 0xa438, 0x0120,
+        0xa436, 0xacce, 0xa438, 0x702f, 0xa436, 0xacd0, 0xa438, 0x0128,
+        0xa436, 0xacce, 0xa438, 0x7847, 0xa436, 0xacd0, 0xa438, 0x0140,
+        0xa436, 0xacce, 0xa438, 0x784f, 0xa436, 0xacd0, 0xa438, 0x0148,
+        0xa436, 0xacce, 0xa438, 0x80a7, 0xa436, 0xacd0, 0xa438, 0x01a0,
+        0xa436, 0xacce, 0xa438, 0x88af, 0xa436, 0xacd0, 0xa438, 0x01a8,
+        0xa436, 0xacce, 0xa438, 0x8067, 0xa436, 0xacd0, 0xa438, 0x0161,
+        0xa436, 0xacce, 0xa438, 0x886f, 0xa436, 0xacd0, 0xa438, 0x0169,
+        0xa436, 0xacce, 0xa438, 0xfb57, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb5f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x6017, 0xa436, 0xacd0, 0xa438, 0x0110,
+        0xa436, 0xacce, 0xa438, 0x601f, 0xa436, 0xacd0, 0xa438, 0x0118,
+        0xa436, 0xacce, 0xa438, 0x6837, 0xa436, 0xacd0, 0xa438, 0x0130,
+        0xa436, 0xacce, 0xa438, 0x683f, 0xa436, 0xacd0, 0xa438, 0x0138,
+        0xa436, 0xacce, 0xa438, 0x7097, 0xa436, 0xacd0, 0xa438, 0x0190,
+        0xa436, 0xacce, 0xa438, 0x705f, 0xa436, 0xacd0, 0xa438, 0x0158,
+        0xa436, 0xacce, 0xa438, 0x7857, 0xa436, 0xacd0, 0xa438, 0x0150,
+        0xa436, 0xacce, 0xa438, 0x789f, 0xa436, 0xacd0, 0xa438, 0x0198,
+        0xa436, 0xacce, 0xa438, 0x90b7, 0xa436, 0xacd0, 0xa438, 0x01b0,
+        0xa436, 0xacce, 0xa438, 0x98bf, 0xa436, 0xacd0, 0xa438, 0x01b8,
+        0xa436, 0xacce, 0xa438, 0x9077, 0xa436, 0xacd0, 0xa438, 0x0171,
+        0xa436, 0xacce, 0xa438, 0x987f, 0xa436, 0xacd0, 0xa438, 0x0179,
+        0xa436, 0xacce, 0xa438, 0xfb67, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb6f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x4087, 0xa436, 0xacd0, 0xa438, 0x0180,
+        0xa436, 0xacce, 0xa438, 0x400f, 0xa436, 0xacd0, 0xa438, 0x0108,
+        0xa436, 0xacce, 0xa438, 0x4807, 0xa436, 0xacd0, 0xa438, 0x0100,
+        0xa436, 0xacce, 0xa438, 0x488f, 0xa436, 0xacd0, 0xa438, 0x0188,
+        0xa436, 0xacce, 0xa438, 0x5027, 0xa436, 0xacd0, 0xa438, 0x0120,
+        0xa436, 0xacce, 0xa438, 0x502f, 0xa436, 0xacd0, 0xa438, 0x0128,
+        0xa436, 0xacce, 0xa438, 0x5847, 0xa436, 0xacd0, 0xa438, 0x0140,
+        0xa436, 0xacce, 0xa438, 0x584f, 0xa436, 0xacd0, 0xa438, 0x0148,
+        0xa436, 0xacce, 0xa438, 0x60a7, 0xa436, 0xacd0, 0xa438, 0x01a0,
+        0xa436, 0xacce, 0xa438, 0x68af, 0xa436, 0xacd0, 0xa438, 0x01a8,
+        0xa436, 0xacce, 0xa438, 0x6067, 0xa436, 0xacd0, 0xa438, 0x0161,
+        0xa436, 0xacce, 0xa438, 0x686f, 0xa436, 0xacd0, 0xa438, 0x0169,
+        0xa436, 0xacce, 0xa438, 0xfb77, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb7f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x4017, 0xa436, 0xacd0, 0xa438, 0x0110,
+        0xa436, 0xacce, 0xa438, 0x401f, 0xa436, 0xacd0, 0xa438, 0x0118,
+        0xa436, 0xacce, 0xa438, 0x4837, 0xa436, 0xacd0, 0xa438, 0x0130,
+        0xa436, 0xacce, 0xa438, 0x483f, 0xa436, 0xacd0, 0xa438, 0x0138,
+        0xa436, 0xacce, 0xa438, 0x5097, 0xa436, 0xacd0, 0xa438, 0x0190,
+        0xa436, 0xacce, 0xa438, 0x505f, 0xa436, 0xacd0, 0xa438, 0x0158,
+        0xa436, 0xacce, 0xa438, 0x5857, 0xa436, 0xacd0, 0xa438, 0x0150,
+        0xa436, 0xacce, 0xa438, 0x589f, 0xa436, 0xacd0, 0xa438, 0x0198,
+        0xa436, 0xacce, 0xa438, 0x70b7, 0xa436, 0xacd0, 0xa438, 0x01b0,
+        0xa436, 0xacce, 0xa438, 0x78bf, 0xa436, 0xacd0, 0xa438, 0x01b8,
+        0xa436, 0xacce, 0xa438, 0x7077, 0xa436, 0xacd0, 0xa438, 0x0171,
+        0xa436, 0xacce, 0xa438, 0x787f, 0xa436, 0xacd0, 0xa438, 0x0179,
+        0xa436, 0xacce, 0xa438, 0xfb87, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb8f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x40a7, 0xa436, 0xacd0, 0xa438, 0x01a0,
+        0xa436, 0xacce, 0xa438, 0x48af, 0xa436, 0xacd0, 0xa438, 0x01a8,
+        0xa436, 0xacce, 0xa438, 0x4067, 0xa436, 0xacd0, 0xa438, 0x0161,
+        0xa436, 0xacce, 0xa438, 0x486f, 0xa436, 0xacd0, 0xa438, 0x0169,
+        0xa436, 0xacce, 0xa438, 0xfb97, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfb9f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x50b7, 0xa436, 0xacd0, 0xa438, 0x01b0,
+        0xa436, 0xacce, 0xa438, 0x58bf, 0xa436, 0xacd0, 0xa438, 0x01b8,
+        0xa436, 0xacce, 0xa438, 0x5077, 0xa436, 0xacd0, 0xa438, 0x0171,
+        0xa436, 0xacce, 0xa438, 0x587f, 0xa436, 0xacd0, 0xa438, 0x0179,
+        0xa436, 0xacce, 0xa438, 0xfba7, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfbaf, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x2067, 0xa436, 0xacd0, 0xa438, 0x0161,
+        0xa436, 0xacce, 0xa438, 0x286f, 0xa436, 0xacd0, 0xa438, 0x0169,
+        0xa436, 0xacce, 0xa438, 0xfbb7, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0xfbbf, 0xa436, 0xacd0, 0xa438, 0x07ff,
+        0xa436, 0xacce, 0xa438, 0x3077, 0xa436, 0xacd0, 0xa438, 0x0171,
+        0xa436, 0xacce, 0xa438, 0x387f, 0xa436, 0xacd0, 0xa438, 0x0179,
+        0xa436, 0xacce, 0xa438, 0xfff9, 0xa436, 0xacd0, 0xa438, 0x17ff,
+        0xa436, 0xacce, 0xa438, 0xfff9, 0xa436, 0xacd0, 0xa438, 0x17ff,
+        0xa436, 0xacca, 0xa438, 0x0004, 0xa436, 0xacc6, 0xa438, 0x0008,
+        0xa436, 0xacc8, 0xa438, 0xc000, 0xa436, 0xacc8, 0xa438, 0x0000,
+        0xB820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8125bp_1_1[] = {
+        0xa436, 0x8024, 0xa438, 0x3600, 0xa436, 0xB82E, 0xa438, 0x0001,
+        0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x8014, 0xa438, 0x1800, 0xa438, 0x8018,
+        0xa438, 0x1800, 0xa438, 0x801c, 0xa438, 0x1800, 0xa438, 0x8020,
+        0xa438, 0x1800, 0xa438, 0x8024, 0xa438, 0x1800, 0xa438, 0x8028,
+        0xa438, 0x1800, 0xa438, 0x8028, 0xa438, 0xdb20, 0xa438, 0xd501,
+        0xa438, 0x1800, 0xa438, 0x034c, 0xa438, 0xdb10, 0xa438, 0xd501,
+        0xa438, 0x1800, 0xa438, 0x032c, 0xa438, 0x8620, 0xa438, 0xa480,
+        0xa438, 0x1800, 0xa438, 0x1cfe, 0xa438, 0xbf40, 0xa438, 0xd703,
+        0xa438, 0x1800, 0xa438, 0x0ce9, 0xa438, 0x9c10, 0xa438, 0x9f40,
+        0xa438, 0x1800, 0xa438, 0x137a, 0xa438, 0x9f20, 0xa438, 0x9f40,
+        0xa438, 0x1800, 0xa438, 0x16c4, 0xa436, 0xA026, 0xa438, 0xffff,
+        0xa436, 0xA024, 0xa438, 0xffff, 0xa436, 0xA022, 0xa438, 0x16c3,
+        0xa436, 0xA020, 0xa438, 0x1379, 0xa436, 0xA006, 0xa438, 0x0ce8,
+        0xa436, 0xA004, 0xa438, 0x1cfd, 0xa436, 0xA002, 0xa438, 0x032b,
+        0xa436, 0xA000, 0xa438, 0x034b, 0xa436, 0xA008, 0xa438, 0x3f00,
+        0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x0000,
+        0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010, 0xa438, 0x1800,
+        0xa438, 0x8018, 0xa438, 0x1800, 0xa438, 0x8021, 0xa438, 0x1800,
+        0xa438, 0x802b, 0xa438, 0x1800, 0xa438, 0x8055, 0xa438, 0x1800,
+        0xa438, 0x805a, 0xa438, 0x1800, 0xa438, 0x805e, 0xa438, 0x1800,
+        0xa438, 0x8062, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0xcb11,
+        0xa438, 0xd1b9, 0xa438, 0xd05b, 0xa438, 0x0000, 0xa438, 0x1800,
+        0xa438, 0x0284, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0x5f95, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x1800, 0xa438, 0x02b7, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0xcb21, 0xa438, 0x1000, 0xa438, 0x0b34, 0xa438, 0xd71f,
+        0xa438, 0x5f5e, 0xa438, 0x0000, 0xa438, 0x1800, 0xa438, 0x0322,
+        0xa438, 0xd700, 0xa438, 0xd113, 0xa438, 0xd040, 0xa438, 0x1000,
+        0xa438, 0x0a57, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xd700,
+        0xa438, 0x6065, 0xa438, 0xd122, 0xa438, 0xf002, 0xa438, 0xd122,
+        0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x0b53, 0xa438, 0xa008,
+        0xa438, 0xd704, 0xa438, 0x4052, 0xa438, 0xa002, 0xa438, 0xd704,
+        0xa438, 0x4054, 0xa438, 0xa740, 0xa438, 0x1000, 0xa438, 0x0a57,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xcb9b, 0xa438, 0xd110,
+        0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x0c01, 0xa438, 0x1000,
+        0xa438, 0x0a57, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x801a,
+        0xa438, 0x1000, 0xa438, 0x0a57, 0xa438, 0xd704, 0xa438, 0x7fb9,
+        0xa438, 0x1800, 0xa438, 0x088d, 0xa438, 0xcb62, 0xa438, 0xd700,
+        0xa438, 0x8880, 0xa438, 0x1800, 0xa438, 0x06cb, 0xa438, 0xbe02,
+        0xa438, 0x0000, 0xa438, 0x1800, 0xa438, 0x002c, 0xa438, 0xbe04,
+        0xa438, 0x0000, 0xa438, 0x1800, 0xa438, 0x002c, 0xa438, 0xbe08,
+        0xa438, 0x0000, 0xa438, 0x1800, 0xa438, 0x002c, 0xa436, 0xA10E,
+        0xa438, 0x802a, 0xa436, 0xA10C, 0xa438, 0x8026, 0xa436, 0xA10A,
+        0xa438, 0x8022, 0xa436, 0xA108, 0xa438, 0x06ca, 0xa436, 0xA106,
+        0xa438, 0x086f, 0xa436, 0xA104, 0xa438, 0x0321, 0xa436, 0xA102,
+        0xa438, 0x02b5, 0xa436, 0xA100, 0xa438, 0x0283, 0xa436, 0xA110,
+        0xa438, 0x001f, 0xb820, 0x0010, 0xb82e, 0x0000, 0xa436, 0x8024,
+        0xa438, 0x0000, 0xB820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8125bp_1_2[] = {
+        0xb892, 0x0000, 0xb88e, 0xC201, 0xb890, 0x2C01, 0xb890, 0xCD02,
+        0xb890, 0x0602, 0xb890, 0x5502, 0xb890, 0xB903, 0xb890, 0x3303,
+        0xb890, 0xC204, 0xb890, 0x6605, 0xb890, 0x1F05, 0xb890, 0xEE06,
+        0xb890, 0xD207, 0xb890, 0xCC08, 0xb890, 0xDA09, 0xb890, 0xFF0B,
+        0xb890, 0x380C, 0xb890, 0x87F3, 0xb88e, 0xC27F, 0xb890, 0x2B66,
+        0xb890, 0x6666, 0xb890, 0x6666, 0xb890, 0x6666, 0xb890, 0x6666,
+        0xb890, 0x6666, 0xb890, 0x6666, 0xb890, 0x6666, 0xb890, 0x66C2,
+        0xb88e, 0xC26F, 0xb890, 0x751D, 0xb890, 0x1D1F, 0xb890, 0x2022,
+        0xb890, 0x2325, 0xb890, 0x2627, 0xb890, 0x2829, 0xb890, 0x2929,
+        0xb890, 0x2A2A, 0xb890, 0x2B66, 0xB820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8125cp_1_1[] = {
+        0xa436, 0x8023, 0xa438, 0x2300, 0xa436, 0xB82E, 0xa438, 0x0001,
+        0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+        0xa438, 0x07f8, 0xa436, 0xA014, 0xa438, 0xcc01, 0xa438, 0x2166,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa436, 0xA152, 0xa438, 0x021c,
+        0xa436, 0xA154, 0xa438, 0x2170, 0xa436, 0xA156, 0xa438, 0x3fff,
+        0xa436, 0xA158, 0xa438, 0x3fff, 0xa436, 0xA15A, 0xa438, 0x3fff,
+        0xa436, 0xA15C, 0xa438, 0x3fff, 0xa436, 0xA15E, 0xa438, 0x3fff,
+        0xa436, 0xA160, 0xa438, 0x3fff, 0xa436, 0xA150, 0xa438, 0x0003,
+        0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x0000,
+        0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010, 0xa438, 0x1800,
+        0xa438, 0x801b, 0xa438, 0x1800, 0xa438, 0x802b, 0xa438, 0x1800,
+        0xa438, 0x8031, 0xa438, 0x1800, 0xa438, 0x8037, 0xa438, 0x1800,
+        0xa438, 0x8037, 0xa438, 0x1800, 0xa438, 0x8037, 0xa438, 0x1800,
+        0xa438, 0x8037, 0xa438, 0x800a, 0xa438, 0x8530, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8d10, 0xa438, 0x9503, 0xa438, 0xd700,
+        0xa438, 0x6050, 0xa438, 0xaa20, 0xa438, 0x1800, 0xa438, 0x0d53,
+        0xa438, 0xd707, 0xa438, 0x40f6, 0xa438, 0x8901, 0xa438, 0xd704,
+        0xa438, 0x6091, 0xa438, 0x8306, 0xa438, 0x8b02, 0xa438, 0x8290,
+        0xa438, 0x1000, 0xa438, 0x0e4d, 0xa438, 0x1000, 0xa438, 0x1277,
+        0xa438, 0xd704, 0xa438, 0x7e77, 0xa438, 0x1800, 0xa438, 0x0dc5,
+        0xa438, 0xd700, 0xa438, 0x4063, 0xa438, 0x1800, 0xa438, 0x0d15,
+        0xa438, 0x1800, 0xa438, 0x0d18, 0xa438, 0xd700, 0xa438, 0x6063,
+        0xa438, 0x1800, 0xa438, 0x0ca6, 0xa438, 0x1800, 0xa438, 0x0ca7,
+        0xa436, 0xA10E, 0xa438, 0xffff, 0xa436, 0xA10C, 0xa438, 0xffff,
+        0xa436, 0xA10A, 0xa438, 0xffff, 0xa436, 0xA108, 0xa438, 0xffff,
+        0xa436, 0xA106, 0xa438, 0x0ca2, 0xa436, 0xA104, 0xa438, 0x0d13,
+        0xa436, 0xA102, 0xa438, 0x0dbf, 0xa436, 0xA100, 0xa438, 0x0d52,
+        0xa436, 0xA110, 0xa438, 0x000f, 0xa436, 0xb87c, 0xa438, 0x85bd,
+        0xa436, 0xb87e, 0xa438, 0xaf85, 0xa438, 0xd5af, 0xa438, 0x85fb,
+        0xa438, 0xaf85, 0xa438, 0xfbaf, 0xa438, 0x85fb, 0xa438, 0xaf85,
+        0xa438, 0xfbaf, 0xa438, 0x85fb, 0xa438, 0xaf85, 0xa438, 0xfbaf,
+        0xa438, 0x85fb, 0xa438, 0xac28, 0xa438, 0x0bd4, 0xa438, 0x0294,
+        0xa438, 0xbf85, 0xa438, 0xf802, 0xa438, 0x61c2, 0xa438, 0xae09,
+        0xa438, 0xd414, 0xa438, 0x50bf, 0xa438, 0x85f8, 0xa438, 0x0261,
+        0xa438, 0xc2bf, 0xa438, 0x60de, 0xa438, 0x0261, 0xa438, 0xe1bf,
+        0xa438, 0x80cf, 0xa438, 0xaf24, 0xa438, 0xe8f0, 0xa438, 0xac52,
+        0xa436, 0xb85e, 0xa438, 0x24e5, 0xa436, 0xb860, 0xa438, 0xffff,
+        0xa436, 0xb862, 0xa438, 0xffff, 0xa436, 0xb864, 0xa438, 0xffff,
+        0xa436, 0xb886, 0xa438, 0xffff, 0xa436, 0xb888, 0xa438, 0xffff,
+        0xa436, 0xb88a, 0xa438, 0xffff, 0xa436, 0xb88c, 0xa438, 0xffff,
+        0xa436, 0xb838, 0xa438, 0x0001, 0xb820, 0x0010, 0xB82E, 0x0000,
+        0xa436, 0x8023, 0xa438, 0x0000, 0xB820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static void
+rtl8125_real_set_phy_mcu_8125b_1(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8125b_1,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8125b_1));
+}
+
+static void
+rtl8125_set_phy_mcu_8125b_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125b_1(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125b_2(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8125b_2,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8125b_2));
+}
+
+static void
+rtl8125_set_phy_mcu_8125b_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125b_2(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125d_1_1(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8125d_1_1,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8125d_1_1));
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125d_1_2(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8125d_1_2,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8125d_1_2));
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125d_1_3(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8125d_1_3,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8125d_1_3));
+}
+
+static void
+rtl8125_set_phy_mcu_8125d_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125d_1_1(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125d_1_2(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125d_1_3(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static void
+rtl8125_set_phy_mcu_8125d_1_efuse(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8125d_1_efuse,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8125d_1_efuse));
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125d_2_1(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8125d_2_1,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8125d_2_1));
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125d_2_2(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8125d_2_2,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8125d_2_2));
+}
+
+static void
+rtl8125_set_phy_mcu_8125d_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125d_2_1(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125d_2_2(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125bp_1_1(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8125bp_1_1,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8125bp_1_1));
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125bp_1_2(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8125bp_1_2,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8125bp_1_2));
+}
+
+static void
+rtl8125_set_phy_mcu_8125bp_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125bp_1_1(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125bp_1_2(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125cp_1_1(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8125cp_1_1,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8125cp_1_1));
+}
+
+static void
+rtl8125_set_phy_mcu_8125cp_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125cp_1_1(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static void
+rtl8125_init_hw_phy_mcu(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u8 require_disable_phy_disable_mode = FALSE;
+
+        if (tp->NotWrRamCodeToMicroP == TRUE)
+                return;
+
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                return;
+
+        if (HW_SUPPORT_CHECK_PHY_DISABLE_MODE(tp) && rtl8125_is_in_phy_disable_mode(dev))
+                require_disable_phy_disable_mode = TRUE;
+
+        if (require_disable_phy_disable_mode)
+                rtl8125_disable_phy_disable_mode(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+                rtl8125_set_phy_mcu_8125a_1(dev);
+                break;
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                rtl8125_set_phy_mcu_8125a_2(dev);
+                break;
+        case CFG_METHOD_4:
+                rtl8125_set_phy_mcu_8125b_1(dev);
+                break;
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                rtl8125_set_phy_mcu_8125b_2(dev);
+                break;
+        case CFG_METHOD_8:
+                rtl8125_set_phy_mcu_8125bp_1(dev);
+                break;
+        case CFG_METHOD_9:
+                /* nothing to do */
+                break;
+        case CFG_METHOD_10:
+                rtl8125_set_phy_mcu_8125d_1(dev);
+                break;
+        case CFG_METHOD_11:
+        case CFG_METHOD_13:
+                rtl8125_set_phy_mcu_8125d_2(dev);
+                break;
+        case CFG_METHOD_12:
+                rtl8125_set_phy_mcu_8125cp_1(dev);
+                break;
+        }
+
+        if (require_disable_phy_disable_mode)
+                rtl8125_enable_phy_disable_mode(dev);
+
+        rtl8125_write_hw_phy_mcu_code_ver(dev);
+
+        rtl8125_mdio_write(tp,0x1F, 0x0000);
+
+        tp->HwHasWrRamCodeToMicroP = TRUE;
+}
+#endif
+
+static void
+rtl8125_enable_phy_aldps(struct rtl8125_private *tp)
+{
+        //enable aldps
+        //GPHY OCP 0xA430 bit[2] = 0x1 (en_aldps)
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA430, BIT_2);
+}
+
+static void
+rtl8125_tgphy_irq_mask_and_ack(struct rtl8125_private *tp)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA4D2, 0x0000);
+                (void)rtl8125_mdio_direct_read_phy_ocp(tp, 0xA4D4);
+                break;
+        default:
+                break;
+        }
+}
+
+static void
+rtl8125_hw_phy_config_8125a_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAD40,
+                                              0x03FF,
+                                              0x84);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xAD4E, BIT_4);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAD16,
+                                              0x03FF,
+                                              0x0006);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAD32,
+                                              0x003F,
+                                              0x0006);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xAC08, BIT_12);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xAC08, BIT_8);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAC8A,
+                                              BIT_15|BIT_14|BIT_13|BIT_12,
+                                              BIT_14|BIT_13|BIT_12);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xAD18, BIT_10);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xAD1A, 0x3FF);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xAD1C, 0x3FF);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80EA);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0xC400);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80EB);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0x0700,
+                                              0x0300);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80F8);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x1C00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80F1);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x3000);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80FE);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0xA500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8102);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x5000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8105);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x3300);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8100);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x7000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8104);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0xF000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8106);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x6500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80DC);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0xED00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80DF);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA438, BIT_8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80E1);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, BIT_8);
+
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBF06,
+                                              0x003F,
+                                              0x38);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x819F);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xD0B6);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBC34, 0x5555);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBF0A,
+                                              BIT_11|BIT_10|BIT_9,
+                                              BIT_11|BIT_9);
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA5C0, BIT_10);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA442, BIT_11);
+
+        //enable aldps
+        //GPHY OCP 0xA430 bit[2] = 0x1 (en_aldps)
+        if (aspm && HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                rtl8125_enable_phy_aldps(tp);
+}
+
+static void
+rtl8125_hw_phy_config_8125a_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xAD4E, BIT_4);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAD16,
+                                              0x03FF,
+                                              0x03FF);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAD32,
+                                              0x003F,
+                                              0x0006);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xAC08, BIT_12);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xAC08, BIT_8);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xACC0,
+                                              BIT_1|BIT_0,
+                                              BIT_1);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAD40,
+                                              BIT_7|BIT_6|BIT_5,
+                                              BIT_6);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAD40,
+                                              BIT_2|BIT_1|BIT_0,
+                                              BIT_2);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xAC14, BIT_7);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xAC80, BIT_9|BIT_8);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAC5E,
+                                              BIT_2|BIT_1|BIT_0,
+                                              BIT_1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xAD4C, 0x00A8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xAC5C, 0x01FF);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAC8A,
+                                              BIT_7|BIT_6|BIT_5|BIT_4,
+                                              BIT_5|BIT_4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8157);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8159);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0700);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80A2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0153);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x809C);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0153);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x81B3);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0043);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00A7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00D6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00EC);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00F6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00FB);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00FD);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00FF);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00BB);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0058);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0029);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0013);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0009);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0004);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8257);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x020F);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80EA);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7843);
+
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xB896, BIT_0);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xB892, 0xFF00);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC091);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x6E12);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC092);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x1214);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC094);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x1516);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC096);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x171B);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC098);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x1B1C);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC09A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x1F1F);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC09C);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x2021);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC09E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x2224);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC0A0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x2424);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC0A2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x2424);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC0A4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x2424);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC018);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x0AF2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC01A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x0D4A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC01C);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x0F26);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC01E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x118D);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC020);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x14F3);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC022);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x175A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC024);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x19C0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC026);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x1C26);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC089);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x6050);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC08A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x5F6E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC08C);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x6E6E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC08E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x6E6E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC090);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x6E12);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xB896, BIT_0);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xD068, BIT_13);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x81A2);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA438, BIT_8);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB54C,
+                                              0xFF00,
+                                              0xDB00);
+
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA454, BIT_0);
+
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA5D4, BIT_5);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xAD4E, BIT_4);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA86A, BIT_0);
+
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA442, BIT_11);
+
+
+        if (tp->RequirePhyMdiSwapPatch) {
+                u16 adccal_offset_p0;
+                u16 adccal_offset_p1;
+                u16 adccal_offset_p2;
+                u16 adccal_offset_p3;
+                u16 rg_lpf_cap_xg_p0;
+                u16 rg_lpf_cap_xg_p1;
+                u16 rg_lpf_cap_xg_p2;
+                u16 rg_lpf_cap_xg_p3;
+                u16 rg_lpf_cap_p0;
+                u16 rg_lpf_cap_p1;
+                u16 rg_lpf_cap_p2;
+                u16 rg_lpf_cap_p3;
+
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xD068,
+                                                      0x0007,
+                                                      0x0001);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xD068,
+                                                      0x0018,
+                                                      0x0000);
+                adccal_offset_p0 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xD06A);
+                adccal_offset_p0 &= 0x07FF;
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xD068,
+                                                      0x0018,
+                                                      0x0008);
+                adccal_offset_p1 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xD06A);
+                adccal_offset_p1 &= 0x07FF;
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xD068,
+                                                      0x0018,
+                                                      0x0010);
+                adccal_offset_p2 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xD06A);
+                adccal_offset_p2 &= 0x07FF;
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xD068,
+                                                      0x0018,
+                                                      0x0018);
+                adccal_offset_p3 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xD06A);
+                adccal_offset_p3 &= 0x07FF;
+
+
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xD068,
+                                                      0x0018,
+                                                      0x0000);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xD06A,
+                                                      0x07FF,
+                                                      adccal_offset_p3);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xD068,
+                                                      0x0018,
+                                                      0x0008);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xD06A,
+                                                      0x07FF,
+                                                      adccal_offset_p2);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xD068,
+                                                      0x0018,
+                                                      0x0010);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xD06A,
+                                                      0x07FF,
+                                                      adccal_offset_p1);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xD068,
+                                                      0x0018,
+                                                      0x0018);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xD06A,
+                                                      0x07FF,
+                                                      adccal_offset_p0);
+
+
+                rg_lpf_cap_xg_p0 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xBD5A);
+                rg_lpf_cap_xg_p0 &= 0x001F;
+                rg_lpf_cap_xg_p1 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xBD5A);
+                rg_lpf_cap_xg_p1 &= 0x1F00;
+                rg_lpf_cap_xg_p2 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xBD5C);
+                rg_lpf_cap_xg_p2 &= 0x001F;
+                rg_lpf_cap_xg_p3 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xBD5C);
+                rg_lpf_cap_xg_p3 &= 0x1F00;
+                rg_lpf_cap_p0 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xBC18);
+                rg_lpf_cap_p0 &= 0x001F;
+                rg_lpf_cap_p1 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xBC18);
+                rg_lpf_cap_p1 &= 0x1F00;
+                rg_lpf_cap_p2 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xBC1A);
+                rg_lpf_cap_p2 &= 0x001F;
+                rg_lpf_cap_p3 = rtl8125_mdio_direct_read_phy_ocp(tp, 0xBC1A);
+                rg_lpf_cap_p3 &= 0x1F00;
+
+
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xBD5A,
+                                                      0x001F,
+                                                      rg_lpf_cap_xg_p3 >> 8);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xBD5A,
+                                                      0x1F00,
+                                                      rg_lpf_cap_xg_p2 << 8);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xBD5C,
+                                                      0x001F,
+                                                      rg_lpf_cap_xg_p1 >> 8);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xBD5C,
+                                                      0x1F00,
+                                                      rg_lpf_cap_xg_p0 << 8);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xBC18,
+                                                      0x001F,
+                                                      rg_lpf_cap_p3 >> 8);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xBC18,
+                                                      0x1F00,
+                                                      rg_lpf_cap_p2 << 8);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xBC1A,
+                                                      0x001F,
+                                                      rg_lpf_cap_p1 >> 8);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xBC1A,
+                                                      0x1F00,
+                                                      rg_lpf_cap_p0 << 8);
+        }
+
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA424, BIT_3);
+
+
+        if (aspm && HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                rtl8125_enable_phy_aldps(tp);
+}
+
+static void
+rtl8125_hw_phy_config_8125b_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA442, BIT_11);
+
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC08, (BIT_3 | BIT_2));
+
+
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FFF);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xA438,
+                                                      0xFF00,
+                                                      0x0400);
+        }
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8560);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x19CC);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8562);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x19CC);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8564);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x19CC);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8566);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x147D);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8568);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x147D);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x856A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x147D);
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FFE);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0907);
+        }
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xACDA,
+                                              0xFF00,
+                                              0xFF00);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xACDE,
+                                              0xF000,
+                                              0xF000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80D6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x2801);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80F2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x2801);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80F4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x6077);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB506, 0x01E7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xAC8C, 0x0FFC);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xAC46, 0xB7B4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xAC50, 0x0FBC);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xAC3C, 0x9240);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xAC4E, 0x0DB4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xACC6, 0x0707);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xACC8, 0xA0D3);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xAD08, 0x0007);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8013);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0700);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FB9);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x2801);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FBA);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0100);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FBC);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x1900);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FBE);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0xE100);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FC0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0800);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FC2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0xE500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FC4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0F00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FC6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0xF100);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FC8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0400);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FCa);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0xF300);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FCc);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0xFD00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FCe);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0xFF00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FD0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0xFB00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FD2);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0100);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FD4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0xF400);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FD6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0xFF00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FD8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0xF600);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x813D);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x390E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x814F);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x790E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80B0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0F31);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xBF4C, BIT_1);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xBCCA, (BIT_9 | BIT_8));
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8141);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x320E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8153);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x720E);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA432, BIT_6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8529);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x050E);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x816C);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xC4A0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8170);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xC4A0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8174);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x04A0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8178);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x04A0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x817C);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0719);
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FF4);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0400);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FF1);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0404);
+        }
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBF4A, 0x001B);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8033);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x7C13);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8037);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x7C13);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x803B);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0xFC32);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x803F);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x7C13);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8043);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x7C13);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8047);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x7C13);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8145);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x370E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8157);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x770E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8169);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0D0A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x817B);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x1D0A);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8217);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x5000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x821A);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x5000);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80DA);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0403);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80DC);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80B3);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0384);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80B7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2007);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80BA);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x6C00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80B5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xF009);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80BD);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x9F00);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80C7);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xf083);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80DD);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x03f0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80DF);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x1000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80CB);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x2007);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80CE);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x6C00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80C9);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8009);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80D1);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x8000);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80A3);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x200A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80A5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xF0AD);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x809F);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x6073);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80A1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x000B);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80A9);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0xC000);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xB896, BIT_0);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xB892, 0xFF00);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC23E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC240);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x0103);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC242);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x0507);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC244);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x090B);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC246);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x0C0E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC248);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x1012);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC24A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB890, 0x1416);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xB896, BIT_0);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA86A, BIT_0);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA6F0, BIT_0);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBFA0, 0xD70D);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBFA2, 0x4100);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBFA4, 0xE868);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBFA6, 0xDC59);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB54C, 0x3C18);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBFA4, BIT_5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x817D);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA438, BIT_12);
+
+
+        if (aspm && HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                rtl8125_enable_phy_aldps(tp);
+}
+
+static void
+rtl8125_hw_phy_config_8125b_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA442, BIT_11);
+
+
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAC46,
+                                              0x00F0,
+                                              0x0090);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAD30,
+                                              0x0003,
+                                              0x0001);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80F5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x760E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8107);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x360E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8551);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              BIT_15 | BIT_14 | BIT_13 | BIT_12 | BIT_11 | BIT_10 | BIT_9 | BIT_8,
+                                              BIT_11);
+
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xbf00,
+                                              0xE000,
+                                              0xA000);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xbf46,
+                                              0x0F00,
+                                              0x0300);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa436, 0x8044);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa436, 0x804A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa436, 0x8050);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa436, 0x8056);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa436, 0x805C);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa436, 0x8062);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa436, 0x8068);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa436, 0x806E);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa436, 0x8074);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa436, 0x807A);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA4CA, BIT_6);
+
+
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBF84,
+                                              BIT_15 | BIT_14 | BIT_13,
+                                              BIT_15 | BIT_13);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8170);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              BIT_13 | BIT_10 | BIT_9 | BIT_8,
+                                              BIT_15 | BIT_14 | BIT_12 | BIT_11);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8015);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xB87E, BIT_8);
+        rtl8125_mdio_direct_read_phy_ocp(tp, 0xB906);
+
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA424, BIT_3);
+
+        /*
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBFA0, 0xD70D);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBFA2, 0x4100);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBFA4, 0xE868);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBFA6, 0xDC59);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB54C, 0x3C18);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBFA4, BIT_5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x817D);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA438, BIT_12);
+        */
+
+
+#ifdef ENABLE_LIB_SUPPORT
+        /* disable phy speed down */
+        ClearEthPhyOcpBit(tp, 0xA442, BIT_3 | BIT_2);
+#endif /* ENABLE_LIB_SUPPORT */
+
+
+        if (aspm && HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                rtl8125_enable_phy_aldps(tp);
+}
+
+static void
+rtl8125_hw_phy_config_8125bp_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA442, BIT_11);
+
+
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA80C,
+                                              BIT_14,
+                                              BIT_15 | BIT_11 | BIT_10);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8010);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, BIT_11);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8088);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x9000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x808F);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x9000);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8174);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              BIT_13,
+                                              BIT_12 | BIT_11);
+
+
+        if (aspm && HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                rtl8125_enable_phy_aldps(tp);
+}
+
+static void
+rtl8125_hw_phy_config_8125bp_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA442, BIT_11);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8010);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, BIT_11);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8088);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x9000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x808F);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x9000);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8174);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              BIT_13,
+                                              BIT_12 | BIT_11);
+
+
+        if (aspm && HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                rtl8125_enable_phy_aldps(tp);
+}
+
+static void
+rtl8125_hw_phy_config_8125cp_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_tgphy_irq_mask_and_ack(tp);
+
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA442, BIT_11);
+
+
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xad0e,
+                                              0x007F,
+                                              0x000B);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xad78, BIT_4);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x81B8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00B4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x81BA);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00E4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x81C5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0104);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x81D0);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x054D);
+
+
+        if (aspm && HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                rtl8125_enable_phy_aldps(tp);
+}
+
+static void
+rtl8125_hw_phy_config_8125d_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA442, BIT_11);
+
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xBF96, BIT_15);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBF94,
+                                              0x0007,
+                                              0x0005);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBF8E,
+                                              0x3C00,
+                                              0x2800);
+
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBCD8,
+                                              0xC000,
+                                              0x4000);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xBCD8, BIT_15 | BIT_14);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBCD8,
+                                              0xC000,
+                                              0x4000);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBC80,
+                                              0x001F,
+                                              0x0004);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC82, BIT_15 | BIT_14 | BIT_13);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC82, BIT_12 | BIT_11 | BIT_10);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBC80,
+                                              0x001F,
+                                              0x0005);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBC82,
+                                              0x00E0,
+                                              0x0040);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC82, BIT_4 | BIT_3 | BIT_2);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBCD8, BIT_15 | BIT_14);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBCD8,
+                                              0xC000,
+                                              0x8000);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBCD8, BIT_15 | BIT_14);
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBD70, BIT_8);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA466, BIT_1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x836a);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, 0xFF00);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x832C);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0500);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB106,
+                                              0x0700,
+                                              0x0100);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB206,
+                                              0x0700,
+                                              0x0200);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB306,
+                                              0x0700,
+                                              0x0300);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80CB);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0300);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBCF4, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBCF6, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBC12, 0x0000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x844d);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0200);
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8feb);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xB87E,
+                                                      0xFF00,
+                                                      0x0100);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8fe9);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xB87E,
+                                                      0xFF00,
+                                                      0x0600);
+        }
+
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAC7E,
+                                              0x01FC,
+                                              0x00B4);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8105);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x7A00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8117);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x3A00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8103);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x7400);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8115);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x3400);
+
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xAD40, BIT_5 | BIT_4);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAD66,
+                                              0x000F,
+                                              0x0007);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAD68,
+                                              0xF000,
+                                              0x8000);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAD68,
+                                              0x0F00,
+                                              0x0500);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAD68,
+                                              0x000F,
+                                              0x0002);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAD6A,
+                                              0xF000,
+                                              0x7000);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xAC50, 0x01E8);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x81FA);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x5400);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA864,
+                                              0x00F0,
+                                              0x00C0);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA42C,
+                                              0x00FF,
+                                              0x0002);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80E1);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x0F00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80DE);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xF000,
+                                              0x0700);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA846, BIT_7);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80BA);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8A04);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80BD);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0xCA00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80B7);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0xB300);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80CE);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8A04);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80D1);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0xCA00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80CB);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0xBB00);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80A6);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4909);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80A8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x05B8);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8200);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x5800);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FF1);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7078);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FF3);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x5D78);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FF5);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x7862);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FF7);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x1400);
+
+
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x814C);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x8455);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x814E);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x84A6);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8163);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xA438,
+                                                      0xFF00,
+                                                      0x0600);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x816A);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xA438,
+                                                      0xFF00,
+                                                      0x0500);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8171);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xA438,
+                                                      0xFF00,
+                                                      0x1f00);
+        }
+
+
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBC3A,
+                                              0x000F,
+                                              0x0006);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8064);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, BIT_10 | BIT_9 | BIT_8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8067);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, BIT_10 | BIT_9 | BIT_8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x806A);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, BIT_10 | BIT_9 | BIT_8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x806D);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, BIT_10 | BIT_9 | BIT_8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8070);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, BIT_10 | BIT_9 | BIT_8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8073);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, BIT_10 | BIT_9 | BIT_8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8076);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, BIT_10 | BIT_9 | BIT_8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8079);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, BIT_10 | BIT_9 | BIT_8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x807C);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, BIT_10 | BIT_9 | BIT_8);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x807F);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA438, BIT_10 | BIT_9 | BIT_8);
+
+
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBFA0,
+                                              0xFF70,
+                                              0x5500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xBFA2, 0x9D00);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8165);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0x0700,
+                                              0x0200);
+
+
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8019);
+                rtl8125_set_eth_phy_ocp_bit(tp, 0xA438, BIT_8);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FE3);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0005);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00ED);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0502);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0B00);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, 0xD401);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xA438,
+                                                      0xFF00,
+                                                      0x2900);
+        }
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8018);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x1700);
+
+
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x815B);
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xA438,
+                                                      0xFF00,
+                                                      0x1700);
+        }
+
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA4E0, BIT_15);
+
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA5D4, BIT_5);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA654, BIT_11);
+
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA430, BIT_12 | BIT_0);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA442, BIT_7);
+
+
+        if (aspm && HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                rtl8125_enable_phy_aldps(tp);
+}
+
+static void
+rtl8125_hw_phy_config_8125d_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA442, BIT_11);
+
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBCD8,
+                                              0xC000,
+                                              0x4000);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xBCD8, BIT_15 | BIT_14);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBCD8,
+                                              0xC000,
+                                              0x4000);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBC80,
+                                              0x001F,
+                                              0x0004);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC82, BIT_15 | BIT_14 | BIT_13);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC82, BIT_12 | BIT_11 | BIT_10);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBC80,
+                                              0x001F,
+                                              0x0005);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBC82,
+                                              0x00E0,
+                                              0x0040);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC82, BIT_4 | BIT_3 | BIT_2);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBCD8, BIT_15 | BIT_14);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBCD8,
+                                              0xC000,
+                                              0x8000);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBCD8, BIT_15 | BIT_14);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+
+
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAC7E,
+                                              0x01FC,
+                                              0x00B4);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8105);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x7A00);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8117);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x3A00);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8103);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x7400);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8115);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x3400);
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FEB);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0500);
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FEA);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0700);
+
+
+        rtl8125_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80D6);
+        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0xEF00);
+
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA5D4, BIT_5);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA654, BIT_11);
+
+
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA448, BIT_10);
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA586, BIT_10);
+
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA430, BIT_12 | BIT_0);
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA442, BIT_7);
+
+
+        if (aspm && HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                rtl8125_enable_phy_aldps(tp);
+}
+
+static void
+rtl8125_hw_phy_config(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long flags;
+
+        if (tp->resume_not_chg_speed)
+                return;
+
+        tp->phy_reset_enable(dev);
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+#ifndef ENABLE_USE_FIRMWARE_FILE
+        if (!tp->rtl_fw) {
+                rtl8125_set_hw_phy_before_init_phy_mcu(dev);
+
+                rtl8125_init_hw_phy_mcu(dev);
+        }
+#endif
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+                rtl8125_hw_phy_config_8125a_1(dev);
+                break;
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                rtl8125_hw_phy_config_8125a_2(dev);
+                break;
+        case CFG_METHOD_4:
+                rtl8125_hw_phy_config_8125b_1(dev);
+                break;
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                rtl8125_hw_phy_config_8125b_2(dev);
+                break;
+        case CFG_METHOD_8:
+                rtl8125_hw_phy_config_8125bp_1(dev);
+                break;
+        case CFG_METHOD_9:
+                rtl8125_hw_phy_config_8125bp_2(dev);
+                break;
+        case CFG_METHOD_10:
+                rtl8125_hw_phy_config_8125d_1(dev);
+                break;
+        case CFG_METHOD_11:
+        case CFG_METHOD_13:
+                rtl8125_hw_phy_config_8125d_2(dev);
+                break;
+        case CFG_METHOD_12:
+                rtl8125_hw_phy_config_8125cp_1(dev);
+                break;
+        }
+
+        //legacy force mode(Chap 22)
+        rtl8125_clear_eth_phy_ocp_bit(tp, 0xA5B4, BIT_15);
+
+#ifdef ENABLE_FIBER_SUPPORT
+        rtl8125_hw_fiber_phy_config(tp);
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        /*ocp phy power saving*/
+        /*
+        if (aspm) {
+        if (tp->mcfg == CFG_METHOD_2 || tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_6)
+                rtl8125_enable_ocp_phy_power_saving(dev);
+        }
+        */
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                if (tp->eee.eee_enabled)
+                        rtl8125_enable_eee(tp);
+                else
+                        rtl8125_disable_eee(tp);
+        }
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+}
+
+static void
+rtl8125_up(struct net_device *dev)
+{
+        rtl8125_hw_init(dev);
+        rtl8125_hw_reset(dev);
+        rtl8125_powerup_pll(dev);
+        rtl8125_hw_ephy_config(dev);
+        rtl8125_hw_phy_config(dev);
+        rtl8125_hw_config(dev);
+}
+
+/*
+static inline void rtl8125_delete_esd_timer(struct net_device *dev, struct timer_list *timer)
+{
+        del_timer_sync(timer);
+}
+
+static inline void rtl8125_request_esd_timer(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct timer_list *timer = &tp->esd_timer;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+        setup_timer(timer, rtl8125_esd_timer, (unsigned long)dev);
+#else
+        timer_setup(timer, rtl8125_esd_timer, 0);
+#endif
+        mod_timer(timer, jiffies + RTL8125_ESD_TIMEOUT);
+}
+*/
+
+/*
+static inline void rtl8125_delete_link_timer(struct net_device *dev, struct timer_list *timer)
+{
+        del_timer_sync(timer);
+}
+
+static inline void rtl8125_request_link_timer(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct timer_list *timer = &tp->link_timer;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+        setup_timer(timer, rtl8125_link_timer, (unsigned long)dev);
+#else
+        timer_setup(timer, rtl8125_link_timer, 0);
+#endif
+        mod_timer(timer, jiffies + RTL8125_LINK_TIMEOUT);
+}
+*/
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+static void
+rtl8125_netpoll(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+        for (i = 0; i < tp->irq_nvecs; i++) {
+                struct r8125_irq *irq = &tp->irq_tbl[i];
+                struct r8125_napi *r8125napi = &tp->r8125napi[i];
+
+                disable_irq(irq->vector);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+                irq->handler(irq->vector, r8125napi);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+                irq->handler(irq->vector, r8125napi, NULL);
+#else
+                irq->handler(irq->vector, r8125napi);
+#endif
+
+                enable_irq(irq->vector);
+        }
+}
+#endif //CONFIG_NET_POLL_CONTROLLER
+
+static void
+rtl8125_setup_interrupt_mask(struct rtl8125_private *tp)
+{
+        int i;
+
+        if (tp->HwCurrIsrVer == 7) {
+                tp->intr_mask = ISRIMR_V7_LINKCHG | ISRIMR_V7_TOK_Q0;
+                if (tp->num_tx_rings > 1)
+                        tp->intr_mask |= ISRIMR_V7_TOK_Q1;
+                for (i = 0; i < tp->num_rx_rings; i++)
+                        tp->intr_mask |= ISRIMR_V7_ROK_Q0 << i;
+        } else if (tp->HwCurrIsrVer == 5) {
+                tp->intr_mask = ISRIMR_V5_LINKCHG | ISRIMR_V5_TOK_Q0;
+                if (tp->num_tx_rings > 1)
+                        tp->intr_mask |= ISRIMR_V5_TOK_Q1;
+                for (i = 0; i < tp->num_rx_rings; i++)
+                        tp->intr_mask |= ISRIMR_V5_ROK_Q0 << i;
+        } else if (tp->HwCurrIsrVer == 4) {
+                tp->intr_mask = ISRIMR_V4_LINKCHG;
+                for (i = 0; i < max(tp->num_tx_rings, tp->num_rx_rings); i++)
+                        tp->intr_mask |= ISRIMR_V4_ROK_Q0 << i;
+
+                if (tp->DASH)
+                        tp->intr_l2_mask |= ISRIMR_V4_L2_IPC2;
+
+                if (tp->intr_l2_mask > 0)
+                        tp->intr_mask |= ISRIMR_V4_LAYER2_INTR_STS;
+        } else if (tp->HwCurrIsrVer == 3) {
+                tp->intr_mask = ISRIMR_V2_LINKCHG;
+                for (i = 0; i < max(tp->num_tx_rings, tp->num_rx_rings); i++)
+                        tp->intr_mask |= ISRIMR_V2_ROK_Q0 << i;
+        } else if (tp->HwCurrIsrVer == 2) {
+                tp->intr_mask = ISRIMR_V2_LINKCHG | ISRIMR_TOK_Q0;
+                if (tp->num_tx_rings > 1)
+                        tp->intr_mask |= ISRIMR_TOK_Q1;
+
+                for (i = 0; i < tp->num_rx_rings; i++)
+                        tp->intr_mask |= ISRIMR_V2_ROK_Q0 << i;
+        } else {
+                tp->intr_mask = LinkChg | RxDescUnavail | TxOK | RxOK | SWInt;
+                tp->timer_intr_mask = LinkChg | PCSTimeout;
+
+#ifdef ENABLE_DASH_SUPPORT
+                if (tp->DASH) {
+                        if (HW_DASH_SUPPORT_IPC2(tp)) {
+                                tp->timer_intr_mask |= ISRIMR_DASH_INTR_EN;
+                                tp->intr_mask |= ISRIMR_DASH_INTR_EN;
+                        }
+                }
+#endif
+        }
+}
+
+static void
+rtl8125_setup_mqs_reg(struct rtl8125_private *tp)
+{
+        u16 hw_clo_ptr0_reg, sw_tail_ptr0_reg;
+        u16 reg_len;
+        int i;
+
+        //tx
+        tp->tx_ring[0].tdsar_reg = TxDescStartAddrLow;
+        for (i = 1; i < tp->HwSuppNumTxQueues; i++) {
+                tp->tx_ring[i].tdsar_reg = (u16)(TNPDS_Q1_LOW_8125 + (i - 1) * 8);
+        }
+
+        switch (tp->HwSuppTxNoCloseVer) {
+        case 4:
+        case 5:
+                hw_clo_ptr0_reg = HW_CLO_PTR0_8126;
+                sw_tail_ptr0_reg = SW_TAIL_PTR0_8126;
+                reg_len = 4;
+                break;
+        case 6:
+                hw_clo_ptr0_reg = HW_CLO_PTR0_8125BP;
+                sw_tail_ptr0_reg = SW_TAIL_PTR0_8125BP;
+                reg_len = 8;
+                break;
+        default:
+                hw_clo_ptr0_reg = HW_CLO_PTR0_8125;
+                sw_tail_ptr0_reg = SW_TAIL_PTR0_8125;
+                reg_len = 4;
+                break;
+        }
+
+        for (i = 0; i < tp->HwSuppNumTxQueues; i++) {
+                tp->tx_ring[i].hw_clo_ptr_reg = (u16)(hw_clo_ptr0_reg + i * reg_len);
+                tp->tx_ring[i].sw_tail_ptr_reg = (u16)(sw_tail_ptr0_reg + i * reg_len);
+        }
+
+        //rx
+        tp->rx_ring[0].rdsar_reg = RxDescAddrLow;
+        for (i = 1; i < tp->HwSuppNumRxQueues; i++)
+                tp->rx_ring[i].rdsar_reg = (u16)(RDSAR_Q1_LOW_8125 + (i - 1) * 8);
+
+        tp->isr_reg[0] = ISR0_8125;
+        for (i = 1; i < tp->hw_supp_irq_nvecs; i++)
+                tp->isr_reg[i] = (u16)(ISR1_8125 + (i - 1) * 4);
+
+        tp->imr_reg[0] = IMR0_8125;
+        for (i = 1; i < tp->hw_supp_irq_nvecs; i++)
+                tp->imr_reg[i] = (u16)(IMR1_8125 + (i - 1) * 4);
+}
+
+static void
+rtl8125_backup_led_select(struct rtl8125_private *tp)
+{
+        tp->BackupLedSel[1] = RTL_R16(tp, LEDSEL_1_8125);
+        tp->BackupLedSel[2] = RTL_R16(tp, LEDSEL_2_8125);
+        tp->BackupLedSel[3] = RTL_R16(tp, LEDSEL_3_8125);
+        tp->BackupLedSel[0] = RTL_R16(tp, CustomLED);
+}
+
+static void
+rtl8125_restore_led_select(struct rtl8125_private *tp)
+{
+        RTL_W16(tp, LEDSEL_1_8125, tp->BackupLedSel[1]);
+        RTL_W16(tp, LEDSEL_2_8125, tp->BackupLedSel[2]);
+        RTL_W16(tp, LEDSEL_3_8125, tp->BackupLedSel[3]);
+        RTL_W16(tp, CustomLED, tp->BackupLedSel[0]);
+}
+
+static bool
+_rtl8125_backup_phy_fuse_dout_v4(struct rtl8125_private *tp)
+{
+        u16 i;
+
+        for (i = 0; i < R8125_PHY_FUSE_DOUT_NUM; i++) {
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xA460,
+                                                      0x001F,
+                                                      i);
+                tp->BackupPhyFuseDout[i] = rtl8125_mdio_direct_read_phy_ocp(tp, 0xA462);
+        }
+
+        if (tp->HwSuppEsdVer == 4) {
+                tp->BackupPhyFuseDout[3] |= 0xF000;
+                tp->BackupPhyFuseDout[7] |= 0x03FF;
+                tp->BackupPhyFuseDout[4] = USHRT_MAX;
+                tp->BackupPhyFuseDout[5] = USHRT_MAX;
+                tp->BackupPhyFuseDout[6] = USHRT_MAX;
+        } else if (tp->HwSuppEsdVer == 5) {
+                tp->BackupPhyFuseDout[30] = USHRT_MAX;
+                tp->BackupPhyFuseDout[31] = USHRT_MAX;
+        }
+
+        return TRUE;
+}
+
+static bool
+rtl8125_backup_phy_fuse_dout(struct rtl8125_private *tp)
+{
+        if (tp->HwSuppEsdVer == 4 || tp->HwSuppEsdVer == 5)
+                return _rtl8125_backup_phy_fuse_dout_v4(tp);
+        else
+                return FALSE;
+}
+
+static void
+_rtl8125_restore_phy_fuse_dout_v4(struct rtl8125_private *tp)
+{
+        u16 i;
+
+        for (i = 0; i < R8125_PHY_FUSE_DOUT_NUM; i++) {
+                if (tp->BackupPhyFuseDout[i] == USHRT_MAX)
+                        continue;
+
+                rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xA460,
+                                                      0x001F,
+                                                      i);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA462, tp->BackupPhyFuseDout[i]);
+        }
+}
+
+static void
+rtl8125_restore_phy_fuse_dout(struct rtl8125_private *tp)
+{
+        if (tp->HwSuppEsdVer == 4 || tp->HwSuppEsdVer == 5)
+                _rtl8125_restore_phy_fuse_dout_v4(tp);
+        else
+                return;
+}
+
+static void
+rtl8125_init_software_variable(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct pci_dev *pdev = tp->pci_dev;
+
+#ifdef ENABLE_LIB_SUPPORT
+        tp->ring_lib_enabled = 1;
+#endif
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3: {
+                u8 tmp = (u8)rtl8125_mac_ocp_read(tp, 0xD006);
+                if (tmp == 0x02 || tmp == 0x04)
+                        tp->HwSuppDashVer = 2;
+        }
+        break;
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+                tp->HwSuppDashVer = 4;
+                break;
+        default:
+                tp->HwSuppDashVer = 0;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+                if (HW_DASH_SUPPORT_DASH(tp))
+                        tp->HwSuppOcpChannelVer = 2;
+                break;
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_12:
+                tp->HwSuppOcpChannelVer = 2;
+                break;
+        }
+        tp->AllowAccessDashOcp = rtl8125_is_allow_access_dash_ocp(tp);
+
+        tp->HwPkgDet = rtl8125_mac_ocp_read(tp, 0xDC00);
+        tp->HwPkgDet = (tp->HwPkgDet >> 3) & 0x07;
+
+        tp->HwSuppNowIsOobVer = 1;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->HwPcieSNOffset = 0x16C;
+                break;
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                tp->HwPcieSNOffset = 0x168;
+                break;
+        }
+
+#ifdef ENABLE_REALWOW_SUPPORT
+        rtl8125_get_realwow_hw_version(dev);
+#endif //ENABLE_REALWOW_SUPPORT
+
+        tp->DASH = rtl8125_check_dash(tp);
+
+        if (tp->DASH) {
+                eee_enable = 0;
+
+                tp->SizeOfSendToFwBuffer = SEND_TO_FW_BUF_SIZE;
+                tp->SizeOfRecvFromFwBuffer = RECV_FROM_FW_BUF_SIZE;
+
+                tp->DashFirmwareVersion = rtl8125_get_dash_fw_ver(tp);
+        }
+
+        if (aspm) {
+                tp->org_pci_offset_99 = rtl8125_csi_fun0_read_byte(tp, 0x99);
+                tp->org_pci_offset_99 &= ~(BIT_5|BIT_6);
+
+                switch (tp->mcfg) {
+                case CFG_METHOD_2:
+                case CFG_METHOD_3:
+                case CFG_METHOD_6:
+                        tp->org_pci_offset_180 = rtl8125_csi_fun0_read_byte(tp, 0x264);
+                        break;
+                case CFG_METHOD_4:
+                case CFG_METHOD_5:
+                case CFG_METHOD_7:
+                        tp->org_pci_offset_180 = rtl8125_csi_fun0_read_byte(tp, 0x214);
+                        break;
+                case CFG_METHOD_8:
+                case CFG_METHOD_9:
+                case CFG_METHOD_10:
+                case CFG_METHOD_11:
+                case CFG_METHOD_13:
+                        tp->org_pci_offset_180 = rtl8125_csi_fun0_read_byte(tp, 0x210);
+                        break;
+                case CFG_METHOD_12:
+                        tp->org_pci_offset_180 = rtl8125_csi_fun0_read_byte(tp, 0x184);
+                        break;
+                }
+        }
+
+        pci_read_config_byte(pdev, 0x80, &tp->org_pci_offset_80);
+        pci_read_config_byte(pdev, 0x81, &tp->org_pci_offset_81);
+
+        tp->use_timer_interrupt = TRUE;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+                tp->HwSuppMaxPhyLinkSpeed = 2500;
+                break;
+        default:
+                tp->HwSuppMaxPhyLinkSpeed = 1000;
+                break;
+        }
+
+        if (timer_count == 0 || tp->mcfg == CFG_METHOD_DEFAULT)
+                tp->use_timer_interrupt = FALSE;
+
+        tp->ShortPacketSwChecksum = TRUE;
+        tp->UseSwPaddingShortPkt = TRUE;
+
+#ifdef ENABLE_FIBER_SUPPORT
+        rtl8125_check_fiber_mode_support(tp);
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_13:
+                tp->HwSuppMagicPktVer = WAKEUP_MAGIC_PACKET_V3;
+                break;
+        default:
+                tp->HwSuppMagicPktVer = WAKEUP_MAGIC_PACKET_NOT_SUPPORT;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                tp->HwSuppEsdVer = 4;
+                break;
+        case CFG_METHOD_10:
+                tp->HwSuppEsdVer = 5;
+                break;
+        default:
+                tp->HwSuppEsdVer = 1;
+                break;
+        }
+
+        if (rtl8125_backup_phy_fuse_dout(tp))
+                tp->TestPhyOcpReg = TRUE;
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+        tp->TestPhyOcpReg = FALSE;
+#endif
+
+        tp->HwSuppLinkChgWakeUpVer = 3;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+                tp->HwSuppD0SpeedUpVer = 1;
+                break;
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                tp->HwSuppD0SpeedUpVer = 2;
+                break;
+        }
+
+        tp->HwSuppCheckPhyDisableModeVer = 3;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->HwSuppTxNoCloseVer = 3;
+                break;
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                tp->HwSuppTxNoCloseVer = 6;
+                break;
+        }
+
+        switch (tp->HwSuppTxNoCloseVer) {
+        case 5:
+        case 6:
+                tp->MaxTxDescPtrMask = MAX_TX_NO_CLOSE_DESC_PTR_MASK_V4;
+                break;
+        case 4:
+                tp->MaxTxDescPtrMask = MAX_TX_NO_CLOSE_DESC_PTR_MASK_V3;
+                break;
+        case 3:
+                tp->MaxTxDescPtrMask = MAX_TX_NO_CLOSE_DESC_PTR_MASK_V2;
+                break;
+        default:
+                tx_no_close_enable = 0;
+                break;
+        }
+
+        if (tp->HwSuppTxNoCloseVer > 0 && tx_no_close_enable == 1)
+                tp->EnableTxNoClose = TRUE;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                tp->RequireLSOPatch = TRUE;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_2;
+                break;
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_3;
+                break;
+        case CFG_METHOD_4:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_4;
+                break;
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_5;
+                break;
+        case CFG_METHOD_8:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_8;
+                break;
+        case CFG_METHOD_9:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_9;
+                break;
+        case CFG_METHOD_10:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_10;
+                break;
+        case CFG_METHOD_11:
+        case CFG_METHOD_13:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_11;
+                break;
+        case CFG_METHOD_12:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_12;
+                break;
+        }
+
+        if (tp->HwIcVerUnknown) {
+                tp->NotWrRamCodeToMicroP = TRUE;
+                tp->NotWrMcuPatchCode = TRUE;
+        }
+
+        rtl8125_check_hw_phy_mcu_code_ver(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                if ((rtl8125_mac_ocp_read(tp, 0xD442) & BIT_5) &&
+                    (rtl8125_mdio_direct_read_phy_ocp(tp, 0xD068) & BIT_1))
+                        tp->RequirePhyMdiSwapPatch = TRUE;
+                break;
+        }
+
+        tp->HwSuppMacMcuVer = 2;
+
+        tp->MacMcuPageSize = RTL8125_MAC_MCU_PAGE_SIZE;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                tp->HwSuppNumTxQueues = 2;
+                tp->HwSuppNumRxQueues = 4;
+                break;
+        default:
+                tp->HwSuppNumTxQueues = 1;
+                tp->HwSuppNumRxQueues = 1;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                /* mac ptp */
+                tp->HwSuppPtpVer = 1;
+                break;
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                /* phy ptp */
+                tp->HwSuppPtpVer = 3;
+                break;
+        }
+#ifdef ENABLE_PTP_SUPPORT
+        if (tp->HwSuppPtpVer > 0)
+                tp->EnablePtp = 1;
+#endif
+
+        //init interrupt
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                tp->HwSuppIsrVer = 2;
+                break;
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+                tp->HwSuppIsrVer = 4;
+                break;
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_13:
+                tp->HwSuppIsrVer = 5;
+                break;
+        case CFG_METHOD_12:
+                tp->HwSuppIsrVer = 7;
+                break;
+        default:
+                tp->HwSuppIsrVer = 1;
+                break;
+        }
+
+        tp->HwCurrIsrVer = tp->HwSuppIsrVer;
+        if (tp->HwCurrIsrVer > 1) {
+                if (!(tp->features & RTL_FEATURE_MSIX) ||
+                    tp->irq_nvecs < tp->min_irq_nvecs)
+                        tp->HwCurrIsrVer = 1;
+        }
+
+        tp->num_tx_rings = 1;
+#ifdef ENABLE_MULTIPLE_TX_QUEUE
+#ifndef ENABLE_LIB_SUPPORT
+        tp->num_tx_rings = tp->HwSuppNumTxQueues;
+#endif
+#endif
+        if (tp->HwCurrIsrVer < 2 ||
+            (tp->HwCurrIsrVer == 2 && tp->irq_nvecs < 19))
+                tp->num_tx_rings = 1;
+
+        //RSS
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                tp->HwSuppRssVer = 5;
+                tp->HwSuppIndirTblEntries = 128;
+                break;
+        }
+
+        tp->num_rx_rings = 1;
+#ifdef ENABLE_RSS_SUPPORT
+#ifdef ENABLE_LIB_SUPPORT
+        if (tp->HwSuppRssVer > 0)
+                tp->EnableRss = 1;
+#else
+        if (tp->HwSuppRssVer > 0 && tp->HwCurrIsrVer > 1) {
+                u8 rss_queue_num = netif_get_num_default_rss_queues();
+                tp->num_rx_rings = (tp->HwSuppNumRxQueues > rss_queue_num)?
+                                   rss_queue_num : tp->HwSuppNumRxQueues;
+
+                if (!(tp->num_rx_rings >= 2 && tp->irq_nvecs >= tp->num_rx_rings))
+                        tp->num_rx_rings = 1;
+
+                if (tp->num_rx_rings >= 2)
+                        tp->EnableRss = 1;
+        }
+#endif
+#endif
+
+        //interrupt mask
+        rtl8125_setup_interrupt_mask(tp);
+
+        rtl8125_setup_mqs_reg(tp);
+
+        rtl8125_set_ring_size(tp, NUM_RX_DESC, NUM_TX_DESC);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                tp->HwSuppIntMitiVer = 3;
+                break;
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                tp->HwSuppIntMitiVer = 4;
+                break;
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                tp->HwSuppIntMitiVer = 6;
+                break;
+        }
+
+        tp->HwSuppTcamVer = 1;
+        tp->TcamNotValidReg = TCAM_NOTVALID_ADDR;
+        tp->TcamValidReg = TCAM_VALID_ADDR;
+        tp->TcamMaAddrcOffset = TCAM_MAC_ADDR;
+        tp->TcamVlanTagOffset = TCAM_VLAN_TAG;
+
+        tp->HwSuppExtendTallyCounterVer = 1;
+
+        timer_count_v2 = (timer_count / 0x100);
+        /* timer unit is double */
+        switch (tp->mcfg) {
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                timer_count_v2 /= 2;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_13:
+                tp->RequiredPfmPatch = TRUE;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->HwSuppRxDescType = RX_DESC_RING_TYPE_3;
+                break;
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                tp->HwSuppRxDescType = RX_DESC_RING_TYPE_4;
+                break;
+        default:
+                tp->HwSuppRxDescType = RX_DESC_RING_TYPE_1;
+                break;
+        }
+
+        tp->InitRxDescType = RX_DESC_RING_TYPE_1;
+        tp->RxDescLength = RX_DESC_LEN_TYPE_1;
+        switch (tp->HwSuppRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                if (tp->EnableRss || tp->EnablePtp) {
+                        tp->InitRxDescType = RX_DESC_RING_TYPE_3;
+                        tp->RxDescLength = RX_DESC_LEN_TYPE_3;
+                }
+                break;
+        case RX_DESC_RING_TYPE_4:
+                if (tp->EnableRss) {
+                        tp->InitRxDescType = RX_DESC_RING_TYPE_4;
+                        tp->RxDescLength = RX_DESC_LEN_TYPE_4;
+                }
+                break;
+        }
+
+        tp->rtl8125_rx_config = rtl_chip_info[tp->chipset].RCR_Cfg;
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                tp->rtl8125_rx_config |= EnableRxDescV3;
+        else if (tp->InitRxDescType == RX_DESC_RING_TYPE_4)
+                tp->rtl8125_rx_config &= ~EnableRxDescV4_1;
+
+        rtl8125_backup_led_select(tp);
+
+        tp->wol_opts = rtl8125_get_hw_wol(tp);
+        tp->wol_enabled = (tp->wol_opts) ? WOL_ENABLED : WOL_DISABLED;
+
+        rtl8125_set_link_option(tp, autoneg_mode, speed_mode, duplex_mode,
+                                rtl8125_fc_full);
+
+        tp->max_jumbo_frame_size = rtl_chip_info[tp->chipset].jumbo_frame_sz;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+        /* MTU range: 60 - hw-specific max */
+        dev->min_mtu = ETH_MIN_MTU;
+        dev->max_mtu = tp->max_jumbo_frame_size;
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+
+        if (tp->mcfg != CFG_METHOD_DEFAULT) {
+                struct ethtool_keee *eee = &tp->eee;
+
+                eee->eee_enabled = eee_enable;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,9,0)
+                eee->supported  = SUPPORTED_100baseT_Full |
+                                  SUPPORTED_1000baseT_Full;
+                eee->advertised = mmd_eee_adv_to_ethtool_adv_t(MDIO_EEE_1000T | MDIO_EEE_100TX);
+                switch (tp->mcfg) {
+                case CFG_METHOD_2:
+                case CFG_METHOD_3:
+                        /* nothing to do */
+                        break;
+                default:
+                        if (HW_SUPP_PHY_LINK_SPEED_2500M(tp)) {
+                                eee->supported |= SUPPORTED_2500baseX_Full;
+                                eee->advertised |= SUPPORTED_2500baseX_Full;
+                        }
+                        break;
+                }
+#else
+                linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, eee->supported);
+                linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, eee->supported);
+                linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, eee->advertised);
+                linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, eee->advertised);
+                switch (tp->mcfg) {
+                case CFG_METHOD_2:
+                case CFG_METHOD_3:
+                        /* nothing to do */
+                        break;
+                default:
+                        if (HW_SUPP_PHY_LINK_SPEED_2500M(tp)) {
+                                linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, eee->supported);
+                                linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, eee->advertised);
+                        }
+                        break;
+                }
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(6,9,0) */
+                eee->tx_lpi_enabled = eee_enable;
+                eee->tx_lpi_timer = dev->mtu + ETH_HLEN + 0x20;
+        }
+
+        tp->ptp_master_mode = enable_ptp_master_mode;
+
+#ifdef ENABLE_RSS_SUPPORT
+        if (tp->EnableRss)
+                rtl8125_init_rss(tp);
+#endif
+}
+
+static void
+rtl8125_release_board(struct pci_dev *pdev,
+                      struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+
+        rtl8125_rar_set(tp, tp->org_mac_addr);
+        tp->wol_enabled = WOL_DISABLED;
+
+        if (!tp->DASH)
+                rtl8125_phy_power_down(dev);
+
+        iounmap(ioaddr);
+        pci_release_regions(pdev);
+        pci_clear_mwi(pdev);
+        pci_disable_device(pdev);
+        free_netdev(dev);
+}
+
+static void
+rtl8125_hw_address_set(struct net_device *dev, u8 mac_addr[MAC_ADDR_LEN])
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+        eth_hw_addr_set(dev, mac_addr);
+#else
+        memcpy(dev->dev_addr, mac_addr, MAC_ADDR_LEN);
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+}
+
+static int
+rtl8125_get_mac_address(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+        u8 mac_addr[MAC_ADDR_LEN];
+
+        for (i = 0; i < MAC_ADDR_LEN; i++)
+                mac_addr[i] = RTL_R8(tp, MAC0 + i);
+
+        *(u32*)&mac_addr[0] = RTL_R32(tp, BACKUP_ADDR0_8125);
+        *(u16*)&mac_addr[4] = RTL_R16(tp, BACKUP_ADDR1_8125);
+
+        if (!is_valid_ether_addr(mac_addr)) {
+                netif_err(tp, probe, dev, "Invalid ether addr %pM\n",
+                          mac_addr);
+                eth_random_addr(mac_addr);
+                dev->addr_assign_type = NET_ADDR_RANDOM;
+                netif_info(tp, probe, dev, "Random ether addr %pM\n",
+                           mac_addr);
+                tp->random_mac = 1;
+        }
+
+        rtl8125_hw_address_set(dev, mac_addr);
+        rtl8125_rar_set(tp, mac_addr);
+
+        /* keep the original MAC address */
+        memcpy(tp->org_mac_addr, dev->dev_addr, MAC_ADDR_LEN);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+        memcpy(dev->perm_addr, dev->dev_addr, MAC_ADDR_LEN);
+#endif
+        return 0;
+}
+
+/**
+ * rtl8125_set_mac_address - Change the Ethernet Address of the NIC
+ * @dev: network interface device structure
+ * @p:   pointer to an address structure
+ *
+ * Return 0 on success, negative on failure
+ **/
+static int
+rtl8125_set_mac_address(struct net_device *dev,
+                        void *p)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct sockaddr *addr = p;
+
+        if (!is_valid_ether_addr(addr->sa_data))
+                return -EADDRNOTAVAIL;
+
+        rtl8125_hw_address_set(dev, addr->sa_data);
+
+        rtl8125_rar_set(tp, dev->dev_addr);
+
+        return 0;
+}
+
+/******************************************************************************
+ * rtl8125_rar_set - Puts an ethernet address into a receive address register.
+ *
+ * tp - The private data structure for driver
+ * addr - Address to put into receive address register
+ *****************************************************************************/
+void
+rtl8125_rar_set(struct rtl8125_private *tp,
+                const u8 *addr)
+{
+        uint32_t rar_low = 0;
+        uint32_t rar_high = 0;
+
+        rar_low = ((uint32_t) addr[0] |
+                   ((uint32_t) addr[1] << 8) |
+                   ((uint32_t) addr[2] << 16) |
+                   ((uint32_t) addr[3] << 24));
+
+        rar_high = ((uint32_t) addr[4] |
+                    ((uint32_t) addr[5] << 8));
+
+        rtl8125_enable_cfg9346_write(tp);
+        RTL_W32(tp, MAC0, rar_low);
+        RTL_W32(tp, MAC4, rar_high);
+
+        rtl8125_disable_cfg9346_write(tp);
+}
+
+#ifdef ETHTOOL_OPS_COMPAT
+static int ethtool_get_settings(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_cmd cmd = { ETHTOOL_GSET };
+        int err;
+
+        if (!ethtool_ops->get_settings)
+                return -EOPNOTSUPP;
+
+        err = ethtool_ops->get_settings(dev, &cmd);
+        if (err < 0)
+                return err;
+
+        if (copy_to_user(useraddr, &cmd, sizeof(cmd)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_settings(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_cmd cmd;
+
+        if (!ethtool_ops->set_settings)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&cmd, useraddr, sizeof(cmd)))
+                return -EFAULT;
+
+        return ethtool_ops->set_settings(dev, &cmd);
+}
+
+static int ethtool_get_drvinfo(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_drvinfo info;
+        struct ethtool_ops *ops = ethtool_ops;
+
+        if (!ops->get_drvinfo)
+                return -EOPNOTSUPP;
+
+        memset(&info, 0, sizeof(info));
+        info.cmd = ETHTOOL_GDRVINFO;
+        ops->get_drvinfo(dev, &info);
+
+        if (ops->self_test_count)
+                info.testinfo_len = ops->self_test_count(dev);
+        if (ops->get_stats_count)
+                info.n_stats = ops->get_stats_count(dev);
+        if (ops->get_regs_len)
+                info.regdump_len = ops->get_regs_len(dev);
+        if (ops->get_eeprom_len)
+                info.eedump_len = ops->get_eeprom_len(dev);
+
+        if (copy_to_user(useraddr, &info, sizeof(info)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_get_regs(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_regs regs;
+        struct ethtool_ops *ops = ethtool_ops;
+        void *regbuf;
+        int reglen, ret;
+
+        if (!ops->get_regs || !ops->get_regs_len)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&regs, useraddr, sizeof(regs)))
+                return -EFAULT;
+
+        reglen = ops->get_regs_len(dev);
+        if (regs.len > reglen)
+                regs.len = reglen;
+
+        regbuf = kmalloc(reglen, GFP_USER);
+        if (!regbuf)
+                return -ENOMEM;
+
+        ops->get_regs(dev, &regs, regbuf);
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &regs, sizeof(regs)))
+                goto out;
+        useraddr += offsetof(struct ethtool_regs, data);
+        if (copy_to_user(useraddr, regbuf, reglen))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(regbuf);
+        return ret;
+}
+
+static int ethtool_get_wol(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_wolinfo wol = { ETHTOOL_GWOL };
+
+        if (!ethtool_ops->get_wol)
+                return -EOPNOTSUPP;
+
+        ethtool_ops->get_wol(dev, &wol);
+
+        if (copy_to_user(useraddr, &wol, sizeof(wol)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_wol(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_wolinfo wol;
+
+        if (!ethtool_ops->set_wol)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&wol, useraddr, sizeof(wol)))
+                return -EFAULT;
+
+        return ethtool_ops->set_wol(dev, &wol);
+}
+
+static int ethtool_get_msglevel(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GMSGLVL };
+
+        if (!ethtool_ops->get_msglevel)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_msglevel(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_msglevel(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_msglevel)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        ethtool_ops->set_msglevel(dev, edata.data);
+        return 0;
+}
+
+static int ethtool_nway_reset(struct net_device *dev)
+{
+        if (!ethtool_ops->nway_reset)
+                return -EOPNOTSUPP;
+
+        return ethtool_ops->nway_reset(dev);
+}
+
+static int ethtool_get_link(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GLINK };
+
+        if (!ethtool_ops->get_link)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_link(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_get_eeprom(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_eeprom eeprom;
+        struct ethtool_ops *ops = ethtool_ops;
+        u8 *data;
+        int ret;
+
+        if (!ops->get_eeprom || !ops->get_eeprom_len)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&eeprom, useraddr, sizeof(eeprom)))
+                return -EFAULT;
+
+        /* Check for wrap and zero */
+        if (eeprom.offset + eeprom.len <= eeprom.offset)
+                return -EINVAL;
+
+        /* Check for exceeding total eeprom len */
+        if (eeprom.offset + eeprom.len > ops->get_eeprom_len(dev))
+                return -EINVAL;
+
+        data = kmalloc(eeprom.len, GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ret = -EFAULT;
+        if (copy_from_user(data, useraddr + sizeof(eeprom), eeprom.len))
+                goto out;
+
+        ret = ops->get_eeprom(dev, &eeprom, data);
+        if (ret)
+                goto out;
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &eeprom, sizeof(eeprom)))
+                goto out;
+        if (copy_to_user(useraddr + sizeof(eeprom), data, eeprom.len))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_set_eeprom(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_eeprom eeprom;
+        struct ethtool_ops *ops = ethtool_ops;
+        u8 *data;
+        int ret;
+
+        if (!ops->set_eeprom || !ops->get_eeprom_len)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&eeprom, useraddr, sizeof(eeprom)))
+                return -EFAULT;
+
+        /* Check for wrap and zero */
+        if (eeprom.offset + eeprom.len <= eeprom.offset)
+                return -EINVAL;
+
+        /* Check for exceeding total eeprom len */
+        if (eeprom.offset + eeprom.len > ops->get_eeprom_len(dev))
+                return -EINVAL;
+
+        data = kmalloc(eeprom.len, GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ret = -EFAULT;
+        if (copy_from_user(data, useraddr + sizeof(eeprom), eeprom.len))
+                goto out;
+
+        ret = ops->set_eeprom(dev, &eeprom, data);
+        if (ret)
+                goto out;
+
+        if (copy_to_user(useraddr + sizeof(eeprom), data, eeprom.len))
+                ret = -EFAULT;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_get_coalesce(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_coalesce coalesce = { ETHTOOL_GCOALESCE };
+
+        if (!ethtool_ops->get_coalesce)
+                return -EOPNOTSUPP;
+
+        ethtool_ops->get_coalesce(dev, &coalesce);
+
+        if (copy_to_user(useraddr, &coalesce, sizeof(coalesce)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_coalesce(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_coalesce coalesce;
+
+        if (!ethtool_ops->get_coalesce)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&coalesce, useraddr, sizeof(coalesce)))
+                return -EFAULT;
+
+        return ethtool_ops->set_coalesce(dev, &coalesce);
+}
+
+static int ethtool_get_ringparam(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_ringparam ringparam = { ETHTOOL_GRINGPARAM };
+
+        if (!ethtool_ops->get_ringparam)
+                return -EOPNOTSUPP;
+
+        ethtool_ops->get_ringparam(dev, &ringparam);
+
+        if (copy_to_user(useraddr, &ringparam, sizeof(ringparam)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_ringparam(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_ringparam ringparam;
+
+        if (!ethtool_ops->get_ringparam)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&ringparam, useraddr, sizeof(ringparam)))
+                return -EFAULT;
+
+        return ethtool_ops->set_ringparam(dev, &ringparam);
+}
+
+static int ethtool_get_pauseparam(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_pauseparam pauseparam = { ETHTOOL_GPAUSEPARAM };
+
+        if (!ethtool_ops->get_pauseparam)
+                return -EOPNOTSUPP;
+
+        ethtool_ops->get_pauseparam(dev, &pauseparam);
+
+        if (copy_to_user(useraddr, &pauseparam, sizeof(pauseparam)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_pauseparam(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_pauseparam pauseparam;
+
+        if (!ethtool_ops->get_pauseparam)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&pauseparam, useraddr, sizeof(pauseparam)))
+                return -EFAULT;
+
+        return ethtool_ops->set_pauseparam(dev, &pauseparam);
+}
+
+static int ethtool_get_rx_csum(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GRXCSUM };
+
+        if (!ethtool_ops->get_rx_csum)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_rx_csum(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_rx_csum(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_rx_csum)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        ethtool_ops->set_rx_csum(dev, edata.data);
+        return 0;
+}
+
+static int ethtool_get_tx_csum(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GTXCSUM };
+
+        if (!ethtool_ops->get_tx_csum)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_tx_csum(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_tx_csum(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_tx_csum)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        return ethtool_ops->set_tx_csum(dev, edata.data);
+}
+
+static int ethtool_get_sg(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GSG };
+
+        if (!ethtool_ops->get_sg)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_sg(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_sg(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_sg)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        return ethtool_ops->set_sg(dev, edata.data);
+}
+
+static int ethtool_get_tso(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GTSO };
+
+        if (!ethtool_ops->get_tso)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_tso(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_tso(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_tso)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        return ethtool_ops->set_tso(dev, edata.data);
+}
+
+static int ethtool_self_test(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_test test;
+        struct ethtool_ops *ops = ethtool_ops;
+        u64 *data;
+        int ret;
+
+        if (!ops->self_test || !ops->self_test_count)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&test, useraddr, sizeof(test)))
+                return -EFAULT;
+
+        test.len = ops->self_test_count(dev);
+        data = kmalloc(test.len * sizeof(u64), GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ops->self_test(dev, &test, data);
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &test, sizeof(test)))
+                goto out;
+        useraddr += sizeof(test);
+        if (copy_to_user(useraddr, data, test.len * sizeof(u64)))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_get_strings(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_gstrings gstrings;
+        struct ethtool_ops *ops = ethtool_ops;
+        u8 *data;
+        int ret;
+
+        if (!ops->get_strings)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&gstrings, useraddr, sizeof(gstrings)))
+                return -EFAULT;
+
+        switch (gstrings.string_set) {
+        case ETH_SS_TEST:
+                if (!ops->self_test_count)
+                        return -EOPNOTSUPP;
+                gstrings.len = ops->self_test_count(dev);
+                break;
+        case ETH_SS_STATS:
+                if (!ops->get_stats_count)
+                        return -EOPNOTSUPP;
+                gstrings.len = ops->get_stats_count(dev);
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        data = kmalloc(gstrings.len * ETH_GSTRING_LEN, GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ops->get_strings(dev, gstrings.string_set, data);
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &gstrings, sizeof(gstrings)))
+                goto out;
+        useraddr += sizeof(gstrings);
+        if (copy_to_user(useraddr, data, gstrings.len * ETH_GSTRING_LEN))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_phys_id(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_value id;
+
+        if (!ethtool_ops->phys_id)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&id, useraddr, sizeof(id)))
+                return -EFAULT;
+
+        return ethtool_ops->phys_id(dev, id.data);
+}
+
+static int ethtool_get_stats(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_stats stats;
+        struct ethtool_ops *ops = ethtool_ops;
+        u64 *data;
+        int ret;
+
+        if (!ops->get_ethtool_stats || !ops->get_stats_count)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&stats, useraddr, sizeof(stats)))
+                return -EFAULT;
+
+        stats.n_stats = ops->get_stats_count(dev);
+        data = kmalloc(stats.n_stats * sizeof(u64), GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ops->get_ethtool_stats(dev, &stats, data);
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &stats, sizeof(stats)))
+                goto out;
+        useraddr += sizeof(stats);
+        if (copy_to_user(useraddr, data, stats.n_stats * sizeof(u64)))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_ioctl(struct ifreq *ifr)
+{
+        struct net_device *dev = __dev_get_by_name(ifr->ifr_name);
+        void *useraddr = (void *) ifr->ifr_data;
+        u32 ethcmd;
+
+        /*
+         * XXX: This can be pushed down into the ethtool_* handlers that
+         * need it.  Keep existing behaviour for the moment.
+         */
+        if (!capable(CAP_NET_ADMIN))
+                return -EPERM;
+
+        if (!dev || !netif_device_present(dev))
+                return -ENODEV;
+
+        if (copy_from_user(&ethcmd, useraddr, sizeof (ethcmd)))
+                return -EFAULT;
+
+        switch (ethcmd) {
+        case ETHTOOL_GSET:
+                return ethtool_get_settings(dev, useraddr);
+        case ETHTOOL_SSET:
+                return ethtool_set_settings(dev, useraddr);
+        case ETHTOOL_GDRVINFO:
+                return ethtool_get_drvinfo(dev, useraddr);
+        case ETHTOOL_GREGS:
+                return ethtool_get_regs(dev, useraddr);
+        case ETHTOOL_GWOL:
+                return ethtool_get_wol(dev, useraddr);
+        case ETHTOOL_SWOL:
+                return ethtool_set_wol(dev, useraddr);
+        case ETHTOOL_GMSGLVL:
+                return ethtool_get_msglevel(dev, useraddr);
+        case ETHTOOL_SMSGLVL:
+                return ethtool_set_msglevel(dev, useraddr);
+        case ETHTOOL_NWAY_RST:
+                return ethtool_nway_reset(dev);
+        case ETHTOOL_GLINK:
+                return ethtool_get_link(dev, useraddr);
+        case ETHTOOL_GEEPROM:
+                return ethtool_get_eeprom(dev, useraddr);
+        case ETHTOOL_SEEPROM:
+                return ethtool_set_eeprom(dev, useraddr);
+        case ETHTOOL_GCOALESCE:
+                return ethtool_get_coalesce(dev, useraddr);
+        case ETHTOOL_SCOALESCE:
+                return ethtool_set_coalesce(dev, useraddr);
+        case ETHTOOL_GRINGPARAM:
+                return ethtool_get_ringparam(dev, useraddr);
+        case ETHTOOL_SRINGPARAM:
+                return ethtool_set_ringparam(dev, useraddr);
+        case ETHTOOL_GPAUSEPARAM:
+                return ethtool_get_pauseparam(dev, useraddr);
+        case ETHTOOL_SPAUSEPARAM:
+                return ethtool_set_pauseparam(dev, useraddr);
+        case ETHTOOL_GRXCSUM:
+                return ethtool_get_rx_csum(dev, useraddr);
+        case ETHTOOL_SRXCSUM:
+                return ethtool_set_rx_csum(dev, useraddr);
+        case ETHTOOL_GTXCSUM:
+                return ethtool_get_tx_csum(dev, useraddr);
+        case ETHTOOL_STXCSUM:
+                return ethtool_set_tx_csum(dev, useraddr);
+        case ETHTOOL_GSG:
+                return ethtool_get_sg(dev, useraddr);
+        case ETHTOOL_SSG:
+                return ethtool_set_sg(dev, useraddr);
+        case ETHTOOL_GTSO:
+                return ethtool_get_tso(dev, useraddr);
+        case ETHTOOL_STSO:
+                return ethtool_set_tso(dev, useraddr);
+        case ETHTOOL_TEST:
+                return ethtool_self_test(dev, useraddr);
+        case ETHTOOL_GSTRINGS:
+                return ethtool_get_strings(dev, useraddr);
+        case ETHTOOL_PHYS_ID:
+                return ethtool_phys_id(dev, useraddr);
+        case ETHTOOL_GSTATS:
+                return ethtool_get_stats(dev, useraddr);
+        default:
+                return -EOPNOTSUPP;
+        }
+
+        return -EOPNOTSUPP;
+}
+#endif //ETHTOOL_OPS_COMPAT
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0)
+static int rtl8125_siocdevprivate(struct net_device *dev, struct ifreq *ifr,
+                                  void __user *data, int cmd)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ret = 0;
+
+        switch (cmd) {
+#ifdef ENABLE_DASH_SUPPORT
+        case SIOCDEVPRIVATE_RTLDASH:
+                if (!netif_running(dev)) {
+                        ret = -ENODEV;
+                        break;
+                }
+                if (!capable(CAP_NET_ADMIN)) {
+                        ret = -EPERM;
+                        break;
+                }
+
+                ret = rtl8125_dash_ioctl(dev, ifr);
+                break;
+#endif
+
+#ifdef ENABLE_REALWOW_SUPPORT
+        case SIOCDEVPRIVATE_RTLREALWOW:
+                if (!netif_running(dev)) {
+                        ret = -ENODEV;
+                        break;
+                }
+
+                ret = rtl8125_realwow_ioctl(dev, ifr);
+                break;
+#endif
+
+        case SIOCRTLTOOL:
+                if (!capable(CAP_NET_ADMIN)) {
+                        ret = -EPERM;
+                        break;
+                }
+
+                ret = rtl8125_tool_ioctl(tp, ifr);
+                break;
+
+        default:
+                ret = -EOPNOTSUPP;
+        }
+
+        return ret;
+}
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0)
+
+static int
+rtl8125_do_ioctl(struct net_device *dev,
+                 struct ifreq *ifr,
+                 int cmd)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct mii_ioctl_data *data = if_mii(ifr);
+        int ret = 0;
+
+        switch (cmd) {
+        case SIOCGMIIPHY:
+                data->phy_id = 32; /* Internal PHY */
+                break;
+
+        case SIOCGMIIREG:
+                rtl8125_mdio_write(tp, 0x1F, 0x0000);
+                data->val_out = rtl8125_mdio_read(tp, data->reg_num);
+                break;
+
+        case SIOCSMIIREG:
+                if (!capable(CAP_NET_ADMIN))
+                        return -EPERM;
+                rtl8125_mdio_write(tp, 0x1F, 0x0000);
+                rtl8125_mdio_write(tp, data->reg_num, data->val_in);
+                break;
+
+#ifdef ETHTOOL_OPS_COMPAT
+        case SIOCETHTOOL:
+                ret = ethtool_ioctl(ifr);
+                break;
+#endif
+
+#ifdef ENABLE_PTP_SUPPORT
+        case SIOCSHWTSTAMP:
+        case SIOCGHWTSTAMP:
+                if (tp->EnablePtp)
+                        ret = rtl8125_ptp_ioctl(dev, ifr, cmd);
+                else
+                        ret = -EOPNOTSUPP;
+                break;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+#ifdef ENABLE_DASH_SUPPORT
+        case SIOCDEVPRIVATE_RTLDASH:
+                if (!netif_running(dev)) {
+                        ret = -ENODEV;
+                        break;
+                }
+                if (!capable(CAP_NET_ADMIN)) {
+                        ret = -EPERM;
+                        break;
+                }
+
+                ret = rtl8125_dash_ioctl(dev, ifr);
+                break;
+#endif
+
+#ifdef ENABLE_REALWOW_SUPPORT
+        case SIOCDEVPRIVATE_RTLREALWOW:
+                if (!netif_running(dev)) {
+                        ret = -ENODEV;
+                        break;
+                }
+
+                if (!capable(CAP_NET_ADMIN)) {
+                        ret = -EPERM;
+                        break;
+                }
+
+                ret = rtl8125_realwow_ioctl(dev, ifr);
+                break;
+#endif
+
+        case SIOCRTLTOOL:
+                if (!capable(CAP_NET_ADMIN)) {
+                        ret = -EPERM;
+                        break;
+                }
+
+                ret = rtl8125_tool_ioctl(tp, ifr);
+                break;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+
+        default:
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        return ret;
+}
+
+static void
+rtl8125_phy_power_up(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long flags;
+
+        if (rtl8125_is_in_phy_disable_mode(dev))
+                return;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        rtl8125_mdio_write(tp, MII_BMCR, BMCR_ANENABLE);
+
+        //wait ups resume (phy state 3)
+        rtl8125_wait_phy_ups_resume(dev, 3);
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+}
+
+static void
+rtl8125_phy_power_down(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long flags;
+
+#ifdef ENABLE_FIBER_SUPPORT
+        if (HW_FIBER_MODE_ENABLED(tp))
+                return;
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        rtl8125_mdio_write(tp, MII_BMCR, BMCR_ANENABLE | BMCR_PDOWN);
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+}
+
+static int __devinit
+rtl8125_init_board(struct pci_dev *pdev,
+                   struct net_device **dev_out,
+                   void __iomem **ioaddr_out)
+{
+        void __iomem *ioaddr;
+        struct net_device *dev;
+        struct rtl8125_private *tp;
+        int rc = -ENOMEM, i, pm_cap;
+
+        assert(ioaddr_out != NULL);
+
+        /* dev zeroed in alloc_etherdev */
+        dev = alloc_etherdev_mq(sizeof (*tp), R8125_MAX_QUEUES);
+        if (dev == NULL) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_drv(&debug))
+                        dev_err(&pdev->dev, "unable to alloc new ethernet\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                goto err_out;
+        }
+
+        SET_MODULE_OWNER(dev);
+        SET_NETDEV_DEV(dev, &pdev->dev);
+        tp = netdev_priv(dev);
+        tp->dev = dev;
+        tp->pci_dev = pdev;
+        tp->msg_enable = netif_msg_init(debug.msg_enable, R8125_MSG_DEFAULT);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        if (!aspm)
+                pci_disable_link_state(pdev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |
+                                       PCIE_LINK_STATE_CLKPM);
+#endif
+
+        /* enable device (incl. PCI PM wakeup and hotplug setup) */
+        rc = pci_enable_device(pdev);
+        if (rc < 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "enable failure\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                goto err_out_free_dev;
+        }
+
+        if (pci_set_mwi(pdev) < 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_drv(&debug))
+                        dev_info(&pdev->dev, "Mem-Wr-Inval unavailable.\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        }
+
+        /* save power state before pci_enable_device overwrites it */
+        pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM);
+        if (pm_cap) {
+                u16 pwr_command;
+
+                pci_read_config_word(pdev, pm_cap + PCI_PM_CTRL, &pwr_command);
+        } else {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp)) {
+                        dev_err(&pdev->dev, "PowerManagement capability not found.\n");
+                }
+#else
+                printk("PowerManagement capability not found.\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+
+        }
+
+        /* make sure PCI base addr 1 is MMIO */
+        if (!(pci_resource_flags(pdev, 2) & IORESOURCE_MEM)) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "region #1 not an MMIO resource, aborting\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                rc = -ENODEV;
+                goto err_out_mwi;
+        }
+        /* check for weird/broken PCI region reporting */
+        if (pci_resource_len(pdev, 2) < R8125_REGS_SIZE) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "Invalid PCI region size(s), aborting\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                rc = -ENODEV;
+                goto err_out_mwi;
+        }
+
+        rc = pci_request_regions(pdev, MODULENAME);
+        if (rc < 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "could not request regions.\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                goto err_out_mwi;
+        }
+
+        if ((sizeof(dma_addr_t) > 4) &&
+            use_dac &&
+            !dma_set_mask(&pdev->dev, DMA_BIT_MASK(64)) &&
+            !dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64))) {
+                dev->features |= NETIF_F_HIGHDMA;
+        } else {
+                rc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
+                if (rc < 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                        if (netif_msg_probe(tp))
+                                dev_err(&pdev->dev, "DMA configuration failed.\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                        goto err_out_free_res;
+                }
+        }
+
+        /* ioremap MMIO region */
+        ioaddr = ioremap(pci_resource_start(pdev, 2), pci_resource_len(pdev, 2));
+        if (ioaddr == NULL) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "cannot remap MMIO, aborting\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                rc = -EIO;
+                goto err_out_free_res;
+        }
+
+        tp->mmio_addr = ioaddr;
+
+        /* Identify chip attached to board */
+        rtl8125_get_mac_version(tp);
+
+        rtl8125_print_mac_version(tp);
+
+        for (i = ARRAY_SIZE(rtl_chip_info) - 1; i >= 0; i--) {
+                if (tp->mcfg == rtl_chip_info[i].mcfg)
+                        break;
+        }
+
+        if (i < 0) {
+                /* Unknown chip: assume array element #0, original RTL-8125 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_printk(KERN_DEBUG, &pdev->dev, "unknown chip version, assuming %s\n", rtl_chip_info[0].name);
+#else
+                printk("Realtek unknown chip version, assuming %s\n", rtl_chip_info[0].name);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+                i++;
+        }
+
+        tp->chipset = i;
+
+        *ioaddr_out = ioaddr;
+        *dev_out = dev;
+out:
+        return rc;
+
+err_out_free_res:
+        pci_release_regions(pdev);
+err_out_mwi:
+        pci_clear_mwi(pdev);
+        pci_disable_device(pdev);
+err_out_free_dev:
+        free_netdev(dev);
+err_out:
+        *ioaddr_out = NULL;
+        *dev_out = NULL;
+        goto out;
+}
+
+static bool
+rtl8125_test_phy_ocp_v4(struct rtl8125_private *tp)
+{
+        bool restore = FALSE;
+        bool uc2_response;
+        u8 phy_fatal_err;
+        u16 val;
+
+        if (FALSE == HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                goto exit;
+
+        uc2_response = !!(rtl8125_mdio_direct_read_phy_ocp(tp, 0xB87A) & BIT_0);
+        phy_fatal_err = rtl8125_mdio_direct_read_phy_ocp(tp, 0xB98E);
+
+        if (!uc2_response && (phy_fatal_err == 0))
+                goto exit;
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xC418, BIT_0);
+        mdelay(24);
+
+        val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xC404);
+        if ((val & 0x03) != 0x00) {
+                u32 wait_cnt = 0;
+
+                while ((val & 0x03) != 0x00 && wait_cnt < 5) {
+                        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC02, 0x000C);
+                        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC04, 0x03FC);
+                        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC4C, 0x1F00);
+                        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC06, 0x7F00);
+
+                        rtl8125_set_eth_phy_ocp_bit(tp, 0xC402, BIT_10);
+                        rtl8125_clear_eth_phy_ocp_bit(tp, 0xC402, BIT_10);
+
+                        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBC06, 0x7F00);
+                        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBC4C, 0x1F00);
+                        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBC04, 0x03FC);
+                        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBC02, 0x000C);
+
+                        mdelay(100);
+                        val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xC404);
+                        wait_cnt++;
+                }
+        }
+
+        rtl8125_restore_phy_fuse_dout(tp);
+
+        rtl8125_wait_phy_state_ready(tp, HW_PHY_STATUS_INI, 5000000);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA468, BIT_0);
+
+        rtl8125_wait_phy_state_ready(tp, HW_PHY_STATUS_LAN_ON, 500000);
+
+        if (phy_fatal_err) {
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x801C);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, phy_fatal_err);
+        }
+        if (uc2_response) {
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x801B);
+                rtl8125_set_eth_phy_ocp_bit(tp, 0xA438, BIT_8);
+        }
+
+        rtl8125_restore_led_select(tp);
+
+        tp->HwHasWrRamCodeToMicroP = FALSE;
+
+        restore = TRUE;
+
+exit:
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xB87A, BIT_0);
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+
+        return restore;
+}
+
+static bool
+rtl8125_test_phy_ocp_v5(struct rtl8125_private *tp)
+{
+        bool restore = FALSE;
+        u8 phy_fatal_err;
+        u16 val;
+
+        if (FALSE == HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                goto exit;
+
+        phy_fatal_err = rtl8125_mdio_direct_read_phy_ocp(tp, 0xB98C);
+
+        if (phy_fatal_err == 0)
+                goto exit;
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xC418, BIT_0);
+        mdelay(24);
+
+        val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xC404);
+        if (val & 0x0F) {
+                u32 wait_cnt = 0;
+
+                while (val & 0x0F && wait_cnt < 5) {
+                        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC02, 0x000C);
+                        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC04, 0x03FC);
+                        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC4C, 0x1F00);
+                        rtl8125_set_eth_phy_ocp_bit(tp, 0xBC06, 0x4F00);
+                        rtl8125_clear_and_set_eth_phy_ocp_bit(tp,
+                                                              0xBC06,
+                                                              0x7F00,
+                                                              0x4F00);
+
+                        rtl8125_set_eth_phy_ocp_bit(tp, 0xC402, BIT_10);
+                        rtl8125_clear_eth_phy_ocp_bit(tp, 0xC402, BIT_10);
+
+                        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBC06, 0x7F00);
+                        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBC4C, 0x1F00);
+                        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBC04, 0x03FC);
+                        rtl8125_clear_eth_phy_ocp_bit(tp, 0xBC02, 0x000C);
+
+                        mdelay(100);
+                        val = rtl8125_mdio_direct_read_phy_ocp(tp, 0xC404);
+                        wait_cnt++;
+                }
+        }
+
+        rtl8125_restore_phy_fuse_dout(tp);
+
+        rtl8125_wait_phy_state_ready(tp, HW_PHY_STATUS_INI, 5000000);
+
+        if (tp->mcfg == CFG_METHOD_10)
+                rtl8125_set_phy_mcu_8125d_1_efuse(tp->dev);
+
+        rtl8125_set_eth_phy_ocp_bit(tp, 0xA468, BIT_0);
+
+        rtl8125_clear_phy_ups_reg(tp->dev);
+
+        rtl8125_wait_phy_state_ready(tp, HW_PHY_STATUS_LAN_ON, 500000);
+
+        if (phy_fatal_err) {
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA436, 0x801C);
+                rtl8125_mdio_direct_write_phy_ocp(tp, 0xA438, phy_fatal_err);
+        }
+
+        rtl8125_restore_led_select(tp);
+
+        tp->HwHasWrRamCodeToMicroP = FALSE;
+
+        restore = TRUE;
+
+exit:
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+
+        return restore;
+}
+
+static bool
+rtl8125_test_phy_ocp(struct rtl8125_private *tp)
+{
+        unsigned long flags;
+        bool reset = false;
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        if (tp->TestPhyOcpReg == FALSE)
+                goto unlock;
+
+        switch (tp->HwSuppEsdVer) {
+        case 4:
+                reset = rtl8125_test_phy_ocp_v4(tp);
+                break;
+        case 5:
+                reset = rtl8125_test_phy_ocp_v5(tp);
+                break;
+        default:
+                goto unlock;
+        }
+
+unlock:
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        return reset;
+}
+
+static void
+rtl8125_esd_checker(struct rtl8125_private *tp)
+{
+        struct net_device *dev = tp->dev;
+        struct pci_dev *pdev = tp->pci_dev;
+        u8 cmd;
+        u16 io_base_l;
+        u16 mem_base_l;
+        u16 mem_base_h;
+        u8 ilr;
+        u16 resv_0x1c_h;
+        u16 resv_0x1c_l;
+        u16 resv_0x20_l;
+        u16 resv_0x20_h;
+        u16 resv_0x24_l;
+        u16 resv_0x24_h;
+        u16 resv_0x2c_h;
+        u16 resv_0x2c_l;
+        u32 pci_sn_l;
+        u32 pci_sn_h;
+
+        if (unlikely(tp->rtk_enable_diag))
+                goto exit;
+
+        tp->esd_flag = 0;
+
+        pci_read_config_byte(pdev, PCI_COMMAND, &cmd);
+        if (cmd != tp->pci_cfg_space.cmd) {
+                printk(KERN_ERR "%s: cmd = 0x%02x, should be 0x%02x \n.", dev->name, cmd, tp->pci_cfg_space.cmd);
+                pci_write_config_byte(pdev, PCI_COMMAND, tp->pci_cfg_space.cmd);
+                tp->esd_flag |= BIT_0;
+
+                pci_read_config_byte(pdev, PCI_COMMAND, &cmd);
+                if (cmd == 0xff) {
+                        printk(KERN_ERR "%s: pci link is down \n.", dev->name);
+                        goto exit;
+                }
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_0, &io_base_l);
+        if (io_base_l != tp->pci_cfg_space.io_base_l) {
+                printk(KERN_ERR "%s: io_base_l = 0x%04x, should be 0x%04x \n.", dev->name, io_base_l, tp->pci_cfg_space.io_base_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_0, tp->pci_cfg_space.io_base_l);
+                tp->esd_flag |= BIT_1;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_2, &mem_base_l);
+        if (mem_base_l != tp->pci_cfg_space.mem_base_l) {
+                printk(KERN_ERR "%s: mem_base_l = 0x%04x, should be 0x%04x \n.", dev->name, mem_base_l, tp->pci_cfg_space.mem_base_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_2, tp->pci_cfg_space.mem_base_l);
+                tp->esd_flag |= BIT_2;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_2 + 2, &mem_base_h);
+        if (mem_base_h!= tp->pci_cfg_space.mem_base_h) {
+                printk(KERN_ERR "%s: mem_base_h = 0x%04x, should be 0x%04x \n.", dev->name, mem_base_h, tp->pci_cfg_space.mem_base_h);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_2 + 2, tp->pci_cfg_space.mem_base_h);
+                tp->esd_flag |= BIT_3;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_3, &resv_0x1c_l);
+        if (resv_0x1c_l != tp->pci_cfg_space.resv_0x1c_l) {
+                printk(KERN_ERR "%s: resv_0x1c_l = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x1c_l, tp->pci_cfg_space.resv_0x1c_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_3, tp->pci_cfg_space.resv_0x1c_l);
+                tp->esd_flag |= BIT_4;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_3 + 2, &resv_0x1c_h);
+        if (resv_0x1c_h != tp->pci_cfg_space.resv_0x1c_h) {
+                printk(KERN_ERR "%s: resv_0x1c_h = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x1c_h, tp->pci_cfg_space.resv_0x1c_h);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_3 + 2, tp->pci_cfg_space.resv_0x1c_h);
+                tp->esd_flag |= BIT_5;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_4, &resv_0x20_l);
+        if (resv_0x20_l != tp->pci_cfg_space.resv_0x20_l) {
+                printk(KERN_ERR "%s: resv_0x20_l = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x20_l, tp->pci_cfg_space.resv_0x20_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_4, tp->pci_cfg_space.resv_0x20_l);
+                tp->esd_flag |= BIT_6;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_4 + 2, &resv_0x20_h);
+        if (resv_0x20_h != tp->pci_cfg_space.resv_0x20_h) {
+                printk(KERN_ERR "%s: resv_0x20_h = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x20_h, tp->pci_cfg_space.resv_0x20_h);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_4 + 2, tp->pci_cfg_space.resv_0x20_h);
+                tp->esd_flag |= BIT_7;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_5, &resv_0x24_l);
+        if (resv_0x24_l != tp->pci_cfg_space.resv_0x24_l) {
+                printk(KERN_ERR "%s: resv_0x24_l = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x24_l, tp->pci_cfg_space.resv_0x24_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_5, tp->pci_cfg_space.resv_0x24_l);
+                tp->esd_flag |= BIT_8;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_5 + 2, &resv_0x24_h);
+        if (resv_0x24_h != tp->pci_cfg_space.resv_0x24_h) {
+                printk(KERN_ERR "%s: resv_0x24_h = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x24_h, tp->pci_cfg_space.resv_0x24_h);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_5 + 2, tp->pci_cfg_space.resv_0x24_h);
+                tp->esd_flag |= BIT_9;
+        }
+
+        pci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &ilr);
+        if (ilr != tp->pci_cfg_space.ilr) {
+                printk(KERN_ERR "%s: ilr = 0x%02x, should be 0x%02x \n.", dev->name, ilr, tp->pci_cfg_space.ilr);
+                pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, tp->pci_cfg_space.ilr);
+                tp->esd_flag |= BIT_10;
+        }
+
+        pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &resv_0x2c_l);
+        if (resv_0x2c_l != tp->pci_cfg_space.resv_0x2c_l) {
+                printk(KERN_ERR "%s: resv_0x2c_l = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x2c_l, tp->pci_cfg_space.resv_0x2c_l);
+                pci_write_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, tp->pci_cfg_space.resv_0x2c_l);
+                tp->esd_flag |= BIT_11;
+        }
+
+        pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID + 2, &resv_0x2c_h);
+        if (resv_0x2c_h != tp->pci_cfg_space.resv_0x2c_h) {
+                printk(KERN_ERR "%s: resv_0x2c_h = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x2c_h, tp->pci_cfg_space.resv_0x2c_h);
+                pci_write_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID + 2, tp->pci_cfg_space.resv_0x2c_h);
+                tp->esd_flag |= BIT_12;
+        }
+
+        if (tp->HwPcieSNOffset > 0) {
+                pci_sn_l = rtl8125_csi_read(tp, tp->HwPcieSNOffset);
+                if (pci_sn_l != tp->pci_cfg_space.pci_sn_l) {
+                        printk(KERN_ERR "%s: pci_sn_l = 0x%08x, should be 0x%08x \n.", dev->name, pci_sn_l, tp->pci_cfg_space.pci_sn_l);
+                        rtl8125_csi_write(tp, tp->HwPcieSNOffset, tp->pci_cfg_space.pci_sn_l);
+                        tp->esd_flag |= BIT_13;
+                }
+
+                pci_sn_h = rtl8125_csi_read(tp, tp->HwPcieSNOffset + 4);
+                if (pci_sn_h != tp->pci_cfg_space.pci_sn_h) {
+                        printk(KERN_ERR "%s: pci_sn_h = 0x%08x, should be 0x%08x \n.", dev->name, pci_sn_h, tp->pci_cfg_space.pci_sn_h);
+                        rtl8125_csi_write(tp, tp->HwPcieSNOffset + 4, tp->pci_cfg_space.pci_sn_h);
+                        tp->esd_flag |= BIT_14;
+                }
+        }
+
+        if (tp->TestPhyOcpReg && rtl8125_test_phy_ocp(tp))
+                tp->esd_flag |= BIT_15;
+
+        if (tp->esd_flag != 0) {
+                printk(KERN_ERR "%s: esd_flag = 0x%04x\n.\n", dev->name, tp->esd_flag);
+                netif_carrier_off(dev);
+                netif_tx_disable(dev);
+                rtl8125_hw_reset(dev);
+                rtl8125_tx_clear(tp);
+                rtl8125_rx_clear(tp);
+                rtl8125_init_ring(dev);
+                rtl8125_up(dev);
+                rtl8125_enable_hw_linkchg_interrupt(tp);
+                rtl8125_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+                tp->esd_flag = 0;
+        }
+exit:
+        return;
+}
+/*
+static void
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+rtl8125_esd_timer(unsigned long __opaque)
+#else
+rtl8125_esd_timer(struct timer_list *t)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+        struct net_device *dev = (struct net_device *)__opaque;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct timer_list *timer = &tp->esd_timer;
+#else
+        struct rtl8125_private *tp = from_timer(tp, t, esd_timer);
+        //struct net_device *dev = tp->dev;
+        struct timer_list *timer = t;
+#endif
+        rtl8125_esd_checker(tp);
+
+        mod_timer(timer, jiffies + timeout);
+}
+*/
+
+/*
+static void
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+rtl8125_link_timer(unsigned long __opaque)
+#else
+rtl8125_link_timer(struct timer_list *t)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+        struct net_device *dev = (struct net_device *)__opaque;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct timer_list *timer = &tp->link_timer;
+#else
+        struct rtl8125_private *tp = from_timer(tp, t, link_timer);
+        struct net_device *dev = tp->dev;
+        struct timer_list *timer = t;
+#endif
+        rtl8125_check_link_status(dev);
+
+        mod_timer(timer, jiffies + RTL8125_LINK_TIMEOUT);
+}
+*/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
+static int pci_enable_msix_range(struct pci_dev *dev, struct msix_entry *entries,
+                                 int minvec, int maxvec)
+{
+        int nvec = maxvec;
+        int rc;
+
+        if (maxvec < minvec)
+                return -ERANGE;
+
+        do {
+                rc = pci_enable_msix(dev, entries, nvec);
+                if (rc < 0) {
+                        return rc;
+                } else if (rc > 0) {
+                        if (rc < minvec)
+                                return -ENOSPC;
+                        nvec = rc;
+                }
+        } while (rc);
+
+        return nvec;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0) */
+
+static int rtl8125_enable_msix(struct rtl8125_private *tp)
+{
+        int i, nvecs = 0;
+        struct msix_entry msix_ent[R8125_MAX_MSIX_VEC];
+        //struct net_device *dev = tp->dev;
+        //const int len = sizeof(tp->irq_tbl[0].name);
+
+        for (i = 0; i < R8125_MAX_MSIX_VEC; i++) {
+                msix_ent[i].entry = i;
+                msix_ent[i].vector = 0;
+        }
+
+        nvecs = pci_enable_msix_range(tp->pci_dev, msix_ent,
+                                      tp->min_irq_nvecs, tp->max_irq_nvecs);
+        if (nvecs < 0)
+                goto out;
+
+        for (i = 0; i < nvecs; i++) {
+                struct r8125_irq *irq = &tp->irq_tbl[i];
+                irq->vector = msix_ent[i].vector;
+                //snprintf(irq->name, len, "%s-%d", dev->name, i);
+                //irq->handler = rtl8125_interrupt_msix;
+        }
+
+out:
+        return nvecs;
+}
+
+/* Cfg9346_Unlock assumed. */
+static int rtl8125_try_msi(struct rtl8125_private *tp)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+        unsigned int hw_supp_irq_nvecs;
+        unsigned msi = 0;
+        int nvecs = 1;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+                hw_supp_irq_nvecs = R8125_MAX_MSIX_VEC_8125A;
+                break;
+        case CFG_METHOD_4 ... CFG_METHOD_7:
+                hw_supp_irq_nvecs = R8125_MAX_MSIX_VEC_8125B;
+                break;
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                hw_supp_irq_nvecs = R8125_MAX_MSIX_VEC_8125D;
+                break;
+        default:
+                hw_supp_irq_nvecs = 1;
+                break;
+        }
+        tp->hw_supp_irq_nvecs = clamp_val(hw_supp_irq_nvecs, 1,
+                                          R8125_MAX_MSIX_VEC);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                tp->max_irq_nvecs = tp->hw_supp_irq_nvecs;
+                tp->min_irq_nvecs = R8125_MIN_MSIX_VEC_8125B;
+                break;
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+                tp->max_irq_nvecs = tp->hw_supp_irq_nvecs;
+                tp->min_irq_nvecs = R8125_MIN_MSIX_VEC_8125BP;
+                break;
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_13:
+                tp->max_irq_nvecs = tp->hw_supp_irq_nvecs;
+                tp->min_irq_nvecs = R8125_MIN_MSIX_VEC_8125D;
+                break;
+        case CFG_METHOD_12:
+                tp->max_irq_nvecs = tp->hw_supp_irq_nvecs;
+                tp->min_irq_nvecs = R8125_MIN_MSIX_VEC_8125CP;
+                break;
+        default:
+                tp->max_irq_nvecs = 1;
+                tp->min_irq_nvecs = 1;
+                break;
+        }
+#ifdef DISABLE_MULTI_MSIX_VECTOR
+        tp->max_irq_nvecs = 1;
+#endif
+
+#if defined(RTL_USE_NEW_INTR_API)
+        if ((nvecs = pci_alloc_irq_vectors(pdev, tp->min_irq_nvecs, tp->max_irq_nvecs, PCI_IRQ_MSIX)) > 0)
+                msi |= RTL_FEATURE_MSIX;
+        else if ((nvecs = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES)) > 0 &&
+                 pci_dev_msi_enabled(pdev))
+                msi |= RTL_FEATURE_MSI;
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+        if ((nvecs = rtl8125_enable_msix(tp)) > 0)
+                msi |= RTL_FEATURE_MSIX;
+        else if (!pci_enable_msi(pdev))
+                msi |= RTL_FEATURE_MSI;
+#endif
+        if (!(msi & (RTL_FEATURE_MSI | RTL_FEATURE_MSIX)))
+                dev_info(&pdev->dev, "no MSI/MSI-X. Back to INTx.\n");
+
+        if (!(msi & RTL_FEATURE_MSIX) || nvecs < 1)
+                nvecs = 1;
+
+        tp->irq_nvecs = nvecs;
+
+        tp->features |= msi;
+
+        return nvecs;
+}
+
+static void rtl8125_disable_msi(struct pci_dev *pdev, struct rtl8125_private *tp)
+{
+#if defined(RTL_USE_NEW_INTR_API)
+        if (tp->features & (RTL_FEATURE_MSI | RTL_FEATURE_MSIX))
+                pci_free_irq_vectors(pdev);
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+        if (tp->features & (RTL_FEATURE_MSIX))
+                pci_disable_msix(pdev);
+        else if (tp->features & (RTL_FEATURE_MSI))
+                pci_disable_msi(pdev);
+#endif
+        tp->features &= ~(RTL_FEATURE_MSI | RTL_FEATURE_MSIX);
+}
+
+static int rtl8125_get_irq(struct pci_dev *pdev)
+{
+#if defined(RTL_USE_NEW_INTR_API)
+        return pci_irq_vector(pdev, 0);
+#else
+        return pdev->irq;
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+static void
+rtl8125_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct rtl8125_counters *counters = tp->tally_vaddr;
+        dma_addr_t paddr = tp->tally_paddr;
+
+        if (!counters)
+                return;
+
+        netdev_stats_to_stats64(stats, &dev->stats);
+        dev_fetch_sw_netstats(stats, dev->tstats);
+
+        /*
+         * Fetch additional counter values missing in stats collected by driver
+         * from tally counters.
+         */
+        rtl8125_dump_tally_counter(tp, paddr);
+
+        stats->tx_errors = le64_to_cpu(counters->tx_errors);
+        stats->collisions = le32_to_cpu(counters->tx_multi_collision);
+        stats->tx_aborted_errors = le16_to_cpu(counters->tx_aborted);
+        stats->rx_missed_errors = le16_to_cpu(counters->rx_missed);
+}
+#else
+/**
+ *  rtl8125_get_stats - Get rtl8125 read/write statistics
+ *  @dev: The Ethernet Device to get statistics for
+ *
+ *  Get TX/RX statistics for rtl8125
+ */
+static struct
+net_device_stats *rtl8125_get_stats(struct net_device *dev)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+        struct rtl8125_private *tp = netdev_priv(dev);
+#endif
+        return &RTLDEV->stats;
+}
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+static const struct net_device_ops rtl8125_netdev_ops = {
+        .ndo_open       = rtl8125_open,
+        .ndo_stop       = rtl8125_close,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+        .ndo_get_stats64    = rtl8125_get_stats64,
+#else
+        .ndo_get_stats      = rtl8125_get_stats,
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+        .ndo_start_xmit     = rtl8125_start_xmit,
+        .ndo_tx_timeout     = rtl8125_tx_timeout,
+        .ndo_change_mtu     = rtl8125_change_mtu,
+        .ndo_set_mac_address    = rtl8125_set_mac_address,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+        .ndo_do_ioctl       = rtl8125_do_ioctl,
+#else
+        .ndo_siocdevprivate = rtl8125_siocdevprivate,
+        .ndo_eth_ioctl      = rtl8125_do_ioctl,
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0)
+        .ndo_set_multicast_list = rtl8125_set_rx_mode,
+#else
+        .ndo_set_rx_mode    = rtl8125_set_rx_mode,
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+#ifdef CONFIG_R8125_VLAN
+        .ndo_vlan_rx_register   = rtl8125_vlan_rx_register,
+#endif
+#else
+        .ndo_fix_features   = rtl8125_fix_features,
+        .ndo_set_features   = rtl8125_set_features,
+#endif
+#ifdef CONFIG_NET_POLL_CONTROLLER
+        .ndo_poll_controller    = rtl8125_netpoll,
+#endif
+};
+#endif
+
+
+#ifdef  CONFIG_R8125_NAPI
+
+static int rtl8125_poll(napi_ptr napi, napi_budget budget)
+{
+        struct r8125_napi *r8125napi = RTL_GET_PRIV(napi, struct r8125_napi);
+        struct rtl8125_private *tp = r8125napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        unsigned int work_done = 0;
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++)
+                rtl8125_tx_interrupt(&tp->tx_ring[i], budget);
+
+        for (i = 0; i < tp->num_rx_rings; i++)
+                work_done += rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[i], budget);
+
+        work_done = min(work_done, work_to_do);
+
+        RTL_NAPI_QUOTA_UPDATE(dev, work_done, budget);
+
+        if (work_done < work_to_do) {
+#ifdef ENABLE_DASH_SUPPORT
+                if (rtl8125_check_dash_interrupt(tp))
+                        rtl8125_schedule_dash_work(tp);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+                if (RTL_NETIF_RX_COMPLETE(dev, napi, work_done) == FALSE)
+                        return RTL_NAPI_RETURN_VALUE;
+#else
+                RTL_NETIF_RX_COMPLETE(dev, napi, work_done);
+#endif
+                /*
+                 * 20040426: the barrier is not strictly required but the
+                 * behavior of the irq handler could be less predictable
+                 * without it. Btw, the lack of flush for the posted pci
+                 * write is safe - FR
+                 */
+                smp_wmb();
+
+                rtl8125_switch_to_timer_interrupt(tp);
+        }
+
+        return RTL_NAPI_RETURN_VALUE;
+}
+
+static int rtl8125_poll_msix_ring(napi_ptr napi, napi_budget budget)
+{
+        struct r8125_napi *r8125napi = RTL_GET_PRIV(napi, struct r8125_napi);
+        struct rtl8125_private *tp = r8125napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        unsigned int work_done = 0;
+        const int message_id = r8125napi->index;
+
+        if (message_id < tp->num_tx_rings)
+                rtl8125_tx_interrupt_with_vector(tp, message_id, budget);
+
+        if (message_id < tp->num_rx_rings)
+                work_done += rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[message_id], budget);
+
+        RTL_NAPI_QUOTA_UPDATE(dev, work_done, budget);
+
+        if (work_done < work_to_do) {
+#ifdef ENABLE_DASH_SUPPORT
+                if (message_id == 31)
+                        if (rtl8125_check_dash_interrupt(tp))
+                                rtl8125_schedule_dash_work(tp);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+                if (RTL_NETIF_RX_COMPLETE(dev, napi, work_done) == FALSE)
+                        return RTL_NAPI_RETURN_VALUE;
+#else
+                RTL_NETIF_RX_COMPLETE(dev, napi, work_done);
+#endif
+                /*
+                 * 20040426: the barrier is not strictly required but the
+                 * behavior of the irq handler could be less predictable
+                 * without it. Btw, the lack of flush for the posted pci
+                 * write is safe - FR
+                 */
+                smp_wmb();
+
+                rtl8125_enable_hw_interrupt_v2(tp, message_id);
+        }
+
+        return RTL_NAPI_RETURN_VALUE;
+}
+
+static int rtl8125_poll_msix_tx(napi_ptr napi, napi_budget budget)
+{
+        struct r8125_napi *r8125napi = RTL_GET_PRIV(napi, struct r8125_napi);
+        struct rtl8125_private *tp = r8125napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        unsigned int work_done = 0;
+        const int message_id = r8125napi->index;
+
+        //suppress unused variable
+        (void)(dev);
+
+        rtl8125_tx_interrupt_with_vector(tp, message_id, budget);
+
+        RTL_NAPI_QUOTA_UPDATE(dev, work_done, budget);
+
+        if (work_done < work_to_do) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+                if (RTL_NETIF_RX_COMPLETE(dev, napi, work_done) == FALSE)
+                        return RTL_NAPI_RETURN_VALUE;
+#else
+                RTL_NETIF_RX_COMPLETE(dev, napi, work_done);
+#endif
+                /*
+                 * 20040426: the barrier is not strictly required but the
+                 * behavior of the irq handler could be less predictable
+                 * without it. Btw, the lack of flush for the posted pci
+                 * write is safe - FR
+                 */
+                smp_wmb();
+
+                rtl8125_enable_hw_interrupt_v2(tp, message_id);
+        }
+
+        return RTL_NAPI_RETURN_VALUE;
+}
+
+static int rtl8125_poll_msix_other(napi_ptr napi, napi_budget budget)
+{
+        struct r8125_napi *r8125napi = RTL_GET_PRIV(napi, struct r8125_napi);
+        struct rtl8125_private *tp = r8125napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        const int message_id = r8125napi->index;
+
+        //suppress unused variable
+        (void)(dev);
+        (void)(work_to_do);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+        RTL_NETIF_RX_COMPLETE(dev, napi, work_to_do);
+#else
+        RTL_NETIF_RX_COMPLETE(dev, napi, work_to_do);
+#endif
+
+        rtl8125_enable_hw_interrupt_v2(tp, message_id);
+
+        return 1;
+}
+
+static int rtl8125_poll_msix_rx(napi_ptr napi, napi_budget budget)
+{
+        struct r8125_napi *r8125napi = RTL_GET_PRIV(napi, struct r8125_napi);
+        struct rtl8125_private *tp = r8125napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        unsigned int work_done = 0;
+        const int message_id = r8125napi->index;
+
+        if (message_id < tp->num_rx_rings)
+                work_done += rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[message_id], budget);
+
+        RTL_NAPI_QUOTA_UPDATE(dev, work_done, budget);
+
+        if (work_done < work_to_do) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+                if (RTL_NETIF_RX_COMPLETE(dev, napi, work_done) == FALSE)
+                        return RTL_NAPI_RETURN_VALUE;
+#else
+                RTL_NETIF_RX_COMPLETE(dev, napi, work_done);
+#endif
+                /*
+                 * 20040426: the barrier is not strictly required but the
+                 * behavior of the irq handler could be less predictable
+                 * without it. Btw, the lack of flush for the posted pci
+                 * write is safe - FR
+                 */
+                smp_wmb();
+
+                rtl8125_enable_hw_interrupt_v2(tp, message_id);
+        }
+
+        return RTL_NAPI_RETURN_VALUE;
+}
+
+void rtl8125_enable_napi(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        int i;
+
+        for (i = 0; i < tp->irq_nvecs; i++)
+                RTL_NAPI_ENABLE(tp->dev, &tp->r8125napi[i].napi);
+#endif
+}
+
+static void rtl8125_disable_napi(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        int i;
+
+        for (i = 0; i < tp->irq_nvecs; i++)
+                RTL_NAPI_DISABLE(tp->dev, &tp->r8125napi[i].napi);
+#endif
+}
+
+static void rtl8125_del_napi(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        int i;
+
+        for (i = 0; i < tp->irq_nvecs; i++)
+                RTL_NAPI_DEL((&tp->r8125napi[i]));
+#endif
+}
+#endif //CONFIG_R8125_NAPI
+
+static void rtl8125_init_napi(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i=0; i<tp->irq_nvecs; i++) {
+                struct r8125_napi *r8125napi = &tp->r8125napi[i];
+#ifdef CONFIG_R8125_NAPI
+                int (*poll)(struct napi_struct *, int);
+
+                poll = rtl8125_poll;
+                if (tp->features & RTL_FEATURE_MSIX) {
+                        switch (tp->HwCurrIsrVer) {
+                        case 7:
+                                if (i < R8125_MAX_RX_QUEUES_VEC_V3)
+                                        poll = rtl8125_poll_msix_rx;
+                                else if (i == 27 || i == 28)
+                                        poll = rtl8125_poll_msix_tx;
+                                else
+                                        poll = rtl8125_poll_msix_other;
+                                break;
+                        case 5:
+                                if (i < R8125_MAX_RX_QUEUES_VEC_V3)
+                                        poll = rtl8125_poll_msix_rx;
+                                else if (i == 16 || i == 17)
+                                        poll = rtl8125_poll_msix_tx;
+                                else
+                                        poll = rtl8125_poll_msix_other;
+                                break;
+                        case 2:
+                                if (i < R8125_MAX_RX_QUEUES_VEC_V3)
+                                        poll = rtl8125_poll_msix_rx;
+                                else if (i == 16 || i == 18)
+                                        poll = rtl8125_poll_msix_tx;
+                                else
+                                        poll = rtl8125_poll_msix_other;
+                                break;
+                        case 3:
+                        case 4:
+                                if (i < R8125_MAX_RX_QUEUES_VEC_V3)
+                                        poll = rtl8125_poll_msix_ring;
+                                else
+                                        poll = rtl8125_poll_msix_other;
+                                break;
+                        }
+                }
+
+                RTL_NAPI_CONFIG(tp->dev, r8125napi, poll, R8125_NAPI_WEIGHT);
+#endif
+
+                r8125napi->priv = tp;
+                r8125napi->index = i;
+        }
+}
+
+static int
+rtl8125_set_real_num_queue(struct rtl8125_private *tp)
+{
+        int retval = 0;
+
+        retval = netif_set_real_num_tx_queues(tp->dev, tp->num_tx_rings);
+        if (retval < 0)
+                goto exit;
+
+        retval = netif_set_real_num_rx_queues(tp->dev, tp->num_rx_rings);
+        if (retval < 0)
+                goto exit;
+
+exit:
+        return retval;
+}
+
+static int __devinit
+rtl8125_init_one(struct pci_dev *pdev,
+                 const struct pci_device_id *ent)
+{
+        struct net_device *dev = NULL;
+        struct rtl8125_private *tp;
+        void __iomem *ioaddr = NULL;
+        static int board_idx = -1;
+
+        int rc;
+
+        assert(pdev != NULL);
+        assert(ent != NULL);
+
+        board_idx++;
+
+        if (netif_msg_drv(&debug))
+                printk(KERN_INFO "%s Ethernet controller driver %s loaded\n",
+                       MODULENAME, RTL8125_VERSION);
+
+        rc = rtl8125_init_board(pdev, &dev, &ioaddr);
+        if (rc)
+                goto out;
+
+        tp = netdev_priv(dev);
+        assert(ioaddr != NULL);
+
+        spin_lock_init(&tp->phy_lock);
+
+        tp->set_speed = rtl8125_set_speed_xmii;
+        tp->get_settings = rtl8125_gset_xmii;
+        tp->phy_reset_enable = rtl8125_xmii_reset_enable;
+        tp->phy_reset_pending = rtl8125_xmii_reset_pending;
+        tp->link_ok = rtl8125_xmii_link_ok;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+        dev->tstats = devm_netdev_alloc_pcpu_stats(&pdev->dev,
+                        struct pcpu_sw_netstats);
+        if (!dev->tstats)
+                goto err_out_1;
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+
+        rc = rtl8125_try_msi(tp);
+        if (rc < 0) {
+                dev_err(&pdev->dev, "Can't allocate interrupt\n");
+                goto err_out_1;
+        }
+
+        rtl8125_init_software_variable(dev);
+
+        RTL_NET_DEVICE_OPS(rtl8125_netdev_ops);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+        SET_ETHTOOL_OPS(dev, &rtl8125_ethtool_ops);
+#endif
+
+        dev->watchdog_timeo = RTL8125_TX_TIMEOUT;
+        dev->irq = rtl8125_get_irq(pdev);
+        dev->base_addr = (unsigned long) ioaddr;
+
+        rtl8125_init_napi(tp);
+
+#ifdef CONFIG_R8125_VLAN
+        if (tp->mcfg != CFG_METHOD_DEFAULT) {
+                dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+                dev->vlan_rx_kill_vid = rtl8125_vlan_rx_kill_vid;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+        }
+#endif
+
+        /* There has been a number of reports that using SG/TSO results in
+         * tx timeouts. However for a lot of people SG/TSO works fine.
+         * Therefore disable both features by default, but allow users to
+         * enable them. Use at own risk!
+         */
+        tp->cp_cmd |= RTL_R16(tp, CPlusCmd);
+        if (tp->mcfg != CFG_METHOD_DEFAULT) {
+                dev->features |= NETIF_F_IP_CSUM;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+                tp->cp_cmd |= RxChkSum;
+#else
+                dev->features |= NETIF_F_RXCSUM;
+                switch (tp->mcfg) {
+                case CFG_METHOD_2:
+                case CFG_METHOD_3:
+                case CFG_METHOD_6:
+                        /* nothing to do */
+                        break;
+                default:
+                        dev->features |= NETIF_F_SG | NETIF_F_TSO;
+                        break;
+                };
+                dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
+                                   NETIF_F_RXCSUM | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
+                dev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
+                                     NETIF_F_HIGHDMA;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
+                dev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
+                dev->hw_features |= NETIF_F_RXALL;
+                dev->hw_features |= NETIF_F_RXFCS;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+                dev->hw_features |= NETIF_F_IPV6_CSUM | NETIF_F_TSO6;
+                dev->features |= NETIF_F_IPV6_CSUM;
+                switch (tp->mcfg) {
+                case CFG_METHOD_2:
+                case CFG_METHOD_3:
+                case CFG_METHOD_6:
+                        /* nothing to do */
+                        break;
+                default:
+                        dev->features |= NETIF_F_TSO6;
+                        break;
+                };
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,19,0)
+                netif_set_tso_max_size(dev, LSO_64K);
+                netif_set_tso_max_segs(dev, NIC_MAX_PHYS_BUF_COUNT_LSO2);
+#else //LINUX_VERSION_CODE >= KERNEL_VERSION(5,19,0)
+                netif_set_gso_max_size(dev, LSO_64K);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
+                dev->gso_max_segs = NIC_MAX_PHYS_BUF_COUNT_LSO2;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+                dev->gso_min_segs = NIC_MIN_PHYS_BUF_COUNT;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,19,0)
+
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+#ifdef ENABLE_RSS_SUPPORT
+                if (tp->EnableRss) {
+                        dev->hw_features |= NETIF_F_RXHASH;
+                        dev->features |= NETIF_F_RXHASH;
+                }
+#endif
+        }
+
+        netdev_sw_irq_coalesce_default_on(dev);
+
+#ifdef ENABLE_LIB_SUPPORT
+        BLOCKING_INIT_NOTIFIER_HEAD(&tp->lib_nh);
+#endif
+        rtl8125_init_all_schedule_work(tp);
+
+        rc = rtl8125_set_real_num_queue(tp);
+        if (rc < 0)
+                goto err_out;
+
+        rtl8125_exit_oob(dev);
+
+        rtl8125_powerup_pll(dev);
+
+        rtl8125_hw_init(dev);
+
+        rtl8125_hw_reset(dev);
+
+        /* Get production from EEPROM */
+        rtl8125_eeprom_type(tp);
+
+        if (tp->eeprom_type == EEPROM_TYPE_93C46 || tp->eeprom_type == EEPROM_TYPE_93C56)
+                rtl8125_set_eeprom_sel_low(tp);
+
+        rtl8125_get_mac_address(dev);
+
+        tp->fw_name = rtl_chip_fw_infos[tp->mcfg].fw_name;
+
+        tp->tally_vaddr = dma_alloc_coherent(&pdev->dev, sizeof(*tp->tally_vaddr),
+                                             &tp->tally_paddr, GFP_KERNEL);
+        if (!tp->tally_vaddr) {
+                rc = -ENOMEM;
+                goto err_out;
+        }
+
+        rtl8125_tally_counter_clear(tp);
+
+        pci_set_drvdata(pdev, dev);
+
+        rc = register_netdev(dev);
+        if (rc)
+                goto err_out;
+
+        printk(KERN_INFO "%s: This product is covered by one or more of the following patents: US6,570,884, US6,115,776, and US6,327,625.\n", MODULENAME);
+
+        rtl8125_disable_rxdvgate(dev);
+
+        device_set_wakeup_enable(&pdev->dev, tp->wol_enabled);
+
+        netif_carrier_off(dev);
+
+#ifdef ENABLE_R8125_SYSFS
+        rtl8125_sysfs_init(dev);
+#endif /* ENABLE_R8125_SYSFS */
+
+        printk("%s", GPL_CLAIM);
+
+out:
+        return rc;
+
+err_out:
+        if (tp->tally_vaddr != NULL) {
+                dma_free_coherent(&pdev->dev, sizeof(*tp->tally_vaddr), tp->tally_vaddr,
+                                  tp->tally_paddr);
+
+                tp->tally_vaddr = NULL;
+        }
+#ifdef  CONFIG_R8125_NAPI
+        rtl8125_del_napi(tp);
+#endif
+        rtl8125_disable_msi(pdev, tp);
+
+err_out_1:
+        rtl8125_release_board(pdev, dev);
+
+        goto out;
+}
+
+static void __devexit
+rtl8125_remove_one(struct pci_dev *pdev)
+{
+        struct net_device *dev = pci_get_drvdata(pdev);
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        assert(dev != NULL);
+        assert(tp != NULL);
+
+        set_bit(R8125_FLAG_DOWN, tp->task_flags);
+
+        rtl8125_cancel_all_schedule_work(tp);
+
+        if (HW_DASH_SUPPORT_DASH(tp))
+                rtl8125_driver_stop(tp);
+
+        rtl8125_disable_pci_offset_180(tp);
+
+#ifdef ENABLE_R8125_SYSFS
+        rtl8125_sysfs_remove(dev);
+#endif //ENABLE_R8125_SYSFS
+
+        unregister_netdev(dev);
+#ifdef  CONFIG_R8125_NAPI
+        rtl8125_del_napi(tp);
+#endif
+        rtl8125_disable_msi(pdev, tp);
+#ifdef ENABLE_R8125_PROCFS
+        rtl8125_proc_remove(dev);
+#endif
+        if (tp->tally_vaddr != NULL) {
+                dma_free_coherent(&pdev->dev, sizeof(*tp->tally_vaddr), tp->tally_vaddr, tp->tally_paddr);
+                tp->tally_vaddr = NULL;
+        }
+
+        rtl8125_release_board(pdev, dev);
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+        rtl8125_release_firmware(tp);
+#endif
+
+        pci_set_drvdata(pdev, NULL);
+}
+
+#ifdef ENABLE_PAGE_REUSE
+static inline unsigned int rtl8125_rx_page_order(unsigned rx_buf_sz, unsigned page_size)
+{
+        unsigned truesize = SKB_DATA_ALIGN(sizeof(struct skb_shared_info)) +
+                            SKB_DATA_ALIGN(rx_buf_sz + R8125_RX_ALIGN);
+
+        return get_order(truesize * 2);
+}
+#endif //ENABLE_PAGE_REUSE
+
+static void
+rtl8125_set_rxbufsize(struct rtl8125_private *tp,
+                      struct net_device *dev)
+{
+        unsigned int mtu = dev->mtu;
+
+        tp->rms = (mtu > ETH_DATA_LEN) ?
+                  mtu + ETH_HLEN + RT_VALN_HLEN + ETH_FCS_LEN:
+                  RX_BUF_SIZE;
+        tp->rx_buf_sz = tp->rms;
+#ifdef ENABLE_RX_PACKET_FRAGMENT
+        tp->rx_buf_sz =  SKB_DATA_ALIGN(RX_BUF_SIZE);
+#endif //ENABLE_RX_PACKET_FRAGMENT
+#ifdef ENABLE_PAGE_REUSE
+        tp->rx_buf_page_order = rtl8125_rx_page_order(tp->rx_buf_sz, PAGE_SIZE);
+        tp->rx_buf_page_size = rtl8125_rx_page_size(tp->rx_buf_page_order);
+#endif //ENABLE_PAGE_REUSE
+}
+
+static void
+rtl8125_set_rms(struct rtl8125_private *tp, u16 rms)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                rms |= AcceppVlanPhys;
+                break;
+        default:
+                rms &= ~AcceppVlanPhys;
+                break;
+        }
+        RTL_W16(tp, RxMaxSize, rms);
+}
+
+static void rtl8125_free_irq(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i=0; i<tp->irq_nvecs; i++) {
+                struct r8125_irq *irq = &tp->irq_tbl[i];
+                struct r8125_napi *r8125napi = &tp->r8125napi[i];
+
+                if (irq->requested) {
+                        irq->requested = 0;
+#if defined(RTL_USE_NEW_INTR_API)
+                        pci_free_irq(tp->pci_dev, i, r8125napi);
+#else
+                        free_irq(irq->vector, r8125napi);
+#endif
+                }
+        }
+}
+
+static int rtl8125_alloc_irq(struct rtl8125_private *tp)
+{
+        struct net_device *dev = tp->dev;
+        int rc = 0;
+        struct r8125_irq *irq;
+        struct r8125_napi *r8125napi;
+        int i = 0;
+        const int len = sizeof(tp->irq_tbl[0].name);
+
+#if defined(RTL_USE_NEW_INTR_API)
+        for (i=0; i<tp->irq_nvecs; i++) {
+                irq = &tp->irq_tbl[i];
+                if (tp->features & RTL_FEATURE_MSIX &&
+                    tp->HwCurrIsrVer > 1)
+                        irq->handler = rtl8125_interrupt_msix;
+                else
+                        irq->handler = rtl8125_interrupt;
+
+                r8125napi = &tp->r8125napi[i];
+                snprintf(irq->name, len, "%s-%d", dev->name, i);
+                rc = pci_request_irq(tp->pci_dev, i, irq->handler, NULL, r8125napi,
+                                     irq->name);
+                if (rc)
+                        break;
+
+                irq->vector = pci_irq_vector(tp->pci_dev, i);
+                irq->requested = 1;
+        }
+#else
+        unsigned long irq_flags = 0;
+#ifdef ENABLE_LIB_SUPPORT
+        irq_flags |= IRQF_NO_SUSPEND;
+#endif
+        if (tp->features & RTL_FEATURE_MSIX &&
+            tp->HwCurrIsrVer > 1) {
+                for (i=0; i<tp->irq_nvecs; i++) {
+                        irq = &tp->irq_tbl[i];
+                        irq->handler = rtl8125_interrupt_msix;
+                        r8125napi = &tp->r8125napi[i];
+                        snprintf(irq->name, len, "%s-%d", dev->name, i);
+                        rc = request_irq(irq->vector, irq->handler, irq_flags, irq->name, r8125napi);
+
+                        if (rc)
+                                break;
+
+                        irq->requested = 1;
+                }
+        } else {
+                irq = &tp->irq_tbl[0];
+                irq->handler = rtl8125_interrupt;
+                r8125napi = &tp->r8125napi[0];
+                snprintf(irq->name, len, "%s-0", dev->name);
+                if (!(tp->features & RTL_FEATURE_MSIX))
+                        irq->vector = dev->irq;
+                irq_flags |= (tp->features & (RTL_FEATURE_MSI | RTL_FEATURE_MSIX)) ? 0 : SA_SHIRQ;
+                rc = request_irq(irq->vector, irq->handler, irq_flags, irq->name, r8125napi);
+
+                if (rc == 0)
+                        irq->requested = 1;
+        }
+#endif
+        if (rc)
+                rtl8125_free_irq(tp);
+
+        return rc;
+}
+
+static int rtl8125_alloc_tx_desc(struct rtl8125_private *tp)
+{
+        struct rtl8125_tx_ring *ring;
+        struct pci_dev *pdev = tp->pci_dev;
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                ring = &tp->tx_ring[i];
+                ring->TxDescAllocSize = (ring->num_tx_desc + 1) * sizeof(struct TxDesc);
+                ring->TxDescArray = dma_alloc_coherent(&pdev->dev,
+                                                       ring->TxDescAllocSize,
+                                                       &ring->TxPhyAddr,
+                                                       GFP_KERNEL);
+
+                if (!ring->TxDescArray)
+                        return -1;
+        }
+
+        return 0;
+}
+
+static int rtl8125_alloc_rx_desc(struct rtl8125_private *tp)
+{
+        struct rtl8125_rx_ring *ring;
+        struct pci_dev *pdev = tp->pci_dev;
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                ring = &tp->rx_ring[i];
+                ring->RxDescAllocSize = (ring->num_rx_desc + 1) * tp->RxDescLength;
+                ring->RxDescArray = dma_alloc_coherent(&pdev->dev,
+                                                       ring->RxDescAllocSize,
+                                                       &ring->RxPhyAddr,
+                                                       GFP_KERNEL);
+
+                if (!ring->RxDescArray)
+                        return -1;
+        }
+
+        return 0;
+}
+
+static void rtl8125_free_tx_desc(struct rtl8125_private *tp)
+{
+        struct rtl8125_tx_ring *ring;
+        struct pci_dev *pdev = tp->pci_dev;
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                ring = &tp->tx_ring[i];
+                if (ring->TxDescArray) {
+                        dma_free_coherent(&pdev->dev,
+                                          ring->TxDescAllocSize,
+                                          ring->TxDescArray,
+                                          ring->TxPhyAddr);
+                        ring->TxDescArray = NULL;
+                }
+        }
+}
+
+static void rtl8125_free_rx_desc(struct rtl8125_private *tp)
+{
+        struct rtl8125_rx_ring *ring;
+        struct pci_dev *pdev = tp->pci_dev;
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                ring = &tp->rx_ring[i];
+                if (ring->RxDescArray) {
+                        dma_free_coherent(&pdev->dev,
+                                          ring->RxDescAllocSize,
+                                          ring->RxDescArray,
+                                          ring->RxPhyAddr);
+                        ring->RxDescArray = NULL;
+                }
+        }
+}
+
+static void rtl8125_free_alloc_resources(struct rtl8125_private *tp)
+{
+        rtl8125_free_rx_desc(tp);
+
+        rtl8125_free_tx_desc(tp);
+}
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+static void rtl8125_request_firmware(struct rtl8125_private *tp)
+{
+        struct rtl8125_fw *rtl_fw;
+
+        /* firmware loaded already or no firmware available */
+        if (tp->rtl_fw || !tp->fw_name)
+                return;
+
+        rtl_fw = kzalloc(sizeof(*rtl_fw), GFP_KERNEL);
+        if (!rtl_fw)
+                return;
+
+        rtl_fw->phy_write = rtl8125_mdio_write;
+        rtl_fw->phy_read = rtl8125_mdio_read;
+        rtl_fw->mac_mcu_write = mac_mcu_write;
+        rtl_fw->mac_mcu_read = mac_mcu_read;
+        rtl_fw->fw_name = tp->fw_name;
+        rtl_fw->dev = tp_to_dev(tp);
+
+        if (rtl8125_fw_request_firmware(rtl_fw))
+                kfree(rtl_fw);
+        else
+                tp->rtl_fw = rtl_fw;
+}
+#endif
+
+int rtl8125_open(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int retval;
+
+        retval = -ENOMEM;
+
+#ifdef ENABLE_R8125_PROCFS
+        rtl8125_proc_init(dev);
+#endif
+        rtl8125_set_rxbufsize(tp, dev);
+        /*
+         * Rx and Tx descriptors needs 256 bytes alignment.
+         * pci_alloc_consistent provides more.
+         */
+        if (rtl8125_alloc_tx_desc(tp) < 0 || rtl8125_alloc_rx_desc(tp) < 0)
+                goto err_free_all_allocated_mem;
+
+        retval = rtl8125_init_ring(dev);
+        if (retval < 0)
+                goto err_free_all_allocated_mem;
+
+        retval = rtl8125_alloc_irq(tp);
+        if (retval < 0)
+                goto err_free_all_allocated_mem;
+
+        if (netif_msg_probe(tp)) {
+                printk(KERN_INFO "%s: 0x%lx, "
+                       "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x, "
+                       "IRQ %d\n",
+                       dev->name,
+                       dev->base_addr,
+                       dev->dev_addr[0], dev->dev_addr[1],
+                       dev->dev_addr[2], dev->dev_addr[3],
+                       dev->dev_addr[4], dev->dev_addr[5], dev->irq);
+        }
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+        rtl8125_request_firmware(tp);
+#endif
+        pci_set_master(tp->pci_dev);
+
+#ifdef  CONFIG_R8125_NAPI
+        rtl8125_enable_napi(tp);
+#endif
+
+        rtl8125_exit_oob(dev);
+
+        rtl8125_up(dev);
+
+#ifdef ENABLE_PTP_SUPPORT
+        if (tp->EnablePtp)
+                rtl8125_ptp_init(tp);
+#endif
+        clear_bit(R8125_FLAG_DOWN, tp->task_flags);
+
+        if (tp->resume_not_chg_speed)
+                _rtl8125_check_link_status(dev, R8125_LINK_STATE_UNKNOWN);
+        else
+                rtl8125_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+
+        if (tp->esd_flag == 0) {
+                //rtl8125_request_esd_timer(dev);
+
+                rtl8125_schedule_esd_work(tp);
+        }
+
+        //rtl8125_request_link_timer(dev);
+#ifdef ENABLE_FIBER_SUPPORT
+        if (HW_FIBER_MODE_ENABLED(tp))
+                rtl8125_schedule_link_work(tp);
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        rtl8125_enable_hw_linkchg_interrupt(tp);
+out:
+
+        return retval;
+
+err_free_all_allocated_mem:
+        rtl8125_free_alloc_resources(tp);
+
+        goto out;
+}
+
+static void
+_rtl8125_set_l1_l0s_entry_latency(struct rtl8125_private *tp, u8 setting)
+{
+        u32 csi_tmp;
+        u32 temp;
+
+        temp = setting & 0x3f;
+        temp <<= 24;
+        /*set PCI configuration space offset 0x70F to setting*/
+        /*When the register offset of PCI configuration space larger than 0xff, use CSI to access it.*/
+
+        csi_tmp = rtl8125_csi_read(tp, 0x70c) & 0xc0ffffff;
+        rtl8125_csi_write(tp, 0x70c, csi_tmp | temp);
+}
+
+static void
+rtl8125_set_l1_l0s_entry_latency(struct rtl8125_private *tp)
+{
+        _rtl8125_set_l1_l0s_entry_latency(tp, 0x27);
+}
+
+static void
+_rtl8125_set_mrrs(struct rtl8125_private *tp, u8 setting)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+        u8 device_control;
+
+        pci_read_config_byte(pdev, 0x79, &device_control);
+        device_control &= ~0x70;
+        device_control |= setting;
+        pci_write_config_byte(pdev, 0x79, device_control);
+}
+
+static void
+rtl8125_set_mrrs(struct rtl8125_private *tp)
+{
+        if (hwoptimize & HW_PATCH_SOC_LAN)
+                return;
+
+        _rtl8125_set_mrrs(tp, 0x40);
+}
+
+void
+rtl8125_hw_set_rx_packet_filter(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 mc_filter[2];   /* Multicast hash filter */
+        int rx_mode;
+        u32 tmp = 0;
+
+        if (dev->flags & IFF_PROMISC) {
+                /* Unconditionally log net taps. */
+                if (netif_msg_link(tp))
+                        printk(KERN_NOTICE "%s: Promiscuous mode enabled.\n",
+                               dev->name);
+
+                rx_mode =
+                        AcceptBroadcast | AcceptMulticast | AcceptMyPhys |
+                        AcceptAllPhys;
+                mc_filter[1] = mc_filter[0] = 0xffffffff;
+        } else if (dev->flags & IFF_ALLMULTI) {
+                /* accept all multicasts. */
+                rx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;
+                mc_filter[1] = mc_filter[0] = 0xffffffff;
+        } else {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+                struct dev_mc_list *mclist;
+                unsigned int i;
+
+                rx_mode = AcceptBroadcast | AcceptMyPhys;
+                mc_filter[1] = mc_filter[0] = 0;
+                for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
+                     i++, mclist = mclist->next) {
+                        int bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+                        mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+                        rx_mode |= AcceptMulticast;
+                }
+#else
+                struct netdev_hw_addr *ha;
+
+                rx_mode = AcceptBroadcast | AcceptMyPhys;
+                mc_filter[1] = mc_filter[0] = 0;
+                netdev_for_each_mc_addr(ha, dev) {
+                        int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
+                        mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+                        rx_mode |= AcceptMulticast;
+                }
+#endif
+        }
+
+        if (dev->features & NETIF_F_RXALL)
+                rx_mode |= (AcceptErr | AcceptRunt);
+
+        tmp = mc_filter[0];
+        mc_filter[0] = swab32(mc_filter[1]);
+        mc_filter[1] = swab32(tmp);
+
+        tmp = tp->rtl8125_rx_config | rx_mode | (RTL_R32(tp, RxConfig) & rtl_chip_info[tp->chipset].RxConfigMask);
+
+        RTL_W32(tp, RxConfig, tmp);
+        RTL_W32(tp, MAR0 + 0, mc_filter[0]);
+        RTL_W32(tp, MAR0 + 4, mc_filter[1]);
+}
+
+static void
+rtl8125_set_rx_mode(struct net_device *dev)
+{
+        rtl8125_hw_set_rx_packet_filter(dev);
+}
+
+void
+rtl8125_set_rx_q_num(struct rtl8125_private *tp,
+                     unsigned int num_rx_queues)
+{
+        u16 q_ctrl;
+        u16 rx_q_num;
+
+        rx_q_num = (u16)ilog2(num_rx_queues);
+        rx_q_num &= (BIT_0 | BIT_1 | BIT_2);
+        rx_q_num <<= 2;
+        q_ctrl = RTL_R16(tp, Q_NUM_CTRL_8125);
+        q_ctrl &= ~(BIT_2 | BIT_3 | BIT_4);
+        q_ctrl |= rx_q_num;
+        RTL_W16(tp, Q_NUM_CTRL_8125, q_ctrl);
+}
+
+void
+rtl8125_set_tx_q_num(struct rtl8125_private *tp,
+                     unsigned int num_tx_queues)
+{
+        u16 mac_ocp_data;
+
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xE63E);
+        mac_ocp_data &= ~(BIT_11 | BIT_10);
+        mac_ocp_data |= ((ilog2(num_tx_queues) & 0x03) << 10);
+        rtl8125_mac_ocp_write(tp, 0xE63E, mac_ocp_data);
+}
+
+void
+rtl8125_enable_mcu(struct rtl8125_private *tp, bool enable)
+{
+        if (FALSE == HW_SUPPORT_MAC_MCU(tp))
+                return;
+
+        if (enable)
+                rtl8125_set_mac_ocp_bit(tp, 0xC0B4, BIT_0);
+        else
+                rtl8125_clear_mac_ocp_bit(tp, 0xC0B4, BIT_0);
+}
+
+static void
+rtl8125_clear_tcam_entries(struct rtl8125_private *tp)
+{
+        if (FALSE == HW_SUPPORT_TCAM(tp))
+                return;
+
+        rtl8125_set_mac_ocp_bit(tp, 0xEB54, BIT_0);
+        udelay(1);
+        rtl8125_clear_mac_ocp_bit(tp, 0xEB54, BIT_0);
+}
+
+static void
+rtl8125_enable_tcam(struct rtl8125_private *tp)
+{
+        if (tp->HwSuppTcamVer != 1)
+                return;
+
+        RTL_W16(tp, 0x382, 0x221B);
+}
+
+static u8
+rtl8125_get_l1off_cap_bits(struct rtl8125_private *tp)
+{
+        u8 l1offCapBits = 0;
+
+        l1offCapBits = (BIT_0 | BIT_1);
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_10:
+        case CFG_METHOD_11:
+        case CFG_METHOD_12:
+        case CFG_METHOD_13:
+                l1offCapBits |= (BIT_2 | BIT_3);
+                break;
+        default:
+                break;
+        }
+
+        return l1offCapBits;
+}
+
+void
+rtl8125_hw_config(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct pci_dev *pdev = tp->pci_dev;
+        u16 mac_ocp_data;
+
+        rtl8125_disable_rx_packet_filter(tp);
+
+        rtl8125_hw_reset(dev);
+
+        rtl8125_enable_cfg9346_write(tp);
+
+        rtl8125_enable_force_clkreq(tp, 0);
+        rtl8125_enable_aspm_clkreq_lock(tp, 0);
+
+        rtl8125_set_eee_lpi_timer(tp);
+
+        //keep magic packet only
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xC0B6);
+        mac_ocp_data &= BIT_0;
+        rtl8125_mac_ocp_write(tp, 0xC0B6, mac_ocp_data);
+
+        rtl8125_tally_counter_addr_fill(tp);
+
+        rtl8125_enable_extend_tally_couter(tp);
+
+        rtl8125_desc_addr_fill(tp);
+
+        /* Set DMA burst size and Interframe Gap Time */
+        RTL_W32(tp, TxConfig, (TX_DMA_BURST_unlimited << TxDMAShift) |
+                (InterFrameGap << TxInterFrameGapShift));
+
+        if (tp->EnableTxNoClose)
+                RTL_W32(tp, TxConfig, (RTL_R32(tp, TxConfig) | BIT_6));
+
+        if (enable_double_vlan)
+                rtl8125_enable_double_vlan(tp);
+        else
+                rtl8125_disable_double_vlan(tp);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2 ... CFG_METHOD_7:
+                rtl8125_enable_tcam(tp);
+                break;
+        }
+
+        rtl8125_set_l1_l0s_entry_latency(tp);
+
+        rtl8125_set_mrrs(tp);
+
+#ifdef ENABLE_RSS_SUPPORT
+        rtl8125_config_rss(tp);
+#else
+        RTL_W32(tp, RSS_CTRL_8125, 0x00);
+#endif
+        rtl8125_set_rx_q_num(tp, rtl8125_tot_rx_rings(tp));
+
+        RTL_W8(tp, Config1, RTL_R8(tp, Config1) & ~0x10);
+
+        rtl8125_mac_ocp_write(tp, 0xC140, 0xFFFF);
+        rtl8125_mac_ocp_write(tp, 0xC142, 0xFFFF);
+
+        //new tx desc format
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xEB58);
+        mac_ocp_data |= (BIT_0);
+        rtl8125_mac_ocp_write(tp, 0xEB58, mac_ocp_data);
+
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xE614);
+        mac_ocp_data &= ~(BIT_10 | BIT_9 | BIT_8);
+        if (tp->mcfg == CFG_METHOD_4 || tp->mcfg == CFG_METHOD_5 ||
+            tp->mcfg == CFG_METHOD_7)
+                mac_ocp_data |= ((2 & 0x07) << 8);
+        else
+                mac_ocp_data |= ((3 & 0x07) << 8);
+        rtl8125_mac_ocp_write(tp, 0xE614, mac_ocp_data);
+
+        rtl8125_set_tx_q_num(tp, rtl8125_tot_tx_rings(tp));
+
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xE63E);
+        mac_ocp_data &= ~(BIT_5 | BIT_4);
+        mac_ocp_data |= (0x02 << 4);
+        rtl8125_mac_ocp_write(tp, 0xE63E, mac_ocp_data);
+
+        rtl8125_enable_mcu(tp, 0);
+        rtl8125_enable_mcu(tp, 1);
+
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xC0B4);
+        mac_ocp_data |= (BIT_3 | BIT_2);
+        rtl8125_mac_ocp_write(tp, 0xC0B4, mac_ocp_data);
+
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xEB6A);
+        mac_ocp_data &= ~(BIT_7 | BIT_6 | BIT_5 | BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0);
+        mac_ocp_data |= (BIT_5 | BIT_4 | BIT_1 | BIT_0);
+        rtl8125_mac_ocp_write(tp, 0xEB6A, mac_ocp_data);
+
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xEB50);
+        mac_ocp_data &= ~(BIT_9 | BIT_8 | BIT_7 | BIT_6 | BIT_5);
+        mac_ocp_data |= (BIT_6);
+        rtl8125_mac_ocp_write(tp, 0xEB50, mac_ocp_data);
+
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xE056);
+        mac_ocp_data &= ~(BIT_7 | BIT_6 | BIT_5 | BIT_4);
+        //mac_ocp_data |= (BIT_4 | BIT_5);
+        rtl8125_mac_ocp_write(tp, 0xE056, mac_ocp_data);
+
+        RTL_W8(tp, TDFNR, 0x10);
+
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xE040);
+        mac_ocp_data &= ~(BIT_12);
+        rtl8125_mac_ocp_write(tp, 0xE040, mac_ocp_data);
+
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xEA1C);
+        mac_ocp_data &= ~(BIT_1 | BIT_0);
+        mac_ocp_data |= (BIT_0);
+        rtl8125_mac_ocp_write(tp, 0xEA1C, mac_ocp_data);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_12:
+                rtl8125_oob_mutex_lock(tp);
+                break;
+        }
+
+        if (tp->mcfg == CFG_METHOD_10 || tp->mcfg == CFG_METHOD_11 ||
+            tp->mcfg == CFG_METHOD_13)
+                rtl8125_mac_ocp_write(tp, 0xE0C0, 0x4403);
+        else
+                rtl8125_mac_ocp_write(tp, 0xE0C0, 0x4000);
+
+        rtl8125_set_mac_ocp_bit(tp, 0xE052, (BIT_6 | BIT_5));
+        rtl8125_clear_mac_ocp_bit(tp, 0xE052, BIT_3 | BIT_7);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+        case CFG_METHOD_8:
+        case CFG_METHOD_9:
+        case CFG_METHOD_12:
+                rtl8125_oob_mutex_unlock(tp);
+                break;
+        }
+
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xD430);
+        mac_ocp_data &= ~(BIT_11 | BIT_10 | BIT_9 | BIT_8 | BIT_7 | BIT_6 | BIT_5 | BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0);
+        mac_ocp_data |= 0x45F;
+        rtl8125_mac_ocp_write(tp, 0xD430, mac_ocp_data);
+
+        //rtl8125_mac_ocp_write(tp, 0xE0C0, 0x4F87);
+        if (!tp->DASH)
+                RTL_W8(tp, 0xD0, RTL_R8(tp, 0xD0) | BIT_6 | BIT_7);
+        else
+                RTL_W8(tp, 0xD0, RTL_R8(tp, 0xD0) & ~(BIT_6 | BIT_7));
+
+        if (tp->mcfg == CFG_METHOD_2 || tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_6)
+                RTL_W8(tp, MCUCmd_reg, RTL_R8(tp, MCUCmd_reg) | BIT_0);
+
+        if (tp->mcfg != CFG_METHOD_10 && tp->mcfg != CFG_METHOD_11 &&
+            tp->mcfg != CFG_METHOD_13)
+                rtl8125_disable_eee_plus(tp);
+
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xEA1C);
+        mac_ocp_data &= ~(BIT_2);
+        rtl8125_mac_ocp_write(tp, 0xEA1C, mac_ocp_data);
+
+        rtl8125_clear_tcam_entries(tp);
+
+        RTL_W16(tp, 0x1880, RTL_R16(tp, 0x1880) & ~(BIT_4 | BIT_5));
+
+        if (tp->HwSuppRxDescType == RX_DESC_RING_TYPE_4) {
+                if (tp->InitRxDescType == RX_DESC_RING_TYPE_4)
+                        RTL_W8(tp, 0xd8, RTL_R8(tp, 0xd8) |
+                               EnableRxDescV4_0);
+                else
+                        RTL_W8(tp, 0xd8, RTL_R8(tp, 0xd8) &
+                               ~EnableRxDescV4_0);
+        }
+
+        if (tp->mcfg == CFG_METHOD_12) {
+                rtl8125_clear_mac_ocp_bit(tp, 0xE00C, BIT_12);
+
+                rtl8125_clear_mac_ocp_bit(tp, 0xC0C2, BIT_6);
+        }
+
+        /* csum offload command for RTL8125 */
+        tp->tx_tcp_csum_cmd = TxTCPCS_C;
+        tp->tx_udp_csum_cmd = TxUDPCS_C;
+        tp->tx_ip_csum_cmd = TxIPCS_C;
+        tp->tx_ipv6_csum_cmd = TxIPV6F_C;
+
+        /* config interrupt type for RTL8125B */
+        if (tp->HwSuppIsrVer > 1)
+                rtl8125_hw_set_interrupt_type(tp, tp->HwCurrIsrVer);
+
+        //other hw parameters
+        rtl8125_hw_clear_timer_int(dev);
+
+        rtl8125_hw_clear_int_miti(dev);
+
+        if (tp->use_timer_interrupt &&
+            (tp->HwCurrIsrVer > 1) &&
+            (tp->HwSuppIntMitiVer > 3) &&
+            (tp->features & RTL_FEATURE_MSIX)) {
+                int i;
+                for (i = 0; i < tp->irq_nvecs; i++)
+                        rtl8125_hw_set_timer_int(tp, i, timer_count_v2);
+        }
+
+        rtl8125_enable_exit_l1_mask(tp);
+
+        rtl8125_mac_ocp_write(tp, 0xE098, 0xC302);
+
+        if (aspm && (tp->org_pci_offset_99 & (BIT_2 | BIT_5 | BIT_6)))
+                rtl8125_init_pci_offset_99(tp);
+        else
+                rtl8125_disable_pci_offset_99(tp);
+
+        if (aspm && (tp->org_pci_offset_180 & rtl8125_get_l1off_cap_bits(tp)))
+                rtl8125_init_pci_offset_180(tp);
+        else
+                rtl8125_disable_pci_offset_180(tp);
+
+        if (tp->RequiredPfmPatch)
+                rtl8125_set_pfm_patch(tp, 0);
+
+        tp->cp_cmd &= ~(EnableBist | Macdbgo_oe | Force_halfdup |
+                        Force_rxflow_en | Force_txflow_en | Cxpl_dbg_sel |
+                        ASF | Macdbgo_sel);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        RTL_W16(tp, CPlusCmd, tp->cp_cmd);
+#else
+        rtl8125_hw_set_features(dev, dev->features);
+#endif
+        rtl8125_set_rms(tp, tp->rms);
+
+        rtl8125_disable_rxdvgate(dev);
+
+        if (!tp->pci_cfg_is_read) {
+                pci_read_config_byte(pdev, PCI_COMMAND, &tp->pci_cfg_space.cmd);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_0, &tp->pci_cfg_space.io_base_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_0 + 2, &tp->pci_cfg_space.io_base_h);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_2, &tp->pci_cfg_space.mem_base_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_2 + 2, &tp->pci_cfg_space.mem_base_h);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_3, &tp->pci_cfg_space.resv_0x1c_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_3 + 2, &tp->pci_cfg_space.resv_0x1c_h);
+                pci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &tp->pci_cfg_space.ilr);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_4, &tp->pci_cfg_space.resv_0x20_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_4 + 2, &tp->pci_cfg_space.resv_0x20_h);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_5, &tp->pci_cfg_space.resv_0x24_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_5 + 2, &tp->pci_cfg_space.resv_0x24_h);
+                pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &tp->pci_cfg_space.resv_0x2c_l);
+                pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID + 2, &tp->pci_cfg_space.resv_0x2c_h);
+                if (tp->HwPcieSNOffset > 0) {
+                        tp->pci_cfg_space.pci_sn_l = rtl8125_csi_read(tp, tp->HwPcieSNOffset);
+                        tp->pci_cfg_space.pci_sn_h = rtl8125_csi_read(tp, tp->HwPcieSNOffset + 4);
+                }
+
+                tp->pci_cfg_is_read = 1;
+        }
+
+        /* Set Rx packet filter */
+        rtl8125_hw_set_rx_packet_filter(dev);
+
+#ifdef ENABLE_DASH_SUPPORT
+        rtl8125_check_and_enable_dash_interrupt(tp);
+#endif
+
+        rtl8125_enable_aspm_clkreq_lock(tp, aspm ? 1 : 0);
+
+        rtl8125_disable_cfg9346_write(tp);
+
+        udelay(10);
+}
+
+void
+rtl8125_hw_start(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+#ifdef ENABLE_LIB_SUPPORT
+        rtl8125_init_lib_ring(tp);
+#endif
+
+        RTL_W8(tp, ChipCmd, CmdTxEnb | CmdRxEnb);
+
+        rtl8125_enable_hw_interrupt(tp);
+
+        rtl8125_lib_reset_complete(tp);
+}
+
+static int
+rtl8125_change_mtu(struct net_device *dev,
+                   int new_mtu)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ret = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+        if (new_mtu < ETH_MIN_MTU)
+                return -EINVAL;
+        else if (new_mtu > tp->max_jumbo_frame_size)
+                new_mtu = tp->max_jumbo_frame_size;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+
+        dev->mtu = new_mtu;
+
+        tp->eee.tx_lpi_timer = dev->mtu + ETH_HLEN + 0x20;
+
+        if (!netif_running(dev))
+                goto out;
+
+        rtl8125_down(dev);
+
+        rtl8125_set_rxbufsize(tp, dev);
+
+        ret = rtl8125_init_ring(dev);
+
+        if (ret < 0)
+                goto err_out;
+
+#ifdef CONFIG_R8125_NAPI
+        rtl8125_enable_napi(tp);
+#endif//CONFIG_R8125_NAPI
+
+        if (tp->link_ok(dev))
+                rtl8125_link_on_patch(dev);
+        else
+                rtl8125_link_down_patch(dev);
+
+        //mod_timer(&tp->esd_timer, jiffies + RTL8125_ESD_TIMEOUT);
+        //mod_timer(&tp->link_timer, jiffies + RTL8125_LINK_TIMEOUT);
+out:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+        netdev_update_features(dev);
+#endif
+
+err_out:
+        return ret;
+}
+
+static inline void
+rtl8125_set_desc_dma_addr(struct rtl8125_private *tp,
+                          struct RxDesc *desc,
+                          dma_addr_t mapping)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                ((struct RxDescV3 *)desc)->addr = cpu_to_le64(mapping);
+                break;
+        case RX_DESC_RING_TYPE_4:
+                ((struct RxDescV4 *)desc)->addr = cpu_to_le64(mapping);
+                break;
+        default:
+                desc->addr = cpu_to_le64(mapping);
+                break;
+        }
+}
+
+static inline void
+rtl8125_mark_to_asic_v1(struct RxDesc *desc,
+                        u32 rx_buf_sz)
+{
+        u32 eor = le32_to_cpu(desc->opts1) & RingEnd;
+
+        WRITE_ONCE(desc->opts1, cpu_to_le32(DescOwn | eor | rx_buf_sz));
+}
+
+static inline void
+rtl8125_mark_to_asic_v3(struct RxDescV3 *descv3,
+                        u32 rx_buf_sz)
+{
+        u32 eor = le32_to_cpu(descv3->RxDescNormalDDWord4.opts1) & RingEnd;
+
+        WRITE_ONCE(descv3->RxDescNormalDDWord4.opts1, cpu_to_le32(DescOwn | eor | rx_buf_sz));
+}
+
+static inline void
+rtl8125_mark_to_asic_v4(struct RxDescV4 *descv4,
+                        u32 rx_buf_sz)
+{
+        u32 eor = le32_to_cpu(descv4->RxDescNormalDDWord2.opts1) & RingEnd;
+
+        WRITE_ONCE(descv4->RxDescNormalDDWord2.opts1, cpu_to_le32(DescOwn | eor | rx_buf_sz));
+}
+
+void
+rtl8125_mark_to_asic(struct rtl8125_private *tp,
+                     struct RxDesc *desc,
+                     u32 rx_buf_sz)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                rtl8125_mark_to_asic_v3((struct RxDescV3 *)desc, rx_buf_sz);
+                break;
+        case RX_DESC_RING_TYPE_4:
+                rtl8125_mark_to_asic_v4((struct RxDescV4 *)desc, rx_buf_sz);
+                break;
+        default:
+                rtl8125_mark_to_asic_v1(desc, rx_buf_sz);
+                break;
+        }
+}
+
+static inline void
+rtl8125_map_to_asic(struct rtl8125_private *tp,
+                    struct rtl8125_rx_ring *ring,
+                    struct RxDesc *desc,
+                    dma_addr_t mapping,
+                    u32 rx_buf_sz,
+                    const u32 cur_rx)
+{
+        ring->RxDescPhyAddr[cur_rx] = mapping;
+        rtl8125_set_desc_dma_addr(tp, desc, mapping);
+        wmb();
+        rtl8125_mark_to_asic(tp, desc, rx_buf_sz);
+}
+
+#ifdef ENABLE_PAGE_REUSE
+
+static int
+rtl8125_alloc_rx_page(struct rtl8125_private *tp, struct rtl8125_rx_ring *ring,
+                      struct rtl8125_rx_buffer *rxb)
+{
+        struct page *page;
+        dma_addr_t dma;
+        unsigned int order = tp->rx_buf_page_order;
+
+        //get free page
+        page = dev_alloc_pages(order);
+
+        if (unlikely(!page))
+                return -ENOMEM;
+
+        dma = dma_map_page_attrs(&tp->pci_dev->dev, page, 0,
+                                 tp->rx_buf_page_size,
+                                 DMA_FROM_DEVICE,
+                                 (DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING));
+
+        if (unlikely(dma_mapping_error(&tp->pci_dev->dev, dma))) {
+                __free_pages(page, order);
+                return -ENOMEM;
+        }
+
+        rxb->page = page;
+        rxb->data = page_address(page);
+        rxb->page_offset = ring->rx_offset;
+        rxb->dma = dma;
+
+        //after page alloc, page refcount already = 1
+
+        return 0;
+}
+
+static void
+rtl8125_free_rx_page(struct rtl8125_private *tp, struct rtl8125_rx_buffer *rxb)
+{
+        if (!rxb->page)
+                return;
+
+        dma_unmap_page_attrs(&tp->pci_dev->dev, rxb->dma,
+                             tp->rx_buf_page_size,
+                             DMA_FROM_DEVICE,
+                             (DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING));
+        __free_pages(rxb->page, tp->rx_buf_page_order);
+        rxb->page = NULL;
+}
+
+static void
+_rtl8125_rx_clear(struct rtl8125_private *tp, struct rtl8125_rx_ring *ring)
+{
+        int i;
+        struct rtl8125_rx_buffer *rxb;
+
+        for (i = 0; i < ring->num_rx_desc; i++) {
+                rxb = &ring->rx_buffer[i];
+                if (rxb->skb) {
+                        dev_kfree_skb(rxb->skb);
+                        rxb->skb = NULL;
+                }
+                rtl8125_free_rx_page(tp, rxb);
+        }
+}
+
+static u32
+rtl8125_rx_fill(struct rtl8125_private *tp,
+                struct rtl8125_rx_ring *ring,
+                struct net_device *dev,
+                u32 start,
+                u32 end,
+                u8 in_intr)
+{
+        u32 cur;
+        struct rtl8125_rx_buffer *rxb;
+
+        for (cur = start; end - cur > 0; cur++) {
+                int ret, i = cur % ring->num_rx_desc;
+
+                rxb = &ring->rx_buffer[i];
+                if (rxb->page)
+                        continue;
+
+                ret = rtl8125_alloc_rx_page(tp, ring, rxb);
+                if (ret)
+                        break;
+
+                dma_sync_single_range_for_device(tp_to_dev(tp),
+                                                 rxb->dma,
+                                                 rxb->page_offset,
+                                                 tp->rx_buf_sz,
+                                                 DMA_FROM_DEVICE);
+
+                rtl8125_map_to_asic(tp, ring,
+                                    rtl8125_get_rxdesc(tp, ring->RxDescArray, i),
+                                    rxb->dma + rxb->page_offset,
+                                    tp->rx_buf_sz, i);
+        }
+        return cur - start;
+}
+
+#else //ENABLE_PAGE_REUSE
+
+static void
+rtl8125_free_rx_skb(struct rtl8125_private *tp,
+                    struct rtl8125_rx_ring *ring,
+                    struct sk_buff **sk_buff,
+                    struct RxDesc *desc,
+                    const u32 cur_rx)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+
+        dma_unmap_single(&pdev->dev, ring->RxDescPhyAddr[cur_rx], tp->rx_buf_sz,
+                         DMA_FROM_DEVICE);
+        dev_kfree_skb(*sk_buff);
+        *sk_buff = NULL;
+        rtl8125_make_unusable_by_asic(tp, desc);
+}
+
+static int
+rtl8125_alloc_rx_skb(struct rtl8125_private *tp,
+                     struct rtl8125_rx_ring *ring,
+                     struct sk_buff **sk_buff,
+                     struct RxDesc *desc,
+                     int rx_buf_sz,
+                     const u32 cur_rx,
+                     u8 in_intr)
+{
+        struct sk_buff *skb;
+        dma_addr_t mapping;
+        int ret = 0;
+
+        if (in_intr)
+                skb = RTL_ALLOC_SKB_INTR(&tp->r8125napi[ring->index].napi, rx_buf_sz + R8125_RX_ALIGN);
+        else
+                skb = dev_alloc_skb(rx_buf_sz + R8125_RX_ALIGN);
+
+        if (unlikely(!skb))
+                goto err_out;
+
+        if (!in_intr || !R8125_USE_NAPI_ALLOC_SKB)
+                skb_reserve(skb, R8125_RX_ALIGN);
+
+        mapping = dma_map_single(tp_to_dev(tp), skb->data, rx_buf_sz,
+                                 DMA_FROM_DEVICE);
+        if (unlikely(dma_mapping_error(tp_to_dev(tp), mapping))) {
+                if (unlikely(net_ratelimit()))
+                        netif_err(tp, drv, tp->dev, "Failed to map RX DMA!\n");
+                goto err_out;
+        }
+
+        *sk_buff = skb;
+        rtl8125_map_to_asic(tp, ring, desc, mapping, rx_buf_sz, cur_rx);
+out:
+        return ret;
+
+err_out:
+        if (skb)
+                dev_kfree_skb(skb);
+        ret = -ENOMEM;
+        rtl8125_make_unusable_by_asic(tp, desc);
+        goto out;
+}
+
+static void
+_rtl8125_rx_clear(struct rtl8125_private *tp, struct rtl8125_rx_ring *ring)
+{
+        int i;
+
+        for (i = 0; i < ring->num_rx_desc; i++) {
+                if (ring->Rx_skbuff[i]) {
+                        rtl8125_free_rx_skb(tp,
+                                            ring,
+                                            ring->Rx_skbuff + i,
+                                            rtl8125_get_rxdesc(tp, ring->RxDescArray, i),
+                                            i);
+                        ring->Rx_skbuff[i] = NULL;
+                }
+        }
+}
+
+static u32
+rtl8125_rx_fill(struct rtl8125_private *tp,
+                struct rtl8125_rx_ring *ring,
+                struct net_device *dev,
+                u32 start,
+                u32 end,
+                u8 in_intr)
+{
+        u32 cur;
+
+        for (cur = start; end - cur > 0; cur++) {
+                int ret, i = cur % ring->num_rx_desc;
+
+                if (ring->Rx_skbuff[i])
+                        continue;
+
+                ret = rtl8125_alloc_rx_skb(tp,
+                                           ring,
+                                           ring->Rx_skbuff + i,
+                                           rtl8125_get_rxdesc(tp, ring->RxDescArray, i),
+                                           tp->rx_buf_sz,
+                                           i,
+                                           in_intr);
+                if (ret < 0)
+                        break;
+        }
+        return cur - start;
+}
+
+#endif //ENABLE_PAGE_REUSE
+
+void
+rtl8125_rx_clear(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
+
+                _rtl8125_rx_clear(tp, ring);
+        }
+}
+
+static void
+rtl8125_mark_as_last_descriptor_v1(struct RxDesc *desc)
+{
+        desc->opts1 |= cpu_to_le32(RingEnd);
+}
+
+static void
+rtl8125_mark_as_last_descriptor_v3(struct RxDescV3 *descv3)
+{
+        descv3->RxDescNormalDDWord4.opts1 |= cpu_to_le32(RingEnd);
+}
+
+static void
+rtl8125_mark_as_last_descriptor_v4(struct RxDescV4 *descv4)
+{
+        descv4->RxDescNormalDDWord2.opts1 |= cpu_to_le32(RingEnd);
+}
+
+void
+rtl8125_mark_as_last_descriptor(struct rtl8125_private *tp,
+                                struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                rtl8125_mark_as_last_descriptor_v3((struct RxDescV3 *)desc);
+                break;
+        case RX_DESC_RING_TYPE_4:
+                rtl8125_mark_as_last_descriptor_v4((struct RxDescV4 *)desc);
+                break;
+        default:
+                rtl8125_mark_as_last_descriptor_v1(desc);
+                break;
+        }
+}
+
+static void
+rtl8125_desc_addr_fill(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8125_tx_ring *ring = &tp->tx_ring[i];
+                RTL_W32(tp, ring->tdsar_reg, ((u64)ring->TxPhyAddr & DMA_BIT_MASK(32)));
+                RTL_W32(tp, ring->tdsar_reg + 4, ((u64)ring->TxPhyAddr >> 32));
+        }
+
+        if (rtl8125_num_lib_rx_rings(tp) == 0) {
+                for (i = 0; i < tp->num_rx_rings; i++) {
+                        struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
+                        RTL_W32(tp, ring->rdsar_reg, ((u64)ring->RxPhyAddr & DMA_BIT_MASK(32)));
+                        RTL_W32(tp, ring->rdsar_reg + 4, ((u64)ring->RxPhyAddr >> 32));
+                }
+        }
+}
+
+static void
+rtl8125_tx_desc_init(struct rtl8125_private *tp)
+{
+        int i = 0;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8125_tx_ring *ring = &tp->tx_ring[i];
+                memset(ring->TxDescArray, 0x0, ring->TxDescAllocSize);
+
+                ring->TxDescArray[ring->num_tx_desc - 1].opts1 = cpu_to_le32(RingEnd);
+        }
+}
+
+static void
+rtl8125_rx_desc_init(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
+                memset(ring->RxDescArray, 0x0, ring->RxDescAllocSize);
+        }
+}
+
+int
+rtl8125_init_ring(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        rtl8125_init_ring_indexes(tp);
+
+        rtl8125_tx_desc_init(tp);
+        rtl8125_rx_desc_init(tp);
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8125_tx_ring *ring = &tp->tx_ring[i];
+                memset(ring->tx_skb, 0x0, sizeof(ring->tx_skb));
+        }
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
+#ifdef ENABLE_PAGE_REUSE
+                ring->rx_offset = R8125_RX_ALIGN;
+#else
+                memset(ring->Rx_skbuff, 0x0, sizeof(ring->Rx_skbuff));
+#endif //ENABLE_PAGE_REUSE
+                if (rtl8125_rx_fill(tp, ring, dev, 0, ring->num_rx_desc, 0) != ring->num_rx_desc)
+                        goto err_out;
+
+                rtl8125_mark_as_last_descriptor(tp, rtl8125_get_rxdesc(tp, ring->RxDescArray, ring->num_rx_desc - 1));
+        }
+
+        return 0;
+
+err_out:
+        rtl8125_rx_clear(tp);
+        return -ENOMEM;
+}
+
+static void
+rtl8125_unmap_tx_skb(struct pci_dev *pdev,
+                     struct ring_info *tx_skb,
+                     struct TxDesc *desc)
+{
+        unsigned int len = tx_skb->len;
+
+        dma_unmap_single(&pdev->dev, le64_to_cpu(desc->addr), len, DMA_TO_DEVICE);
+
+        desc->opts1 = cpu_to_le32(RTK_MAGIC_DEBUG_VALUE);
+        desc->opts2 = 0x00;
+        desc->addr = RTL8125_MAGIC_NUMBER;
+        tx_skb->len = 0;
+}
+
+static void
+rtl8125_tx_clear_range(struct rtl8125_private *tp,
+                       struct rtl8125_tx_ring *ring,
+                       u32 start,
+                       unsigned int n)
+{
+        unsigned int i;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+        struct net_device *dev = tp->dev;
+#endif
+
+        for (i = 0; i < n; i++) {
+                unsigned int entry = (start + i) % ring->num_tx_desc;
+                struct ring_info *tx_skb = ring->tx_skb + entry;
+                unsigned int len = tx_skb->len;
+
+                if (len) {
+                        struct sk_buff *skb = tx_skb->skb;
+
+                        rtl8125_unmap_tx_skb(tp->pci_dev, tx_skb,
+                                             ring->TxDescArray + entry);
+                        if (skb) {
+                                RTLDEV->stats.tx_dropped++;
+                                dev_kfree_skb_any(skb);
+                                tx_skb->skb = NULL;
+                        }
+                }
+        }
+}
+
+void
+rtl8125_tx_clear(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8125_tx_ring *ring = &tp->tx_ring[i];
+                rtl8125_tx_clear_range(tp, ring, ring->dirty_tx, ring->num_tx_desc);
+                ring->cur_tx = ring->dirty_tx = 0;
+        }
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8125_schedule_reset_work(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        set_bit(R8125_FLAG_TASK_RESET_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->reset_task, 4);
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+}
+
+static void rtl8125_schedule_esd_work(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        set_bit(R8125_FLAG_TASK_ESD_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->esd_task, RTL8125_ESD_TIMEOUT);
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+}
+
+static void rtl8125_schedule_linkchg_work(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        set_bit(R8125_FLAG_TASK_LINKCHG_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->linkchg_task, 4);
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+}
+
+static void rtl8125_schedule_link_work(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        set_bit(R8125_FLAG_TASK_LINK_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->link_task, RTL8125_LINK_TIMEOUT);
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+}
+
+static void rtl8125_schedule_dash_work(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        set_bit(R8125_FLAG_TASK_DASH_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->dash_task, RTL8125_DASH_TIMEOUT);
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+}
+
+#define rtl8125_cancel_schedule_reset_work(a)
+#define rtl8125_cancel_schedule_esd_work(a)
+#define rtl8125_cancel_schedule_linkchg_work(a)
+#define rtl8125_cancel_schedule_link_work(a)
+#define rtl8125_cancel_schedule_dash_work(a)
+
+#else
+static void rtl8125_schedule_reset_work(struct rtl8125_private *tp)
+{
+        set_bit(R8125_FLAG_TASK_RESET_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->reset_task, 4);
+}
+
+static void rtl8125_cancel_schedule_reset_work(struct rtl8125_private *tp)
+{
+        struct work_struct *work = &tp->reset_task.work;
+
+        if (!work->func)
+                return;
+
+        cancel_delayed_work_sync(&tp->reset_task);
+}
+
+static void rtl8125_schedule_esd_work(struct rtl8125_private *tp)
+{
+        set_bit(R8125_FLAG_TASK_ESD_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->esd_task, RTL8125_ESD_TIMEOUT);
+}
+
+static void rtl8125_cancel_schedule_esd_work(struct rtl8125_private *tp)
+{
+        struct work_struct *work = &tp->esd_task.work;
+
+        if (!work->func)
+                return;
+
+        cancel_delayed_work_sync(&tp->esd_task);
+}
+
+static void rtl8125_schedule_linkchg_work(struct rtl8125_private *tp)
+{
+        set_bit(R8125_FLAG_TASK_LINKCHG_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->linkchg_task, 4);
+}
+
+static void rtl8125_cancel_schedule_linkchg_work(struct rtl8125_private *tp)
+{
+        struct work_struct *work = &tp->linkchg_task.work;
+
+        if (!work->func)
+                return;
+
+        cancel_delayed_work_sync(&tp->linkchg_task);
+}
+
+static void rtl8125_schedule_link_work(struct rtl8125_private *tp)
+{
+        set_bit(R8125_FLAG_TASK_LINK_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->link_task, RTL8125_LINK_TIMEOUT);
+}
+
+static void rtl8125_cancel_schedule_link_work(struct rtl8125_private *tp)
+{
+        struct work_struct *work = &tp->link_task.work;
+
+        if (!work->func)
+                return;
+
+        cancel_delayed_work_sync(&tp->link_task);
+}
+
+void rtl8125_schedule_dash_work(struct rtl8125_private *tp)
+{
+        set_bit(R8125_FLAG_TASK_DASH_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->dash_task, RTL8125_DASH_TIMEOUT);
+}
+
+static void rtl8125_cancel_schedule_dash_work(struct rtl8125_private *tp)
+{
+        struct work_struct *work = &tp->dash_task.work;
+
+        if (!work->func)
+                return;
+
+        cancel_delayed_work_sync(&tp->dash_task);
+}
+#endif
+
+static void rtl8125_init_all_schedule_work(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+        INIT_WORK(&tp->reset_task, rtl8125_reset_task, dev);
+        INIT_WORK(&tp->esd_task, rtl8125_esd_task, dev);
+        INIT_WORK(&tp->linkchg_task, rtl8125_linkchg_task, dev);
+        INIT_WORK(&tp->link_task, rtl8125_link_task, dev);
+        INIT_WORK(&tp->dash_task, rtl8125_dash_task, dev);
+#else
+        INIT_DELAYED_WORK(&tp->reset_task, rtl8125_reset_task);
+        INIT_DELAYED_WORK(&tp->esd_task, rtl8125_esd_task);
+        INIT_DELAYED_WORK(&tp->linkchg_task, rtl8125_linkchg_task);
+        INIT_DELAYED_WORK(&tp->link_task, rtl8125_link_task);
+        INIT_DELAYED_WORK(&tp->dash_task, rtl8125_dash_task);
+#endif
+}
+
+static void rtl8125_cancel_all_schedule_work(struct rtl8125_private *tp)
+{
+        rtl8125_cancel_schedule_reset_work(tp);
+        rtl8125_cancel_schedule_esd_work(tp);
+        rtl8125_cancel_schedule_linkchg_work(tp);
+        rtl8125_cancel_schedule_link_work(tp);
+        rtl8125_cancel_schedule_dash_work(tp);
+}
+
+static void
+rtl8125_wait_for_irq_complete(struct rtl8125_private *tp)
+{
+        if (tp->features & RTL_FEATURE_MSIX) {
+                int i;
+                for (i = 0; i < tp->irq_nvecs; i++)
+                        synchronize_irq(tp->irq_tbl[i].vector);
+        } else {
+                synchronize_irq(tp->dev->irq);
+        }
+}
+
+void
+_rtl8125_wait_for_quiescence(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        /* Wait for any pending NAPI task to complete */
+#ifdef CONFIG_R8125_NAPI
+        rtl8125_disable_napi(tp);
+#endif//CONFIG_R8125_NAPI
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,67)
+        /* Give a racing hard_start_xmit a few cycles to complete. */
+        synchronize_net();
+#endif
+
+        rtl8125_irq_mask_and_ack(tp);
+
+        rtl8125_wait_for_irq_complete(tp);
+}
+
+static void
+rtl8125_wait_for_quiescence(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        //suppress unused variable
+        (void)(tp);
+
+        _rtl8125_wait_for_quiescence(dev);
+
+#ifdef CONFIG_R8125_NAPI
+        rtl8125_enable_napi(tp);
+#endif//CONFIG_R8125_NAPI
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8125_reset_task(void *_data)
+{
+        struct net_device *dev = _data;
+        struct rtl8125_private *tp = netdev_priv(dev);
+#else
+static void rtl8125_reset_task(struct work_struct *work)
+{
+        struct rtl8125_private *tp =
+                container_of(work, struct rtl8125_private, reset_task.work);
+        struct net_device *dev = tp->dev;
+#endif
+        int i;
+
+        rtnl_lock();
+
+        if (!netif_running(dev) ||
+            test_bit(R8125_FLAG_DOWN, tp->task_flags) ||
+            !test_and_clear_bit(R8125_FLAG_TASK_RESET_PENDING, tp->task_flags))
+                goto out_unlock;
+
+        netdev_err(dev, "Device reseting!\n");
+
+        netif_carrier_off(dev);
+        netif_tx_disable(dev);
+        _rtl8125_wait_for_quiescence(dev);
+        rtl8125_hw_reset(dev);
+
+        rtl8125_tx_clear(tp);
+
+        rtl8125_init_ring_indexes(tp);
+
+        rtl8125_tx_desc_init(tp);
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8125_rx_ring *ring;
+                u32 entry;
+
+                ring = &tp->rx_ring[i];
+                for (entry = 0; entry < ring->num_rx_desc; entry++) {
+                        struct RxDesc *desc;
+
+                        desc = rtl8125_get_rxdesc(tp, ring->RxDescArray, entry);
+                        rtl8125_mark_to_asic(tp, desc, tp->rx_buf_sz);
+                }
+        }
+
+#ifdef ENABLE_PTP_SUPPORT
+        rtl8125_ptp_reset(tp);
+#endif
+
+#ifdef CONFIG_R8125_NAPI
+        rtl8125_enable_napi(tp);
+#endif //CONFIG_R8125_NAPI
+
+        if (tp->resume_not_chg_speed) {
+                _rtl8125_check_link_status(dev, R8125_LINK_STATE_UNKNOWN);
+
+                tp->resume_not_chg_speed = 0;
+        } else {
+                rtl8125_enable_hw_linkchg_interrupt(tp);
+
+                rtl8125_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+        }
+
+out_unlock:
+        rtnl_unlock();
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8125_esd_task(void *_data)
+{
+        struct net_device *dev = _data;
+        struct rtl8125_private *tp = netdev_priv(dev);
+#else
+static void rtl8125_esd_task(struct work_struct *work)
+{
+        struct rtl8125_private *tp =
+                container_of(work, struct rtl8125_private, esd_task.work);
+        struct net_device *dev = tp->dev;
+#endif
+        rtnl_lock();
+
+        if (!netif_running(dev) ||
+            test_bit(R8125_FLAG_DOWN, tp->task_flags) ||
+            !test_and_clear_bit(R8125_FLAG_TASK_ESD_CHECK_PENDING, tp->task_flags))
+                goto out_unlock;
+
+        rtl8125_esd_checker(tp);
+
+        rtl8125_schedule_esd_work(tp);
+
+out_unlock:
+        rtnl_unlock();
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8125_linkchg_task(void *_data)
+{
+        struct net_device *dev = _data;
+        //struct rtl8125_private *tp = netdev_priv(dev);
+#else
+static void rtl8125_linkchg_task(struct work_struct *work)
+{
+        struct rtl8125_private *tp =
+                container_of(work, struct rtl8125_private, linkchg_task.work);
+        struct net_device *dev = tp->dev;
+#endif
+        rtnl_lock();
+
+        if (!netif_running(dev) ||
+            test_bit(R8125_FLAG_DOWN, tp->task_flags) ||
+            !test_and_clear_bit(R8125_FLAG_TASK_LINKCHG_CHECK_PENDING, tp->task_flags))
+                goto out_unlock;
+
+        rtl8125_check_link_status(dev);
+
+out_unlock:
+        rtnl_unlock();
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8125_link_task(void *_data)
+{
+        struct net_device *dev = _data;
+        //struct rtl8125_private *tp = netdev_priv(dev);
+#else
+static void rtl8125_link_task(struct work_struct *work)
+{
+        struct rtl8125_private *tp =
+                container_of(work, struct rtl8125_private, link_task.work);
+        struct net_device *dev = tp->dev;
+#endif
+        rtnl_lock();
+
+        if (!netif_running(dev) ||
+            test_bit(R8125_FLAG_DOWN, tp->task_flags) ||
+            !test_and_clear_bit(R8125_FLAG_TASK_LINK_CHECK_PENDING,
+                                tp->task_flags))
+                goto out_unlock;
+
+        if (netif_carrier_ok(dev) != tp->link_ok(dev))
+                rtl8125_schedule_linkchg_work(tp);
+
+        rtl8125_schedule_link_work(tp);
+
+out_unlock:
+        rtnl_unlock();
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8125_dash_task(void *_data)
+{
+        struct net_device *dev = _data;
+        //struct rtl8125_private *tp = netdev_priv(dev);
+#else
+static void rtl8125_dash_task(struct work_struct *work)
+{
+        struct rtl8125_private *tp =
+                container_of(work, struct rtl8125_private, dash_task.work);
+        struct net_device *dev = tp->dev;
+#endif
+        rtnl_lock();
+
+        if (!netif_running(dev) ||
+            test_bit(R8125_FLAG_DOWN, tp->task_flags) ||
+            !test_and_clear_bit(R8125_FLAG_TASK_DASH_CHECK_PENDING, tp->task_flags))
+                goto out_unlock;
+
+#ifdef ENABLE_DASH_SUPPORT
+        rtl8125_handle_dash_interrupt(dev);
+#endif
+
+out_unlock:
+        rtnl_unlock();
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+static void
+rtl8125_tx_timeout(struct net_device *dev, unsigned int txqueue)
+#else
+static void
+rtl8125_tx_timeout(struct net_device *dev)
+#endif
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        netdev_err(dev, "Transmit timeout reset Device!\n");
+
+        /* Let's wait a bit while any (async) irq lands on */
+        rtl8125_schedule_reset_work(tp);
+}
+
+static u32
+rtl8125_get_txd_opts1(struct rtl8125_tx_ring *ring,
+                      u32 opts1,
+                      u32 len,
+                      unsigned int entry)
+{
+        u32 status = opts1 | len;
+
+        if (entry == ring->num_tx_desc - 1)
+                status |= RingEnd;
+
+        return status;
+}
+
+static int
+rtl8125_xmit_frags(struct rtl8125_private *tp,
+                   struct rtl8125_tx_ring *ring,
+                   struct sk_buff *skb,
+                   const u32 *opts)
+{
+        struct skb_shared_info *info = skb_shinfo(skb);
+        unsigned int cur_frag, entry;
+        struct TxDesc *txd = NULL;
+        const unsigned char nr_frags = info->nr_frags;
+        unsigned long PktLenCnt = 0;
+        bool LsoPatchEnabled = FALSE;
+
+        entry = ring->cur_tx;
+        for (cur_frag = 0; cur_frag < nr_frags; cur_frag++) {
+                skb_frag_t *frag = info->frags + cur_frag;
+                dma_addr_t mapping;
+                u32 status, len;
+                void *addr;
+
+                entry = (entry + 1) % ring->num_tx_desc;
+
+                txd = ring->TxDescArray + entry;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0)
+                len = frag->size;
+                addr = ((void *) page_address(frag->page)) + frag->page_offset;
+#else
+                len = skb_frag_size(frag);
+                addr = skb_frag_address(frag);
+#endif
+                if (tp->RequireLSOPatch  &&
+                    (cur_frag == nr_frags - 1) &&
+                    (opts[0] & (GiantSendv4|GiantSendv6)) &&
+                    PktLenCnt < ETH_FRAME_LEN &&
+                    len > 1) {
+                        len -= 1;
+                        mapping = dma_map_single(tp_to_dev(tp), addr, len, DMA_TO_DEVICE);
+
+                        if (unlikely(dma_mapping_error(tp_to_dev(tp), mapping))) {
+                                if (unlikely(net_ratelimit()))
+                                        netif_err(tp, drv, tp->dev,
+                                                  "Failed to map TX fragments DMA!\n");
+                                goto err_out;
+                        }
+
+                        /* anti gcc 2.95.3 bugware (sic) */
+                        status = rtl8125_get_txd_opts1(ring, opts[0], len, entry);
+
+                        txd->addr = cpu_to_le64(mapping);
+
+                        ring->tx_skb[entry].len = len;
+
+                        txd->opts2 = cpu_to_le32(opts[1]);
+                        wmb();
+                        txd->opts1 = cpu_to_le32(status);
+
+                        //second txd
+                        addr += len;
+                        len = 1;
+                        entry = (entry + 1) % ring->num_tx_desc;
+                        txd = ring->TxDescArray + entry;
+                        cur_frag += 1;
+
+                        LsoPatchEnabled = TRUE;
+                }
+
+                mapping = dma_map_single(tp_to_dev(tp), addr, len, DMA_TO_DEVICE);
+
+                if (unlikely(dma_mapping_error(tp_to_dev(tp), mapping))) {
+                        if (unlikely(net_ratelimit()))
+                                netif_err(tp, drv, tp->dev,
+                                          "Failed to map TX fragments DMA!\n");
+                        goto err_out;
+                }
+
+                /* anti gcc 2.95.3 bugware (sic) */
+                status = rtl8125_get_txd_opts1(ring, opts[0], len, entry);
+                if (cur_frag == (nr_frags - 1) || LsoPatchEnabled == TRUE)
+                        status |= LastFrag;
+
+                txd->addr = cpu_to_le64(mapping);
+
+                ring->tx_skb[entry].len = len;
+
+                txd->opts2 = cpu_to_le32(opts[1]);
+                wmb();
+                txd->opts1 = cpu_to_le32(status);
+
+                PktLenCnt += len;
+        }
+
+        return cur_frag;
+
+err_out:
+        rtl8125_tx_clear_range(tp, ring, ring->cur_tx + 1, cur_frag);
+        return -EIO;
+}
+
+static inline
+__be16 get_protocol(struct sk_buff *skb)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+        return vlan_get_protocol(skb);
+#else
+        __be16 protocol;
+
+        if (skb->protocol == htons(ETH_P_8021Q))
+                protocol = vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;
+        else
+                protocol = skb->protocol;
+
+        return protocol;
+#endif
+}
+
+static inline
+u8 rtl8125_get_l4_protocol(struct sk_buff *skb)
+{
+        int no = skb_network_offset(skb);
+        struct ipv6hdr *i6h, _i6h;
+        struct iphdr *ih, _ih;
+        u8 ip_protocol = IPPROTO_RAW;
+
+        switch (get_protocol(skb)) {
+        case  __constant_htons(ETH_P_IP):
+                ih = skb_header_pointer(skb, no, sizeof(_ih), &_ih);
+                if (ih)
+                        ip_protocol = ih->protocol;
+                break;
+        case  __constant_htons(ETH_P_IPV6):
+                i6h = skb_header_pointer(skb, no, sizeof(_i6h), &_i6h);
+                if (i6h)
+                        ip_protocol = i6h->nexthdr;
+                break;
+        }
+
+        return ip_protocol;
+}
+
+static bool rtl8125_skb_pad_with_len(struct sk_buff *skb, unsigned int len)
+{
+        if (skb_padto(skb, len))
+                return false;
+        skb_put(skb, len - skb->len);
+        return true;
+}
+
+static bool rtl8125_skb_pad(struct sk_buff *skb)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0)
+        return rtl8125_skb_pad_with_len(skb, ETH_ZLEN);
+#else
+        return !eth_skb_pad(skb);
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+/* msdn_giant_send_check()
+ * According to the document of microsoft, the TCP Pseudo Header excludes the
+ * packet length for IPv6 TCP large packets.
+ */
+static int msdn_giant_send_check(struct sk_buff *skb)
+{
+        const struct ipv6hdr *ipv6h;
+        struct tcphdr *th;
+        int ret;
+
+        ret = skb_cow_head(skb, 0);
+        if (ret)
+                return ret;
+
+        ipv6h = ipv6_hdr(skb);
+        th = tcp_hdr(skb);
+
+        th->check = 0;
+        th->check = ~tcp_v6_check(0, &ipv6h->saddr, &ipv6h->daddr, 0);
+
+        return ret;
+}
+#endif
+
+static bool rtl8125_require_pad_ptp_pkt(struct rtl8125_private *tp)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_2 ... CFG_METHOD_7:
+                return true;
+        default:
+                return false;
+        }
+}
+
+#define MIN_PATCH_LEN (47)
+static u32
+rtl8125_get_patch_pad_len(struct rtl8125_private *tp,
+                          struct sk_buff *skb)
+{
+        u32 pad_len = 0;
+        int trans_data_len;
+        u32 hdr_len;
+        u32 pkt_len = skb->len;
+        u8 ip_protocol;
+        bool has_trans = skb_transport_header_was_set(skb);
+
+        if (!rtl8125_require_pad_ptp_pkt(tp))
+                goto no_padding;
+
+        if (!(has_trans && (pkt_len < 175))) //128 + MIN_PATCH_LEN
+                goto no_padding;
+
+        ip_protocol = rtl8125_get_l4_protocol(skb);
+        if (!(ip_protocol == IPPROTO_TCP || ip_protocol == IPPROTO_UDP))
+                goto no_padding;
+
+        trans_data_len = pkt_len -
+                         (skb->transport_header -
+                          skb_headroom(skb));
+        if (ip_protocol == IPPROTO_UDP) {
+                if (trans_data_len > 3 && trans_data_len < MIN_PATCH_LEN) {
+                        u16 dest_port = 0;
+
+                        skb_copy_bits(skb, skb->transport_header - skb_headroom(skb) + 2, &dest_port, 2);
+                        dest_port = ntohs(dest_port);
+
+                        if (dest_port == 0x13f ||
+                            dest_port == 0x140) {
+                                pad_len = MIN_PATCH_LEN - trans_data_len;
+                                goto out;
+                        }
+                }
+        }
+
+        hdr_len = 0;
+        if (ip_protocol == IPPROTO_TCP)
+                hdr_len = 20;
+        else if (ip_protocol == IPPROTO_UDP)
+                hdr_len = 8;
+        if (trans_data_len < hdr_len)
+                pad_len = hdr_len - trans_data_len;
+
+out:
+        if ((pkt_len + pad_len) < ETH_ZLEN)
+                pad_len = ETH_ZLEN - pkt_len;
+
+        return pad_len;
+
+no_padding:
+
+        return 0;
+}
+
+static bool
+rtl8125_tso_csum(struct sk_buff *skb,
+                 struct net_device *dev,
+                 u32 *opts,
+                 unsigned int *bytecount,
+                 unsigned short *gso_segs)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long large_send = 0;
+        u32 csum_cmd = 0;
+        u8 sw_calc_csum = false;
+        u8 check_patch_required = true;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        if (dev->features & (NETIF_F_TSO | NETIF_F_TSO6)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+                u32 mss = skb_shinfo(skb)->tso_size;
+#else
+                u32 mss = skb_shinfo(skb)->gso_size;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+
+                /* TCP Segmentation Offload (or TCP Large Send) */
+                if (mss) {
+                        union {
+                                struct iphdr *v4;
+                                struct ipv6hdr *v6;
+                                unsigned char *hdr;
+                        } ip;
+                        union {
+                                struct tcphdr *tcp;
+                                struct udphdr *udp;
+                                unsigned char *hdr;
+                        } l4;
+                        u32 l4_offset, hdr_len;
+
+                        ip.hdr = skb_network_header(skb);
+                        l4.hdr = skb_checksum_start(skb);
+
+                        l4_offset = skb_transport_offset(skb);
+                        assert((l4_offset%2) == 0);
+                        switch (get_protocol(skb)) {
+                        case __constant_htons(ETH_P_IP):
+                                if (l4_offset <= GTTCPHO_MAX) {
+                                        opts[0] |= GiantSendv4;
+                                        opts[0] |= l4_offset << GTTCPHO_SHIFT;
+                                        opts[1] |= min(mss, MSS_MAX) << 18;
+                                        large_send = 1;
+                                }
+                                break;
+                        case __constant_htons(ETH_P_IPV6):
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+                                if (msdn_giant_send_check(skb))
+                                        return false;
+#endif
+                                if (l4_offset <= GTTCPHO_MAX) {
+                                        opts[0] |= GiantSendv6;
+                                        opts[0] |= l4_offset << GTTCPHO_SHIFT;
+                                        opts[1] |= min(mss, MSS_MAX) << 18;
+                                        large_send = 1;
+                                }
+                                break;
+                        default:
+                                if (unlikely(net_ratelimit()))
+                                        dprintk("tso proto=%x!\n", skb->protocol);
+                                break;
+                        }
+
+                        if (large_send == 0)
+                                return false;
+
+
+                        /* compute length of segmentation header */
+                        hdr_len = (l4.tcp->doff * 4) + l4_offset;
+                        /* update gso size and bytecount with header size */
+                        *gso_segs = skb_shinfo(skb)->gso_segs;
+                        *bytecount += (*gso_segs - 1) * hdr_len;
+
+                        return true;
+                }
+        }
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+
+        if (skb->ip_summed == CHECKSUM_PARTIAL) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+                const struct iphdr *ip = skb->nh.iph;
+
+                if (dev->features & NETIF_F_IP_CSUM) {
+                        if (ip->protocol == IPPROTO_TCP)
+                                csum_cmd = tp->tx_ip_csum_cmd | tp->tx_tcp_csum_cmd;
+                        else if (ip->protocol == IPPROTO_UDP)
+                                csum_cmd = tp->tx_ip_csum_cmd | tp->tx_udp_csum_cmd;
+                        else if (ip->protocol == IPPROTO_IP)
+                                csum_cmd = tp->tx_ip_csum_cmd;
+                }
+#else
+                u8 ip_protocol = IPPROTO_RAW;
+
+                switch (get_protocol(skb)) {
+                case  __constant_htons(ETH_P_IP):
+                        if (dev->features & NETIF_F_IP_CSUM) {
+                                ip_protocol = ip_hdr(skb)->protocol;
+                                csum_cmd = tp->tx_ip_csum_cmd;
+                        }
+                        break;
+                case  __constant_htons(ETH_P_IPV6):
+                        if (dev->features & NETIF_F_IPV6_CSUM) {
+                                if (skb_transport_offset(skb) > 0 && skb_transport_offset(skb) <= TCPHO_MAX) {
+                                        ip_protocol = ipv6_hdr(skb)->nexthdr;
+                                        csum_cmd = tp->tx_ipv6_csum_cmd;
+                                        csum_cmd |= skb_transport_offset(skb) << TCPHO_SHIFT;
+                                }
+                        }
+                        break;
+                default:
+                        if (unlikely(net_ratelimit()))
+                                dprintk("checksum_partial proto=%x!\n", skb->protocol);
+                        break;
+                }
+
+                if (ip_protocol == IPPROTO_TCP)
+                        csum_cmd |= tp->tx_tcp_csum_cmd;
+                else if (ip_protocol == IPPROTO_UDP)
+                        csum_cmd |= tp->tx_udp_csum_cmd;
+#endif
+                if (csum_cmd == 0) {
+                        sw_calc_csum = true;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                        WARN_ON(1); /* we need a WARN() */
+#endif
+                }
+
+                if (ip_protocol == IPPROTO_TCP)
+                        check_patch_required = false;
+        }
+
+        if (check_patch_required) {
+                u32 pad_len = rtl8125_get_patch_pad_len(tp, skb);
+
+                if (pad_len > 0) {
+                        if (!rtl8125_skb_pad_with_len(skb, skb->len + pad_len))
+                                return false;
+
+                        if (csum_cmd != 0)
+                                sw_calc_csum = true;
+                }
+        }
+
+        if (skb->len < ETH_ZLEN) {
+                if (tp->UseSwPaddingShortPkt ||
+                    (tp->ShortPacketSwChecksum && csum_cmd != 0)) {
+                        if (!rtl8125_skb_pad(skb))
+                                return false;
+
+                        if (csum_cmd != 0)
+                                sw_calc_csum = true;
+                }
+        }
+
+        if (sw_calc_csum) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,7)
+                skb_checksum_help(&skb, 0);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)
+                skb_checksum_help(skb, 0);
+#else
+                skb_checksum_help(skb);
+#endif
+        } else
+                opts[1] |= csum_cmd;
+
+        return true;
+}
+
+static bool rtl8125_tx_slots_avail(struct rtl8125_private *tp,
+                                   struct rtl8125_tx_ring *ring)
+{
+        unsigned int slots_avail = READ_ONCE(ring->dirty_tx) + ring->num_tx_desc
+                                   - READ_ONCE(ring->cur_tx);
+
+        /* A skbuff with nr_frags needs nr_frags+1 entries in the tx queue */
+        return slots_avail > MAX_SKB_FRAGS;
+}
+
+static inline u32
+rtl8125_fast_mod_mask(const u32 input, const u32 mask)
+{
+        return input > mask ? input & mask : input;
+}
+
+static void rtl8125_doorbell(struct rtl8125_private *tp,
+                             struct rtl8125_tx_ring *ring)
+{
+        if (tp->EnableTxNoClose) {
+                if (tp->HwSuppTxNoCloseVer > 3)
+                        RTL_W32(tp, ring->sw_tail_ptr_reg, ring->cur_tx);
+                else
+                        RTL_W16(tp, ring->sw_tail_ptr_reg, ring->cur_tx);
+        } else
+                RTL_W16(tp, TPPOLL_8125, BIT(ring->index));    /* set polling bit */
+}
+
+static netdev_tx_t
+rtl8125_start_xmit(struct sk_buff *skb,
+                   struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned int   bytecount;
+        unsigned short gso_segs;
+        struct ring_info *last;
+        unsigned int last_entry;
+        unsigned int entry;
+        struct TxDesc *txd;
+        dma_addr_t mapping;
+        u32 len;
+        u32 opts[2];
+        netdev_tx_t ret = NETDEV_TX_OK;
+        int frags;
+        u8 EnableTxNoClose = tp->EnableTxNoClose;
+        const u16 queue_mapping = skb_get_queue_mapping(skb);
+        struct rtl8125_tx_ring *ring;
+        bool stop_queue;
+
+        assert(queue_mapping < tp->num_tx_rings);
+
+        ring = &tp->tx_ring[queue_mapping];
+
+        if (unlikely(!rtl8125_tx_slots_avail(tp, ring))) {
+                if (netif_msg_drv(tp)) {
+                        printk(KERN_ERR
+                               "%s: BUG! Tx Ring[%d] full when queue awake!\n",
+                               dev->name,
+                               queue_mapping);
+                }
+                goto err_stop;
+        }
+
+        entry = ring->cur_tx % ring->num_tx_desc;
+        txd = ring->TxDescArray + entry;
+
+        if (!EnableTxNoClose) {
+                if (unlikely(le32_to_cpu(txd->opts1) & DescOwn)) {
+                        if (netif_msg_drv(tp)) {
+                                printk(KERN_ERR
+                                       "%s: BUG! Tx Desc is own by hardware!\n",
+                                       dev->name);
+                        }
+                        goto err_stop;
+                }
+        }
+
+        bytecount = skb->len;
+        gso_segs = 1;
+
+        opts[0] = DescOwn;
+        opts[1] = rtl8125_tx_vlan_tag(tp, skb);
+
+        if (unlikely(!rtl8125_tso_csum(skb, dev, opts, &bytecount, &gso_segs)))
+                goto err_dma_0;
+
+        frags = rtl8125_xmit_frags(tp, ring, skb, opts);
+        if (unlikely(frags < 0))
+                goto err_dma_0;
+        if (frags) {
+                len = skb_headlen(skb);
+                opts[0] |= FirstFrag;
+        } else {
+                len = skb->len;
+                opts[0] |= FirstFrag | LastFrag;
+        }
+
+        opts[0] = rtl8125_get_txd_opts1(ring, opts[0], len, entry);
+        mapping = dma_map_single(tp_to_dev(tp), skb->data, len, DMA_TO_DEVICE);
+        if (unlikely(dma_mapping_error(tp_to_dev(tp), mapping))) {
+                if (unlikely(net_ratelimit()))
+                        netif_err(tp, drv, dev, "Failed to map TX DMA!\n");
+                goto err_dma_1;
+        }
+
+#ifdef ENABLE_PTP_SUPPORT
+        if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {
+                if (!test_and_set_bit_lock(__RTL8125_PTP_TX_IN_PROGRESS, &tp->state)) {
+                        if (tp->hwtstamp_config.tx_type == HWTSTAMP_TX_ON &&
+                            !tp->ptp_tx_skb) {
+                                skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+
+                                tp->ptp_tx_skb = skb_get(skb);
+                                tp->ptp_tx_start = jiffies;
+                                schedule_work(&tp->ptp_tx_work);
+                        } else
+                                tp->tx_hwtstamp_skipped++;
+                }
+        }
+#endif
+        /* set first fragment's length */
+        ring->tx_skb[entry].len = len;
+
+        /* set skb to last fragment */
+        last_entry = (entry + frags) % ring->num_tx_desc;
+        last = &ring->tx_skb[last_entry];
+        last->skb = skb;
+        last->gso_segs = gso_segs;
+        last->bytecount = bytecount;
+
+        txd->addr = cpu_to_le64(mapping);
+        txd->opts2 = cpu_to_le32(opts[1]);
+        wmb();
+        txd->opts1 = cpu_to_le32(opts[0]);
+
+        netdev_tx_sent_queue(txring_txq(ring), bytecount);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+        dev->trans_start = jiffies;
+#else
+        skb_tx_timestamp(skb);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+
+        /* rtl_tx needs to see descriptor changes before updated tp->cur_tx */
+        smp_wmb();
+
+        WRITE_ONCE(ring->cur_tx, ring->cur_tx + frags + 1);
+
+        stop_queue = !rtl8125_tx_slots_avail(tp, ring);
+        if (unlikely(stop_queue)) {
+                /* Avoid wrongly optimistic queue wake-up: rtl_tx thread must
+                 * not miss a ring update when it notices a stopped queue.
+                 */
+                smp_wmb();
+                netif_stop_subqueue(dev, queue_mapping);
+        }
+
+        if (netif_xmit_stopped(txring_txq(ring)) || !netdev_xmit_more())
+                rtl8125_doorbell(tp, ring);
+
+        if (unlikely(stop_queue)) {
+                /* Sync with rtl_tx:
+                 * - publish queue status and cur_tx ring index (write barrier)
+                 * - refresh dirty_tx ring index (read barrier).
+                 * May the current thread have a pessimistic view of the ring
+                 * status and forget to wake up queue, a racing rtl_tx thread
+                 * can't.
+                 */
+                smp_mb();
+                if (rtl8125_tx_slots_avail(tp, ring))
+                        netif_start_subqueue(dev, queue_mapping);
+        }
+out:
+        return ret;
+err_dma_1:
+        rtl8125_tx_clear_range(tp, ring, ring->cur_tx + 1, frags);
+err_dma_0:
+        RTLDEV->stats.tx_dropped++;
+        dev_kfree_skb_any(skb);
+        ret = NETDEV_TX_OK;
+        goto out;
+err_stop:
+        netif_stop_subqueue(dev, queue_mapping);
+        ret = NETDEV_TX_BUSY;
+        RTLDEV->stats.tx_dropped++;
+        goto out;
+}
+
+/* recycle tx no close desc*/
+static int
+rtl8125_tx_interrupt_noclose(struct rtl8125_tx_ring *ring, int budget)
+{
+        unsigned int total_bytes = 0, total_packets = 0;
+        struct rtl8125_private *tp = ring->priv;
+        struct net_device *dev = tp->dev;
+        unsigned int dirty_tx, tx_left;
+        unsigned int tx_desc_closed;
+        unsigned int count = 0;
+
+        dirty_tx = ring->dirty_tx;
+        ring->NextHwDesCloPtr = rtl8125_get_hw_clo_ptr(ring);
+        tx_desc_closed = rtl8125_fast_mod_mask(ring->NextHwDesCloPtr -
+                                               ring->BeginHwDesCloPtr,
+                                               tp->MaxTxDescPtrMask);
+        tx_left = min((READ_ONCE(ring->cur_tx) - dirty_tx), tx_desc_closed);
+        ring->BeginHwDesCloPtr += tx_left;
+
+        while (tx_left > 0) {
+                unsigned int entry = dirty_tx % ring->num_tx_desc;
+                struct ring_info *tx_skb = ring->tx_skb + entry;
+
+                rtl8125_unmap_tx_skb(tp->pci_dev,
+                                     tx_skb,
+                                     ring->TxDescArray + entry);
+
+                if (tx_skb->skb != NULL) {
+                        /* update the statistics for this packet */
+                        total_bytes += tx_skb->bytecount;
+                        total_packets += tx_skb->gso_segs;
+
+                        RTL_NAPI_CONSUME_SKB_ANY(tx_skb->skb, budget);
+                        tx_skb->skb = NULL;
+                }
+                dirty_tx++;
+                tx_left--;
+        }
+
+        if (total_packets) {
+                netdev_tx_completed_queue(txring_txq(ring),
+                                          total_packets, total_bytes);
+
+                RTLDEV->stats.tx_bytes += total_bytes;
+                RTLDEV->stats.tx_packets+= total_packets;
+        }
+
+        if (ring->dirty_tx != dirty_tx) {
+                count = dirty_tx - ring->dirty_tx;
+                WRITE_ONCE(ring->dirty_tx, dirty_tx);
+                smp_wmb();
+                if (__netif_subqueue_stopped(dev, ring->index) &&
+                    rtl8125_tx_slots_avail(tp, ring) && netif_carrier_ok(dev)) {
+                        netif_start_subqueue(dev, ring->index);
+                }
+        }
+
+        return count;
+}
+
+/* recycle tx close desc*/
+static int
+rtl8125_tx_interrupt_close(struct rtl8125_tx_ring *ring, int budget)
+{
+        unsigned int total_bytes = 0, total_packets = 0;
+        struct rtl8125_private *tp = ring->priv;
+        struct net_device *dev = tp->dev;
+        unsigned int dirty_tx, tx_left;
+        unsigned int count = 0;
+
+        dirty_tx = ring->dirty_tx;
+        tx_left = READ_ONCE(ring->cur_tx) - dirty_tx;
+
+        while (tx_left > 0) {
+                unsigned int entry = dirty_tx % ring->num_tx_desc;
+                struct ring_info *tx_skb = ring->tx_skb + entry;
+
+                if (le32_to_cpu(READ_ONCE(ring->TxDescArray[entry].opts1)) & DescOwn)
+                        break;
+
+                rtl8125_unmap_tx_skb(tp->pci_dev,
+                                     tx_skb,
+                                     ring->TxDescArray + entry);
+
+                if (tx_skb->skb != NULL) {
+                        /* update the statistics for this packet */
+                        total_bytes += tx_skb->bytecount;
+                        total_packets += tx_skb->gso_segs;
+
+                        RTL_NAPI_CONSUME_SKB_ANY(tx_skb->skb, budget);
+                        tx_skb->skb = NULL;
+                }
+                dirty_tx++;
+                tx_left--;
+        }
+
+        if (total_packets) {
+                netdev_tx_completed_queue(txring_txq(ring),
+                                          total_packets, total_bytes);
+
+                RTLDEV->stats.tx_bytes += total_bytes;
+                RTLDEV->stats.tx_packets+= total_packets;
+        }
+
+        if (ring->dirty_tx != dirty_tx) {
+                count = dirty_tx - ring->dirty_tx;
+                WRITE_ONCE(ring->dirty_tx, dirty_tx);
+                smp_wmb();
+                if (__netif_subqueue_stopped(dev, ring->index) &&
+                    rtl8125_tx_slots_avail(tp, ring) && netif_carrier_ok(dev)) {
+                        netif_start_subqueue(dev, ring->index);
+                }
+
+                if (READ_ONCE(ring->cur_tx) != dirty_tx)
+                        rtl8125_doorbell(tp, ring);
+        }
+
+        return count;
+}
+
+static int
+rtl8125_tx_interrupt(struct rtl8125_tx_ring *ring, int budget)
+{
+        struct rtl8125_private *tp = ring->priv;
+
+        if (tp->EnableTxNoClose)
+                return rtl8125_tx_interrupt_noclose(ring, budget);
+        else
+                return rtl8125_tx_interrupt_close(ring, budget);
+}
+
+static int
+rtl8125_tx_interrupt_with_vector(struct rtl8125_private *tp,
+                                 const int message_id,
+                                 int budget)
+{
+        int count = 0;
+
+        switch (tp->HwCurrIsrVer) {
+        case 3:
+        case 4:
+                if (message_id < tp->num_tx_rings)
+                        count += rtl8125_tx_interrupt(&tp->tx_ring[message_id], budget);
+                break;
+        case 5:
+                if (message_id == 16)
+                        count += rtl8125_tx_interrupt(&tp->tx_ring[0], budget);
+#ifdef ENABLE_MULTIPLE_TX_QUEUE
+                else if (message_id == 17 && tp->num_tx_rings > 1)
+                        count += rtl8125_tx_interrupt(&tp->tx_ring[1], budget);
+#endif
+                break;
+        case 7:
+                if (message_id == 27)
+                        count += rtl8125_tx_interrupt(&tp->tx_ring[0], budget);
+#ifdef ENABLE_MULTIPLE_TX_QUEUE
+                else if (message_id == 28 && tp->num_tx_rings > 1)
+                        count += rtl8125_tx_interrupt(&tp->tx_ring[1], budget);
+#endif
+                break;
+        default:
+                if (message_id == 16)
+                        count += rtl8125_tx_interrupt(&tp->tx_ring[0], budget);
+#ifdef ENABLE_MULTIPLE_TX_QUEUE
+                else if (message_id == 18 && tp->num_tx_rings > 1)
+                        count += rtl8125_tx_interrupt(&tp->tx_ring[1], budget);
+#endif
+                break;
+        }
+
+        return count;
+}
+
+static inline int
+rtl8125_fragmented_frame(struct rtl8125_private *tp, u32 status)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                return (status & (FirstFrag_V3 | LastFrag_V3)) != (FirstFrag_V3 | LastFrag_V3);
+        case RX_DESC_RING_TYPE_4:
+                return (status & (FirstFrag_V4 | LastFrag_V4)) != (FirstFrag_V4 | LastFrag_V4);
+        default:
+                return (status & (FirstFrag | LastFrag)) != (FirstFrag | LastFrag);
+        }
+}
+
+static inline int
+rtl8125_is_non_eop(struct rtl8125_private *tp, u32 status)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                return !(status & LastFrag_V3);
+        case RX_DESC_RING_TYPE_4:
+                return !(status & LastFrag_V4);
+        default:
+                return !(status & LastFrag);
+        }
+}
+
+static inline int
+rtl8125_rx_desc_type(u32 status)
+{
+        return ((status >> 26) & 0x0F);
+}
+
+static inline void
+rtl8125_rx_v1_csum(struct rtl8125_private *tp,
+                   struct sk_buff *skb,
+                   struct RxDesc *desc)
+{
+        u32 opts1 = le32_to_cpu(desc->opts1);
+
+        if (((opts1 & RxTCPT) && !(opts1 & RxTCPF)) ||
+            ((opts1 & RxUDPT) && !(opts1 & RxUDPF)))
+                skb->ip_summed = CHECKSUM_UNNECESSARY;
+        else
+                skb_checksum_none_assert(skb);
+}
+
+static inline void
+rtl8125_rx_v3_csum(struct rtl8125_private *tp,
+                   struct sk_buff *skb,
+                   struct RxDescV3 *descv3)
+{
+        u32 opts2 = le32_to_cpu(descv3->RxDescNormalDDWord4.opts2);
+
+        /* rx csum offload for RTL8125 */
+        if (((opts2 & RxTCPT_v3) && !(opts2 & RxTCPF_v3)) ||
+            ((opts2 & RxUDPT_v3) && !(opts2 & RxUDPF_v3)))
+                skb->ip_summed = CHECKSUM_UNNECESSARY;
+        else
+                skb_checksum_none_assert(skb);
+}
+
+static inline void
+rtl8125_rx_v4_csum(struct rtl8125_private *tp,
+                   struct sk_buff *skb,
+                   struct RxDescV4 *descv4)
+{
+        u32 opts1 = le32_to_cpu(descv4->RxDescNormalDDWord2.opts1);
+
+        /* rx csum offload for RTL8125 */
+        if (((opts1 & RxTCPT_v4) && !(opts1 & RxTCPF_v4)) ||
+            ((opts1 & RxUDPT_v4) && !(opts1 & RxUDPF_v4)))
+                skb->ip_summed = CHECKSUM_UNNECESSARY;
+        else
+                skb_checksum_none_assert(skb);
+}
+
+static inline void
+rtl8125_rx_csum(struct rtl8125_private *tp,
+                struct sk_buff *skb,
+                struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                rtl8125_rx_v3_csum(tp, skb, (struct RxDescV3 *)desc);
+                break;
+        case RX_DESC_RING_TYPE_4:
+                rtl8125_rx_v4_csum(tp, skb, (struct RxDescV4 *)desc);
+                break;
+        default:
+                rtl8125_rx_v1_csum(tp, skb, desc);
+                break;
+        }
+}
+
+/*
+static inline int
+rtl8125_try_rx_copy(struct rtl8125_private *tp,
+                    struct rtl8125_rx_ring *ring,
+                    struct sk_buff **sk_buff,
+                    int pkt_size,
+                    struct RxDesc *desc,
+                    int rx_buf_sz)
+{
+        int ret = -1;
+
+        struct sk_buff *skb;
+
+        skb = RTL_ALLOC_SKB_INTR(&tp->r8125napi[ring->index].napi, pkt_size + R8125_RX_ALIGN);
+        if (skb) {
+                u8 *data;
+
+                data = sk_buff[0]->data;
+                if (!R8125_USE_NAPI_ALLOC_SKB)
+                    skb_reserve(skb, R8125_RX_ALIGN);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
+                prefetch(data - R8125_RX_ALIGN);
+#endif
+                eth_copy_and_sum(skb, data, pkt_size, 0);
+                *sk_buff = skb;
+                rtl8125_mark_to_asic(tp, desc, rx_buf_sz);
+                ret = 0;
+        }
+
+        return ret;
+}
+*/
+
+static inline void
+rtl8125_rx_skb(struct rtl8125_private *tp,
+               struct sk_buff *skb,
+               u32 ring_index)
+{
+#ifdef CONFIG_R8125_NAPI
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+        netif_receive_skb(skb);
+#else
+        napi_gro_receive(&tp->r8125napi[ring_index].napi, skb);
+#endif
+#else
+        netif_rx(skb);
+#endif
+}
+
+static int
+rtl8125_check_rx_desc_error(struct net_device *dev,
+                            struct rtl8125_private *tp,
+                            u32 status)
+{
+        int ret = 0;
+
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                if (unlikely(status & RxRES_V3)) {
+                        if (status & (RxRWT_V3 | RxRUNT_V3))
+                                RTLDEV->stats.rx_length_errors++;
+                        if (status & RxCRC_V3)
+                                RTLDEV->stats.rx_crc_errors++;
+
+                        ret = -1;
+                }
+                break;
+        case RX_DESC_RING_TYPE_4:
+                if (unlikely(status & RxRES_V4)) {
+                        if (status & RxRUNT_V4)
+                                RTLDEV->stats.rx_length_errors++;
+                        if (status & RxCRC_V4)
+                                RTLDEV->stats.rx_crc_errors++;
+
+                        ret = -1;
+                }
+                break;
+        default:
+                if (unlikely(status & RxRES)) {
+                        if (status & (RxRWT | RxRUNT))
+                                RTLDEV->stats.rx_length_errors++;
+                        if (status & RxCRC)
+                                RTLDEV->stats.rx_crc_errors++;
+
+                        ret = -1;
+                }
+                break;
+        }
+
+        return ret;
+}
+
+#ifdef ENABLE_PAGE_REUSE
+
+static inline bool
+rtl8125_reuse_rx_ok(struct page *page)
+{
+        /* avoid re-using remote pages */
+        if (!dev_page_is_reusable(page)) {
+                //printk(KERN_INFO "r8125 page pfmemalloc, can't reuse!\n");
+                return false;
+        }
+        /* if we are only owner of page we can reuse it */
+        if (unlikely(page_ref_count(page) != 1)) {
+                //printk(KERN_INFO "r8125 page refcnt %d, can't reuse!\n", page_ref_count(page));
+                return false;
+        }
+
+        return true;
+}
+
+static void
+rtl8125_reuse_rx_buffer(struct rtl8125_private *tp, struct rtl8125_rx_ring *ring, u32 cur_rx, struct rtl8125_rx_buffer *rxb)
+{
+        struct page *page = rxb->page;
+
+        u32 dirty_rx = ring->dirty_rx;
+        u32 entry = dirty_rx % ring->num_rx_desc;
+        struct rtl8125_rx_buffer *nrxb = &ring->rx_buffer[entry];
+
+        u32 noffset;
+
+        //the page gonna be shared by us and kernel, keep page ref = 2
+        page_ref_inc(page);
+
+        //flip the buffer in page to use next
+        noffset = rxb->page_offset ^ (tp->rx_buf_page_size / 2); //one page, two buffer, ping-pong
+
+        nrxb->dma = rxb->dma;
+        nrxb->page_offset = noffset;
+        nrxb->data = rxb->data;
+
+        if (cur_rx != dirty_rx) {
+                //move the buffer to other slot
+                nrxb->page = page;
+                rxb->page = NULL;
+        }
+}
+
+static void rtl8125_put_rx_buffer(struct rtl8125_private *tp,
+                                  struct rtl8125_rx_ring *ring,
+                                  u32 cur_rx,
+                                  struct rtl8125_rx_buffer *rxb)
+{
+        struct rtl8125_rx_buffer *nrxb;
+        struct page *page = rxb->page;
+        u32 entry;
+
+        entry = ring->dirty_rx % ring->num_rx_desc;
+        nrxb = &ring->rx_buffer[entry];
+        if (likely(rtl8125_reuse_rx_ok(page))) {
+                /* hand second half of page back to the ring */
+                rtl8125_reuse_rx_buffer(tp, ring, cur_rx, rxb);
+        } else {
+                tp->page_reuse_fail_cnt++;
+
+                dma_unmap_page_attrs(&tp->pci_dev->dev, rxb->dma,
+                                     tp->rx_buf_page_size,
+                                     DMA_FROM_DEVICE,
+                                     (DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING));
+                //the page ref is kept 1, uniquely owned by kernel now
+                rxb->page = NULL;
+
+                return;
+        }
+
+        dma_sync_single_range_for_device(tp_to_dev(tp),
+                                         nrxb->dma,
+                                         nrxb->page_offset,
+                                         tp->rx_buf_sz,
+                                         DMA_FROM_DEVICE);
+
+        rtl8125_map_to_asic(tp, ring,
+                            rtl8125_get_rxdesc(tp, ring->RxDescArray, entry),
+                            nrxb->dma + nrxb->page_offset,
+                            tp->rx_buf_sz, entry);
+
+        ring->dirty_rx++;
+}
+
+#endif //ENABLE_PAGE_REUSE
+
+static int
+rtl8125_rx_interrupt(struct net_device *dev,
+                     struct rtl8125_private *tp,
+                     struct rtl8125_rx_ring *ring,
+                     napi_budget budget)
+{
+        unsigned int cur_rx, rx_left;
+        unsigned int delta, count = 0;
+        unsigned int entry;
+        struct RxDesc *desc;
+        struct sk_buff *skb;
+        u32 status;
+        u32 rx_quota;
+        u32 ring_index = ring->index;
+#ifdef ENABLE_PAGE_REUSE
+        struct rtl8125_rx_buffer *rxb;
+#else //ENABLE_PAGE_REUSE
+        u64 rx_buf_phy_addr;
+#endif //ENABLE_PAGE_REUSE
+        unsigned int total_rx_multicast_packets = 0;
+        unsigned int total_rx_bytes = 0, total_rx_packets = 0;
+
+        assert(dev != NULL);
+        assert(tp != NULL);
+
+        if (ring->RxDescArray == NULL)
+                goto rx_out;
+
+        rx_quota = RTL_RX_QUOTA(budget);
+        cur_rx = ring->cur_rx;
+        rx_left = ring->num_rx_desc + ring->dirty_rx - cur_rx;
+        rx_left = rtl8125_rx_quota(rx_left, (u32)rx_quota);
+
+        for (; rx_left > 0; rx_left--, cur_rx++) {
+#ifdef ENABLE_PTP_SUPPORT
+                u8 desc_type = RXDESC_TYPE_NORMAL;
+                struct RxDescV3 ptp_desc;
+#endif //ENABLE_PTP_SUPPORT
+#ifndef ENABLE_PAGE_REUSE
+                const void *rx_buf;
+#endif //!ENABLE_PAGE_REUSE
+                u32 pkt_size;
+
+                entry = cur_rx % ring->num_rx_desc;
+                desc = rtl8125_get_rxdesc(tp, ring->RxDescArray, entry);
+                status = le32_to_cpu(rtl8125_rx_desc_opts1(tp, desc));
+                if (status & DescOwn) {
+                        RTL_R8(tp, tp->imr_reg[0]);
+                        status = le32_to_cpu(rtl8125_rx_desc_opts1(tp, desc));
+                        if (status & DescOwn)
+                                break;
+                }
+
+                rmb();
+
+                if (unlikely(rtl8125_check_rx_desc_error(dev, tp, status) < 0)) {
+                        if (netif_msg_rx_err(tp)) {
+                                printk(KERN_INFO
+                                       "%s: Rx ERROR. status = %08x\n",
+                                       dev->name, status);
+                        }
+
+                        RTLDEV->stats.rx_errors++;
+
+                        if (!(dev->features & NETIF_F_RXALL))
+                                goto release_descriptor;
+                }
+                pkt_size = status & 0x00003fff;
+                if (likely(!(dev->features & NETIF_F_RXFCS))) {
+#ifdef ENABLE_RX_PACKET_FRAGMENT
+                        if (rtl8125_is_non_eop(tp, status) &&
+                            pkt_size == tp->rx_buf_sz) {
+                                struct RxDesc *desc_next;
+                                unsigned int entry_next;
+                                int pkt_size_next;
+                                u32 status_next;
+
+                                entry_next = (cur_rx + 1) % ring->num_rx_desc;
+                                desc_next = rtl8125_get_rxdesc(tp, ring->RxDescArray, entry_next);
+                                status_next = le32_to_cpu(rtl8125_rx_desc_opts1(tp, desc_next));
+                                if (!(status_next & DescOwn)) {
+                                        pkt_size_next = status_next & 0x00003fff;
+                                        if (pkt_size_next < ETH_FCS_LEN)
+                                                pkt_size -= (ETH_FCS_LEN - pkt_size_next);
+                                }
+                        }
+#endif //ENABLE_RX_PACKET_FRAGMENT
+                        if (!rtl8125_is_non_eop(tp, status)) {
+                                if (pkt_size < ETH_FCS_LEN) {
+#ifdef ENABLE_RX_PACKET_FRAGMENT
+                                        pkt_size = 0;
+#else
+                                        goto drop_packet;
+#endif //ENABLE_RX_PACKET_FRAGMENT
+                                } else
+                                        pkt_size -= ETH_FCS_LEN;
+                        }
+                }
+
+                if (unlikely(pkt_size > tp->rx_buf_sz))
+                        goto drop_packet;
+
+#if !defined(ENABLE_RX_PACKET_FRAGMENT) || !defined(ENABLE_PAGE_REUSE)
+                /*
+                 * The driver does not support incoming fragmented
+                 * frames. They are seen as a symptom of over-mtu
+                 * sized frames.
+                 */
+                if (unlikely(rtl8125_fragmented_frame(tp, status)))
+                        goto drop_packet;
+#endif //!ENABLE_RX_PACKET_FRAGMENT || !ENABLE_PAGE_REUSE
+
+#ifdef ENABLE_PTP_SUPPORT
+                if (tp->HwSuppPtpVer == 1) {
+                        desc_type = rtl8125_rx_desc_type(status);
+                        if (desc_type == RXDESC_TYPE_NEXT && rx_left > 0) {
+                                u32 status_next;
+                                struct RxDescV3 *desc_next;
+                                unsigned int entry_next;
+
+                                cur_rx++;
+                                rx_left--;
+                                entry_next = cur_rx % ring->num_rx_desc;
+                                desc_next = (struct RxDescV3 *)rtl8125_get_rxdesc(tp, ring->RxDescArray, entry_next);
+                                status_next = le32_to_cpu(desc_next->RxDescNormalDDWord4.opts1);
+                                if (unlikely(status_next & DescOwn)) {
+                                        udelay(1);
+                                        status_next = le32_to_cpu(desc_next->RxDescNormalDDWord4.opts1);
+                                        if (unlikely(status_next & DescOwn)) {
+                                                if (netif_msg_rx_err(tp)) {
+                                                        printk(KERN_ERR
+                                                               "%s: Rx Next Desc ERROR. status = %08x\n",
+                                                               dev->name, status_next);
+                                                }
+                                                rtl8125_set_desc_dma_addr(tp, (struct RxDesc *)desc_next,
+                                                                          ring->RxDescPhyAddr[entry_next]);
+                                                wmb();
+                                                rtl8125_mark_to_asic(tp, (struct RxDesc *)desc_next, tp->rx_buf_sz);
+                                                goto drop_packet;
+                                        }
+                                }
+
+                                rmb();
+
+                                desc_type = rtl8125_rx_desc_type(status_next);
+                                if (desc_type == RXDESC_TYPE_PTP) {
+                                        ptp_desc = *desc_next;
+                                        rmb();
+                                        rtl8125_set_desc_dma_addr(tp, (struct RxDesc *)desc_next,
+                                                                  ring->RxDescPhyAddr[entry_next]);
+                                        wmb();
+                                        rtl8125_mark_to_asic(tp, (struct RxDesc *)desc_next, tp->rx_buf_sz);
+                                } else {
+                                        WARN_ON(1);
+                                        rtl8125_set_desc_dma_addr(tp, (struct RxDesc *)desc_next,
+                                                                  ring->RxDescPhyAddr[entry_next]);
+                                        wmb();
+                                        rtl8125_mark_to_asic(tp, (struct RxDesc *)desc_next, tp->rx_buf_sz);
+                                        goto drop_packet;
+                                }
+                        } else
+                                WARN_ON(desc_type != RXDESC_TYPE_NORMAL);
+                }
+#endif
+#ifdef ENABLE_PAGE_REUSE
+                rxb = &ring->rx_buffer[entry];
+                skb = rxb->skb;
+                rxb->skb = NULL;
+                if (!skb) {
+                        skb = RTL_BUILD_SKB_INTR(rxb->data + rxb->page_offset - ring->rx_offset, tp->rx_buf_page_size / 2);
+                        if (!skb) {
+                                //netdev_err(tp->dev, "Failed to allocate RX skb!\n");
+                                goto drop_packet;
+                        }
+
+                        skb->dev = dev;
+                        if (!R8125_USE_NAPI_ALLOC_SKB)
+                                skb_reserve(skb, R8125_RX_ALIGN);
+                        skb_put(skb, pkt_size);
+#ifdef ENABLE_RSS_SUPPORT
+                        rtl8125_rx_hash(tp, desc, skb);
+#endif
+                        rtl8125_rx_csum(tp, skb, desc);
+                } else
+                        skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, rxb->page,
+                                        rxb->page_offset, pkt_size, tp->rx_buf_page_size / 2);
+
+                //recycle desc
+                rtl8125_put_rx_buffer(tp, ring, cur_rx, rxb);
+
+                dma_sync_single_range_for_cpu(tp_to_dev(tp),
+                                              rxb->dma,
+                                              rxb->page_offset,
+                                              tp->rx_buf_sz,
+                                              DMA_FROM_DEVICE);
+#else //ENABLE_PAGE_REUSE
+                skb = RTL_ALLOC_SKB_INTR(&tp->r8125napi[ring->index].napi, pkt_size + R8125_RX_ALIGN);
+                if (!skb) {
+                        //netdev_err(tp->dev, "Failed to allocate RX skb!\n");
+                        goto drop_packet;
+                }
+
+                skb->dev = dev;
+                if (!R8125_USE_NAPI_ALLOC_SKB)
+                        skb_reserve(skb, R8125_RX_ALIGN);
+                skb_put(skb, pkt_size);
+
+                rx_buf_phy_addr = ring->RxDescPhyAddr[entry];
+                dma_sync_single_for_cpu(tp_to_dev(tp),
+                                        rx_buf_phy_addr, tp->rx_buf_sz,
+                                        DMA_FROM_DEVICE);
+                rx_buf = ring->Rx_skbuff[entry]->data;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
+                prefetch(rx_buf - R8125_RX_ALIGN);
+#endif
+                eth_copy_and_sum(skb, rx_buf, pkt_size, 0);
+
+                dma_sync_single_for_device(tp_to_dev(tp), rx_buf_phy_addr,
+                                           tp->rx_buf_sz, DMA_FROM_DEVICE);
+#endif //ENABLE_PAGE_REUSE
+
+#ifdef ENABLE_PTP_SUPPORT
+                if (tp->HwSuppPtpVer == 1 && desc_type == RXDESC_TYPE_PTP)
+                        rtl8125_rx_mac_ptp_pktstamp(tp, skb, &ptp_desc);
+                else if (tp->HwSuppPtpVer == 3 && (tp->flags & RTL_FLAG_RX_HWTSTAMP_ENABLED))
+                        rtl8125_rx_phy_ptp_timestamp(tp, skb);
+#endif // ENABLE_PTP_SUPPORT
+
+#ifdef ENABLE_RX_PACKET_FRAGMENT
+                if (rtl8125_is_non_eop(tp, status)) {
+                        unsigned int entry_next;
+                        entry_next = (entry + 1) % ring->num_rx_desc;
+                        rxb = &ring->rx_buffer[entry_next];
+                        rxb->skb = skb;
+                        continue;
+                }
+#endif //ENABLE_RX_PACKET_FRAGMENT
+
+#ifndef ENABLE_PAGE_REUSE
+#ifdef ENABLE_RSS_SUPPORT
+                rtl8125_rx_hash(tp, desc, skb);
+#endif
+                rtl8125_rx_csum(tp, skb, desc);
+#endif /* !ENABLE_PAGE_REUSE */
+
+                skb->protocol = eth_type_trans(skb, dev);
+
+                total_rx_bytes += skb->len;
+
+                if (skb->pkt_type == PACKET_MULTICAST)
+                        total_rx_multicast_packets++;
+
+                if (rtl8125_rx_vlan_skb(tp, desc, skb) < 0)
+                        rtl8125_rx_skb(tp, skb, ring_index);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0)
+                dev->last_rx = jiffies;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0)
+                total_rx_packets++;
+
+#ifdef ENABLE_PAGE_REUSE
+                rxb->skb = NULL;
+                continue;
+#endif
+
+release_descriptor:
+                switch (tp->InitRxDescType) {
+                case RX_DESC_RING_TYPE_3:
+                case RX_DESC_RING_TYPE_4:
+                        rtl8125_set_desc_dma_addr(tp, desc,
+                                                  ring->RxDescPhyAddr[entry]);
+                        wmb();
+                        break;
+                }
+                rtl8125_mark_to_asic(tp, desc, tp->rx_buf_sz);
+                continue;
+drop_packet:
+                RTLDEV->stats.rx_dropped++;
+                RTLDEV->stats.rx_length_errors++;
+                goto release_descriptor;
+        }
+
+        count = cur_rx - ring->cur_rx;
+        ring->cur_rx = cur_rx;
+
+        delta = rtl8125_rx_fill(tp, ring, dev, ring->dirty_rx, ring->cur_rx, 1);
+        if (!delta && count && netif_msg_intr(tp))
+                printk(KERN_INFO "%s: no Rx buffer allocated\n", dev->name);
+        ring->dirty_rx += delta;
+
+        RTLDEV->stats.rx_bytes += total_rx_bytes;
+        RTLDEV->stats.rx_packets += total_rx_packets;
+        RTLDEV->stats.multicast += total_rx_multicast_packets;
+
+        /*
+         * FIXME: until there is periodic timer to try and refill the ring,
+         * a temporary shortage may definitely kill the Rx process.
+         * - disable the asic to try and avoid an overflow and kick it again
+         *   after refill ?
+         * - how do others driver handle this condition (Uh oh...).
+         */
+        if ((ring->dirty_rx + ring->num_rx_desc == ring->cur_rx) && netif_msg_intr(tp))
+                printk(KERN_EMERG "%s: Rx buffers exhausted\n", dev->name);
+
+rx_out:
+        return total_rx_packets;
+}
+
+static bool
+rtl8125_linkchg_interrupt(struct rtl8125_private *tp, u32 status)
+{
+        switch (tp->HwCurrIsrVer) {
+        case 2:
+        case 3:
+                return status & ISRIMR_V2_LINKCHG;
+        case 4:
+                return status & ISRIMR_V4_LINKCHG;
+        case 5:
+                return status & ISRIMR_V5_LINKCHG;
+        case 7:
+                return status & ISRIMR_V7_LINKCHG;
+        default:
+                return status & LinkChg;
+        }
+}
+
+static u32
+rtl8125_get_linkchg_message_id(struct rtl8125_private *tp)
+{
+        switch (tp->HwCurrIsrVer) {
+        case 4:
+        case 7:
+                return 29;
+        case 5:
+                return 18;
+        default:
+                return 21;
+        }
+}
+
+/*
+ *The interrupt handler does all of the Rx thread work and cleans up after
+ *the Tx thread.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t rtl8125_interrupt(int irq, void *dev_instance, struct pt_regs *regs)
+#else
+static irqreturn_t rtl8125_interrupt(int irq, void *dev_instance)
+#endif
+{
+        struct r8125_napi *r8125napi = dev_instance;
+        struct rtl8125_private *tp = r8125napi->priv;
+        struct net_device *dev = tp->dev;
+        u32 status;
+        int handled = 0;
+
+        do {
+                status = RTL_R32(tp, tp->isr_reg[0]);
+
+                if (!(tp->features & (RTL_FEATURE_MSI | RTL_FEATURE_MSIX))) {
+                        /* hotplug/major error/no more work/shared irq */
+                        if (!status)
+                                break;
+
+                        if (status == 0xFFFFFFFF)
+                                break;
+
+                        if (!(status & (tp->intr_mask | tp->timer_intr_mask)))
+                                break;
+                }
+
+                handled = 1;
+
+#if defined(RTL_USE_NEW_INTR_API)
+                if (!tp->irq_tbl[0].requested)
+                        break;
+#endif
+                rtl8125_disable_hw_interrupt(tp);
+
+                RTL_W32(tp, tp->isr_reg[0], status&~RxFIFOOver);
+
+                if (rtl8125_linkchg_interrupt(tp, status))
+                        rtl8125_schedule_linkchg_work(tp);
+
+#ifdef ENABLE_DASH_SUPPORT
+                if ((status & ISRIMR_V4_LAYER2_INTR_STS) &&
+                    rtl8125_check_dash_interrupt(tp))
+                        rtl8125_schedule_dash_work(tp);
+#endif
+
+#ifdef CONFIG_R8125_NAPI
+                if (status & tp->intr_mask || tp->keep_intr_cnt-- > 0) {
+                        if (status & tp->intr_mask)
+                                tp->keep_intr_cnt = RTK_KEEP_INTERRUPT_COUNT;
+
+                        if (likely(RTL_NETIF_RX_SCHEDULE_PREP(dev, &tp->r8125napi[0].napi)))
+                                __RTL_NETIF_RX_SCHEDULE(dev, &tp->r8125napi[0].napi);
+                        else if (netif_msg_intr(tp))
+                                printk(KERN_INFO "%s: interrupt %04x in poll\n",
+                                       dev->name, status);
+                } else {
+                        tp->keep_intr_cnt = RTK_KEEP_INTERRUPT_COUNT;
+                        rtl8125_switch_to_hw_interrupt(tp);
+                }
+#else
+                if (status & tp->intr_mask || tp->keep_intr_cnt-- > 0) {
+                        u32 budget = ~(u32)0;
+                        int i;
+
+                        if (status & tp->intr_mask)
+                                tp->keep_intr_cnt = RTK_KEEP_INTERRUPT_COUNT;
+
+                        for (i = 0; i < tp->num_tx_rings; i++)
+                                rtl8125_tx_interrupt(&tp->tx_ring[i], ~(u32)0);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+                        rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[0], &budget);
+#else
+                        rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[0], budget);
+#endif	//LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+
+#ifdef ENABLE_DASH_SUPPORT
+                        if ((status & ISRIMR_V4_LAYER2_INTR_STS) &&
+                            rtl8125_check_dash_interrupt(tp))
+                                rtl8125_schedule_dash_work(tp);
+#endif
+
+                        rtl8125_switch_to_timer_interrupt(tp);
+                } else {
+                        tp->keep_intr_cnt = RTK_KEEP_INTERRUPT_COUNT;
+                        rtl8125_switch_to_hw_interrupt(tp);
+                }
+#endif
+        } while (false);
+
+        return IRQ_RETVAL(handled);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t rtl8125_interrupt_msix(int irq, void *dev_instance, struct pt_regs *regs)
+#else
+static irqreturn_t rtl8125_interrupt_msix(int irq, void *dev_instance)
+#endif
+{
+        struct r8125_napi *r8125napi = dev_instance;
+        struct rtl8125_private *tp = r8125napi->priv;
+        struct net_device *dev = tp->dev;
+        int message_id = r8125napi->index;
+#ifndef CONFIG_R8125_NAPI
+        u32 budget = ~(u32)0;
+#endif
+
+        do {
+#if defined(RTL_USE_NEW_INTR_API)
+                if (!tp->irq_tbl[message_id].requested)
+                        break;
+#endif
+                //link change
+                if (message_id == rtl8125_get_linkchg_message_id(tp)) {
+                        rtl8125_disable_hw_interrupt_v2(tp, message_id);
+                        rtl8125_clear_hw_isr_v2(tp, message_id);
+                        rtl8125_schedule_linkchg_work(tp);
+                        break;
+                }
+
+#ifdef ENABLE_DASH_SUPPORT
+                if (message_id == 31) {
+                        if (rtl8125_check_dash_interrupt(tp))
+                                rtl8125_disable_hw_interrupt_v2(tp, message_id);
+                        rtl8125_clear_hw_isr_v2(tp, message_id);
+                        rtl8125_schedule_dash_work(tp);
+                        rtl8125_enable_hw_interrupt_v2(tp, message_id);
+                        break;
+                }
+#endif
+
+#ifdef CONFIG_R8125_NAPI
+                if (likely(RTL_NETIF_RX_SCHEDULE_PREP(dev, &r8125napi->napi))) {
+                        rtl8125_disable_hw_interrupt_v2(tp, message_id);
+                        __RTL_NETIF_RX_SCHEDULE(dev, &r8125napi->napi);
+                } else if (netif_msg_intr(tp))
+                        printk(KERN_INFO "%s: interrupt message id %d in poll_msix\n",
+                               dev->name, message_id);
+                rtl8125_clear_hw_isr_v2(tp, message_id);
+#else
+                rtl8125_disable_hw_interrupt_v2(tp, message_id);
+
+                rtl8125_clear_hw_isr_v2(tp, message_id);
+
+                rtl8125_tx_interrupt_with_vector(tp, message_id, ~(u32)0);
+
+                if (message_id < tp->num_rx_rings) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+                        rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[message_id], &budget);
+#else
+                        rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[message_id], budget);
+#endif	//LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+                }
+
+                rtl8125_enable_hw_interrupt_v2(tp, message_id);
+#endif
+
+        } while (false);
+
+        return IRQ_HANDLED;
+}
+
+static void rtl8125_down(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        //rtl8125_delete_esd_timer(dev, &tp->esd_timer);
+
+        //rtl8125_delete_link_timer(dev, &tp->link_timer);
+
+        netif_carrier_off(dev);
+
+        netif_tx_disable(dev);
+
+        _rtl8125_wait_for_quiescence(dev);
+
+        rtl8125_hw_reset(dev);
+
+        rtl8125_tx_clear(tp);
+
+        rtl8125_rx_clear(tp);
+}
+
+static int rtl8125_resource_freed(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++)
+                if (tp->tx_ring[i].TxDescArray)
+                        return 0;
+
+        for (i = 0; i < tp->num_rx_rings; i++)
+                if (tp->rx_ring[i].RxDescArray)
+                        return 0;
+
+        return 1;
+}
+
+int rtl8125_close(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (!rtl8125_resource_freed(tp)) {
+                set_bit(R8125_FLAG_DOWN, tp->task_flags);
+
+                rtl8125_down(dev);
+
+                pci_clear_master(tp->pci_dev);
+
+#ifdef ENABLE_PTP_SUPPORT
+                rtl8125_ptp_stop(tp);
+#endif
+                rtl8125_hw_d3_para(dev);
+
+                rtl8125_powerdown_pll(dev, 0);
+
+                rtl8125_free_irq(tp);
+
+                rtl8125_free_alloc_resources(tp);
+        } else {
+                rtl8125_hw_d3_para(dev);
+
+                rtl8125_powerdown_pll(dev, 0);
+        }
+
+        return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,11)
+static void rtl8125_shutdown(struct pci_dev *pdev)
+{
+        struct net_device *dev = pci_get_drvdata(pdev);
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtnl_lock();
+
+        if (HW_DASH_SUPPORT_DASH(tp))
+                rtl8125_driver_stop(tp);
+
+        rtl8125_disable_pci_offset_180(tp);
+
+        if (s5_keep_curr_mac == 0 && tp->random_mac == 0)
+                rtl8125_rar_set(tp, tp->org_mac_addr);
+
+        if (s5wol == 0)
+                tp->wol_enabled = WOL_DISABLED;
+
+        rtl8125_close(dev);
+        rtl8125_disable_msi(pdev, tp);
+
+        rtnl_unlock();
+
+        if (system_state == SYSTEM_POWER_OFF) {
+                pci_clear_master(tp->pci_dev);
+                pci_wake_from_d3(pdev, tp->wol_enabled);
+                pci_set_power_state(pdev, PCI_D3hot);
+        }
+}
+#endif
+
+#ifdef CONFIG_PM
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+static int
+rtl8125_suspend(struct pci_dev *pdev, u32 state)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+static int
+rtl8125_suspend(struct device *device)
+#else
+static int
+rtl8125_suspend(struct pci_dev *pdev, pm_message_t state)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+        struct pci_dev *pdev = to_pci_dev(device);
+        struct net_device *dev = pci_get_drvdata(pdev);
+#else
+        struct net_device *dev = pci_get_drvdata(pdev);
+#endif
+        struct rtl8125_private *tp = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+        u32 pci_pm_state = pci_choose_state(pdev, state);
+#endif
+        rtnl_lock();
+
+        if (!netif_running(dev))
+                goto out;
+
+        set_bit(R8125_FLAG_DOWN, tp->task_flags);
+
+        netif_carrier_off(dev);
+
+        netif_tx_disable(dev);
+
+        netif_device_detach(dev);
+
+#ifdef ENABLE_PTP_SUPPORT
+        rtl8125_ptp_suspend(tp);
+#endif
+        rtl8125_hw_reset(dev);
+
+        pci_clear_master(pdev);
+
+        rtl8125_hw_d3_para(dev);
+
+        rtl8125_powerdown_pll(dev, 1);
+
+out:
+        if (HW_DASH_SUPPORT_DASH(tp))
+                rtl8125_driver_stop(tp);
+
+        rtnl_unlock();
+
+        pci_disable_device(pdev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+        pci_save_state(pdev, &pci_pm_state);
+#else
+        pci_save_state(pdev);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+        pci_enable_wake(pdev, pci_choose_state(pdev, state), tp->wol_enabled);
+#endif
+
+        pci_prepare_to_sleep(pdev);
+
+        return 0;
+}
+
+static int
+rtl8125_hw_d3_not_power_off(struct net_device *dev)
+{
+        return rtl8125_check_hw_phy_mcu_code_ver(dev);
+}
+
+static int rtl8125_wait_phy_nway_complete_sleep(struct rtl8125_private *tp)
+{
+        int i, val;
+
+        for (i = 0; i < 30; i++) {
+                val = rtl8125_mdio_read(tp, MII_BMSR) & BMSR_ANEGCOMPLETE;
+                if (val)
+                        return 0;
+
+                mdelay(100);
+        }
+
+        return -1;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+static int
+rtl8125_resume(struct pci_dev *pdev)
+#else
+static int
+rtl8125_resume(struct device *device)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+        struct pci_dev *pdev = to_pci_dev(device);
+        struct net_device *dev = pci_get_drvdata(pdev);
+#else
+        struct net_device *dev = pci_get_drvdata(pdev);
+#endif
+        struct rtl8125_private *tp = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+        u32 pci_pm_state = PCI_D0;
+#endif
+        unsigned long flags;
+        u32 err;
+
+        rtnl_lock();
+
+        err = pci_enable_device(pdev);
+        if (err) {
+                dev_err(&pdev->dev, "Cannot enable PCI device from suspend\n");
+                goto out_unlock;
+        }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+        pci_restore_state(pdev, &pci_pm_state);
+#else
+        pci_restore_state(pdev);
+#endif
+        pci_enable_wake(pdev, PCI_D0, 0);
+
+        /* restore last modified mac address */
+        rtl8125_rar_set(tp, dev->dev_addr);
+
+        r8125_spin_lock(&tp->phy_lock, flags);
+
+        rtl8125_check_hw_phy_mcu_code_ver(dev);
+
+        tp->resume_not_chg_speed = 0;
+        if (tp->check_keep_link_speed &&
+            //tp->link_ok(dev) &&
+            rtl8125_hw_d3_not_power_off(dev) &&
+            rtl8125_wait_phy_nway_complete_sleep(tp) == 0)
+                tp->resume_not_chg_speed = 1;
+
+        r8125_spin_unlock(&tp->phy_lock, flags);
+
+        if (!netif_running(dev))
+                goto out_unlock;
+
+        pci_set_master(pdev);
+
+        rtl8125_exit_oob(dev);
+
+        rtl8125_up(dev);
+
+        clear_bit(R8125_FLAG_DOWN, tp->task_flags);
+
+        rtl8125_schedule_reset_work(tp);
+
+        rtl8125_schedule_esd_work(tp);
+
+#ifdef ENABLE_FIBER_SUPPORT
+        if (HW_FIBER_MODE_ENABLED(tp))
+                rtl8125_schedule_link_work(tp);
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        //mod_timer(&tp->esd_timer, jiffies + RTL8125_ESD_TIMEOUT);
+        //mod_timer(&tp->link_timer, jiffies + RTL8125_LINK_TIMEOUT);
+out_unlock:
+        netif_device_attach(dev);
+
+        rtnl_unlock();
+
+        return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+
+static struct dev_pm_ops rtl8125_pm_ops = {
+        .suspend = rtl8125_suspend,
+        .resume = rtl8125_resume,
+        .freeze = rtl8125_suspend,
+        .thaw = rtl8125_resume,
+        .poweroff = rtl8125_suspend,
+        .restore = rtl8125_resume,
+};
+
+#define RTL8125_PM_OPS	(&rtl8125_pm_ops)
+
+#endif
+
+#else /* !CONFIG_PM */
+
+#define RTL8125_PM_OPS	NULL
+
+#endif /* CONFIG_PM */
+
+static struct pci_driver rtl8125_pci_driver = {
+        .name       = MODULENAME,
+        .id_table   = rtl8125_pci_tbl,
+        .probe      = rtl8125_init_one,
+        .remove     = __devexit_p(rtl8125_remove_one),
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,11)
+        .shutdown   = rtl8125_shutdown,
+#endif
+#ifdef CONFIG_PM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+        .suspend    = rtl8125_suspend,
+        .resume     = rtl8125_resume,
+#else
+        .driver.pm	= RTL8125_PM_OPS,
+#endif
+#endif
+};
+
+static int __init
+rtl8125_init_module(void)
+{
+        int ret = 0;
+#ifdef ENABLE_R8125_PROCFS
+        rtl8125_proc_module_init();
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+
+        ret = pci_register_driver(&rtl8125_pci_driver);
+#else
+        ret = pci_module_init(&rtl8125_pci_driver);
+#endif
+
+        return ret;
+}
+
+static void __exit
+rtl8125_cleanup_module(void)
+{
+        pci_unregister_driver(&rtl8125_pci_driver);
+
+#ifdef ENABLE_R8125_PROCFS
+        if (rtl8125_proc) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+                remove_proc_subtree(MODULENAME, init_net.proc_net);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+                remove_proc_entry(MODULENAME, init_net.proc_net);
+#else
+                remove_proc_entry(MODULENAME, proc_net);
+#endif  //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#endif  //LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+                rtl8125_proc = NULL;
+        }
+#endif
+}
+
+module_init(rtl8125_init_module);
+module_exit(rtl8125_cleanup_module);
Index: drivers/net/ethernet/r8125-9.016.01/r8125.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/r8125.h b/drivers/net/ethernet/r8125-9.016.01/r8125.h
new file mode 100755
--- /dev/null	(date 1763113879451)
+++ b/drivers/net/ethernet/r8125-9.016.01/r8125.h	(date 1763113879451)
@@ -0,0 +1,3052 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef __R8125_H
+#define __R8125_H
+
+//#include <linux/pci.h>
+#include <linux/ethtool.h>
+#include <linux/interrupt.h>
+#include <linux/version.h>
+#include "r8125_dash.h"
+#include "r8125_realwow.h"
+#ifdef ENABLE_FIBER_SUPPORT
+#include "r8125_fiber.h"
+#endif /* ENABLE_FIBER_SUPPORT */
+#ifdef ENABLE_PTP_SUPPORT
+#include "r8125_ptp.h"
+#endif
+#include "r8125_rss.h"
+#ifdef ENABLE_LIB_SUPPORT
+#include "r8125_lib.h"
+#endif
+
+#ifndef fallthrough
+#define fallthrough
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+#define netif_xmit_stopped netif_tx_queue_stopped
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+#ifndef MDIO_AN_EEE_ADV_100TX
+#define MDIO_AN_EEE_ADV_100TX	0x0002	/* Advertise 100TX EEE cap */
+#endif
+#ifndef MDIO_AN_EEE_ADV_1000T
+#define MDIO_AN_EEE_ADV_1000T	0x0004	/* Advertise 1000T EEE cap */
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+#define MDIO_EEE_100TX		MDIO_AN_EEE_ADV_100TX	/* 100TX EEE cap */
+#define MDIO_EEE_1000T		MDIO_AN_EEE_ADV_1000T	/* 1000T EEE cap */
+#define MDIO_EEE_10GT		0x0008	/* 10GT EEE cap */
+#define MDIO_EEE_1000KX		0x0010	/* 1000KX EEE cap */
+#define MDIO_EEE_10GKX4		0x0020	/* 10G KX4 EEE cap */
+#define MDIO_EEE_10GKR		0x0040	/* 10G KR EEE cap */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0) */
+
+static inline u32 mmd_eee_adv_to_ethtool_adv_t(u16 eee_adv)
+{
+        u32 adv = 0;
+
+        if (eee_adv & MDIO_EEE_100TX)
+                adv |= ADVERTISED_100baseT_Full;
+        if (eee_adv & MDIO_EEE_1000T)
+                adv |= ADVERTISED_1000baseT_Full;
+        if (eee_adv & MDIO_EEE_10GT)
+                adv |= ADVERTISED_10000baseT_Full;
+        if (eee_adv & MDIO_EEE_1000KX)
+                adv |= ADVERTISED_1000baseKX_Full;
+        if (eee_adv & MDIO_EEE_10GKX4)
+                adv |= ADVERTISED_10000baseKX4_Full;
+        if (eee_adv & MDIO_EEE_10GKR)
+                adv |= ADVERTISED_10000baseKR_Full;
+
+        return adv;
+}
+
+static inline u16 ethtool_adv_to_mmd_eee_adv_t(u32 adv)
+{
+        u16 reg = 0;
+
+        if (adv & ADVERTISED_100baseT_Full)
+                reg |= MDIO_EEE_100TX;
+        if (adv & ADVERTISED_1000baseT_Full)
+                reg |= MDIO_EEE_1000T;
+        if (adv & ADVERTISED_10000baseT_Full)
+                reg |= MDIO_EEE_10GT;
+        if (adv & ADVERTISED_1000baseKX_Full)
+                reg |= MDIO_EEE_1000KX;
+        if (adv & ADVERTISED_10000baseKX4_Full)
+                reg |= MDIO_EEE_10GKX4;
+        if (adv & ADVERTISED_10000baseKR_Full)
+                reg |= MDIO_EEE_10GKR;
+
+        return reg;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0)
+static inline bool skb_transport_header_was_set(const struct sk_buff *skb)
+{
+        return skb->transport_header != ~0U;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0)
+static inline
+ssize_t strscpy(char *dest, const char *src, size_t count)
+{
+        long res = 0;
+
+        if (count == 0)
+                return -E2BIG;
+
+        while (count) {
+                char c;
+
+                c = src[res];
+                dest[res] = c;
+                if (!c)
+                        return res;
+                res++;
+                count--;
+        }
+
+        /* Hit buffer length without finding a NUL; force NUL-termination. */
+        if (res)
+                dest[res-1] = '\0';
+
+        return -E2BIG;
+}
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0))
+static inline unsigned char *skb_checksum_start(const struct sk_buff *skb)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22))
+        return skb->head + skb->csum_start;
+#else /* < 2.6.22 */
+        return skb_transport_header(skb);
+#endif
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+static inline void netdev_tx_sent_queue(struct netdev_queue *dev_queue,
+                                        unsigned int bytes)
+{}
+static inline void netdev_tx_completed_queue(struct netdev_queue *dev_queue,
+                unsigned int pkts,
+                unsigned int bytes)
+{}
+static inline void netdev_tx_reset_queue(struct netdev_queue *q) {}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0)
+static inline void fsleep(unsigned long usecs)
+{
+        if (usecs <= 10)
+                udelay(usecs);
+        else if (usecs <= 20000)
+                usleep_range(usecs, 2 * usecs);
+        else
+                msleep(DIV_ROUND_UP(usecs, 1000));
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,2,0)
+#define netdev_xmit_more() (0)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0)
+#define netif_testing_on(dev)
+#define netif_testing_off(dev)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,2,0)
+#define netdev_sw_irq_coalesce_default_on(dev)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(6,2,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+typedef int netdev_tx_t;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,12,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,1,9)
+static inline bool page_is_pfmemalloc(struct page *page)
+{
+        /*
+         * Page index cannot be this large so this must be
+         * a pfmemalloc page.
+         */
+        return page->index == -1UL;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,1,9) */
+static inline bool dev_page_is_reusable(struct page *page)
+{
+        return likely(page_to_nid(page) == numa_mem_id() &&
+                      !page_is_pfmemalloc(page));
+}
+#endif
+
+/*
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)&& !defined(ENABLE_LIB_SUPPORT)
+#define RTL_USE_NEW_INTR_API
+#endif
+*/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+#define dma_map_page_attrs(dev, page, offset, size, dir, attrs) \
+	dma_map_page(dev, page, offset, size, dir)
+#define dma_unmap_page_attrs(dev, page, size, dir, attrs) \
+	 dma_unmap_page(dev, page, size, dir)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+#define page_ref_inc(page) atomic_inc(&page->_count)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,4,216)
+#define page_ref_count(page) atomic_read(&page->_count)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,4,216)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#define skb_transport_offset(skb) (skb->h.raw - skb->data)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+#define device_set_wakeup_enable(dev, val)	do {} while (0)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+        u16 *a = (u16 *)dst;
+        const u16 *b = (const u16 *)src;
+
+        a[0] = b[0];
+        a[1] = b[1];
+        a[2] = b[2];
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+#define IS_ERR_OR_NULL(ptr)			(!ptr)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
+#define reinit_completion(x)			((x)->done = 0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#define pm_runtime_mark_last_busy(x)
+#define pm_runtime_put_autosuspend(x)		pm_runtime_put(x)
+#define pm_runtime_put_sync_autosuspend(x)	pm_runtime_put_sync(x)
+
+static inline bool pm_runtime_suspended(struct device *dev)
+{
+        return dev->power.runtime_status == RPM_SUSPENDED
+               && !dev->power.disable_depth;
+}
+
+static inline bool pm_runtime_active(struct device *dev)
+{
+        return dev->power.runtime_status == RPM_ACTIVE
+               || dev->power.disable_depth;
+}
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+#define queue_delayed_work(long_wq, work, delay)	schedule_delayed_work(work, delay)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)
+#define netif_printk(priv, type, level, netdev, fmt, args...)	\
+	do {								\
+		if (netif_msg_##type(priv))				\
+			printk(level "%s: " fmt,(netdev)->name , ##args); \
+	} while (0)
+
+#define netif_emerg(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_EMERG, netdev, fmt, ##args)
+#define netif_alert(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ALERT, netdev, fmt, ##args)
+#define netif_crit(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_CRIT, netdev, fmt, ##args)
+#define netif_err(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ERR, netdev, fmt, ##args)
+#define netif_warn(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_WARNING, netdev, fmt, ##args)
+#define netif_notice(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_NOTICE, netdev, fmt, ##args)
+#define netif_info(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_INFO, (netdev), fmt, ##args)
+#endif
+#endif
+#endif
+#endif
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+#define setup_timer(_timer, _function, _data) \
+do { \
+	(_timer)->function = _function; \
+	(_timer)->data = _data; \
+	init_timer(_timer); \
+} while (0)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+#if defined(skb_vlan_tag_present) && !defined(vlan_tx_tag_present)
+#define vlan_tx_tag_present skb_vlan_tag_present
+#endif
+#if defined(skb_vlan_tag_get) && !defined(vlan_tx_tag_get)
+#define vlan_tx_tag_get skb_vlan_tag_get
+#endif
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+
+#define RTL_ALLOC_SKB_INTR(napi, length) dev_alloc_skb(length)
+#define R8125_USE_NAPI_ALLOC_SKB 0
+#ifdef CONFIG_R8125_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+#undef RTL_ALLOC_SKB_INTR
+#define RTL_ALLOC_SKB_INTR(napi, length) napi_alloc_skb(napi, length)
+#undef R8125_USE_NAPI_ALLOC_SKB
+#define R8125_USE_NAPI_ALLOC_SKB 1
+#endif
+#endif
+
+#define RTL_BUILD_SKB_INTR(data, frag_size) build_skb(data, frag_size)
+#ifdef CONFIG_R8125_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,12,0)
+#undef RTL_BUILD_SKB_INTR
+#define RTL_BUILD_SKB_INTR(data, frag_size) napi_build_skb(data, frag_size)
+#endif
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+#define eth_random_addr(addr) random_ether_addr(addr)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+#define netdev_features_t  u32
+#endif
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,5,0)
+#define NETIF_F_ALL_CSUM        NETIF_F_CSUM_MASK
+#else
+#ifndef NETIF_F_ALL_CSUM
+#define NETIF_F_ALL_CSUM        NETIF_F_CSUM_MASK
+#endif
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
+#define ENABLE_R8125_PROCFS
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+#define ENABLE_R8125_SYSFS
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+#define NETIF_F_HW_VLAN_RX	NETIF_F_HW_VLAN_CTAG_RX
+#define NETIF_F_HW_VLAN_TX	NETIF_F_HW_VLAN_CTAG_TX
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)
+#define __devinit
+#define __devexit
+#define __devexit_p(func)   func
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#define CHECKSUM_PARTIAL CHECKSUM_HW
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define irqreturn_t void
+#define IRQ_HANDLED    1
+#define IRQ_NONE   0
+#define IRQ_RETVAL(x)
+#endif
+
+#ifndef NETIF_F_RXALL
+#define NETIF_F_RXALL  0
+#endif
+
+#ifndef NETIF_F_RXFCS
+#define NETIF_F_RXFCS  0
+#endif
+
+#if !defined(HAVE_FREE_NETDEV) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+#define free_netdev(x)  kfree(x)
+#endif
+
+#ifndef SET_NETDEV_DEV
+#define SET_NETDEV_DEV(net, pdev)
+#endif
+
+#ifndef SET_MODULE_OWNER
+#define SET_MODULE_OWNER(dev)
+#endif
+
+#ifndef SA_SHIRQ
+#define SA_SHIRQ IRQF_SHARED
+#endif
+
+#ifndef NETIF_F_GSO
+#define gso_size    tso_size
+#define gso_segs    tso_segs
+#endif
+
+#ifndef PCI_VENDOR_ID_DLINK
+#define PCI_VENDOR_ID_DLINK 0x1186
+#endif
+
+#ifndef dma_mapping_error
+#define dma_mapping_error(a,b) 0
+#endif
+
+#ifndef netif_err
+#define netif_err(a,b,c,d)
+#endif
+
+#ifndef AUTONEG_DISABLE
+#define AUTONEG_DISABLE   0x00
+#endif
+
+#ifndef AUTONEG_ENABLE
+#define AUTONEG_ENABLE    0x01
+#endif
+
+#ifndef BMCR_SPEED1000
+#define BMCR_SPEED1000  0x0040
+#endif
+
+#ifndef BMCR_SPEED100
+#define BMCR_SPEED100   0x2000
+#endif
+
+#ifndef BMCR_SPEED10
+#define BMCR_SPEED10    0x0000
+#endif
+
+#ifndef SPEED_UNKNOWN
+#define SPEED_UNKNOWN   -1
+#endif
+
+#ifndef DUPLEX_UNKNOWN
+#define DUPLEX_UNKNOWN  0xff
+#endif
+
+#ifndef SUPPORTED_Pause
+#define SUPPORTED_Pause  (1 << 13)
+#endif
+
+#ifndef SUPPORTED_Asym_Pause
+#define SUPPORTED_Asym_Pause  (1 << 14)
+#endif
+
+#ifndef  MDIO_EEE_100TX
+#define  MDIO_EEE_100TX  0x0002
+#endif
+
+#ifndef  MDIO_EEE_1000T
+#define  MDIO_EEE_1000T  0x0004
+#endif
+
+#ifndef  MDIO_EEE_2_5GT
+#define  MDIO_EEE_2_5GT  0x0001
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,9,0)
+#define ethtool_keee ethtool_eee
+#define rtl8125_ethtool_adv_to_mmd_eee_adv_cap1_t ethtool_adv_to_mmd_eee_adv_t
+static inline u32 rtl8125_ethtool_adv_to_mmd_eee_adv_cap2_t(u32 adv)
+{
+        u32 result = 0;
+
+        if (adv & SUPPORTED_2500baseX_Full)
+                result |= MDIO_EEE_2_5GT;
+
+        return result;
+}
+#else
+#define rtl8125_ethtool_adv_to_mmd_eee_adv_cap1_t linkmode_to_mii_eee_cap1_t
+#define rtl8125_ethtool_adv_to_mmd_eee_adv_cap2_t linkmode_to_mii_eee_cap2_t
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(6,9,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+#ifdef CONFIG_NET_POLL_CONTROLLER
+#define RTL_NET_POLL_CONTROLLER dev->poll_controller=rtl8125_netpoll
+#else
+#define RTL_NET_POLL_CONTROLLER
+#endif
+
+#ifdef CONFIG_R8125_VLAN
+#define RTL_SET_VLAN dev->vlan_rx_register=rtl8125_vlan_rx_register
+#else
+#define RTL_SET_VLAN
+#endif
+
+#define RTL_NET_DEVICE_OPS(ops) dev->open=rtl8125_open; \
+                    dev->hard_start_xmit=rtl8125_start_xmit; \
+                    dev->get_stats=rtl8125_get_stats; \
+                    dev->stop=rtl8125_close; \
+                    dev->tx_timeout=rtl8125_tx_timeout; \
+                    dev->set_multicast_list=rtl8125_set_rx_mode; \
+                    dev->change_mtu=rtl8125_change_mtu; \
+                    dev->set_mac_address=rtl8125_set_mac_address; \
+                    dev->do_ioctl=rtl8125_do_ioctl; \
+                    RTL_NET_POLL_CONTROLLER; \
+                    RTL_SET_VLAN;
+#else
+#define RTL_NET_DEVICE_OPS(ops) dev->netdev_ops=&ops
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE  1
+#endif
+
+#ifndef false
+#define false 0
+#endif
+
+#ifndef true
+#define true  1
+#endif
+
+//Hardware will continue interrupt 10 times after interrupt finished.
+#define RTK_KEEP_INTERRUPT_COUNT (10)
+
+//the low 32 bit address of receive buffer must be 8-byte alignment.
+#ifndef NET_IP_ALIGN
+#define NET_IP_ALIGN        2
+#endif
+#define R8125_RX_ALIGN        NET_IP_ALIGN
+
+#ifdef CONFIG_R8125_NAPI
+#define NAPI_SUFFIX "-NAPI"
+#else
+#define NAPI_SUFFIX ""
+#endif
+
+#if defined(ENABLE_REALWOW_SUPPORT)
+#define REALWOW_SUFFIX "-REALWOW"
+#else
+#define REALWOW_SUFFIX ""
+#endif
+
+#if defined(ENABLE_DASH_SUPPORT)
+#define DASH_SUFFIX "-DASH"
+#else
+#define DASH_SUFFIX ""
+#endif
+
+#if defined(ENABLE_PTP_SUPPORT)
+#define PTP_SUFFIX "-PTP"
+#else
+#define PTP_SUFFIX ""
+#endif
+
+#if defined(ENABLE_RSS_SUPPORT)
+#define RSS_SUFFIX "-RSS"
+#else
+#define RSS_SUFFIX ""
+#endif
+
+#define RTL8125_VERSION "9.016.01" NAPI_SUFFIX DASH_SUFFIX REALWOW_SUFFIX PTP_SUFFIX RSS_SUFFIX
+#define MODULENAME "r8125"
+#define PFX MODULENAME ": "
+
+#define GPL_CLAIM "\
+r8125  Copyright (C) 2025 Realtek NIC software team <nicfae@realtek.com> \n \
+This program comes with ABSOLUTELY NO WARRANTY; for details, please see <http://www.gnu.org/licenses/>. \n \
+This is free software, and you are welcome to redistribute it under certain conditions; see <http://www.gnu.org/licenses/>. \n"
+
+#ifdef RTL8125_DEBUG
+#define assert(expr) \
+        if(!(expr)) {                   \
+            printk("Assertion failed! %s,%s,%s,line=%d\n", \
+            #expr,__FILE__,__FUNCTION__,__LINE__);      \
+        }
+#define dprintk(fmt, args...)   do { printk(PFX fmt, ## args); } while (0)
+#else
+#define assert(expr) do {} while (0)
+#define dprintk(fmt, args...)   do {} while (0)
+#endif /* RTL8125_DEBUG */
+
+#define R8125_MSG_DEFAULT \
+    (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_IFUP | NETIF_MSG_IFDOWN)
+
+#ifdef CONFIG_R8125_NAPI
+#define rtl8125_rx_hwaccel_skb      vlan_hwaccel_receive_skb
+#define rtl8125_rx_quota(count, quota)  min(count, quota)
+#else
+#define rtl8125_rx_hwaccel_skb      vlan_hwaccel_rx
+#define rtl8125_rx_quota(count, quota)  count
+#endif
+
+#ifdef CONFIG_R8125_NAPI
+#define r8125_spin_lock(lock, flags)  (void)flags;spin_lock_bh(lock)
+#define r8125_spin_unlock(lock, flags)  (void)flags;spin_unlock_bh(lock)
+#else
+#define r8125_spin_lock(lock, flags)  spin_lock_irqsave(lock, flags)
+#define r8125_spin_unlock(lock, flags)  spin_unlock_irqrestore(lock, flags)
+#endif
+
+/* MAC address length */
+#ifndef MAC_ADDR_LEN
+#define MAC_ADDR_LEN    6
+#endif
+
+#ifndef MAC_PROTOCOL_LEN
+#define MAC_PROTOCOL_LEN    2
+#endif
+
+#ifndef ETH_FCS_LEN
+#define ETH_FCS_LEN	  4
+#endif
+
+#ifndef NETIF_F_TSO6
+#define NETIF_F_TSO6  0
+#endif
+
+#define Reserved2_data  7
+#define RX_DMA_BURST_unlimited  7   /* Maximum PCI burst, '7' is unlimited */
+#define RX_DMA_BURST_512    5
+#define RX_DMA_BURST_256    4
+#define TX_DMA_BURST_unlimited  7
+#define TX_DMA_BURST_1024   6
+#define TX_DMA_BURST_512    5
+#define TX_DMA_BURST_256    4
+#define TX_DMA_BURST_128    3
+#define TX_DMA_BURST_64     2
+#define TX_DMA_BURST_32     1
+#define TX_DMA_BURST_16     0
+#define Reserved1_data  0x3F
+#define RxPacketMaxSize 0x3FE8  /* 16K - 1 - ETH_HLEN - VLAN - CRC... */
+#define Jumbo_Frame_1k  ETH_DATA_LEN
+#define Jumbo_Frame_2k  (2*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_3k  (3*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_4k  (4*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_5k  (5*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_6k  (6*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_7k  (7*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_8k  (8*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_9k  (9*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define InterFrameGap   0x03    /* 3 means InterFrameGap = the shortest one */
+#define RxEarly_off_V1 (0x07 << 11)
+#define RxEarly_off_V2 (1 << 11)
+#define Rx_Single_fetch_V2 (1 << 14)
+#define Rx_Close_Multiple (1 << 21)
+#define Rx_Fetch_Number_8 (1 << 30)
+
+#define R8125_REGS_SIZE     (256)
+#define R8125_MAC_REGS_SIZE     (256)
+#define R8125_PHY_REGS_SIZE     (16*2)
+#define R8125_EPHY_REGS_SIZE  	(31*2)
+#define R8125_ERI_REGS_SIZE  	(0x100)
+#define R8125_REGS_DUMP_SIZE     (0x400)
+#define R8125_PCI_REGS_SIZE  	(0x100)
+#define R8125_NAPI_WEIGHT   64
+
+#define R8125_MAX_MSIX_VEC_8125A   4
+#define R8125_MAX_MSIX_VEC_8125B   32
+#define R8125_MAX_MSIX_VEC_8125D   32
+#define R8125_MIN_MSIX_VEC_8125B   22
+#define R8125_MIN_MSIX_VEC_8125BP  32
+#define R8125_MIN_MSIX_VEC_8125CP  31
+#define R8125_MIN_MSIX_VEC_8125D   20
+#define R8125_MAX_MSIX_VEC   32
+#define R8125_MAX_RX_QUEUES_VEC_V3 (16)
+
+#define RTL8125_TX_TIMEOUT  (6 * HZ)
+#define RTL8125_LINK_TIMEOUT    (1 * HZ)
+#define RTL8125_ESD_TIMEOUT (2 * HZ)
+#define RTL8125_DASH_TIMEOUT    (0)
+
+#define rtl8125_rx_page_size(order) (PAGE_SIZE << order)
+
+#define MAX_NUM_TX_DESC 1024    /* Maximum number of Tx descriptor registers */
+#define MAX_NUM_RX_DESC 1024    /* Maximum number of Rx descriptor registers */
+
+#define MIN_NUM_TX_DESC 256    /* Minimum number of Tx descriptor registers */
+#define MIN_NUM_RX_DESC 256    /* Minimum number of Rx descriptor registers */
+
+#define NUM_TX_DESC MAX_NUM_TX_DESC    /* Number of Tx descriptor registers */
+#define NUM_RX_DESC MAX_NUM_RX_DESC    /* Number of Rx descriptor registers */
+
+#ifdef ENABLE_DOUBLE_VLAN
+#define RX_BUF_SIZE 0x05F6  /* 0x05F6(1526) = 1514 + 8(double vlan) + 4(crc) bytes */
+#define RT_VALN_HLEN 8      /* 8(double vlan) bytes */
+#else
+#define RX_BUF_SIZE 0x05F2  /* 0x05F2(1522) = 1514 + 4(single vlan) + 4(crc) bytes */
+#define RT_VALN_HLEN 4      /* 4(single vlan) bytes */
+#endif
+
+#define R8125_MAX_TX_QUEUES (2)
+#define R8125_MAX_RX_QUEUES_V2 (4)
+#define R8125_MAX_RX_QUEUES_V3 (16)
+#define R8125_MAX_RX_QUEUES R8125_MAX_RX_QUEUES_V3
+#define R8125_MAX_QUEUES R8125_MAX_RX_QUEUES
+
+#define OCP_STD_PHY_BASE	0xa400
+
+//Channel Wait Count
+#define R8125_CHANNEL_WAIT_COUNT (20000)
+#define R8125_CHANNEL_WAIT_TIME (1)  // 1us
+#define R8125_CHANNEL_EXIT_DELAY_TIME (20)  //20us
+
+#ifdef ENABLE_LIB_SUPPORT
+#define R8125_MULTI_RX_Q(tp) 0
+#else
+#define R8125_MULTI_RX_Q(tp) (tp->num_rx_rings > 1)
+#endif
+
+#define NODE_ADDRESS_SIZE 6
+
+#define SHORT_PACKET_PADDING_BUF_SIZE 256
+
+#define RTK_MAGIC_DEBUG_VALUE 0x0badbeef
+
+/* write/read MMIO register */
+#define RTL_W8(tp, reg, val8)	writeb((val8), tp->mmio_addr + (reg))
+#define RTL_W16(tp, reg, val16)	writew((val16), tp->mmio_addr + (reg))
+#define RTL_W32(tp, reg, val32)	writel((val32), tp->mmio_addr + (reg))
+#define RTL_R8(tp, reg)		readb(tp->mmio_addr + (reg))
+#define RTL_R16(tp, reg)		readw(tp->mmio_addr + (reg))
+#define RTL_R32(tp, reg)		((unsigned long) readl(tp->mmio_addr + (reg)))
+
+#ifndef DMA_64BIT_MASK
+#define DMA_64BIT_MASK  0xffffffffffffffffULL
+#endif
+
+#ifndef DMA_32BIT_MASK
+#define DMA_32BIT_MASK  0x00000000ffffffffULL
+#endif
+
+#ifndef NETDEV_TX_OK
+#define NETDEV_TX_OK 0      /* driver took care of packet */
+#endif
+
+#ifndef NETDEV_TX_BUSY
+#define NETDEV_TX_BUSY 1    /* driver tx path was busy*/
+#endif
+
+#ifndef NETDEV_TX_LOCKED
+#define NETDEV_TX_LOCKED -1t /* driver tx lock was already taken */
+#endif
+
+#ifndef ADVERTISED_Pause
+#define ADVERTISED_Pause    (1 << 13)
+#endif
+
+#ifndef ADVERTISED_Asym_Pause
+#define ADVERTISED_Asym_Pause   (1 << 14)
+#endif
+
+#ifndef ADVERTISE_PAUSE_CAP
+#define ADVERTISE_PAUSE_CAP 0x400
+#endif
+
+#ifndef ADVERTISE_PAUSE_ASYM
+#define ADVERTISE_PAUSE_ASYM    0x800
+#endif
+
+#ifndef MII_CTRL1000
+#define MII_CTRL1000        0x09
+#endif
+
+#ifndef ADVERTISE_1000FULL
+#define ADVERTISE_1000FULL  0x200
+#endif
+
+#ifndef ADVERTISE_1000HALF
+#define ADVERTISE_1000HALF  0x100
+#endif
+
+#ifndef ADVERTISED_2500baseX_Full
+#define ADVERTISED_2500baseX_Full  0x8000
+#endif
+
+#define RTK_ADVERTISE_2500FULL  0x80
+#define RTK_ADVERTISE_5000FULL  0x100
+#define RTK_ADVERTISE_10000FULL  0x1000
+#define RTK_LPA_ADVERTISE_2500FULL  0x20
+#define RTK_LPA_ADVERTISE_5000FULL  0x40
+#define RTK_LPA_ADVERTISE_10000FULL  0x800
+
+#define RTK_EEE_ADVERTISE_2500FULL  BIT(0)
+#define RTK_EEE_ADVERTISE_5000FULL  BIT(1)
+#define RTK_LPA_EEE_ADVERTISE_2500FULL  BIT(0)
+#define RTK_LPA_EEE_ADVERTISE_5000FULL  BIT(1)
+
+/* Tx NO CLOSE */
+#define MAX_TX_NO_CLOSE_DESC_PTR_V2 0x10000
+#define MAX_TX_NO_CLOSE_DESC_PTR_MASK_V2 0xFFFF
+#define MAX_TX_NO_CLOSE_DESC_PTR_V3 0x100000000
+#define MAX_TX_NO_CLOSE_DESC_PTR_MASK_V3 0xFFFFFFFF
+#define MAX_TX_NO_CLOSE_DESC_PTR_V4 0x80000000
+#define MAX_TX_NO_CLOSE_DESC_PTR_MASK_V4 0x7FFFFFFF
+#define TX_NO_CLOSE_SW_PTR_MASK_V2 0x1FFFF
+
+#ifndef ETH_MIN_MTU
+#define ETH_MIN_MTU  68
+#endif
+
+#define D0_SPEED_UP_SPEED_DISABLE    0
+#define D0_SPEED_UP_SPEED_1000       1
+#define D0_SPEED_UP_SPEED_2500       2
+
+#define RTL8125_MAC_MCU_PAGE_SIZE 256 //256 words
+
+#ifndef WRITE_ONCE
+#define WRITE_ONCE(var, val) (*((volatile typeof(val) *)(&(var))) = (val))
+#endif
+#ifndef READ_ONCE
+#define READ_ONCE(var) (*((volatile typeof(var) *)(&(var))))
+#endif
+
+#define R8125_LINK_STATE_OFF 0
+#define R8125_LINK_STATE_ON 1
+#define R8125_LINK_STATE_UNKNOWN 2
+
+/*****************************************************************************/
+
+//#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3)
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27)) || \
+     ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)) && \
+      (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3))))
+/* copied from linux kernel 2.6.20 include/linux/netdev.h */
+#define NETDEV_ALIGN        32
+#define NETDEV_ALIGN_CONST  (NETDEV_ALIGN - 1)
+
+static inline void *netdev_priv(struct net_device *dev)
+{
+        return (char *)dev + ((sizeof(struct net_device)
+                               + NETDEV_ALIGN_CONST)
+                              & ~NETDEV_ALIGN_CONST);
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3)
+
+/*****************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#define RTLDEV  tp
+#else
+#define RTLDEV  dev
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+/*****************************************************************************/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+typedef struct net_device *napi_ptr;
+typedef int *napi_budget;
+
+#define napi dev
+#define RTL_NAPI_CONFIG(ndev, priv, function, weig) ndev->poll=function;    \
+                                ndev->weight=weig;
+#define RTL_NAPI_QUOTA(budget, ndev)            min(*budget, ndev->quota)
+#define RTL_GET_PRIV(stuct_ptr, priv_struct)        netdev_priv(stuct_ptr)
+#define RTL_GET_NETDEV(priv_ptr)
+#define RTL_RX_QUOTA(budget)          *budget
+#define RTL_NAPI_QUOTA_UPDATE(ndev, work_done, budget)  *budget -= work_done;   \
+                                ndev->quota -= work_done;
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        netif_rx_complete(dev)
+#define RTL_NETIF_RX_SCHEDULE_PREP(dev, napi)       netif_rx_schedule_prep(dev)
+#define __RTL_NETIF_RX_SCHEDULE(dev, napi)      __netif_rx_schedule(dev)
+#define RTL_NAPI_RETURN_VALUE               work_done >= work_to_do
+#define RTL_NAPI_ENABLE(dev, napi)          netif_poll_enable(dev)
+#define RTL_NAPI_DISABLE(dev, napi)         netif_poll_disable(dev)
+#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
+#else
+typedef struct napi_struct *napi_ptr;
+typedef int napi_budget;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)
+#define RTL_NAPI_CONFIG(ndev, priv, function, weight)   netif_napi_add_weight(ndev, &priv->napi, function, weight)
+#else
+#define RTL_NAPI_CONFIG(ndev, priv, function, weight)   netif_napi_add(ndev, &priv->napi, function, weight)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)
+#define RTL_NAPI_QUOTA(budget, ndev)            min(budget, budget)
+#define RTL_GET_PRIV(stuct_ptr, priv_struct)        container_of(stuct_ptr, priv_struct, stuct_ptr)
+#define RTL_GET_NETDEV(priv_ptr)            struct net_device *dev = priv_ptr->dev;
+#define RTL_RX_QUOTA(budget)          budget
+#define RTL_NAPI_QUOTA_UPDATE(ndev, work_done, budget)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        netif_rx_complete(dev, napi)
+#define RTL_NETIF_RX_SCHEDULE_PREP(dev, napi)       netif_rx_schedule_prep(dev, napi)
+#define __RTL_NETIF_RX_SCHEDULE(dev, napi)      __netif_rx_schedule(dev, napi)
+#endif
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2,6,29)
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        netif_rx_complete(napi)
+#define RTL_NETIF_RX_SCHEDULE_PREP(dev, napi)       netif_rx_schedule_prep(napi)
+#define __RTL_NETIF_RX_SCHEDULE(dev, napi)      __netif_rx_schedule(napi)
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        napi_complete_done(napi, work_done)
+#else
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        napi_complete(napi)
+#endif
+#define RTL_NETIF_RX_SCHEDULE_PREP(dev, napi)       napi_schedule_prep(napi)
+#define __RTL_NETIF_RX_SCHEDULE(dev, napi)      __napi_schedule(napi)
+#endif
+#define RTL_NAPI_RETURN_VALUE work_done
+#define RTL_NAPI_ENABLE(dev, napi)          napi_enable(napi)
+#define RTL_NAPI_DISABLE(dev, napi)         napi_disable(napi)
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+#define RTL_NAPI_DEL(priv)
+#else
+#define RTL_NAPI_DEL(priv)   netif_napi_del(&priv->napi)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+
+/*****************************************************************************/
+#ifdef CONFIG_R8125_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          napi_consume_skb(skb, budget)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          dev_consume_skb_any(skb);
+#else
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          dev_kfree_skb_any(skb);
+#endif  //LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+#else   //CONFIG_R8125_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          dev_consume_skb_any(skb);
+#else
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          dev_kfree_skb_any(skb);
+#endif
+#endif  //CONFIG_R8125_NAPI
+
+/*****************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+#ifdef __CHECKER__
+#define __iomem __attribute__((noderef, address_space(2)))
+extern void __chk_io_ptr(void __iomem *);
+#define __bitwise __attribute__((bitwise))
+#else
+#define __iomem
+#define __chk_io_ptr(x) (void)0
+#define __bitwise
+#endif
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+
+/*****************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+#ifdef __CHECKER__
+#define __force __attribute__((force))
+#else
+#define __force
+#endif
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+
+#ifndef module_param
+#define module_param(v,t,p) MODULE_PARM(v, "i");
+#endif
+
+#ifndef PCI_DEVICE
+#define PCI_DEVICE(vend,dev) \
+    .vendor = (vend), .device = (dev), \
+    .subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID
+#endif
+
+/*****************************************************************************/
+/* 2.5.28 => 2.4.23 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,28))
+
+static inline void _kc_synchronize_irq(void)
+{
+        synchronize_irq();
+}
+#undef synchronize_irq
+#define synchronize_irq(X) _kc_synchronize_irq()
+
+#include <linux/tqueue.h>
+#define work_struct tq_struct
+#undef INIT_WORK
+#define INIT_WORK(a,b,c) INIT_TQUEUE(a,(void (*)(void *))b,c)
+#undef container_of
+#define container_of list_entry
+#define schedule_work schedule_task
+#define flush_scheduled_work flush_scheduled_tasks
+#endif /* 2.5.28 => 2.4.17 */
+
+/*****************************************************************************/
+/* 2.6.4 => 2.6.0 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4))
+#define MODULE_VERSION(_version) MODULE_INFO(version, _version)
+#endif /* 2.6.4 => 2.6.0 */
+/*****************************************************************************/
+/* 2.6.0 => 2.5.28 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+#define MODULE_INFO(version, _version)
+#ifndef CONFIG_E1000_DISABLE_PACKET_SPLIT
+#define CONFIG_E1000_DISABLE_PACKET_SPLIT 1
+#endif
+
+#define pci_set_consistent_dma_mask(dev,mask) 1
+
+#undef dev_put
+#define dev_put(dev) __dev_put(dev)
+
+#ifndef skb_fill_page_desc
+#define skb_fill_page_desc _kc_skb_fill_page_desc
+extern void _kc_skb_fill_page_desc(struct sk_buff *skb, int i, struct page *page, int off, int size);
+#endif
+
+#ifndef pci_dma_mapping_error
+#define pci_dma_mapping_error _kc_pci_dma_mapping_error
+static inline int _kc_pci_dma_mapping_error(dma_addr_t dma_addr)
+{
+        return dma_addr == 0;
+}
+#endif
+
+#undef ALIGN
+#define ALIGN(x,a) (((x)+(a)-1)&~((a)-1))
+
+#endif /* 2.6.0 => 2.5.28 */
+
+/*****************************************************************************/
+/* 2.4.22 => 2.4.17 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22))
+#define pci_name(x) ((x)->slot_name)
+#endif /* 2.4.22 => 2.4.17 */
+
+/*****************************************************************************/
+/* 2.6.5 => 2.6.0 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5))
+#define pci_dma_sync_single_for_cpu pci_dma_sync_single
+#define pci_dma_sync_single_for_device  pci_dma_sync_single_for_cpu
+#endif /* 2.6.5 => 2.6.0 */
+
+/*****************************************************************************/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+/*
+ * initialize a work-struct's func and data pointers:
+ */
+#define PREPARE_WORK(_work, _func, _data)           \
+    do {                            \
+        (_work)->func = _func;              \
+        (_work)->data = _data;              \
+    } while (0)
+
+#endif
+/*****************************************************************************/
+/* 2.6.4 => 2.6.0 */
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(2,4,25) && \
+     LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)) || \
+    (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) && \
+      LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4)))
+#define ETHTOOL_OPS_COMPAT
+#endif /* 2.6.4 => 2.6.0 */
+
+/*****************************************************************************/
+/* Installations with ethtool version without eeprom, adapter id, or statistics
+ * support */
+
+#ifndef ETH_GSTRING_LEN
+#define ETH_GSTRING_LEN 32
+#endif
+
+#ifndef ETHTOOL_GSTATS
+#define ETHTOOL_GSTATS 0x1d
+#undef ethtool_drvinfo
+#define ethtool_drvinfo k_ethtool_drvinfo
+struct k_ethtool_drvinfo {
+        u32 cmd;
+        char driver[32];
+        char version[32];
+        char fw_version[32];
+        char bus_info[32];
+        char reserved1[32];
+        char reserved2[16];
+        u32 n_stats;
+        u32 testinfo_len;
+        u32 eedump_len;
+        u32 regdump_len;
+};
+
+struct ethtool_stats {
+        u32 cmd;
+        u32 n_stats;
+        u64 data[0];
+};
+#endif /* ETHTOOL_GSTATS */
+
+#ifndef ETHTOOL_PHYS_ID
+#define ETHTOOL_PHYS_ID 0x1c
+#endif /* ETHTOOL_PHYS_ID */
+
+#ifndef ETHTOOL_GSTRINGS
+#define ETHTOOL_GSTRINGS 0x1b
+enum ethtool_stringset {
+        ETH_SS_TEST             = 0,
+        ETH_SS_STATS,
+};
+struct ethtool_gstrings {
+        u32 cmd;            /* ETHTOOL_GSTRINGS */
+        u32 string_set;     /* string set id e.c. ETH_SS_TEST, etc*/
+        u32 len;            /* number of strings in the string set */
+        u8 data[0];
+};
+#endif /* ETHTOOL_GSTRINGS */
+
+#ifndef ETHTOOL_TEST
+#define ETHTOOL_TEST 0x1a
+enum ethtool_test_flags {
+        ETH_TEST_FL_OFFLINE = (1 << 0),
+        ETH_TEST_FL_FAILED  = (1 << 1),
+};
+struct ethtool_test {
+        u32 cmd;
+        u32 flags;
+        u32 reserved;
+        u32 len;
+        u64 data[0];
+};
+#endif /* ETHTOOL_TEST */
+
+#ifndef ETHTOOL_GEEPROM
+#define ETHTOOL_GEEPROM 0xb
+#undef ETHTOOL_GREGS
+struct ethtool_eeprom {
+        u32 cmd;
+        u32 magic;
+        u32 offset;
+        u32 len;
+        u8 data[0];
+};
+
+struct ethtool_value {
+        u32 cmd;
+        u32 data;
+};
+#endif /* ETHTOOL_GEEPROM */
+
+#ifndef ETHTOOL_GLINK
+#define ETHTOOL_GLINK 0xa
+#endif /* ETHTOOL_GLINK */
+
+#ifndef ETHTOOL_GREGS
+#define ETHTOOL_GREGS       0x00000004 /* Get NIC registers */
+#define ethtool_regs _kc_ethtool_regs
+/* for passing big chunks of data */
+struct _kc_ethtool_regs {
+        u32 cmd;
+        u32 version; /* driver-specific, indicates different chips/revs */
+        u32 len; /* bytes */
+        u8 data[0];
+};
+#endif /* ETHTOOL_GREGS */
+
+#ifndef ETHTOOL_GMSGLVL
+#define ETHTOOL_GMSGLVL     0x00000007 /* Get driver message level */
+#endif
+#ifndef ETHTOOL_SMSGLVL
+#define ETHTOOL_SMSGLVL     0x00000008 /* Set driver msg level, priv. */
+#endif
+#ifndef ETHTOOL_NWAY_RST
+#define ETHTOOL_NWAY_RST    0x00000009 /* Restart autonegotiation, priv */
+#endif
+#ifndef ETHTOOL_GLINK
+#define ETHTOOL_GLINK       0x0000000a /* Get link status */
+#endif
+#ifndef ETHTOOL_GEEPROM
+#define ETHTOOL_GEEPROM     0x0000000b /* Get EEPROM data */
+#endif
+#ifndef ETHTOOL_SEEPROM
+#define ETHTOOL_SEEPROM     0x0000000c /* Set EEPROM data */
+#endif
+#ifndef ETHTOOL_GCOALESCE
+#define ETHTOOL_GCOALESCE   0x0000000e /* Get coalesce config */
+/* for configuring coalescing parameters of chip */
+#define ethtool_coalesce _kc_ethtool_coalesce
+struct _kc_ethtool_coalesce {
+        u32 cmd;    /* ETHTOOL_{G,S}COALESCE */
+
+        /* How many usecs to delay an RX interrupt after
+         * a packet arrives.  If 0, only rx_max_coalesced_frames
+         * is used.
+         */
+        u32 rx_coalesce_usecs;
+
+        /* How many packets to delay an RX interrupt after
+         * a packet arrives.  If 0, only rx_coalesce_usecs is
+         * used.  It is illegal to set both usecs and max frames
+         * to zero as this would cause RX interrupts to never be
+         * generated.
+         */
+        u32 rx_max_coalesced_frames;
+
+        /* Same as above two parameters, except that these values
+         * apply while an IRQ is being serviced by the host.  Not
+         * all cards support this feature and the values are ignored
+         * in that case.
+         */
+        u32 rx_coalesce_usecs_irq;
+        u32 rx_max_coalesced_frames_irq;
+
+        /* How many usecs to delay a TX interrupt after
+         * a packet is sent.  If 0, only tx_max_coalesced_frames
+         * is used.
+         */
+        u32 tx_coalesce_usecs;
+
+        /* How many packets to delay a TX interrupt after
+         * a packet is sent.  If 0, only tx_coalesce_usecs is
+         * used.  It is illegal to set both usecs and max frames
+         * to zero as this would cause TX interrupts to never be
+         * generated.
+         */
+        u32 tx_max_coalesced_frames;
+
+        /* Same as above two parameters, except that these values
+         * apply while an IRQ is being serviced by the host.  Not
+         * all cards support this feature and the values are ignored
+         * in that case.
+         */
+        u32 tx_coalesce_usecs_irq;
+        u32 tx_max_coalesced_frames_irq;
+
+        /* How many usecs to delay in-memory statistics
+         * block updates.  Some drivers do not have an in-memory
+         * statistic block, and in such cases this value is ignored.
+         * This value must not be zero.
+         */
+        u32 stats_block_coalesce_usecs;
+
+        /* Adaptive RX/TX coalescing is an algorithm implemented by
+         * some drivers to improve latency under low packet rates and
+         * improve throughput under high packet rates.  Some drivers
+         * only implement one of RX or TX adaptive coalescing.  Anything
+         * not implemented by the driver causes these values to be
+         * silently ignored.
+         */
+        u32 use_adaptive_rx_coalesce;
+        u32 use_adaptive_tx_coalesce;
+
+        /* When the packet rate (measured in packets per second)
+         * is below pkt_rate_low, the {rx,tx}_*_low parameters are
+         * used.
+         */
+        u32 pkt_rate_low;
+        u32 rx_coalesce_usecs_low;
+        u32 rx_max_coalesced_frames_low;
+        u32 tx_coalesce_usecs_low;
+        u32 tx_max_coalesced_frames_low;
+
+        /* When the packet rate is below pkt_rate_high but above
+         * pkt_rate_low (both measured in packets per second) the
+         * normal {rx,tx}_* coalescing parameters are used.
+         */
+
+        /* When the packet rate is (measured in packets per second)
+         * is above pkt_rate_high, the {rx,tx}_*_high parameters are
+         * used.
+         */
+        u32 pkt_rate_high;
+        u32 rx_coalesce_usecs_high;
+        u32 rx_max_coalesced_frames_high;
+        u32 tx_coalesce_usecs_high;
+        u32 tx_max_coalesced_frames_high;
+
+        /* How often to do adaptive coalescing packet rate sampling,
+         * measured in seconds.  Must not be zero.
+         */
+        u32 rate_sample_interval;
+};
+#endif /* ETHTOOL_GCOALESCE */
+
+#ifndef ETHTOOL_SCOALESCE
+#define ETHTOOL_SCOALESCE   0x0000000f /* Set coalesce config. */
+#endif
+#ifndef ETHTOOL_GRINGPARAM
+#define ETHTOOL_GRINGPARAM  0x00000010 /* Get ring parameters */
+/* for configuring RX/TX ring parameters */
+#define ethtool_ringparam _kc_ethtool_ringparam
+struct _kc_ethtool_ringparam {
+        u32 cmd;    /* ETHTOOL_{G,S}RINGPARAM */
+
+        /* Read only attributes.  These indicate the maximum number
+         * of pending RX/TX ring entries the driver will allow the
+         * user to set.
+         */
+        u32 rx_max_pending;
+        u32 rx_mini_max_pending;
+        u32 rx_jumbo_max_pending;
+        u32 tx_max_pending;
+
+        /* Values changeable by the user.  The valid values are
+         * in the range 1 to the "*_max_pending" counterpart above.
+         */
+        u32 rx_pending;
+        u32 rx_mini_pending;
+        u32 rx_jumbo_pending;
+        u32 tx_pending;
+};
+#endif /* ETHTOOL_GRINGPARAM */
+
+#ifndef ETHTOOL_SRINGPARAM
+#define ETHTOOL_SRINGPARAM  0x00000011 /* Set ring parameters, priv. */
+#endif
+#ifndef ETHTOOL_GPAUSEPARAM
+#define ETHTOOL_GPAUSEPARAM 0x00000012 /* Get pause parameters */
+/* for configuring link flow control parameters */
+#define ethtool_pauseparam _kc_ethtool_pauseparam
+struct _kc_ethtool_pauseparam {
+        u32 cmd;    /* ETHTOOL_{G,S}PAUSEPARAM */
+
+        /* If the link is being auto-negotiated (via ethtool_cmd.autoneg
+         * being true) the user may set 'autonet' here non-zero to have the
+         * pause parameters be auto-negotiated too.  In such a case, the
+         * {rx,tx}_pause values below determine what capabilities are
+         * advertised.
+         *
+         * If 'autoneg' is zero or the link is not being auto-negotiated,
+         * then {rx,tx}_pause force the driver to use/not-use pause
+         * flow control.
+         */
+        u32 autoneg;
+        u32 rx_pause;
+        u32 tx_pause;
+};
+#endif /* ETHTOOL_GPAUSEPARAM */
+
+#ifndef ETHTOOL_SPAUSEPARAM
+#define ETHTOOL_SPAUSEPARAM 0x00000013 /* Set pause parameters. */
+#endif
+#ifndef ETHTOOL_GRXCSUM
+#define ETHTOOL_GRXCSUM     0x00000014 /* Get RX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_SRXCSUM
+#define ETHTOOL_SRXCSUM     0x00000015 /* Set RX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_GTXCSUM
+#define ETHTOOL_GTXCSUM     0x00000016 /* Get TX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_STXCSUM
+#define ETHTOOL_STXCSUM     0x00000017 /* Set TX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_GSG
+#define ETHTOOL_GSG     0x00000018 /* Get scatter-gather enable
+* (ethtool_value) */
+#endif
+#ifndef ETHTOOL_SSG
+#define ETHTOOL_SSG     0x00000019 /* Set scatter-gather enable
+* (ethtool_value). */
+#endif
+#ifndef ETHTOOL_TEST
+#define ETHTOOL_TEST        0x0000001a /* execute NIC self-test, priv. */
+#endif
+#ifndef ETHTOOL_GSTRINGS
+#define ETHTOOL_GSTRINGS    0x0000001b /* get specified string set */
+#endif
+#ifndef ETHTOOL_PHYS_ID
+#define ETHTOOL_PHYS_ID     0x0000001c /* identify the NIC */
+#endif
+#ifndef ETHTOOL_GSTATS
+#define ETHTOOL_GSTATS      0x0000001d /* get NIC-specific statistics */
+#endif
+#ifndef ETHTOOL_GTSO
+#define ETHTOOL_GTSO        0x0000001e /* Get TSO enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_STSO
+#define ETHTOOL_STSO        0x0000001f /* Set TSO enable (ethtool_value) */
+#endif
+
+#ifndef ETHTOOL_BUSINFO_LEN
+#define ETHTOOL_BUSINFO_LEN 32
+#endif
+
+/*****************************************************************************/
+
+enum RTL8125_registers {
+        MAC0            = 0x00,     /* Ethernet hardware address. */
+        MAC4            = 0x04,
+        MAR0            = 0x08,     /* Multicast filter. */
+        CounterAddrLow      = 0x10,
+        CounterAddrHigh     = 0x14,
+        CustomLED       = 0x18,
+        TxDescStartAddrLow  = 0x20,
+        TxDescStartAddrHigh = 0x24,
+        TxHDescStartAddrLow = 0x28,
+        TxHDescStartAddrHigh    = 0x2c,
+        FLASH           = 0x30,
+        INT_CFG0_8125   = 0x34,
+        ERSR            = 0x36,
+        ChipCmd         = 0x37,
+        TxPoll          = 0x38,
+        IntrMask        = 0x3C,
+        IntrStatus      = 0x3E,
+        TxConfig        = 0x40,
+        RxConfig        = 0x44,
+        TCTR            = 0x48,
+        Cfg9346         = 0x50,
+        Config0         = 0x51,
+        Config1         = 0x52,
+        Config2         = 0x53,
+        Config3         = 0x54,
+        Config4         = 0x55,
+        Config5         = 0x56,
+        TDFNR           = 0x57,
+        TimeInt0        = 0x58,
+        TimeInt1        = 0x5C,
+        PHYAR           = 0x60,
+        CSIDR           = 0x64,
+        CSIAR           = 0x68,
+        PHYstatus       = 0x6C,
+        MACDBG          = 0x6D,
+        GPIO            = 0x6E,
+        PMCH            = 0x6F,
+        ERIDR           = 0x70,
+        ERIAR           = 0x74,
+        INT_CFG1_8125   = 0x7A,
+        EPHY_RXER_NUM   = 0x7C,
+        EPHYAR          = 0x80,
+        LEDSEL_2_8125   = 0x84,
+        LEDSEL_1_8125   = 0x86,
+        TimeInt2        = 0x8C,
+        LEDSEL_3_8125   = 0x96,
+        OCPDR           = 0xB0,
+        MACOCP          = 0xB0,
+        OCPAR           = 0xB4,
+        SecMAC0         = 0xB4,
+        SecMAC4         = 0xB8,
+        PHYOCP          = 0xB8,
+        DBG_reg         = 0xD1,
+        TwiCmdReg       = 0xD2,
+        MCUCmd_reg      = 0xD3,
+        RxMaxSize       = 0xDA,
+        EFUSEAR         = 0xDC,
+        CPlusCmd        = 0xE0,
+        IntrMitigate    = 0xE2,
+        RxDescAddrLow   = 0xE4,
+        RxDescAddrHigh  = 0xE8,
+        MTPS            = 0xEC,
+        FuncEvent       = 0xF0,
+        PPSW            = 0xF2,
+        FuncEventMask   = 0xF4,
+        TimeInt3        = 0xF4,
+        FuncPresetState = 0xF8,
+        CMAC_IBCR0      = 0xF8,
+        CMAC_IBCR2      = 0xF9,
+        CMAC_IBIMR0     = 0xFA,
+        CMAC_IBISR0     = 0xFB,
+        FuncForceEvent  = 0xFC,
+        //8125
+        IMR0_8125          = 0x38,
+        ISR0_8125          = 0x3C,
+        TPPOLL_8125        = 0x90,
+        IMR1_8125          = 0x800,
+        ISR1_8125          = 0x802,
+        IMR2_8125          = 0x804,
+        ISR2_8125          = 0x806,
+        IMR3_8125          = 0x808,
+        ISR3_8125          = 0x80A,
+        BACKUP_ADDR0_8125  = 0x19E0,
+        BACKUP_ADDR1_8125  = 0X19E4,
+        TCTR0_8125         = 0x0048,
+        TCTR1_8125         = 0x004C,
+        TCTR2_8125         = 0x0088,
+        TCTR3_8125         = 0x001C,
+        TIMER_INT0_8125    = 0x0058,
+        TIMER_INT1_8125    = 0x005C,
+        TIMER_INT2_8125    = 0x008C,
+        TIMER_INT3_8125    = 0x00F4,
+        INT_MITI_V2_0_RX   = 0x0A00,
+        INT_MITI_V2_0_TX   = 0x0A02,
+        INT_MITI_V2_1_RX   = 0x0A08,
+        INT_MITI_V2_1_TX   = 0x0A0A,
+        IMR_V2_CLEAR_REG_8125 = 0x0D00,
+        ISR_V2_8125           = 0x0D04,
+        IMR_V2_SET_REG_8125   = 0x0D0C,
+        TDU_STA_8125       = 0x0D08,
+        RDU_STA_8125       = 0x0D0A,
+        IMR_V4_L2_CLEAR_REG_8125 = 0x0D10,
+        IMR_V4_L2_SET_REG_8125   = 0x0D18,
+        ISR_V4_L2_8125     = 0x0D14,
+        SW_TAIL_PTR0_8125BP = 0x0D30,
+        SW_TAIL_PTR1_8125BP = 0x0D38,
+        HW_CLO_PTR0_8125BP = 0x0D34,
+        HW_CLO_PTR1_8125BP = 0x0D3C,
+        DOUBLE_VLAN_CONFIG = 0x1000,
+        TX_NEW_CTRL        = 0x203E,
+        TNPDS_Q1_LOW_8125  = 0x2100,
+        PLA_TXQ0_IDLE_CREDIT = 0x2500,
+        PLA_TXQ1_IDLE_CREDIT = 0x2504,
+        SW_TAIL_PTR0_8125  = 0x2800,
+        HW_CLO_PTR0_8125   = 0x2802,
+        SW_TAIL_PTR0_8126  = 0x2800,
+        HW_CLO_PTR0_8126   = 0x2800,
+        RDSAR_Q1_LOW_8125  = 0x4000,
+        RSS_CTRL_8125      = 0x4500,
+        Q_NUM_CTRL_8125    = 0x4800,
+        RSS_KEY_8125       = 0x4600,
+        RSS_INDIRECTION_TBL_8125_V2 = 0x4700,
+        EEE_TXIDLE_TIMER_8125   = 0x6048,
+        /* mac ptp */
+        PTP_CTRL_8125      = 0x6800,
+        PTP_STATUS_8125    = 0x6802,
+        PTP_ISR_8125       = 0x6804,
+        PTP_IMR_8125       = 0x6805,
+        PTP_TIME_CORRECT_CMD_8125    = 0x6806,
+        PTP_SOFT_CONFIG_Time_NS_8125 = 0x6808,
+        PTP_SOFT_CONFIG_Time_S_8125  = 0x680C,
+        PTP_SOFT_CONFIG_Time_Sign    = 0x6812,
+        PTP_LOCAL_Time_SUB_NS_8125   = 0x6814,
+        PTP_LOCAL_Time_NS_8125       = 0x6818,
+        PTP_LOCAL_Time_S_8125        = 0x681C,
+        PTP_Time_SHIFTER_S_8125      = 0x6856,
+        PPS_RISE_TIME_NS_8125        = 0x68A0,
+        PPS_RISE_TIME_S_8125         = 0x68A4,
+        PTP_EGRESS_TIME_BASE_NS_8125 = 0XCF20,
+        PTP_EGRESS_TIME_BASE_S_8125  = 0XCF24,
+        /* phy ptp */
+        PTP_CTL                 = 0xE400,
+        PTP_INER                = 0xE402,
+        PTP_INSR                = 0xE404,
+        PTP_SYNCE_CTL           = 0xE406,
+        PTP_GEN_CFG             = 0xE408,
+        PTP_CLK_CFG_8126        = 0xE410,
+        PTP_CFG_NS_LO_8126      = 0xE412,
+        PTP_CFG_NS_HI_8126      = 0xE414,
+        PTP_CFG_S_LO_8126       = 0xE416,
+        PTP_CFG_S_MI_8126       = 0xE418,
+        PTP_CFG_S_HI_8126       = 0xE41A,
+        PTP_TAI_CFG             = 0xE420,
+        PTP_TAI_TS_S_LO         = 0xE42A,
+        PTP_TAI_TS_S_HI         = 0xE42C,
+        PTP_TRX_TS_STA          = 0xE430,
+        PTP_TRX_TS_NS_LO        = 0xE446,
+        PTP_TRX_TS_NS_HI        = 0xE448,
+        PTP_TRX_TS_S_LO         = 0xE44A,
+        PTP_TRX_TS_S_MI         = 0xE44C,
+        PTP_TRX_TS_S_HI         = 0xE44E,
+
+
+        //TCAM
+        TCAM_NOTVALID_ADDR           = 0xA000,
+        TCAM_VALID_ADDR              = 0xA800,
+        TCAM_MAC_ADDR                = 448,
+        TCAM_VLAN_TAG                = 496,
+        //TCAM V2
+        TCAM_NOTVALID_ADDR_V2           = 0xA000,
+        TCAM_VALID_ADDR_V2              = 0xB000,
+        TCAM_MAC_ADDR_V2                = 0x00,
+        TCAM_VLAN_TAG_V2                = 0x03,
+        //ipc2
+        IB2SOC_SET     = 0x0010,
+        IB2SOC_DATA    = 0x0014,
+        IB2SOC_CMD     = 0x0018,
+        IB2SOC_IMR     = 0x001C,
+
+        RISC_IMR_8125BP     = 0x0D20,
+        RISC_ISR_8125BP     = 0x0D22,
+};
+
+enum RTL8125_register_content {
+        /* InterruptStatusBits */
+        SYSErr      = 0x8000,
+        PCSTimeout  = 0x4000,
+        SWInt       = 0x0100,
+        TxDescUnavail   = 0x0080,
+        RxFIFOOver  = 0x0040,
+        LinkChg     = 0x0020,
+        RxDescUnavail   = 0x0010,
+        TxErr       = 0x0008,
+        TxOK        = 0x0004,
+        RxErr       = 0x0002,
+        RxOK        = 0x0001,
+        RxDU1       = 0x0002,
+        RxOK1       = 0x0001,
+
+        /* RxStatusDesc */
+        RxRWT = (1 << 22),
+        RxRES = (1 << 21),
+        RxRUNT = (1 << 20),
+        RxCRC = (1 << 19),
+
+        RxRWT_V3 = (1 << 18),
+        RxRES_V3 = (1 << 20),
+        RxRUNT_V3 = (1 << 19),
+        RxCRC_V3 = (1 << 17),
+
+        RxRES_V4 = (1 << 22),
+        RxRUNT_V4 = (1 << 21),
+        RxCRC_V4 = (1 << 20),
+
+        /* ChipCmdBits */
+        StopReq  = 0x80,
+        CmdReset = 0x10,
+        CmdRxEnb = 0x08,
+        CmdTxEnb = 0x04,
+        RxBufEmpty = 0x01,
+
+        /* Cfg9346Bits */
+        Cfg9346_EEM_MASK = 0xC0,
+        Cfg9346_Lock = 0x00,
+        Cfg9346_Unlock = 0xC0,
+        Cfg9346_EEDO = (1 << 0),
+        Cfg9346_EEDI = (1 << 1),
+        Cfg9346_EESK = (1 << 2),
+        Cfg9346_EECS = (1 << 3),
+        Cfg9346_EEM0 = (1 << 6),
+        Cfg9346_EEM1 = (1 << 7),
+
+        /* rx_mode_bits */
+        AcceptErr = 0x20,
+        AcceptRunt = 0x10,
+        AcceptBroadcast = 0x08,
+        AcceptMulticast = 0x04,
+        AcceptMyPhys = 0x02,
+        AcceptAllPhys = 0x01,
+        AcceppVlanPhys = 0x8000,
+
+        /* Transmit Priority Polling*/
+        HPQ = 0x80,
+        NPQ = 0x40,
+        FSWInt = 0x01,
+
+        /* RxConfigBits */
+        Reserved2_shift = 13,
+        RxCfgDMAShift = 8,
+        EnableRxDescV3 = (1 << 24),
+        EnableRxDescV4_1 = (1 << 24),
+        EnableOuterVlan = (1 << 23),
+        EnableInnerVlan = (1 << 22),
+        RxCfg_128_int_en = (1 << 15),
+        RxCfg_fet_multi_en = (1 << 14),
+        RxCfg_half_refetch = (1 << 13),
+        RxCfg_pause_slot_en = (1 << 11),
+        RxCfg_9356SEL = (1 << 6),
+        EnableRxDescV4_0 = (1 << 1), //not in rcr
+
+        /* TxConfigBits */
+        TxInterFrameGapShift = 24,
+        TxDMAShift = 8, /* DMA burst value (0-7) is shift this many bits */
+        TxMACLoopBack = (1 << 17),  /* MAC loopback */
+
+        /* Config1 register */
+        LEDS1       = (1 << 7),
+        LEDS0       = (1 << 6),
+        Speed_down  = (1 << 4),
+        MEMMAP      = (1 << 3),
+        IOMAP       = (1 << 2),
+        VPD         = (1 << 1),
+        PMEnable    = (1 << 0), /* Power Management Enable */
+
+        /* Config2 register */
+        PMSTS_En    = (1 << 5),
+
+        /* Config3 register */
+        Isolate_en  = (1 << 12), /* Isolate enable */
+        MagicPacket = (1 << 5), /* Wake up when receives a Magic Packet */
+        LinkUp      = (1 << 4), /* This bit is reserved in RTL8125B.*/
+        /* Wake up when the cable connection is re-established */
+        ECRCEN      = (1 << 3), /* This bit is reserved in RTL8125B*/
+        Jumbo_En0   = (1 << 2), /* This bit is reserved in RTL8125B*/
+        RDY_TO_L23  = (1 << 1), /* This bit is reserved in RTL8125B*/
+        Beacon_en   = (1 << 0), /* This bit is reserved in RTL8125B*/
+
+        /* Config4 register */
+        Jumbo_En1   = (1 << 1), /* This bit is reserved in RTL8125B*/
+
+        /* Config5 register */
+        BWF     = (1 << 6), /* Accept Broadcast wakeup frame */
+        MWF     = (1 << 5), /* Accept Multicast wakeup frame */
+        UWF     = (1 << 4), /* Accept Unicast wakeup frame */
+        LanWake     = (1 << 1), /* LanWake enable/disable */
+        PMEStatus   = (1 << 0), /* PME status can be reset by PCI RST# */
+
+        /* CPlusCmd */
+        EnableBist  = (1 << 15),
+        Macdbgo_oe  = (1 << 14),
+        Normal_mode = (1 << 13),
+        Force_halfdup   = (1 << 12),
+        Force_rxflow_en = (1 << 11),
+        Force_txflow_en = (1 << 10),
+        Cxpl_dbg_sel    = (1 << 9),//This bit is reserved in RTL8125B
+        ASF     = (1 << 8),//This bit is reserved in RTL8125C
+        PktCntrDisable  = (1 << 7),
+        RxVlan      = (1 << 6),
+        RxChkSum    = (1 << 5),
+        Macdbgo_sel = 0x001C,
+        INTT_0      = 0x0000,
+        INTT_1      = 0x0001,
+        INTT_2      = 0x0002,
+        INTT_3      = 0x0003,
+
+        /* rtl8125_PHYstatus */
+        PowerSaveStatus = 0x80,
+        _1000bpsL = 0x80000,
+        _5000bpsF = 0x1000,
+        _2500bpsF = 0x400,
+        _2500bpsL = 0x200,
+        TxFlowCtrl = 0x40,
+        RxFlowCtrl = 0x20,
+        _1000bpsF = 0x10,
+        _100bps = 0x08,
+        _10bps = 0x04,
+        LinkStatus = 0x02,
+        FullDup = 0x01,
+
+        /* DBG_reg */
+        Fix_Nak_1 = (1 << 4),
+        Fix_Nak_2 = (1 << 3),
+        DBGPIN_E2 = (1 << 0),
+
+        /* ResetCounterCommand */
+        CounterReset = 0x1,
+        /* DumpCounterCommand */
+        CounterDump = 0x8,
+
+        /* PHY access */
+        PHYAR_Flag = 0x80000000,
+        PHYAR_Write = 0x80000000,
+        PHYAR_Read = 0x00000000,
+        PHYAR_Reg_Mask = 0x1f,
+        PHYAR_Reg_shift = 16,
+        PHYAR_Data_Mask = 0xffff,
+
+        /* EPHY access */
+        EPHYAR_Flag = 0x80000000,
+        EPHYAR_Write = 0x80000000,
+        EPHYAR_Read = 0x00000000,
+        EPHYAR_Reg_Mask = 0x3f,
+        EPHYAR_Reg_Mask_v2 = 0x7f,
+        EPHYAR_Reg_shift = 16,
+        EPHYAR_Data_Mask = 0xffff,
+
+        /* CSI access */
+        CSIAR_Flag = 0x80000000,
+        CSIAR_Write = 0x80000000,
+        CSIAR_Read = 0x00000000,
+        CSIAR_ByteEn = 0x0f,
+        CSIAR_ByteEn_shift = 12,
+        CSIAR_Addr_Mask = 0x0fff,
+
+        /* ERI access */
+        ERIAR_Flag = 0x80000000,
+        ERIAR_Write = 0x80000000,
+        ERIAR_Read = 0x00000000,
+        ERIAR_Addr_Align = 4, /* ERI access register address must be 4 byte alignment */
+        ERIAR_ExGMAC = 0,
+        ERIAR_MSIX = 1,
+        ERIAR_ASF = 2,
+        ERIAR_OOB = 2,
+        ERIAR_Type_shift = 16,
+        ERIAR_ByteEn = 0x0f,
+        ERIAR_ByteEn_shift = 12,
+
+        /* OCP GPHY access */
+        OCPDR_Write = 0x80000000,
+        OCPDR_Read = 0x00000000,
+        OCPDR_Reg_Mask = 0xFF,
+        OCPDR_Data_Mask = 0xFFFF,
+        OCPDR_GPHY_Reg_shift = 16,
+        OCPAR_Flag = 0x80000000,
+        OCPAR_GPHY_Write = 0x8000F060,
+        OCPAR_GPHY_Read = 0x0000F060,
+        OCPR_Write = 0x80000000,
+        OCPR_Read = 0x00000000,
+        OCPR_Addr_Reg_shift = 16,
+        OCPR_Flag = 0x80000000,
+        OCP_STD_PHY_BASE_PAGE = 0x0A40,
+
+        /* MCU Command */
+        Now_is_oob = (1 << 7),
+        Txfifo_empty = (1 << 5),
+        Rxfifo_empty = (1 << 4),
+
+        /* E-FUSE access */
+        EFUSE_WRITE = 0x80000000,
+        EFUSE_WRITE_OK  = 0x00000000,
+        EFUSE_READ  = 0x00000000,
+        EFUSE_READ_OK   = 0x80000000,
+        EFUSE_WRITE_V3 = 0x40000000,
+        EFUSE_WRITE_OK_V3  = 0x00000000,
+        EFUSE_READ_V3  = 0x80000000,
+        EFUSE_READ_OK_V3   = 0x00000000,
+        EFUSE_Reg_Mask  = 0x03FF,
+        EFUSE_Reg_Shift = 8,
+        EFUSE_Check_Cnt = 300,
+        EFUSE_READ_FAIL = 0xFF,
+        EFUSE_Data_Mask = 0x000000FF,
+
+        /* GPIO */
+        GPIO_en = (1 << 0),
+
+        /* PTP */
+        PTP_ISR_TOK = (1 << 1),
+        PTP_ISR_TER = (1 << 2),
+        PTP_EXEC_CMD = (1 << 7),
+        PTP_ADJUST_TIME_NS_NEGATIVE = (1 << 30),
+        PTP_ADJUST_TIME_S_NEGATIVE = (1ULL << 48),
+        PTP_SOFT_CONFIG_TIME_NS_NEGATIVE = (1 << 30),
+        PTP_SOFT_CONFIG_TIME_S_NEGATIVE = (1ULL << 48),
+
+        /* New Interrupt Bits */
+        INT_CFG0_ENABLE_8125 = (1 << 0),
+        INT_CFG0_TIMEOUT0_BYPASS_8125 = (1 << 1),
+        INT_CFG0_MITIGATION_BYPASS_8125 = (1 << 2),
+        INT_CFG0_RDU_BYPASS_8126 = (1 << 4),
+        INT_CFG0_MSIX_ENTRY_NUM_MODE = (1 << 5),
+        INT_CFG0_AUTO_CLEAR_IMR = (1 << 5),
+        INT_CFG0_AVOID_MISS_INTR = (1 << 6),
+        ISRIMR_V2_ROK_Q0     = (1 << 0),
+        ISRIMR_TOK_Q0        = (1 << 16),
+        ISRIMR_TOK_Q1        = (1 << 18),
+        ISRIMR_V2_LINKCHG    = (1 << 21),
+
+        ISRIMR_V4_ROK_Q0     = (1 << 0),
+        ISRIMR_V4_LINKCHG    = (1 << 29),
+        ISRIMR_V4_LAYER2_INTR_STS = (1 << 31),
+        ISRIMR_V4_L2_IPC2    = (1 << 17),
+
+        ISRIMR_V5_ROK_Q0     = (1 << 0),
+        ISRIMR_V5_TOK_Q0     = (1 << 16),
+        ISRIMR_V5_TOK_Q1     = (1 << 17),
+        ISRIMR_V5_LINKCHG    = (1 << 18),
+
+        ISRIMR_V7_ROK_Q0     = (1 << 0),
+        ISRIMR_V7_TOK_Q0     = (1 << 27),
+        ISRIMR_V7_TOK_Q1     = (1 << 28),
+        ISRIMR_V7_LINKCHG    = (1 << 29),
+
+        /* IPC2 */
+        RISC_IPC2_INTR    = (1 << 1),
+
+        /* Magic Number */
+        RTL8125_MAGIC_NUMBER = 0x0badbadbadbadbadull,
+};
+
+enum _DescStatusBit {
+        DescOwn     = (1 << 31), /* Descriptor is owned by NIC */
+        RingEnd     = (1 << 30), /* End of descriptor ring */
+        FirstFrag   = (1 << 29), /* First segment of a packet */
+        LastFrag    = (1 << 28), /* Final segment of a packet */
+
+        DescOwn_V3     = (DescOwn), /* Descriptor is owned by NIC */
+        RingEnd_V3     = (RingEnd), /* End of descriptor ring */
+        FirstFrag_V3   = (1 << 25), /* First segment of a packet */
+        LastFrag_V3    = (1 << 24), /* Final segment of a packet */
+
+        DescOwn_V4     = (DescOwn), /* Descriptor is owned by NIC */
+        RingEnd_V4     = (RingEnd), /* End of descriptor ring */
+        FirstFrag_V4   = (FirstFrag), /* First segment of a packet */
+        LastFrag_V4    = (LastFrag), /* Final segment of a packet */
+
+        /* Tx private */
+        /*------ offset 0 of tx descriptor ------*/
+        LargeSend   = (1 << 27), /* TCP Large Send Offload (TSO) */
+        GiantSendv4 = (1 << 26), /* TCP Giant Send Offload V4 (GSOv4) */
+        GiantSendv6 = (1 << 25), /* TCP Giant Send Offload V6 (GSOv6) */
+        LargeSend_DP = (1 << 16), /* TCP Large Send Offload (TSO) */
+        MSSShift    = 16,        /* MSS value position */
+        MSSMask     = 0x7FFU,    /* MSS value 11 bits */
+        TxIPCS      = (1 << 18), /* Calculate IP checksum */
+        TxUDPCS     = (1 << 17), /* Calculate UDP/IP checksum */
+        TxTCPCS     = (1 << 16), /* Calculate TCP/IP checksum */
+        TxVlanTag   = (1 << 17), /* Add VLAN tag */
+
+        /*@@@@@@ offset 4 of tx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        TxUDPCS_C   = (1 << 31), /* Calculate UDP/IP checksum */
+        TxTCPCS_C   = (1 << 30), /* Calculate TCP/IP checksum */
+        TxIPCS_C    = (1 << 29), /* Calculate IP checksum */
+        TxIPV6F_C   = (1 << 28), /* Indicate it is an IPv6 packet */
+        /*@@@@@@ offset 4 of tx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+
+        /* Rx private */
+        /*------ offset 0 of rx descriptor ------*/
+        PID1        = (1 << 18), /* Protocol ID bit 1/2 */
+        PID0        = (1 << 17), /* Protocol ID bit 2/2 */
+
+#define RxProtoUDP  (PID1)
+#define RxProtoTCP  (PID0)
+#define RxProtoIP   (PID1 | PID0)
+#define RxProtoMask RxProtoIP
+
+        RxIPF       = (1 << 16), /* IP checksum failed */
+        RxUDPF      = (1 << 15), /* UDP/IP checksum failed */
+        RxTCPF      = (1 << 14), /* TCP/IP checksum failed */
+        RxVlanTag   = (1 << 16), /* VLAN tag available */
+
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxUDPT      = (1 << 18),
+        RxTCPT      = (1 << 17),
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxV6F       = (1 << 31),
+        RxV4F       = (1 << 30),
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+
+        PID1_v3        = (1 << 29), /* Protocol ID bit 1/2 */
+        PID0_v3        = (1 << 28), /* Protocol ID bit 2/2 */
+
+#define RxProtoUDP_v3  (PID1_v3)
+#define RxProtoTCP_v3  (PID0_v3)
+#define RxProtoIP_v3   (PID1_v3 | PID0_v3)
+#define RxProtoMask_v3 RxProtoIP_v3
+
+        RxIPF_v3       = (1 << 26), /* IP checksum failed */
+        RxUDPF_v3      = (1 << 25), /* UDP/IP checksum failed */
+        RxTCPF_v3      = (1 << 24), /* TCP/IP checksum failed */
+        RxSCTPF_v3     = (1 << 23), /* SCTP checksum failed */
+        RxVlanTag_v3   = (RxVlanTag), /* VLAN tag available */
+
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxUDPT_v3      = (1 << 29),
+        RxTCPT_v3      = (1 << 28),
+        RxSCTP_v3      = (1 << 27),
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxV6F_v3       = (RxV6F),
+        RxV4F_v3       = (RxV4F),
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+        RxIPF_v4       = (1 << 17), /* IP checksum failed */
+        RxUDPF_v4      = (1 << 16), /* UDP/IP checksum failed */
+        RxTCPF_v4      = (1 << 15), /* TCP/IP checksum failed */
+        RxSCTPF_v4     = (1 << 19), /* SCTP checksum failed */
+        RxVlanTag_v4   = (RxVlanTag), /* VLAN tag available */
+
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxUDPT_v4      = (1 << 19),
+        RxTCPT_v4      = (1 << 18),
+        RxSCTP_v4      = (1 << 19),
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxV6F_v4       = (RxV6F),
+        RxV4F_v4       = (RxV4F),
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+};
+
+enum features {
+//  RTL_FEATURE_WOL = (1 << 0),
+        RTL_FEATURE_MSI = (1 << 1),
+        RTL_FEATURE_MSIX = (1 << 2),
+};
+
+enum wol_capability {
+        WOL_DISABLED = 0,
+        WOL_ENABLED = 1
+};
+
+enum bits {
+        BIT_0 = (1 << 0),
+        BIT_1 = (1 << 1),
+        BIT_2 = (1 << 2),
+        BIT_3 = (1 << 3),
+        BIT_4 = (1 << 4),
+        BIT_5 = (1 << 5),
+        BIT_6 = (1 << 6),
+        BIT_7 = (1 << 7),
+        BIT_8 = (1 << 8),
+        BIT_9 = (1 << 9),
+        BIT_10 = (1 << 10),
+        BIT_11 = (1 << 11),
+        BIT_12 = (1 << 12),
+        BIT_13 = (1 << 13),
+        BIT_14 = (1 << 14),
+        BIT_15 = (1 << 15),
+        BIT_16 = (1 << 16),
+        BIT_17 = (1 << 17),
+        BIT_18 = (1 << 18),
+        BIT_19 = (1 << 19),
+        BIT_20 = (1 << 20),
+        BIT_21 = (1 << 21),
+        BIT_22 = (1 << 22),
+        BIT_23 = (1 << 23),
+        BIT_24 = (1 << 24),
+        BIT_25 = (1 << 25),
+        BIT_26 = (1 << 26),
+        BIT_27 = (1 << 27),
+        BIT_28 = (1 << 28),
+        BIT_29 = (1 << 29),
+        BIT_30 = (1 << 30),
+        BIT_31 = (1 << 31)
+};
+
+/* Phy Fuse Dout */
+#define R8125_PHY_FUSE_DOUT_NUM (32)
+#define R8125_MAX_PHY_FUSE_DOUT_NUM R8125_PHY_FUSE_DOUT_NUM
+
+#define RTL8125_CP_NUM 4
+#define RTL8125_MAX_SUPPORT_CP_LEN 110
+
+enum rtl8125_cp_status {
+        rtl8125_cp_normal = 0,
+        rtl8125_cp_short,
+        rtl8125_cp_open,
+        rtl8125_cp_mismatch,
+        rtl8125_cp_unknown
+};
+
+enum efuse {
+        EFUSE_NOT_SUPPORT = 0,
+        EFUSE_SUPPORT_V1,
+        EFUSE_SUPPORT_V2,
+        EFUSE_SUPPORT_V3,
+        EFUSE_SUPPORT_V4,
+};
+#define RsvdMask    0x3fffc000
+#define RsvdMaskV3  0x3fff8000
+#define RsvdMaskV4  RsvdMaskV3
+
+struct TxDesc {
+        u32 opts1;
+        u32 opts2;
+        u64 addr;
+        u32 reserved0;
+        u32 reserved1;
+        u32 reserved2;
+        u32 reserved3;
+};
+
+struct RxDesc {
+        u32 opts1;
+        u32 opts2;
+        u64 addr;
+};
+
+struct RxDescV3 {
+        union {
+                struct {
+                        u32 rsv1;
+                        u32 rsv2;
+                } RxDescDDWord1;
+        };
+
+        union {
+                struct {
+                        u32 RSSResult;
+                        u16 HeaderBufferLen;
+                        u16 HeaderInfo;
+                } RxDescNormalDDWord2;
+
+                struct {
+                        u32 rsv5;
+                        u32 rsv6;
+                } RxDescDDWord2;
+        };
+
+        union {
+                u64   addr;
+
+                struct {
+                        u32 TimeStampLow;
+                        u32 TimeStampHigh;
+                } RxDescTimeStamp;
+
+                struct {
+                        u32 rsv8;
+                        u32 rsv9;
+                } RxDescDDWord3;
+        };
+
+        union {
+                struct {
+                        u32 opts2;
+                        u32 opts1;
+                } RxDescNormalDDWord4;
+
+                struct {
+                        u16 TimeStampHHigh;
+                        u16 rsv11;
+                        u32 opts1;
+                } RxDescPTPDDWord4;
+        };
+};
+
+struct RxDescV4 {
+        union {
+                u64   addr;
+
+                struct {
+                        u32 RSSInfo;
+                        u32 RSSResult;
+                } RxDescNormalDDWord1;
+        };
+
+        struct {
+                u32 opts2;
+                u32 opts1;
+        } RxDescNormalDDWord2;
+};
+
+enum rxdesc_type {
+        RXDESC_TYPE_NORMAL=0,
+        RXDESC_TYPE_NEXT,
+        RXDESC_TYPE_PTP,
+        RXDESC_TYPE_MAX
+};
+
+//Rx Desc Type
+enum rx_desc_ring_type {
+        RX_DESC_RING_TYPE_UNKNOWN=0,
+        RX_DESC_RING_TYPE_1,
+        RX_DESC_RING_TYPE_2,
+        RX_DESC_RING_TYPE_3,
+        RX_DESC_RING_TYPE_4,
+        RX_DESC_RING_TYPE_MAX
+};
+
+enum rx_desc_len {
+        RX_DESC_LEN_TYPE_1 = (sizeof(struct RxDesc)),
+        RX_DESC_LEN_TYPE_3 = (sizeof(struct RxDescV3)),
+        RX_DESC_LEN_TYPE_4 = (sizeof(struct RxDescV4))
+};
+
+struct ring_info {
+        struct sk_buff  *skb;
+        u32     len;
+        unsigned int   bytecount;
+        unsigned short gso_segs;
+        u8      __pad[sizeof(void *) - sizeof(u32)];
+};
+
+struct pci_resource {
+        u8  cmd;
+        u8  cls;
+        u16 io_base_h;
+        u16 io_base_l;
+        u16 mem_base_h;
+        u16 mem_base_l;
+        u8  ilr;
+        u16 resv_0x1c_h;
+        u16 resv_0x1c_l;
+        u16 resv_0x20_h;
+        u16 resv_0x20_l;
+        u16 resv_0x24_h;
+        u16 resv_0x24_l;
+        u16 resv_0x2c_h;
+        u16 resv_0x2c_l;
+        u32 pci_sn_l;
+        u32 pci_sn_h;
+};
+
+enum r8125_dash_req_flag {
+        R8125_RCV_REQ_SYS_OK = 0,
+        R8125_RCV_REQ_DASH_OK,
+        R8125_SEND_REQ_HOST_OK,
+        R8125_CMAC_RESET,
+        R8125_CMAC_DISALE_RX_FLAG_MAX,
+        R8125_DASH_REQ_FLAG_MAX
+};
+
+enum r8125_flag {
+        R8125_FLAG_DOWN = 0,
+        R8125_FLAG_TASK_RESET_PENDING,
+        R8125_FLAG_TASK_ESD_CHECK_PENDING,
+        R8125_FLAG_TASK_LINKCHG_CHECK_PENDING,
+        R8125_FLAG_TASK_LINK_CHECK_PENDING,
+        R8125_FLAG_TASK_DASH_CHECK_PENDING,
+        R8125_FLAG_MAX
+};
+
+enum r8125_sysfs_flag {
+        R8125_SYSFS_RTL_ADV = 0,
+        R8125_SYSFS_FLAG_MAX
+};
+
+struct rtl8125_tx_ring {
+        void* priv;
+        struct net_device *netdev;
+        u32 index;
+        u32 cur_tx; /* Index into the Tx descriptor buffer of next Rx pkt. */
+        u32 dirty_tx;
+        u32 num_tx_desc; /* Number of Tx descriptor registers */
+        struct TxDesc *TxDescArray; /* 256-aligned Tx descriptor ring */
+        dma_addr_t TxPhyAddr;
+        u32 TxDescAllocSize;
+        struct ring_info tx_skb[MAX_NUM_TX_DESC]; /* Tx data buffers */
+
+        u32 NextHwDesCloPtr;
+        u32 BeginHwDesCloPtr;
+
+        u16 hw_clo_ptr_reg;
+        u16 sw_tail_ptr_reg;
+
+        u16 tdsar_reg; /* Transmit Descriptor Start Address */
+};
+
+struct rtl8125_rx_buffer {
+        struct page *page;
+        u32 page_offset;
+        dma_addr_t dma;
+        void* data;
+        struct sk_buff *skb;
+};
+
+struct rtl8125_rx_ring {
+        void* priv;
+        struct net_device *netdev;
+        u32 index;
+        u32 cur_rx; /* Index into the Rx descriptor buffer of next Rx pkt. */
+        u32 dirty_rx;
+        u32 num_rx_desc; /* Number of Rx descriptor registers */
+        struct RxDesc *RxDescArray; /* 256-aligned Rx descriptor ring */
+        u32 RxDescAllocSize;
+        u64 RxDescPhyAddr[MAX_NUM_RX_DESC]; /* Rx desc physical address*/
+        dma_addr_t RxPhyAddr;
+#ifdef ENABLE_PAGE_REUSE
+        struct rtl8125_rx_buffer rx_buffer[MAX_NUM_RX_DESC];
+        u16 rx_offset;
+#else
+        struct sk_buff *Rx_skbuff[MAX_NUM_RX_DESC]; /* Rx data buffers */
+#endif //ENABLE_PAGE_REUSE
+
+        u16 rdsar_reg; /* Receive Descriptor Start Address */
+};
+
+struct r8125_napi {
+#ifdef CONFIG_R8125_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+        struct napi_struct napi;
+#endif
+#endif
+        void* priv;
+        int index;
+};
+
+struct r8125_irq {
+        irq_handler_t	handler;
+        unsigned int	vector;
+        u8		requested;
+        char		name[IFNAMSIZ + 10];
+};
+
+#pragma pack(1)
+struct rtl8125_regs {
+        //00
+        u8 mac_id[6];
+        u16 reg_06;
+        u8 mar[8];
+        //10
+        u64 dtccr;
+        u16 ledsel0;
+        u16 legreg;
+        u32 tctr3;
+        //20
+        u32 txq0_dsc_st_addr_0;
+        u32 txq0_dsc_st_addr_2;
+        u64 reg_28;
+        //30
+        u16 rit;
+        u16 ritc;
+        u16 reg_34;
+        u8 reg_36;
+        u8 command;
+        u32 imr0;
+        u32 isr0;
+        //40
+        u32 tcr;
+        u32 rcr;
+        u32 tctr0;
+        u32 tctr1;
+        //50
+        u8 cr93c46;
+        u8 config0;
+        u8 config1;
+        u8 config2;
+        u8 config3;
+        u8 config4;
+        u8 config5;
+        u8 tdfnr;
+        u32 timer_int0;
+        u32 timer_int1;
+        //60
+        u32 gphy_mdcmdio;
+        u32 csidr;
+        u32 csiar;
+        u16 phy_status;
+        u8 config6;
+        u8 pmch;
+        //70
+        u32 eridr;
+        u32 eriar;
+        u16 config7;
+        u16 reg_7a;
+        u32 ephy_rxerr_cnt;
+        //80
+        u32 ephy_mdcmdio;
+        u16 ledsel2;
+        u16 ledsel1;
+        u32 tctr2;
+        u32 timer_int2;
+        //90
+        u8 tppoll0;
+        u8 reg_91;
+        u16 reg_92;
+        u16 led_feature;
+        u16 ledsel3;
+        u16 eee_led_config;
+        u16 reg_9a;
+        u32 reg_9c;
+        //a0
+        u32 reg_a0;
+        u32 reg_a4;
+        u32 reg_a8;
+        u32 reg_ac;
+        //b0
+        u32 patch_dbg;
+        u32 reg_b4;
+        u32 gphy_ocp;
+        u32 reg_bc;
+        //c0
+        u32 reg_c0;
+        u32 reg_c4;
+        u32 reg_c8;
+        u16 otp_cmd;
+        u16 otp_pg_config;
+        //d0
+        u16 phy_pwr;
+        u8 twsi_ctrl;
+        u8 oob_ctrl;
+        u16 mac_dbgo;
+        u16 mac_dbg;
+        u16 reg_d8;
+        u16 rms;
+        u32 efuse_data;
+        //e0
+        u16 cplus_cmd;
+        u16 reg_e2;
+        u32 rxq0_dsc_st_addr_0;
+        u32 rxq0_dsc_st_addr_2;
+        u16 reg_ec;
+        u16 tx10midle_cnt;
+        //f0
+        u16 misc0;
+        u16 misc1;
+        u32 timer_int3;
+        u32 cmac_ib;
+        u16 reg_fc;
+        u16 sw_rst;
+};
+#pragma pack()
+
+struct rtl8125_regs_save {
+        union {
+                u8 mac_io[R8125_MAC_REGS_SIZE];
+
+                struct rtl8125_regs mac_reg;
+        };
+        u16 pcie_phy[R8125_EPHY_REGS_SIZE/2];
+        u16 eth_phy[R8125_PHY_REGS_SIZE/2];
+        u32 eri_reg[R8125_ERI_REGS_SIZE/4];
+        u32 pci_reg[R8125_PCI_REGS_SIZE/4];
+        u16 sw_tail_ptr_reg[R8125_MAX_TX_QUEUES];
+        u16 hw_clo_ptr_reg[R8125_MAX_TX_QUEUES];
+
+        //ktime_t begin_ktime;
+        //ktime_t end_ktime;
+        //u64 duration_ns;
+
+        u16 sw0_tail_ptr;
+        u16 next_hwq0_clo_ptr;
+        u16 sw1_tail_ptr;
+        u16 next_hwq1_clo_ptr;
+
+        u16 int_miti_rxq0;
+        u16 int_miti_txq0;
+        u16 int_miti_rxq1;
+        u16 int_miti_txq1;
+        u8 int_config;
+        u32 imr_new;
+        u32 isr_new;
+
+        u8 tdu_status;
+        u16 rdu_status;
+
+        u16 tc_mode;
+
+        u32 txq1_dsc_st_addr_0;
+        u32 txq1_dsc_st_addr_2;
+
+        u32 pla_tx_q0_idle_credit;
+        u32 pla_tx_q1_idle_credit;
+
+        u32 rxq1_dsc_st_addr_0;
+        u32 rxq1_dsc_st_addr_2;
+
+        u32 rss_ctrl;
+        u8 rss_key[RTL8125_RSS_KEY_SIZE];
+        u8 rss_i_table[RTL8125_MAX_INDIRECTION_TABLE_ENTRIES];
+        u16 rss_queue_num_sel_r;
+};
+
+struct rtl8125_counters {
+        /* legacy */
+        u64 tx_packets;
+        u64 rx_packets;
+        u64 tx_errors;
+        u32 rx_errors;
+        u16 rx_missed;
+        u16 align_errors;
+        u32 tx_one_collision;
+        u32 tx_multi_collision;
+        u64 rx_unicast;
+        u64 rx_broadcast;
+        u32 rx_multicast;
+        u16 tx_aborted;
+        u16 tx_underrun;
+
+        /* extended */
+        u64 tx_octets;
+        u64 rx_octets;
+        u64 rx_multicast64;
+        u64 tx_unicast64;
+        u64 tx_broadcast64;
+        u64 tx_multicast64;
+        u32 tx_pause_on;
+        u32 tx_pause_off;
+        u32 tx_pause_all;
+        u32 tx_deferred;
+        u32 tx_late_collision;
+        u32 tx_all_collision;
+        u32 tx_aborted32;
+        u32 align_errors32;
+        u32 rx_frame_too_long;
+        u32 rx_runt;
+        u32 rx_pause_on;
+        u32 rx_pause_off;
+        u32 rx_pause_all;
+        u32 rx_unknown_opcode;
+        u32 rx_mac_error;
+        u32 tx_underrun32;
+        u32 rx_mac_missed;
+        u32 rx_tcam_dropped;
+        u32 tdu;
+        u32 rdu;
+};
+
+/* Flow Control Settings */
+enum rtl8125_fc_mode {
+        rtl8125_fc_none = 0,
+        rtl8125_fc_rx_pause,
+        rtl8125_fc_tx_pause,
+        rtl8125_fc_full,
+        rtl8125_fc_default
+};
+
+enum rtl8125_state_t {
+        __RTL8125_TESTING = 0,
+        __RTL8125_RESETTING,
+        __RTL8125_DOWN,
+        __RTL8125_PTP_TX_IN_PROGRESS,
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+struct ethtool_eee {
+        __u32	cmd;
+        __u32	supported;
+        __u32	advertised;
+        __u32	lp_advertised;
+        __u32	eee_active;
+        __u32	eee_enabled;
+        __u32	tx_lpi_enabled;
+        __u32	tx_lpi_timer;
+        __u32	reserved[2];
+};
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0) */
+
+struct rtl8125_private {
+        void __iomem *mmio_addr;    /* memory map physical address */
+        struct pci_dev *pci_dev;    /* Index of PCI device */
+        struct net_device *dev;
+        struct r8125_napi r8125napi[R8125_MAX_MSIX_VEC];
+        struct r8125_irq irq_tbl[R8125_MAX_MSIX_VEC];
+        unsigned int irq_nvecs;
+        unsigned int max_irq_nvecs;
+        unsigned int min_irq_nvecs;
+        unsigned int hw_supp_irq_nvecs;
+        //struct msix_entry msix_entries[R8125_MAX_MSIX_VEC];
+        struct net_device_stats stats;  /* statistics of net device */
+        unsigned long state;
+        u8 flags;
+
+        u32 msg_enable;
+        u32 tx_tcp_csum_cmd;
+        u32 tx_udp_csum_cmd;
+        u32 tx_ip_csum_cmd;
+        u32 tx_ipv6_csum_cmd;
+        int max_jumbo_frame_size;
+        int chipset;
+        u32 mcfg;
+        //u32 cur_rx; /* Index into the Rx descriptor buffer of next Rx pkt. */
+        //u32 cur_tx; /* Index into the Tx descriptor buffer of next Rx pkt. */
+        //u32 dirty_rx;
+        //u32 dirty_tx;
+        //struct TxDesc *TxDescArray; /* 256-aligned Tx descriptor ring */
+        //struct RxDesc *RxDescArray; /* 256-aligned Rx descriptor ring */
+        //dma_addr_t TxPhyAddr;
+        //dma_addr_t RxPhyAddr;
+        //struct sk_buff *Rx_skbuff[MAX_NUM_RX_DESC]; /* Rx data buffers */
+        //struct ring_info tx_skb[MAX_NUM_TX_DESC];   /* Tx data buffers */
+        unsigned rx_buf_sz;
+#ifdef ENABLE_PAGE_REUSE
+        unsigned rx_buf_page_order;
+        unsigned rx_buf_page_size;
+        u32 page_reuse_fail_cnt;
+#endif //ENABLE_PAGE_REUSE
+        u16 HwSuppNumTxQueues;
+        u16 HwSuppNumRxQueues;
+        unsigned int num_tx_rings;
+        unsigned int num_rx_rings;
+        struct rtl8125_tx_ring tx_ring[R8125_MAX_TX_QUEUES];
+        struct rtl8125_rx_ring rx_ring[R8125_MAX_RX_QUEUES];
+#ifdef ENABLE_LIB_SUPPORT
+        struct blocking_notifier_head lib_nh;
+        struct rtl8125_ring lib_tx_ring[R8125_MAX_TX_QUEUES];
+        struct rtl8125_ring lib_rx_ring[R8125_MAX_RX_QUEUES];
+#endif
+        //struct timer_list esd_timer;
+        //struct timer_list link_timer;
+        struct pci_resource pci_cfg_space;
+        unsigned int esd_flag;
+        unsigned int pci_cfg_is_read;
+        unsigned int rtl8125_rx_config;
+        u16 rms;
+        u16 cp_cmd;
+        u32 intr_mask;
+        u32 intr_l2_mask;
+        u32 timer_intr_mask;
+        u16 isr_reg[R8125_MAX_MSIX_VEC];
+        u16 imr_reg[R8125_MAX_MSIX_VEC];
+        int phy_auto_nego_reg;
+        int phy_1000_ctrl_reg;
+        int phy_2500_ctrl_reg;
+        u8 org_mac_addr[NODE_ADDRESS_SIZE];
+        struct rtl8125_counters *tally_vaddr;
+        dma_addr_t tally_paddr;
+
+#ifdef CONFIG_R8125_VLAN
+        struct vlan_group *vlgrp;
+#endif
+        u8  wol_enabled;
+        u32 wol_opts;
+        u8  efuse_ver;
+        u8  eeprom_type;
+        u8  autoneg;
+        u8  duplex;
+        u32 speed;
+        u64 advertising;
+        enum rtl8125_fc_mode fcpause;
+        u32 HwSuppMaxPhyLinkSpeed;
+        u16 eeprom_len;
+        u16 cur_page;
+        u32 bios_setting;
+
+        int (*set_speed)(struct net_device *, u8 autoneg, u32 speed, u8 duplex, u64 adv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+        void (*get_settings)(struct net_device *, struct ethtool_cmd *);
+#else
+        void (*get_settings)(struct net_device *, struct ethtool_link_ksettings *);
+#endif
+        void (*phy_reset_enable)(struct net_device *);
+        unsigned int (*phy_reset_pending)(struct net_device *);
+        unsigned int (*link_ok)(struct net_device *);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+        struct work_struct reset_task;
+        struct work_struct esd_task;
+        struct work_struct linkchg_task;
+        struct work_struct link_task;
+        struct work_struct dash_task;
+#else
+        struct delayed_work reset_task;
+        struct delayed_work esd_task;
+        struct delayed_work linkchg_task;
+        struct delayed_work link_task;
+        struct delayed_work dash_task;
+#endif
+        DECLARE_BITMAP(task_flags, R8125_FLAG_MAX);
+        unsigned features;
+
+        u8 org_pci_offset_99;
+        u8 org_pci_offset_180;
+        u8 issue_offset_99_event;
+
+        u8 org_pci_offset_80;
+        u8 org_pci_offset_81;
+        u8 use_timer_interrupt;
+
+        u32 keep_intr_cnt;
+
+        u8  HwIcVerUnknown;
+        u8  NotWrRamCodeToMicroP;
+        u8  NotWrMcuPatchCode;
+        u8  HwHasWrRamCodeToMicroP;
+
+        u16 sw_ram_code_ver;
+        u16 hw_ram_code_ver;
+
+        u8 rtk_enable_diag;
+
+        u8 ShortPacketSwChecksum;
+
+        u8 UseSwPaddingShortPkt;
+
+        u8 RequireAdcBiasPatch;
+        u16 AdcBiasPatchIoffset;
+
+        u8 RequireAdjustUpsTxLinkPulseTiming;
+        u16 SwrCnt1msIni;
+
+        u8 HwSuppNowIsOobVer;
+
+        u8 RequiredSecLanDonglePatch;
+
+        u8 RequiredPfmPatch;
+
+        u8 RequirePhyMdiSwapPatch;
+
+        u8 RequireLSOPatch;
+
+        u32 HwFiberModeVer;
+        u32 HwFiberStat;
+        u8 HwSwitchMdiToFiber;
+
+        u16 BackupLedSel[4];
+
+        u8 HwSuppMagicPktVer;
+
+        u8 HwSuppLinkChgWakeUpVer;
+
+        u8 HwSuppCheckPhyDisableModeVer;
+
+        u8 random_mac;
+
+        u16 phy_reg_aner;
+        u16 phy_reg_anlpar;
+        u16 phy_reg_gbsr;
+        u16 phy_reg_status_2500;
+
+        u32 HwPcieSNOffset;
+
+        u8 HwSuppEsdVer;
+        u8 TestPhyOcpReg;
+        u16 BackupPhyFuseDout[R8125_MAX_PHY_FUSE_DOUT_NUM];
+
+        u32 MaxTxDescPtrMask;
+        u8 HwSuppTxNoCloseVer;
+        u8 EnableTxNoClose;
+
+        u8 HwSuppIsrVer;
+        u8 HwCurrIsrVer;
+
+        u8 HwSuppIntMitiVer;
+
+        u8 HwSuppExtendTallyCounterVer;
+
+        u8 check_keep_link_speed;
+        u8 resume_not_chg_speed;
+
+        u8 HwSuppD0SpeedUpVer;
+        u8 D0SpeedUpSpeed;
+
+        u8 ring_lib_enabled;
+
+        const char *fw_name;
+        struct rtl8125_fw *rtl_fw;
+        u32 ocp_base;
+
+        //Dash+++++++++++++++++
+        u8 HwSuppDashVer;
+        u8 DASH;
+        u8 HwPkgDet;
+        u8 HwSuppOcpChannelVer;
+        u32 DashFirmwareVersion;
+        u32 SizeOfSendToFwBuffer;
+        u32 SizeOfRecvFromFwBuffer;
+        u8 AllowAccessDashOcp;
+        DECLARE_BITMAP(dash_req_flags, R8125_DASH_REQ_FLAG_MAX);
+
+#ifdef ENABLE_DASH_SUPPORT
+        u16 AfterRecvFromFwBufLen;
+        u8 AfterRecvFromFwBuf[RECV_FROM_FW_BUF_SIZE];
+        u32 RecvFromFwBufErrCnt;
+        u16 AfterSendToFwBufLen;
+        u8 AfterSendToFwBuf[SEND_TO_FW_BUF_SIZE];
+        u16 SendToFwBufferLen;
+
+        u8 OobReq;
+        u8 OobAck;
+        u32 OobReqComplete;
+        u32 OobAckComplete;
+
+        u8 SendingToFw;
+
+        u32 RecvFromDashFwCnt;
+
+        u8 DashReqRegValue;
+
+        //Dash-----------------
+#endif //ENABLE_DASH_SUPPORT
+
+        //Realwow++++++++++++++
+        u8 HwSuppKCPOffloadVer;
+
+        u8 EnableDhcpTimeoutWake;
+        u8 EnableTeredoOffload;
+        u8 EnableKCPOffload;
+#ifdef ENABLE_REALWOW_SUPPORT
+        u32 DhcpTimeout;
+        MP_KCP_INFO MpKCPInfo;
+        //Realwow--------------
+#endif //ENABLE_REALWOW_SUPPORT
+
+        struct ethtool_keee eee;
+
+#ifdef ENABLE_R8125_PROCFS
+        //Procfs support
+        struct proc_dir_entry *proc_dir;
+        struct proc_dir_entry *proc_dir_debug;
+        struct proc_dir_entry *proc_dir_test;
+#endif
+#ifdef ENABLE_R8125_SYSFS
+        //sysfs support
+        DECLARE_BITMAP(sysfs_flag, R8125_SYSFS_FLAG_MAX);
+        u32 testmode;
+#endif
+        u8 HwSuppRxDescType;
+        u8 InitRxDescType;
+        u16 RxDescLength; //V1 16 Byte V2 32 Bytes
+
+        spinlock_t phy_lock;
+
+        u8 HwSuppPtpVer;
+        u8 EnablePtp;
+        u8 ptp_master_mode;
+#ifdef ENABLE_PTP_SUPPORT
+        u32 tx_hwtstamp_timeouts;
+        u32 tx_hwtstamp_skipped;
+        struct work_struct ptp_tx_work;
+        struct sk_buff *ptp_tx_skb;
+        struct hwtstamp_config hwtstamp_config;
+        unsigned long ptp_tx_start;
+        struct ptp_clock_info ptp_clock_info;
+        struct ptp_clock *ptp_clock;
+        u8 syncE_en;
+        u8 pps_enable;
+        struct hrtimer pps_timer;
+#endif
+
+        u8 HwSuppRssVer;
+        u8 EnableRss;
+        u16 HwSuppIndirTblEntries;
+#ifdef ENABLE_RSS_SUPPORT
+        u32 rss_flags;
+        /* Receive Side Scaling settings */
+        u8 rss_key[RTL8125_RSS_KEY_SIZE];
+        u8 rss_indir_tbl[RTL8125_MAX_INDIRECTION_TABLE_ENTRIES];
+        u32 rss_options;
+#endif
+
+        u8 HwSuppMacMcuVer;
+        u16 MacMcuPageSize;
+        u64 hw_mcu_patch_code_ver;
+        u64 bin_mcu_patch_code_ver;
+
+        u8 HwSuppTcamVer;
+
+        u16 TcamNotValidReg;
+        u16 TcamValidReg;
+        u16 TcamMaAddrcOffset;
+        u16 TcamVlanTagOffset;
+};
+
+#ifdef ENABLE_LIB_SUPPORT
+static inline unsigned int
+rtl8125_num_lib_tx_rings(struct rtl8125_private *tp)
+{
+        int count, i;
+
+        for (count = 0, i = tp->num_tx_rings; i < tp->HwSuppNumTxQueues; i++)
+                if(tp->lib_tx_ring[i].enabled)
+                        count++;
+
+        return count;
+}
+
+static inline unsigned int
+rtl8125_num_lib_rx_rings(struct rtl8125_private *tp)
+{
+        int count, i;
+
+        for (count = 0, i = 0; i < tp->HwSuppNumRxQueues; i++)
+                if(tp->lib_rx_ring[i].enabled)
+                        count++;
+
+        return count;
+}
+
+#else
+static inline unsigned int
+rtl8125_num_lib_tx_rings(struct rtl8125_private *tp)
+{
+        return 0;
+}
+
+static inline unsigned int
+rtl8125_num_lib_rx_rings(struct rtl8125_private *tp)
+{
+        return 0;
+}
+#endif
+
+static inline unsigned int
+rtl8125_tot_tx_rings(struct rtl8125_private *tp)
+{
+        return tp->num_tx_rings + rtl8125_num_lib_tx_rings(tp);
+}
+
+static inline unsigned int
+rtl8125_tot_rx_rings(struct rtl8125_private *tp)
+{
+        unsigned int num_lib_rx_rings;
+
+        num_lib_rx_rings = rtl8125_num_lib_rx_rings(tp);
+        if (num_lib_rx_rings > 0)
+                return num_lib_rx_rings;
+        else
+                return tp->num_rx_rings;
+}
+
+static inline struct netdev_queue *txring_txq(const struct rtl8125_tx_ring *ring)
+{
+        return netdev_get_tx_queue(ring->netdev, ring->index);
+}
+
+enum eetype {
+        EEPROM_TYPE_NONE=0,
+        EEPROM_TYPE_93C46,
+        EEPROM_TYPE_93C56,
+        EEPROM_TWSI
+};
+
+enum mcfg {
+        CFG_METHOD_2=2,
+        CFG_METHOD_3,
+        CFG_METHOD_4,
+        CFG_METHOD_5,
+        CFG_METHOD_6,
+        CFG_METHOD_7,
+        CFG_METHOD_8,
+        CFG_METHOD_9,
+        CFG_METHOD_10,
+        CFG_METHOD_11,
+        CFG_METHOD_12,
+        CFG_METHOD_13,
+        CFG_METHOD_DEFAULT,
+        CFG_METHOD_MAX
+};
+
+#define LSO_32K 32000
+#define LSO_64K 64000
+
+#define NIC_MIN_PHYS_BUF_COUNT          (2)
+#define NIC_MAX_PHYS_BUF_COUNT_LSO_64K  (24)
+#define NIC_MAX_PHYS_BUF_COUNT_LSO2     (16*4)
+
+#define GTTCPHO_SHIFT                   18
+#define GTTCPHO_MAX                     0x70U
+#define GTPKTSIZE_MAX                   0x3ffffU
+#define TCPHO_SHIFT                     18
+#define TCPHO_MAX                       0x3ffU
+#define LSOPKTSIZE_MAX                  0xffffU
+#define MSS_MAX                         0x07ffu /* MSS value */
+
+#define OOB_CMD_RESET       0x00
+#define OOB_CMD_DRIVER_START    0x05
+#define OOB_CMD_DRIVER_STOP 0x06
+#define OOB_CMD_SET_IPMAC   0x41
+
+#define WAKEUP_MAGIC_PACKET_NOT_SUPPORT (0)
+#define WAKEUP_MAGIC_PACKET_V1 (1)
+#define WAKEUP_MAGIC_PACKET_V2 (2)
+#define WAKEUP_MAGIC_PACKET_V3 (3)
+
+//Ram Code Version
+#define NIC_RAMCODE_VERSION_CFG_METHOD_2 (0x0b11)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_3 (0x0b33)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_4 (0x0b17)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_5 (0x0b99)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_8 (0x0013)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_9 (0x0001)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_10 (0x0027)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_11 (0x0031)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_12 (0x0010)
+
+//hwoptimize
+#define HW_PATCH_SOC_LAN (BIT_0)
+#define HW_PATCH_SAMSUNG_LAN_DONGLE (BIT_2)
+
+static const u16 other_q_intr_mask = (RxOK1 | RxDU1);
+
+#define HW_PHY_STATUS_INI       1
+#define HW_PHY_STATUS_EXT_INI   2
+#define HW_PHY_STATUS_LAN_ON    3
+
+void rtl8125_mdio_write(struct rtl8125_private *tp, u16 RegAddr, u16 value);
+void rtl8125_mdio_prot_write(struct rtl8125_private *tp, u32 RegAddr, u32 value);
+void rtl8125_mdio_prot_direct_write_phy_ocp(struct rtl8125_private *tp, u32 RegAddr, u32 value);
+u32 rtl8125_mdio_read(struct rtl8125_private *tp, u16 RegAddr);
+u32 rtl8125_mdio_prot_read(struct rtl8125_private *tp, u32 RegAddr);
+u32 rtl8125_mdio_prot_direct_read_phy_ocp(struct rtl8125_private *tp, u32 RegAddr);
+void rtl8125_ephy_write(struct rtl8125_private *tp, int RegAddr, int value);
+void rtl8125_mac_ocp_write(struct rtl8125_private *tp, u16 reg_addr, u16 value);
+u16 rtl8125_mac_ocp_read(struct rtl8125_private *tp, u16 reg_addr);
+void rtl8125_clear_eth_phy_bit(struct rtl8125_private *tp, u8 addr, u16 mask);
+void rtl8125_set_eth_phy_bit(struct rtl8125_private *tp,  u8  addr, u16  mask);
+void rtl8125_ocp_write(struct rtl8125_private *tp, u16 addr, u8 len, u32 data);
+void rtl8125_init_ring_indexes(struct rtl8125_private *tp);
+void rtl8125_oob_mutex_lock(struct rtl8125_private *tp);
+u32 rtl8125_ocp_read(struct rtl8125_private *tp, u16 addr, u8 len);
+u32 rtl8125_ocp_read_with_oob_base_address(struct rtl8125_private *tp, u16 addr, u8 len, u32 base_address);
+u32 rtl8125_ocp_write_with_oob_base_address(struct rtl8125_private *tp, u16 addr, u8 len, u32 value, u32 base_address);
+u32 rtl8125_eri_read(struct rtl8125_private *tp, int addr, int len, int type);
+u32 rtl8125_eri_read_with_oob_base_address(struct rtl8125_private *tp, int addr, int len, int type, u32 base_address);
+int rtl8125_eri_write(struct rtl8125_private *tp, int addr, int len, u32 value, int type);
+int rtl8125_eri_write_with_oob_base_address(struct rtl8125_private *tp, int addr, int len, u32 value, int type, u32 base_address);
+u16 rtl8125_ephy_read(struct rtl8125_private *tp, int RegAddr);
+void rtl8125_wait_txrx_fifo_empty(struct net_device *dev);
+void rtl8125_enable_now_is_oob(struct rtl8125_private *tp);
+void rtl8125_disable_now_is_oob(struct rtl8125_private *tp);
+void rtl8125_oob_mutex_unlock(struct rtl8125_private *tp);
+void rtl8125_dash2_disable_tx(struct rtl8125_private *tp);
+void rtl8125_dash2_enable_tx(struct rtl8125_private *tp);
+void rtl8125_dash2_disable_rx(struct rtl8125_private *tp);
+void rtl8125_dash2_enable_rx(struct rtl8125_private *tp);
+void rtl8125_hw_disable_mac_mcu_bps(struct net_device *dev);
+void rtl8125_mark_to_asic(struct rtl8125_private *tp, struct RxDesc *desc, u32 rx_buf_sz);
+void rtl8125_mark_as_last_descriptor(struct rtl8125_private *tp, struct RxDesc *desc);
+
+static inline void
+rtl8125_make_unusable_by_asic(struct rtl8125_private *tp,
+                              struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                ((struct RxDescV3 *)desc)->addr = RTL8125_MAGIC_NUMBER;
+                ((struct RxDescV3 *)desc)->RxDescNormalDDWord4.opts1 &= ~cpu_to_le32(DescOwn | RsvdMaskV3);
+                break;
+        case RX_DESC_RING_TYPE_4:
+                ((struct RxDescV4 *)desc)->addr = RTL8125_MAGIC_NUMBER;
+                ((struct RxDescV4 *)desc)->RxDescNormalDDWord2.opts1 &= ~cpu_to_le32(DescOwn | RsvdMaskV4);
+                break;
+        default:
+                desc->addr = RTL8125_MAGIC_NUMBER;
+                desc->opts1 &= ~cpu_to_le32(DescOwn | RsvdMask);
+                break;
+        }
+}
+
+static inline struct RxDesc*
+rtl8125_get_rxdesc(struct rtl8125_private *tp, struct RxDesc *RxDescBase, u32 const cur_rx)
+{
+        return (struct RxDesc*)((u8*)RxDescBase + (cur_rx * tp->RxDescLength));
+}
+
+static inline void
+rtl8125_disable_hw_interrupt_v2(struct rtl8125_private *tp,
+                                u32 message_id)
+{
+        RTL_W32(tp, IMR_V2_CLEAR_REG_8125, BIT(message_id));
+}
+
+static inline void
+rtl8125_enable_hw_interrupt_v2(struct rtl8125_private *tp, u32 message_id)
+{
+        RTL_W32(tp, IMR_V2_SET_REG_8125, BIT(message_id));
+}
+
+int rtl8125_open(struct net_device *dev);
+int rtl8125_close(struct net_device *dev);
+void rtl8125_hw_config(struct net_device *dev);
+void rtl8125_hw_set_timer_int(struct rtl8125_private *tp, u32 message_id, u8 timer_intmiti_val);
+void rtl8125_set_rx_q_num(struct rtl8125_private *tp, unsigned int num_rx_queues);
+void rtl8125_set_tx_q_num(struct rtl8125_private *tp, unsigned int num_tx_queues);
+void rtl8125_enable_mcu(struct rtl8125_private *tp, bool enable);
+void rtl8125_hw_start(struct net_device *dev);
+void rtl8125_hw_reset(struct net_device *dev);
+void rtl8125_tx_clear(struct rtl8125_private *tp);
+void rtl8125_rx_clear(struct rtl8125_private *tp);
+int rtl8125_init_ring(struct net_device *dev);
+void rtl8125_hw_set_rx_packet_filter(struct net_device *dev);
+void rtl8125_enable_hw_linkchg_interrupt(struct rtl8125_private *tp);
+int rtl8125_dump_tally_counter(struct rtl8125_private *tp, dma_addr_t paddr);
+void rtl8125_enable_napi(struct rtl8125_private *tp);
+void _rtl8125_wait_for_quiescence(struct net_device *dev);
+
+void rtl8125_clear_mac_ocp_bit(struct rtl8125_private *tp, u16 addr, u16 mask);
+void rtl8125_set_mac_ocp_bit(struct rtl8125_private *tp, u16 addr, u16 mask);
+
+void rtl8125_mdio_direct_write_phy_ocp(struct rtl8125_private *tp, u16 RegAddr,u16 value);
+u32 rtl8125_mdio_direct_read_phy_ocp(struct rtl8125_private *tp, u16 RegAddr);
+void rtl8125_clear_and_set_eth_phy_ocp_bit(struct rtl8125_private *tp, u16 addr, u16 clearmask, u16 setmask);
+void rtl8125_clear_eth_phy_ocp_bit(struct rtl8125_private *tp, u16 addr, u16 mask);
+void rtl8125_set_eth_phy_ocp_bit(struct rtl8125_private *tp,  u16 addr, u16 mask);
+
+#ifndef ENABLE_LIB_SUPPORT
+static inline void rtl8125_lib_reset_prepare(struct rtl8125_private *tp) { }
+static inline void rtl8125_lib_reset_complete(struct rtl8125_private *tp) { }
+#endif
+
+#define HW_SUPPORT_CHECK_PHY_DISABLE_MODE(_M)        ((_M)->HwSuppCheckPhyDisableModeVer > 0)
+#define HW_HAS_WRITE_PHY_MCU_RAM_CODE(_M)        (((_M)->HwHasWrRamCodeToMicroP == TRUE) ? 1 : 0)
+#define HW_SUPPORT_D0_SPEED_UP(_M)        ((_M)->HwSuppD0SpeedUpVer > 0)
+#define HW_SUPPORT_MAC_MCU(_M)        ((_M)->HwSuppMacMcuVer > 0)
+#define HW_SUPPORT_TCAM(_M)        ((_M)->HwSuppTcamVer > 0)
+
+#define HW_SUPP_PHY_LINK_SPEED_GIGA(_M)        ((_M)->HwSuppMaxPhyLinkSpeed >= 1000)
+#define HW_SUPP_PHY_LINK_SPEED_2500M(_M)        ((_M)->HwSuppMaxPhyLinkSpeed >= 2500)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)
+#define netdev_mc_count(dev) ((dev)->mc_count)
+#define netdev_mc_empty(dev) (netdev_mc_count(dev) == 0)
+#define netdev_for_each_mc_addr(mclist, dev) \
+    for (mclist = dev->mc_list; mclist; mclist = mclist->next)
+#endif
+
+#endif /* __R8125_H */
Index: drivers/net/ethernet/r8125-9.016.01/rtltool.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/rtltool.h b/drivers/net/ethernet/r8125-9.016.01/rtltool.h
new file mode 100755
--- /dev/null	(date 1763113879457)
+++ b/drivers/net/ethernet/r8125-9.016.01/rtltool.h	(date 1763113879457)
@@ -0,0 +1,89 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_RTLTOOL_H
+#define _LINUX_RTLTOOL_H
+
+#define SIOCRTLTOOL		SIOCDEVPRIVATE+1
+
+enum rtl_cmd {
+        RTLTOOL_READ_MAC=0,
+        RTLTOOL_WRITE_MAC,
+        RTLTOOL_READ_PHY,
+        RTLTOOL_WRITE_PHY,
+        RTLTOOL_READ_EPHY,
+        RTLTOOL_WRITE_EPHY,
+        RTLTOOL_READ_ERI,
+        RTLTOOL_WRITE_ERI,
+        RTLTOOL_READ_PCI,
+        RTLTOOL_WRITE_PCI,
+        RTLTOOL_READ_EEPROM,
+        RTLTOOL_WRITE_EEPROM,
+
+        RTL_READ_OOB_MAC,
+        RTL_WRITE_OOB_MAC,
+
+        RTL_ENABLE_PCI_DIAG,
+        RTL_DISABLE_PCI_DIAG,
+
+        RTL_READ_MAC_OCP,
+        RTL_WRITE_MAC_OCP,
+
+        RTL_DIRECT_READ_PHY_OCP,
+        RTL_DIRECT_WRITE_PHY_OCP,
+
+        RTL_READ_FIBER_PHY,
+        RTL_WRITE_FIBER_PHY,
+
+        RTLTOOL_INVALID
+};
+
+struct rtltool_cmd {
+        __u32	cmd;
+        __u32	offset;
+        __u32	len;
+        __u32	data;
+};
+
+enum mode_access {
+        MODE_NONE=0,
+        MODE_READ,
+        MODE_WRITE
+};
+
+#ifdef __KERNEL__
+int rtl8125_tool_ioctl(struct rtl8125_private *tp, struct ifreq *ifr);
+#endif
+
+#endif /* _LINUX_RTLTOOL_H */
Index: drivers/net/ethernet/r8125-9.016.01/r8125_ptp.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/r8125_ptp.h b/drivers/net/ethernet/r8125-9.016.01/r8125_ptp.h
new file mode 100755
--- /dev/null	(date 1763113879455)
+++ b/drivers/net/ethernet/r8125-9.016.01/r8125_ptp.h	(date 1763113879455)
@@ -0,0 +1,159 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_rtl8125_PTP_H
+#define _LINUX_rtl8125_PTP_H
+
+#include <linux/ktime.h>
+#include <linux/timecounter.h>
+#include <linux/net_tstamp.h>
+#include <linux/ptp_clock_kernel.h>
+#include <linux/ptp_classify.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,11,0)
+#define PTP_MSGTYPE_SYNC        0x0
+#define PTP_MSGTYPE_DELAY_REQ   0x1
+#define PTP_MSGTYPE_PDELAY_REQ  0x2
+#define PTP_MSGTYPE_PDELAY_RESP 0x3
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,11,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0)
+struct clock_identity {
+        u8 id[8];
+} __packed;
+
+struct port_identity {
+        struct clock_identity	clock_identity;
+        __be16			port_number;
+} __packed;
+
+struct ptp_header {
+        u8			tsmt;  /* transportSpecific | messageType */
+        u8			ver;   /* reserved          | versionPTP  */
+        __be16			message_length;
+        u8			domain_number;
+        u8			reserved1;
+        u8			flag_field[2];
+        __be64			correction;
+        __be32			reserved2;
+        struct port_identity	source_port_identity;
+        __be16			sequence_id;
+        u8			control;
+        u8			log_message_interval;
+} __packed;
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0) */
+
+struct rtl8125_ptp_info {
+        s64 time_sec;
+        u32 time_ns;
+        u16 ts_info;
+};
+
+#ifndef _STRUCT_TIMESPEC
+#define _STRUCT_TIMESPEC
+struct timespec {
+        __kernel_old_time_t tv_sec;     /* seconds */
+        long            tv_nsec;    /* nanoseconds */
+};
+#endif
+
+enum PTP_CMD_TYPE {
+        PTP_CMD_SET_LOCAL_TIME = 0,
+        PTP_CMD_DRIFT_LOCAL_TIME,
+        PTP_CMD_LATCHED_LOCAL_TIME,
+};
+
+#define PTP_CLKADJ_MODE_SET BIT_0
+
+enum PTP_CLKADJ_MOD_TYPE {
+        NO_FUNCTION     = 0,
+        CLKADJ_MODE_SET = 1,
+        RESERVED        = 2,
+        DIRECT_READ     = 4,
+        DIRECT_WRITE    = 6,
+        INCREMENT_STEP  = 8,
+        DECREMENT_STEP  = 10,
+        RATE_READ       = 12,
+        RATE_WRITE      = 14,
+};
+
+enum PTP_INSR_TYPE {
+        EVENT_CAP_INTR   = (1 << 0),
+        TRIG_GEN_INTR    = (1 << 1),
+        RX_TS_INTR       = (1 << 2),
+        TX_TX_INTR       = (1 << 3),
+};
+
+enum PTP_TRX_TS_STA_REG {
+        TRX_TS_RD               = (1 << 0),
+        TRXTS_SEL               = (1 << 1),
+        RX_TS_PDLYRSP_RDY       = (1 << 8),
+        RX_TS_PDLYREQ_RDY       = (1 << 9),
+        RX_TS_DLYREQ_RDY        = (1 << 10),
+        RX_TS_SYNC_RDY          = (1 << 11),
+        TX_TS_PDLYRSP_RDY       = (1 << 12),
+        TX_TS_PDLYREQ_RDY       = (1 << 13),
+        TX_TS_DLYREQ_RDY        = (1 << 14),
+        TX_TS_SYNC_RDY          = (1 << 15),
+};
+
+#define RTL_FLAG_RX_HWTSTAMP_ENABLED BIT_0
+
+struct rtl8125_private;
+struct RxDescV3;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,11,0)
+int rtl8125_get_ts_info(struct net_device *netdev,
+                        struct ethtool_ts_info *info);
+#else
+int rtl8125_get_ts_info(struct net_device *netdev,
+                        struct kernel_ethtool_ts_info *info);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(6,11,0) */
+
+void rtl8125_ptp_reset(struct rtl8125_private *tp);
+void rtl8125_ptp_init(struct rtl8125_private *tp);
+void rtl8125_ptp_suspend(struct rtl8125_private *tp);
+void rtl8125_ptp_stop(struct rtl8125_private *tp);
+
+int rtl8125_ptp_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
+
+void rtl8125_rx_mac_ptp_pktstamp(struct rtl8125_private *tp, struct sk_buff *skb,
+                                 struct RxDescV3 *descv3);
+
+void rtl8125_set_phy_local_time(struct rtl8125_private *tp);
+
+void rtl8125_rx_phy_ptp_timestamp(struct rtl8125_private *tp, struct sk_buff *skb);
+
+#endif /* _LINUX_rtl8125_PTP_H */
Index: drivers/net/ethernet/r8125-9.016.01/r8125_fiber.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/r8125_fiber.h b/drivers/net/ethernet/r8125-9.016.01/r8125_fiber.h
new file mode 100755
--- /dev/null	(date 1763113879453)
+++ b/drivers/net/ethernet/r8125-9.016.01/r8125_fiber.h	(date 1763113879453)
@@ -0,0 +1,63 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_R8125_FIBER_H
+#define _LINUX_R8125_FIBER_H
+
+enum {
+        FIBER_MODE_NIC_ONLY = 0,
+        FIBER_MODE_RTL8125D_RTL8221D,
+        FIBER_MODE_MAX
+};
+
+enum {
+        FIBER_STAT_NOT_CHECKED = 0,
+        FIBER_STAT_DISCONNECT,
+        FIBER_STAT_CONNECT_GPO_C45,
+        FIBER_STAT_MAX
+};
+
+#define HW_FIBER_MODE_ENABLED(_M)        ((_M)->HwFiberModeVer > 0)
+#define HW_FIBER_STATUS_CONNECTED(_M)        (((_M)->HwFiberStat == FIBER_STAT_CONNECT_GPO_C45))
+#define HW_FIBER_STATUS_DISCONNECTED(_M)        ((_M)->HwFiberStat == FIBER_STAT_DISCONNECT)
+
+struct rtl8125_private;
+
+void rtl8125_hw_fiber_phy_config(struct rtl8125_private *tp);
+void rtl8125_check_fiber_mode_support(struct rtl8125_private *tp);
+void rtl8125_fiber_mdio_write( struct rtl8125_private *tp, u32 reg, u16 val);
+u16 rtl8125_fiber_mdio_read(struct rtl8125_private *tp, u32 reg);
+unsigned int rtl8125_fiber_link_ok(struct net_device *dev);
+
+#endif /* _LINUX_R8125_FIBER_H */
Index: drivers/net/ethernet/r8126-10.016.00/r8126_fiber.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/r8126_fiber.h b/drivers/net/ethernet/r8126-10.016.00/r8126_fiber.h
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/r8126_fiber.h	(date 1763109333415)
@@ -0,0 +1,63 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_R8126_FIBER_H
+#define _LINUX_R8126_FIBER_H
+
+enum {
+        FIBER_MODE_NIC_ONLY = 0,
+        FIBER_MODE_RTL8126_RTL8251B,
+        FIBER_MODE_MAX
+};
+
+enum {
+        FIBER_STAT_NOT_CHECKED = 0,
+        FIBER_STAT_DISCONNECT,
+        FIBER_STAT_CONNECT_GPO_C45,
+        FIBER_STAT_MAX
+};
+
+#define HW_FIBER_MODE_ENABLED(_M)        ((_M)->HwFiberModeVer > 0)
+#define HW_FIBER_STATUS_CONNECTED(_M)        (((_M)->HwFiberStat == FIBER_STAT_CONNECT_GPO_C45))
+#define HW_FIBER_STATUS_DISCONNECTED(_M)        ((_M)->HwFiberStat == FIBER_STAT_DISCONNECT)
+
+struct rtl8126_private;
+
+void rtl8126_hw_fiber_phy_config(struct rtl8126_private *tp);
+void rtl8126_check_fiber_mode_support(struct rtl8126_private *tp);
+void rtl8126_fiber_mdio_write( struct rtl8126_private *tp, u32 reg, u16 val);
+u16 rtl8126_fiber_mdio_read(struct rtl8126_private *tp, u32 reg);
+unsigned int rtl8126_fiber_link_ok(struct net_device *dev);
+
+#endif /* _LINUX_R8126_FIBER_H */
Index: drivers/net/ethernet/r8125-9.016.01/rtl_eeprom.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/rtl_eeprom.c b/drivers/net/ethernet/r8125-9.016.01/rtl_eeprom.c
new file mode 100755
--- /dev/null	(date 1763113879456)
+++ b/drivers/net/ethernet/r8125-9.016.01/rtl_eeprom.c	(date 1763113879456)
@@ -0,0 +1,284 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/ethtool.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+
+#include "r8125.h"
+#include "rtl_eeprom.h"
+
+//-------------------------------------------------------------------
+//rtl8125_eeprom_type():
+//  tell the eeprom type
+//return value:
+//  0: the eeprom type is 93C46
+//  1: the eeprom type is 93C56 or 93C66
+//-------------------------------------------------------------------
+void rtl8125_eeprom_type(struct rtl8125_private *tp)
+{
+        u16 magic = 0;
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                goto out_no_eeprom;
+
+        if(RTL_R8(tp, 0xD2)&0x04) {
+                //not support
+                //tp->eeprom_type = EEPROM_TWSI;
+                //tp->eeprom_len = 256;
+                goto out_no_eeprom;
+        } else if(RTL_R32(tp, RxConfig) & RxCfg_9356SEL) {
+                tp->eeprom_type = EEPROM_TYPE_93C56;
+                tp->eeprom_len = 256;
+        } else {
+                tp->eeprom_type = EEPROM_TYPE_93C46;
+                tp->eeprom_len = 128;
+        }
+
+        magic = rtl8125_eeprom_read_sc(tp, 0);
+
+out_no_eeprom:
+        if ((magic != 0x8129) && (magic != 0x8128)) {
+                tp->eeprom_type = EEPROM_TYPE_NONE;
+                tp->eeprom_len = 0;
+        }
+}
+
+void rtl8125_eeprom_cleanup(struct rtl8125_private *tp)
+{
+        u8 x;
+
+        x = RTL_R8(tp, Cfg9346);
+        x &= ~(Cfg9346_EEDI | Cfg9346_EECS);
+
+        RTL_W8(tp, Cfg9346, x);
+
+        rtl8125_raise_clock(tp, &x);
+        rtl8125_lower_clock(tp, &x);
+}
+
+static int rtl8125_eeprom_cmd_done(struct rtl8125_private *tp)
+{
+        u8 x;
+        int i;
+
+        rtl8125_stand_by(tp);
+
+        for (i = 0; i < 50000; i++) {
+                x = RTL_R8(tp, Cfg9346);
+
+                if (x & Cfg9346_EEDO) {
+                        udelay(RTL_CLOCK_RATE * 2 * 3);
+                        return 0;
+                }
+                udelay(1);
+        }
+
+        return -1;
+}
+
+//-------------------------------------------------------------------
+//rtl8125_eeprom_read_sc():
+//  read one word from eeprom
+//-------------------------------------------------------------------
+u16 rtl8125_eeprom_read_sc(struct rtl8125_private *tp, u16 reg)
+{
+        int addr_sz = 6;
+        u8 x;
+        u16 data;
+
+        if(tp->eeprom_type == EEPROM_TYPE_NONE)
+                return -1;
+
+        if (tp->eeprom_type==EEPROM_TYPE_93C46)
+                addr_sz = 6;
+        else if (tp->eeprom_type==EEPROM_TYPE_93C56)
+                addr_sz = 8;
+
+        x = Cfg9346_EEM1 | Cfg9346_EECS;
+        RTL_W8(tp, Cfg9346, x);
+
+        rtl8125_shift_out_bits(tp, RTL_EEPROM_READ_OPCODE, 3);
+        rtl8125_shift_out_bits(tp, reg, addr_sz);
+
+        data = rtl8125_shift_in_bits(tp);
+
+        rtl8125_eeprom_cleanup(tp);
+
+        RTL_W8(tp, Cfg9346, 0);
+
+        return data;
+}
+
+//-------------------------------------------------------------------
+//rtl8125_eeprom_write_sc():
+//  write one word to a specific address in the eeprom
+//-------------------------------------------------------------------
+void rtl8125_eeprom_write_sc(struct rtl8125_private *tp, u16 reg, u16 data)
+{
+        u8 x;
+        int addr_sz = 6;
+        int w_dummy_addr = 4;
+
+        if(tp->eeprom_type == EEPROM_TYPE_NONE)
+                return;
+
+        if (tp->eeprom_type==EEPROM_TYPE_93C46) {
+                addr_sz = 6;
+                w_dummy_addr = 4;
+        } else if (tp->eeprom_type==EEPROM_TYPE_93C56) {
+                addr_sz = 8;
+                w_dummy_addr = 6;
+        }
+
+        x = Cfg9346_EEM1 | Cfg9346_EECS;
+        RTL_W8(tp, Cfg9346, x);
+
+        rtl8125_shift_out_bits(tp, RTL_EEPROM_EWEN_OPCODE, 5);
+        rtl8125_shift_out_bits(tp, reg, w_dummy_addr);
+        rtl8125_stand_by(tp);
+
+        rtl8125_shift_out_bits(tp, RTL_EEPROM_ERASE_OPCODE, 3);
+        rtl8125_shift_out_bits(tp, reg, addr_sz);
+        if (rtl8125_eeprom_cmd_done(tp) < 0)
+                return;
+        rtl8125_stand_by(tp);
+
+        rtl8125_shift_out_bits(tp, RTL_EEPROM_WRITE_OPCODE, 3);
+        rtl8125_shift_out_bits(tp, reg, addr_sz);
+        rtl8125_shift_out_bits(tp, data, 16);
+        if (rtl8125_eeprom_cmd_done(tp) < 0)
+                return;
+        rtl8125_stand_by(tp);
+
+        rtl8125_shift_out_bits(tp, RTL_EEPROM_EWDS_OPCODE, 5);
+        rtl8125_shift_out_bits(tp, reg, w_dummy_addr);
+
+        rtl8125_eeprom_cleanup(tp);
+        RTL_W8(tp, Cfg9346, 0);
+}
+
+void rtl8125_raise_clock(struct rtl8125_private *tp, u8 *x)
+{
+        *x = *x | Cfg9346_EESK;
+        RTL_W8(tp, Cfg9346, *x);
+        udelay(RTL_CLOCK_RATE);
+}
+
+void rtl8125_lower_clock(struct rtl8125_private *tp, u8 *x)
+{
+        *x = *x & ~Cfg9346_EESK;
+        RTL_W8(tp, Cfg9346, *x);
+        udelay(RTL_CLOCK_RATE);
+}
+
+void rtl8125_shift_out_bits(struct rtl8125_private *tp, int data, int count)
+{
+        u8 x;
+        int  mask;
+
+        mask = 0x01 << (count - 1);
+        x = RTL_R8(tp, Cfg9346);
+        x &= ~(Cfg9346_EEDI | Cfg9346_EEDO);
+
+        do {
+                if (data & mask)
+                        x |= Cfg9346_EEDI;
+                else
+                        x &= ~Cfg9346_EEDI;
+
+                RTL_W8(tp, Cfg9346, x);
+                udelay(RTL_CLOCK_RATE);
+                rtl8125_raise_clock(tp, &x);
+                rtl8125_lower_clock(tp, &x);
+                mask = mask >> 1;
+        } while(mask);
+
+        x &= ~Cfg9346_EEDI;
+        RTL_W8(tp, Cfg9346, x);
+}
+
+u16 rtl8125_shift_in_bits(struct rtl8125_private *tp)
+{
+        u8 x;
+        u16 d, i;
+
+        x = RTL_R8(tp, Cfg9346);
+        x &= ~(Cfg9346_EEDI | Cfg9346_EEDO);
+
+        d = 0;
+
+        for (i = 0; i < 16; i++) {
+                d = d << 1;
+                rtl8125_raise_clock(tp, &x);
+
+                x = RTL_R8(tp, Cfg9346);
+                x &= ~Cfg9346_EEDI;
+
+                if (x & Cfg9346_EEDO)
+                        d |= 1;
+
+                rtl8125_lower_clock(tp, &x);
+        }
+
+        return d;
+}
+
+void rtl8125_stand_by(struct rtl8125_private *tp)
+{
+        u8 x;
+
+        x = RTL_R8(tp, Cfg9346);
+        x &= ~(Cfg9346_EECS | Cfg9346_EESK);
+        RTL_W8(tp, Cfg9346, x);
+        udelay(RTL_CLOCK_RATE);
+
+        x |= Cfg9346_EECS;
+        RTL_W8(tp, Cfg9346, x);
+}
+
+void rtl8125_set_eeprom_sel_low(struct rtl8125_private *tp)
+{
+        RTL_W8(tp, Cfg9346, Cfg9346_EEM1);
+        RTL_W8(tp, Cfg9346, Cfg9346_EEM1 | Cfg9346_EESK);
+
+        udelay(20);
+
+        RTL_W8(tp, Cfg9346, Cfg9346_EEM1);
+}
Index: drivers/net/ethernet/r8126-10.016.00/r8126_ptp.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/r8126_ptp.h b/drivers/net/ethernet/r8126-10.016.00/r8126_ptp.h
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/r8126_ptp.h	(date 1763109333415)
@@ -0,0 +1,207 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_R8126_PTP_H
+#define _LINUX_R8126_PTP_H
+
+#include <linux/ktime.h>
+#include <linux/timecounter.h>
+#include <linux/net_tstamp.h>
+#include <linux/ptp_clock_kernel.h>
+#include <linux/ptp_classify.h>
+
+#ifndef PTP_CLASS_NONE
+#define PTP_CLASS_NONE  0x00
+#endif
+
+#ifndef PTP_MSGTYPE_SYNC
+#define PTP_MSGTYPE_SYNC        0x0
+#endif
+#ifndef PTP_MSGTYPE_DELAY_REQ
+#define PTP_MSGTYPE_DELAY_REQ   0x1
+#endif
+#ifndef PTP_MSGTYPE_PDELAY_REQ
+#define PTP_MSGTYPE_PDELAY_REQ  0x2
+#endif
+#ifndef PTP_MSGTYPE_PDELAY_RESP
+#define PTP_MSGTYPE_PDELAY_RESP 0x3
+#endif
+
+struct rtl8126_ptp_info {
+        s64 time_sec;
+        u32 time_ns;
+        u16 ts_info;
+};
+
+#ifndef _STRUCT_TIMESPEC
+#define _STRUCT_TIMESPEC
+struct timespec {
+        __kernel_old_time_t tv_sec;     /* seconds */
+        long            tv_nsec;    /* nanoseconds */
+};
+#endif
+
+enum PTP_CMD_TYPE {
+        PTP_CMD_SET_LOCAL_TIME = 0,
+        PTP_CMD_DRIFT_LOCAL_TIME,
+        PTP_CMD_LATCHED_LOCAL_TIME,
+};
+
+enum PTP_CLKADJ_MOD_TYPE {
+        NO_FUNCTION     = 0,
+        CLKADJ_MODE_SET = 1,
+        RESERVED        = 2,
+        DIRECT_READ     = 4,
+        DIRECT_WRITE    = 6,
+        INCREMENT_STEP  = 8,
+        DECREMENT_STEP  = 10,
+        RATE_READ       = 12,
+        RATE_WRITE      = 14,
+};
+
+enum PTP_INSR_TYPE {
+        EVENT_CAP_INTR   = (1 << 0),
+        TRIG_GEN_INTR    = (1 << 1),
+        RX_TS_INTR       = (1 << 2),
+        TX_TX_INTR       = (1 << 3),
+};
+
+enum PTP_TRX_TS_STA_REG {
+        TRX_TS_RD               = (1 << 0),
+        TRXTS_SEL               = (1 << 1),
+        RX_TS_PDLYRSP_RDY       = (1 << 8),
+        RX_TS_PDLYREQ_RDY       = (1 << 9),
+        RX_TS_DLYREQ_RDY        = (1 << 10),
+        RX_TS_SYNC_RDY          = (1 << 11),
+        TX_TS_PDLYRSP_RDY       = (1 << 12),
+        TX_TS_PDLYREQ_RDY       = (1 << 13),
+        TX_TS_DLYREQ_RDY        = (1 << 14),
+        TX_TS_SYNC_RDY          = (1 << 15),
+};
+
+#define PTP_CTL_TYPE_0 (0xF3F)
+#define PTP_CTL_TYPE_1 (0x2FF)
+#define PTP_CTL_TYPE_2 (0x0FF)
+#define PTP_CTL_TYPE_3 (0x03F)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0)
+struct clock_identity {
+        u8 id[8];
+} __packed;
+
+struct port_identity {
+        struct clock_identity	clock_identity;
+        __be16			port_number;
+} __packed;
+
+struct ptp_header {
+        u8			tsmt;  /* transportSpecific | messageType */
+        u8			ver;   /* reserved          | versionPTP  */
+        __be16			message_length;
+        u8			domain_number;
+        u8			reserved1;
+        u8			flag_field[2];
+        __be64			correction;
+        __be32			reserved2;
+        struct port_identity	source_port_identity;
+        __be16			sequence_id;
+        u8			control;
+        u8			log_message_interval;
+} __packed;
+
+/**
+ * ptp_parse_header - Get pointer to the PTP v2 header
+ * @skb: packet buffer
+ * @type: type of the packet (see ptp_classify_raw())
+ *
+ * This function takes care of the VLAN, UDP, IPv4 and IPv6 headers. The length
+ * is checked.
+ *
+ * Note, internally skb_mac_header() is used. Make sure that the @skb is
+ * initialized accordingly.
+ *
+ * Return: Pointer to the ptp v2 header or NULL if not found
+ */
+struct ptp_header *ptp_parse_header(struct sk_buff *skb, unsigned int type);
+
+/**
+ * ptp_get_msgtype - Extract ptp message type from given header
+ * @hdr: ptp header
+ * @type: type of the packet (see ptp_classify_raw())
+ *
+ * This function returns the message type for a given ptp header. It takes care
+ * of the different ptp header versions (v1 or v2).
+ *
+ * Return: The message type
+ */
+static inline u8 ptp_get_msgtype(const struct ptp_header *hdr,
+                                 unsigned int type)
+{
+        u8 msgtype;
+
+        if (unlikely(type & PTP_CLASS_V1)) {
+                /* msg type is located at the control field for ptp v1 */
+                msgtype = hdr->control;
+        } else {
+                msgtype = hdr->tsmt & 0x0f;
+        }
+
+        return msgtype;
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0) */
+
+struct rtl8126_private;
+struct RxDescV3;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,11,0)
+int rtl8126_get_ts_info(struct net_device *netdev,
+                        struct ethtool_ts_info *info);
+#else
+int rtl8126_get_ts_info(struct net_device *netdev,
+                        struct kernel_ethtool_ts_info *info);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(6,11,0) */
+
+void rtl8126_ptp_reset(struct rtl8126_private *tp);
+void rtl8126_ptp_init(struct rtl8126_private *tp);
+void rtl8126_ptp_suspend(struct rtl8126_private *tp);
+void rtl8126_ptp_stop(struct rtl8126_private *tp);
+
+int rtl8126_ptp_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
+
+void rtl8126_rx_ptp_timestamp(struct rtl8126_private *tp, struct sk_buff *skb);
+
+void rtl8126_set_local_time(struct rtl8126_private *tp);
+
+#endif /* _LINUX_R8126_PTP_H */
Index: drivers/net/ethernet/r8126-10.016.00/r8126.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/r8126.h b/drivers/net/ethernet/r8126-10.016.00/r8126.h
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/r8126.h	(date 1763109333415)
@@ -0,0 +1,2976 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef __R8126_H
+#define __R8126_H
+
+//#include <linux/pci.h>
+#include <linux/ethtool.h>
+#include <linux/interrupt.h>
+#include <linux/version.h>
+#include "r8126_realwow.h"
+#ifdef ENABLE_FIBER_SUPPORT
+#include "r8126_fiber.h"
+#endif /* ENABLE_FIBER_SUPPORT */
+#ifdef ENABLE_PTP_SUPPORT
+#include "r8126_ptp.h"
+#endif
+#include "r8126_rss.h"
+#ifdef ENABLE_LIB_SUPPORT
+#include "r8126_lib.h"
+#endif
+
+#ifndef fallthrough
+#define fallthrough
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+#define netif_xmit_stopped netif_tx_queue_stopped
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+#ifndef MDIO_AN_EEE_ADV_100TX
+#define MDIO_AN_EEE_ADV_100TX	0x0002	/* Advertise 100TX EEE cap */
+#endif
+#ifndef MDIO_AN_EEE_ADV_1000T
+#define MDIO_AN_EEE_ADV_1000T	0x0004	/* Advertise 1000T EEE cap */
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+#define MDIO_EEE_100TX		MDIO_AN_EEE_ADV_100TX	/* 100TX EEE cap */
+#define MDIO_EEE_1000T		MDIO_AN_EEE_ADV_1000T	/* 1000T EEE cap */
+#define MDIO_EEE_10GT		0x0008	/* 10GT EEE cap */
+#define MDIO_EEE_1000KX		0x0010	/* 1000KX EEE cap */
+#define MDIO_EEE_10GKX4		0x0020	/* 10G KX4 EEE cap */
+#define MDIO_EEE_10GKR		0x0040	/* 10G KR EEE cap */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0) */
+
+static inline u32 mmd_eee_adv_to_ethtool_adv_t(u16 eee_adv)
+{
+        u32 adv = 0;
+
+        if (eee_adv & MDIO_EEE_100TX)
+                adv |= ADVERTISED_100baseT_Full;
+        if (eee_adv & MDIO_EEE_1000T)
+                adv |= ADVERTISED_1000baseT_Full;
+        if (eee_adv & MDIO_EEE_10GT)
+                adv |= ADVERTISED_10000baseT_Full;
+        if (eee_adv & MDIO_EEE_1000KX)
+                adv |= ADVERTISED_1000baseKX_Full;
+        if (eee_adv & MDIO_EEE_10GKX4)
+                adv |= ADVERTISED_10000baseKX4_Full;
+        if (eee_adv & MDIO_EEE_10GKR)
+                adv |= ADVERTISED_10000baseKR_Full;
+
+        return adv;
+}
+
+static inline u16 ethtool_adv_to_mmd_eee_adv_t(u32 adv)
+{
+        u16 reg = 0;
+
+        if (adv & ADVERTISED_100baseT_Full)
+                reg |= MDIO_EEE_100TX;
+        if (adv & ADVERTISED_1000baseT_Full)
+                reg |= MDIO_EEE_1000T;
+        if (adv & ADVERTISED_10000baseT_Full)
+                reg |= MDIO_EEE_10GT;
+        if (adv & ADVERTISED_1000baseKX_Full)
+                reg |= MDIO_EEE_1000KX;
+        if (adv & ADVERTISED_10000baseKX4_Full)
+                reg |= MDIO_EEE_10GKX4;
+        if (adv & ADVERTISED_10000baseKR_Full)
+                reg |= MDIO_EEE_10GKR;
+
+        return reg;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0)
+static inline bool skb_transport_header_was_set(const struct sk_buff *skb)
+{
+        return skb->transport_header != ~0U;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0)
+static inline void linkmode_set_bit(int nr, volatile unsigned long *addr)
+{
+        __set_bit(nr, addr);
+}
+
+static inline void linkmode_clear_bit(int nr, volatile unsigned long *addr)
+{
+        __clear_bit(nr, addr);
+}
+
+static inline int linkmode_test_bit(int nr, volatile unsigned long *addr)
+{
+        return test_bit(nr, addr);
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+static inline void linkmode_mod_bit(int nr, volatile unsigned long *addr,
+                                    int set)
+{
+        if (set)
+                linkmode_set_bit(nr, addr);
+        else
+                linkmode_clear_bit(nr, addr);
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0)
+static inline
+ssize_t strscpy(char *dest, const char *src, size_t count)
+{
+        long res = 0;
+
+        if (count == 0)
+                return -E2BIG;
+
+        while (count) {
+                char c;
+
+                c = src[res];
+                dest[res] = c;
+                if (!c)
+                        return res;
+                res++;
+                count--;
+        }
+
+        /* Hit buffer length without finding a NUL; force NUL-termination. */
+        if (res)
+                dest[res-1] = '\0';
+
+        return -E2BIG;
+}
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0))
+static inline unsigned char *skb_checksum_start(const struct sk_buff *skb)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22))
+        return skb->head + skb->csum_start;
+#else /* < 2.6.22 */
+        return skb_transport_header(skb);
+#endif
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+static inline void netdev_tx_sent_queue(struct netdev_queue *dev_queue,
+                                        unsigned int bytes)
+{}
+static inline void netdev_tx_completed_queue(struct netdev_queue *dev_queue,
+                unsigned int pkts,
+                unsigned int bytes)
+{}
+static inline void netdev_tx_reset_queue(struct netdev_queue *q) {}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0)
+static inline void fsleep(unsigned long usecs)
+{
+        if (usecs <= 10)
+                udelay(usecs);
+        else if (usecs <= 20000)
+                usleep_range(usecs, 2 * usecs);
+        else
+                msleep(DIV_ROUND_UP(usecs, 1000));
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,2,0)
+#define netdev_xmit_more() (0)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0)
+#define netif_testing_on(dev)
+#define netif_testing_off(dev)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,2,0)
+#define netdev_sw_irq_coalesce_default_on(dev)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(6,2,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+typedef int netdev_tx_t;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,12,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,1,9)
+static inline bool page_is_pfmemalloc(struct page *page)
+{
+        /*
+         * Page index cannot be this large so this must be
+         * a pfmemalloc page.
+         */
+        return page->index == -1UL;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,1,9) */
+static inline bool dev_page_is_reusable(struct page *page)
+{
+        return likely(page_to_nid(page) == numa_mem_id() &&
+                      !page_is_pfmemalloc(page));
+}
+#endif
+
+/*
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)&& !defined(ENABLE_LIB_SUPPORT)
+#define RTL_USE_NEW_INTR_API
+#endif
+*/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+#define dma_map_page_attrs(dev, page, offset, size, dir, attrs) \
+	dma_map_page(dev, page, offset, size, dir)
+#define dma_unmap_page_attrs(dev, page, size, dir, attrs) \
+	 dma_unmap_page(dev, page, size, dir)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+#define page_ref_inc(page) atomic_inc(&page->_count)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,4,216)
+#define page_ref_count(page) atomic_read(&page->_count)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,4,216)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#define skb_transport_offset(skb) (skb->h.raw - skb->data)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+#define device_set_wakeup_enable(dev, val)	do {} while (0)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+        u16 *a = (u16 *)dst;
+        const u16 *b = (const u16 *)src;
+
+        a[0] = b[0];
+        a[1] = b[1];
+        a[2] = b[2];
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+#define IS_ERR_OR_NULL(ptr)			(!ptr)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
+#define reinit_completion(x)			((x)->done = 0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#define pm_runtime_mark_last_busy(x)
+#define pm_runtime_put_autosuspend(x)		pm_runtime_put(x)
+#define pm_runtime_put_sync_autosuspend(x)	pm_runtime_put_sync(x)
+
+static inline bool pm_runtime_suspended(struct device *dev)
+{
+        return dev->power.runtime_status == RPM_SUSPENDED
+               && !dev->power.disable_depth;
+}
+
+static inline bool pm_runtime_active(struct device *dev)
+{
+        return dev->power.runtime_status == RPM_ACTIVE
+               || dev->power.disable_depth;
+}
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+#define queue_delayed_work(long_wq, work, delay)	schedule_delayed_work(work, delay)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)
+#define netif_printk(priv, type, level, netdev, fmt, args...)	\
+	do {								\
+		if (netif_msg_##type(priv))				\
+			printk(level "%s: " fmt,(netdev)->name , ##args); \
+	} while (0)
+
+#define netif_emerg(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_EMERG, netdev, fmt, ##args)
+#define netif_alert(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ALERT, netdev, fmt, ##args)
+#define netif_crit(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_CRIT, netdev, fmt, ##args)
+#define netif_err(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ERR, netdev, fmt, ##args)
+#define netif_warn(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_WARNING, netdev, fmt, ##args)
+#define netif_notice(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_NOTICE, netdev, fmt, ##args)
+#define netif_info(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_INFO, (netdev), fmt, ##args)
+#endif
+#endif
+#endif
+#endif
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+#define setup_timer(_timer, _function, _data) \
+do { \
+	(_timer)->function = _function; \
+	(_timer)->data = _data; \
+	init_timer(_timer); \
+} while (0)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+#if defined(skb_vlan_tag_present) && !defined(vlan_tx_tag_present)
+#define vlan_tx_tag_present skb_vlan_tag_present
+#endif
+#if defined(skb_vlan_tag_get) && !defined(vlan_tx_tag_get)
+#define vlan_tx_tag_get skb_vlan_tag_get
+#endif
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+
+#define RTL_ALLOC_SKB_INTR(napi, length) dev_alloc_skb(length)
+#define R8126_USE_NAPI_ALLOC_SKB 0
+#ifdef CONFIG_R8126_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+#undef RTL_ALLOC_SKB_INTR
+#define RTL_ALLOC_SKB_INTR(napi, length) napi_alloc_skb(napi, length)
+#undef R8126_USE_NAPI_ALLOC_SKB
+#define R8126_USE_NAPI_ALLOC_SKB 1
+#endif
+#endif
+
+#define RTL_BUILD_SKB_INTR(data, frag_size) build_skb(data, frag_size)
+#ifdef CONFIG_R8126_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,12,0)
+#undef RTL_BUILD_SKB_INTR
+#define RTL_BUILD_SKB_INTR(data, frag_size) napi_build_skb(data, frag_size)
+#endif
+#endif
+
+#ifdef CONFIG_R8126_NAPI
+#define r8126_spin_lock(lock, flags)  (void)flags;spin_lock_bh(lock)
+#define r8126_spin_unlock(lock, flags)  (void)flags;spin_unlock_bh(lock)
+#else
+#define r8126_spin_lock(lock, flags)  spin_lock_irqsave(lock, flags)
+#define r8126_spin_unlock(lock, flags)  spin_unlock_irqrestore(lock, flags)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+#define eth_random_addr(addr) random_ether_addr(addr)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+#define netdev_features_t  u32
+#endif
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,5,0)
+#define NETIF_F_ALL_CSUM        NETIF_F_CSUM_MASK
+#else
+#ifndef NETIF_F_ALL_CSUM
+#define NETIF_F_ALL_CSUM        NETIF_F_CSUM_MASK
+#endif
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
+#define ENABLE_R8126_PROCFS
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+#define ENABLE_R8126_SYSFS
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+#define NETIF_F_HW_VLAN_RX	NETIF_F_HW_VLAN_CTAG_RX
+#define NETIF_F_HW_VLAN_TX	NETIF_F_HW_VLAN_CTAG_TX
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)
+#define __devinit
+#define __devexit
+#define __devexit_p(func)   func
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#define CHECKSUM_PARTIAL CHECKSUM_HW
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define irqreturn_t void
+#define IRQ_HANDLED    1
+#define IRQ_NONE   0
+#define IRQ_RETVAL(x)
+#endif
+
+#ifndef NETIF_F_RXALL
+#define NETIF_F_RXALL  0
+#endif
+
+#ifndef NETIF_F_RXFCS
+#define NETIF_F_RXFCS  0
+#endif
+
+#if !defined(HAVE_FREE_NETDEV) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+#define free_netdev(x)  kfree(x)
+#endif
+
+#ifndef SET_NETDEV_DEV
+#define SET_NETDEV_DEV(net, pdev)
+#endif
+
+#ifndef SET_MODULE_OWNER
+#define SET_MODULE_OWNER(dev)
+#endif
+
+#ifndef SA_SHIRQ
+#define SA_SHIRQ IRQF_SHARED
+#endif
+
+#ifndef NETIF_F_GSO
+#define gso_size    tso_size
+#define gso_segs    tso_segs
+#endif
+
+#ifndef PCI_VENDOR_ID_DLINK
+#define PCI_VENDOR_ID_DLINK 0x1186
+#endif
+
+#ifndef dma_mapping_error
+#define dma_mapping_error(a,b) 0
+#endif
+
+#ifndef netif_err
+#define netif_err(a,b,c,d)
+#endif
+
+#ifndef AUTONEG_DISABLE
+#define AUTONEG_DISABLE   0x00
+#endif
+
+#ifndef AUTONEG_ENABLE
+#define AUTONEG_ENABLE    0x01
+#endif
+
+#ifndef BMCR_SPEED1000
+#define BMCR_SPEED1000  0x0040
+#endif
+
+#ifndef BMCR_SPEED100
+#define BMCR_SPEED100   0x2000
+#endif
+
+#ifndef BMCR_SPEED10
+#define BMCR_SPEED10    0x0000
+#endif
+
+#ifndef SPEED_UNKNOWN
+#define SPEED_UNKNOWN   -1
+#endif
+
+#ifndef DUPLEX_UNKNOWN
+#define DUPLEX_UNKNOWN  0xff
+#endif
+
+#ifndef SUPPORTED_Pause
+#define SUPPORTED_Pause  (1 << 13)
+#endif
+
+#ifndef SUPPORTED_Asym_Pause
+#define SUPPORTED_Asym_Pause  (1 << 14)
+#endif
+
+#ifndef  MDIO_EEE_100TX
+#define  MDIO_EEE_100TX  0x0002
+#endif
+
+#ifndef  MDIO_EEE_1000T
+#define  MDIO_EEE_1000T  0x0004
+#endif
+
+#ifndef  MDIO_EEE_2_5GT
+#define  MDIO_EEE_2_5GT  0x0001
+#endif
+
+#ifndef  MDIO_EEE_5GT
+#define  MDIO_EEE_5GT  0x0002
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,9,0)
+#define ethtool_keee ethtool_eee
+#define rtl8126_ethtool_adv_to_mmd_eee_adv_cap1_t ethtool_adv_to_mmd_eee_adv_t
+static inline u32 rtl8126_ethtool_adv_to_mmd_eee_adv_cap2_t(u32 adv)
+{
+        u32 result = 0;
+
+        if (adv & SUPPORTED_2500baseX_Full)
+                result |= MDIO_EEE_2_5GT;
+
+        return result;
+}
+#else
+#define rtl8126_ethtool_adv_to_mmd_eee_adv_cap1_t linkmode_to_mii_eee_cap1_t
+#define rtl8126_ethtool_adv_to_mmd_eee_adv_cap2_t linkmode_to_mii_eee_cap2_t
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(6,9,0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+#ifdef CONFIG_NET_POLL_CONTROLLER
+#define RTL_NET_POLL_CONTROLLER dev->poll_controller=rtl8126_netpoll
+#else
+#define RTL_NET_POLL_CONTROLLER
+#endif
+
+#ifdef CONFIG_R8126_VLAN
+#define RTL_SET_VLAN dev->vlan_rx_register=rtl8126_vlan_rx_register
+#else
+#define RTL_SET_VLAN
+#endif
+
+#define RTL_NET_DEVICE_OPS(ops) dev->open=rtl8126_open; \
+                    dev->hard_start_xmit=rtl8126_start_xmit; \
+                    dev->get_stats=rtl8126_get_stats; \
+                    dev->stop=rtl8126_close; \
+                    dev->tx_timeout=rtl8126_tx_timeout; \
+                    dev->set_multicast_list=rtl8126_set_rx_mode; \
+                    dev->change_mtu=rtl8126_change_mtu; \
+                    dev->set_mac_address=rtl8126_set_mac_address; \
+                    dev->do_ioctl=rtl8126_do_ioctl; \
+                    RTL_NET_POLL_CONTROLLER; \
+                    RTL_SET_VLAN;
+#else
+#define RTL_NET_DEVICE_OPS(ops) dev->netdev_ops=&ops
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE  1
+#endif
+
+#ifndef false
+#define false 0
+#endif
+
+#ifndef true
+#define true  1
+#endif
+
+//Hardware will continue interrupt 10 times after interrupt finished.
+#define RTK_KEEP_INTERRUPT_COUNT (10)
+
+//the low 32 bit address of receive buffer must be 8-byte alignment.
+#ifndef NET_IP_ALIGN
+#define NET_IP_ALIGN        2
+#endif
+#define R8126_RX_ALIGN        NET_IP_ALIGN
+
+#ifdef CONFIG_R8126_NAPI
+#define NAPI_SUFFIX "-NAPI"
+#else
+#define NAPI_SUFFIX ""
+#endif
+#ifdef ENABLE_REALWOW_SUPPORT
+#define REALWOW_SUFFIX "-REALWOW"
+#else
+#define REALWOW_SUFFIX ""
+#endif
+
+#if defined(ENABLE_REALWOW_SUPPORT)
+#define REALWOW_SUFFIX "-REALWOW"
+#else
+#define REALWOW_SUFFIX ""
+#endif
+
+#if defined(ENABLE_PTP_SUPPORT)
+#define PTP_SUFFIX "-PTP"
+#else
+#define PTP_SUFFIX ""
+#endif
+
+#if defined(ENABLE_RSS_SUPPORT)
+#define RSS_SUFFIX "-RSS"
+#else
+#define RSS_SUFFIX ""
+#endif
+
+#define RTL8126_VERSION "10.016.00" NAPI_SUFFIX REALWOW_SUFFIX PTP_SUFFIX RSS_SUFFIX
+#define MODULENAME "r8126"
+#define PFX MODULENAME ": "
+
+#define GPL_CLAIM "\
+r8126  Copyright (C) 2025 Realtek NIC software team <nicfae@realtek.com> \n \
+This program comes with ABSOLUTELY NO WARRANTY; for details, please see <http://www.gnu.org/licenses/>. \n \
+This is free software, and you are welcome to redistribute it under certain conditions; see <http://www.gnu.org/licenses/>. \n"
+
+#ifdef RTL8126_DEBUG
+#define assert(expr) \
+        if(!(expr)) {                   \
+            printk("Assertion failed! %s,%s,%s,line=%d\n", \
+            #expr,__FILE__,__FUNCTION__,__LINE__);      \
+        }
+#define dprintk(fmt, args...)   do { printk(PFX fmt, ## args); } while (0)
+#else
+#define assert(expr) do {} while (0)
+#define dprintk(fmt, args...)   do {} while (0)
+#endif /* RTL8126_DEBUG */
+
+#define R8126_MSG_DEFAULT \
+    (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_IFUP | NETIF_MSG_IFDOWN)
+
+#ifdef CONFIG_R8126_NAPI
+#define rtl8126_rx_hwaccel_skb      vlan_hwaccel_receive_skb
+#define rtl8126_rx_quota(count, quota)  min(count, quota)
+#else
+#define rtl8126_rx_hwaccel_skb      vlan_hwaccel_rx
+#define rtl8126_rx_quota(count, quota)  count
+#endif
+
+/* MAC address length */
+#ifndef MAC_ADDR_LEN
+#define MAC_ADDR_LEN    6
+#endif
+
+#ifndef MAC_PROTOCOL_LEN
+#define MAC_PROTOCOL_LEN    2
+#endif
+
+#ifndef ETH_FCS_LEN
+#define ETH_FCS_LEN	  4
+#endif
+
+#ifndef NETIF_F_TSO6
+#define NETIF_F_TSO6  0
+#endif
+
+#define Reserved2_data  7
+#define RX_DMA_BURST_unlimited  7   /* Maximum PCI burst, '7' is unlimited */
+#define RX_DMA_BURST_512    5
+#define RX_DMA_BURST_256    4
+#define TX_DMA_BURST_unlimited  7
+#define TX_DMA_BURST_1024   6
+#define TX_DMA_BURST_512    5
+#define TX_DMA_BURST_256    4
+#define TX_DMA_BURST_128    3
+#define TX_DMA_BURST_64     2
+#define TX_DMA_BURST_32     1
+#define TX_DMA_BURST_16     0
+#define Reserved1_data  0x3F
+#define RxPacketMaxSize 0x3FE8  /* 16K - 1 - ETH_HLEN - VLAN - CRC... */
+#define Jumbo_Frame_1k  ETH_DATA_LEN
+#define Jumbo_Frame_2k  (2*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_3k  (3*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_4k  (4*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_5k  (5*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_6k  (6*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_7k  (7*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_8k  (8*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_9k  (9*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define InterFrameGap   0x03    /* 3 means InterFrameGap = the shortest one */
+#define RxEarly_off_V1 (0x07 << 11)
+#define RxEarly_off_V2 (1 << 11)
+#define Rx_Single_fetch_V2 (1 << 14)
+#define Rx_Close_Multiple (1 << 21)
+#define Rx_Fetch_Number_8 (1 << 30)
+
+#define R8126_REGS_SIZE     (256)
+#define R8126_MAC_REGS_SIZE     (256)
+#define R8126_PHY_REGS_SIZE     (16*2)
+#define R8126_EPHY_REGS_SIZE  	(31*2)
+#define R8126_ERI_REGS_SIZE  	(0x100)
+#define R8126_REGS_DUMP_SIZE     (0x400)
+#define R8126_PCI_REGS_SIZE  	(0x100)
+#define R8126_NAPI_WEIGHT   64
+
+#define R8126_MAX_MSIX_VEC_8125A   4
+#define R8126_MAX_MSIX_VEC_8125B   32
+#define R8126_MAX_MSIX_VEC_8125D   32
+#define R8126_MIN_MSIX_VEC_8125B   22
+#define R8126_MIN_MSIX_VEC_8125BP  31
+#define R8126_MIN_MSIX_VEC_8125D   20
+#define R8126_MAX_MSIX_VEC   32
+#define R8126_MAX_RX_QUEUES_VEC_V3 (16)
+
+#define RTL8126_TX_TIMEOUT  (6 * HZ)
+#define RTL8126_LINK_TIMEOUT    (1 * HZ)
+#define RTL8126_ESD_TIMEOUT (2 * HZ)
+
+#define rtl8126_rx_page_size(order) (PAGE_SIZE << order)
+
+#define MAX_NUM_TX_DESC 1024    /* Maximum number of Tx descriptor registers */
+#define MAX_NUM_RX_DESC 1024    /* Maximum number of Rx descriptor registers */
+
+#define MIN_NUM_TX_DESC 256    /* Minimum number of Tx descriptor registers */
+#define MIN_NUM_RX_DESC 256    /* Minimum number of Rx descriptor registers */
+
+#define NUM_TX_DESC MAX_NUM_TX_DESC    /* Number of Tx descriptor registers */
+#define NUM_RX_DESC MAX_NUM_RX_DESC    /* Number of Rx descriptor registers */
+
+#ifdef ENABLE_DOUBLE_VLAN
+#define RX_BUF_SIZE 0x05F6  /* 0x05F6(1526) = 1514 + 8(double vlan) + 4(crc) bytes */
+#define RT_VALN_HLEN 8      /* 8(double vlan) bytes */
+#else
+#define RX_BUF_SIZE 0x05F2  /* 0x05F2(1522) = 1514 + 4(single vlan) + 4(crc) bytes */
+#define RT_VALN_HLEN 4      /* 4(single vlan) bytes */
+#endif
+
+#define R8126_MAX_TX_QUEUES (2)
+#define R8126_MAX_RX_QUEUES_V2 (4)
+#define R8126_MAX_RX_QUEUES_V3 (16)
+#define R8126_MAX_RX_QUEUES R8126_MAX_RX_QUEUES_V3
+#define R8126_MAX_QUEUES R8126_MAX_RX_QUEUES
+
+#define OCP_STD_PHY_BASE	0xa400
+
+//Channel Wait Count
+#define R8126_CHANNEL_WAIT_COUNT (20000)
+#define R8126_CHANNEL_WAIT_TIME (1)  // 1us
+#define R8126_CHANNEL_EXIT_DELAY_TIME (20)  //20us
+
+#ifdef ENABLE_LIB_SUPPORT
+#define R8126_MULTI_RX_Q(tp) 0
+#else
+#define R8126_MULTI_RX_Q(tp) (tp->num_rx_rings > 1)
+#endif
+
+#define NODE_ADDRESS_SIZE 6
+
+#define SHORT_PACKET_PADDING_BUF_SIZE 256
+
+#define RTK_MAGIC_DEBUG_VALUE 0x0badbeef
+
+/* write/read MMIO register */
+#define RTL_W8(tp, reg, val8)	writeb((val8), tp->mmio_addr + (reg))
+#define RTL_W16(tp, reg, val16)	writew((val16), tp->mmio_addr + (reg))
+#define RTL_W32(tp, reg, val32)	writel((val32), tp->mmio_addr + (reg))
+#define RTL_R8(tp, reg)		readb(tp->mmio_addr + (reg))
+#define RTL_R16(tp, reg)		readw(tp->mmio_addr + (reg))
+#define RTL_R32(tp, reg)		((unsigned long) readl(tp->mmio_addr + (reg)))
+
+#ifndef DMA_64BIT_MASK
+#define DMA_64BIT_MASK  0xffffffffffffffffULL
+#endif
+
+#ifndef DMA_32BIT_MASK
+#define DMA_32BIT_MASK  0x00000000ffffffffULL
+#endif
+
+#ifndef NETDEV_TX_OK
+#define NETDEV_TX_OK 0      /* driver took care of packet */
+#endif
+
+#ifndef NETDEV_TX_BUSY
+#define NETDEV_TX_BUSY 1    /* driver tx path was busy*/
+#endif
+
+#ifndef NETDEV_TX_LOCKED
+#define NETDEV_TX_LOCKED -1t /* driver tx lock was already taken */
+#endif
+
+#ifndef ADVERTISED_Pause
+#define ADVERTISED_Pause    (1 << 13)
+#endif
+
+#ifndef ADVERTISED_Asym_Pause
+#define ADVERTISED_Asym_Pause   (1 << 14)
+#endif
+
+#ifndef ADVERTISE_PAUSE_CAP
+#define ADVERTISE_PAUSE_CAP 0x400
+#endif
+
+#ifndef ADVERTISE_PAUSE_ASYM
+#define ADVERTISE_PAUSE_ASYM    0x800
+#endif
+
+#ifndef MII_CTRL1000
+#define MII_CTRL1000        0x09
+#endif
+
+#ifndef ADVERTISE_1000FULL
+#define ADVERTISE_1000FULL  0x200
+#endif
+
+#ifndef ADVERTISE_1000HALF
+#define ADVERTISE_1000HALF  0x100
+#endif
+
+#ifndef BIT_ULL
+#define BIT_ULL(nr)		(1ULL << (nr))
+#endif
+
+#ifndef ADVERTISED_2500baseX_Full
+#define ADVERTISED_2500baseX_Full  0x8000
+#endif
+#define RTK_ADVERTISED_5000baseX_Full  BIT_ULL(48)
+#define RTK_SUPPORTED_5000baseX_Full BIT_ULL(48)
+
+#define RTK_ADVERTISE_2500FULL  0x80
+#define RTK_ADVERTISE_5000FULL  0x100
+#define RTK_ADVERTISE_10000FULL  0x1000
+#define RTK_LPA_ADVERTISE_2500FULL  0x20
+#define RTK_LPA_ADVERTISE_5000FULL  0x40
+#define RTK_LPA_ADVERTISE_10000FULL  0x800
+
+#define RTK_EEE_ADVERTISE_2500FULL  BIT(0)
+#define RTK_EEE_ADVERTISE_5000FULL  BIT(1)
+#define RTK_LPA_EEE_ADVERTISE_2500FULL  BIT(0)
+#define RTK_LPA_EEE_ADVERTISE_5000FULL  BIT(1)
+
+/* Tx NO CLOSE */
+#define MAX_TX_NO_CLOSE_DESC_PTR_V2 0x10000
+#define MAX_TX_NO_CLOSE_DESC_PTR_MASK_V2 0xFFFF
+#define MAX_TX_NO_CLOSE_DESC_PTR_V3 0x100000000
+#define MAX_TX_NO_CLOSE_DESC_PTR_MASK_V3 0xFFFFFFFF
+#define MAX_TX_NO_CLOSE_DESC_PTR_V4 0x80000000
+#define MAX_TX_NO_CLOSE_DESC_PTR_MASK_V4 0x7FFFFFFF
+#define TX_NO_CLOSE_SW_PTR_MASK_V2 0x1FFFF
+
+#ifndef ETH_MIN_MTU
+#define ETH_MIN_MTU  68
+#endif
+
+#define D0_SPEED_UP_SPEED_DISABLE    0
+#define D0_SPEED_UP_SPEED_1000       1
+#define D0_SPEED_UP_SPEED_2500       2
+#define D0_SPEED_UP_SPEED_5000       3
+
+#define RTL8126_MAC_MCU_PAGE_SIZE 256 //256 words
+
+#ifndef WRITE_ONCE
+#define WRITE_ONCE(var, val) (*((volatile typeof(val) *)(&(var))) = (val))
+#endif
+#ifndef READ_ONCE
+#define READ_ONCE(var) (*((volatile typeof(var) *)(&(var))))
+#endif
+
+#ifndef SPEED_5000
+#define SPEED_5000		5000
+#endif
+
+#define R8126_LINK_STATE_OFF 0
+#define R8126_LINK_STATE_ON 1
+#define R8126_LINK_STATE_UNKNOWN 2
+
+/*****************************************************************************/
+
+//#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3)
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27)) || \
+     ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)) && \
+      (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3))))
+/* copied from linux kernel 2.6.20 include/linux/netdev.h */
+#define NETDEV_ALIGN        32
+#define NETDEV_ALIGN_CONST  (NETDEV_ALIGN - 1)
+
+static inline void *netdev_priv(struct net_device *dev)
+{
+        return (char *)dev + ((sizeof(struct net_device)
+                               + NETDEV_ALIGN_CONST)
+                              & ~NETDEV_ALIGN_CONST);
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3)
+
+/*****************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#define RTLDEV  tp
+#else
+#define RTLDEV  dev
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+/*****************************************************************************/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+typedef struct net_device *napi_ptr;
+typedef int *napi_budget;
+
+#define napi dev
+#define RTL_NAPI_CONFIG(ndev, priv, function, weig) ndev->poll=function;    \
+                                ndev->weight=weig;
+#define RTL_NAPI_QUOTA(budget, ndev)            min(*budget, ndev->quota)
+#define RTL_GET_PRIV(stuct_ptr, priv_struct)        netdev_priv(stuct_ptr)
+#define RTL_GET_NETDEV(priv_ptr)
+#define RTL_RX_QUOTA(budget)          *budget
+#define RTL_NAPI_QUOTA_UPDATE(ndev, work_done, budget)  *budget -= work_done;   \
+                                ndev->quota -= work_done;
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        netif_rx_complete(dev)
+#define RTL_NETIF_RX_SCHEDULE_PREP(dev, napi)       netif_rx_schedule_prep(dev)
+#define __RTL_NETIF_RX_SCHEDULE(dev, napi)      __netif_rx_schedule(dev)
+#define RTL_NAPI_RETURN_VALUE               work_done >= work_to_do
+#define RTL_NAPI_ENABLE(dev, napi)          netif_poll_enable(dev)
+#define RTL_NAPI_DISABLE(dev, napi)         netif_poll_disable(dev)
+#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
+#else
+typedef struct napi_struct *napi_ptr;
+typedef int napi_budget;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)
+#define RTL_NAPI_CONFIG(ndev, priv, function, weight)   netif_napi_add_weight(ndev, &priv->napi, function, weight)
+#else
+#define RTL_NAPI_CONFIG(ndev, priv, function, weight)   netif_napi_add(ndev, &priv->napi, function, weight)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)
+#define RTL_NAPI_QUOTA(budget, ndev)            min(budget, budget)
+#define RTL_GET_PRIV(stuct_ptr, priv_struct)        container_of(stuct_ptr, priv_struct, stuct_ptr)
+#define RTL_GET_NETDEV(priv_ptr)            struct net_device *dev = priv_ptr->dev;
+#define RTL_RX_QUOTA(budget)          budget
+#define RTL_NAPI_QUOTA_UPDATE(ndev, work_done, budget)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        netif_rx_complete(dev, napi)
+#define RTL_NETIF_RX_SCHEDULE_PREP(dev, napi)       netif_rx_schedule_prep(dev, napi)
+#define __RTL_NETIF_RX_SCHEDULE(dev, napi)      __netif_rx_schedule(dev, napi)
+#endif
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2,6,29)
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        netif_rx_complete(napi)
+#define RTL_NETIF_RX_SCHEDULE_PREP(dev, napi)       netif_rx_schedule_prep(napi)
+#define __RTL_NETIF_RX_SCHEDULE(dev, napi)      __netif_rx_schedule(napi)
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        napi_complete_done(napi, work_done)
+#else
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        napi_complete(napi)
+#endif
+#define RTL_NETIF_RX_SCHEDULE_PREP(dev, napi)       napi_schedule_prep(napi)
+#define __RTL_NETIF_RX_SCHEDULE(dev, napi)      __napi_schedule(napi)
+#endif
+#define RTL_NAPI_RETURN_VALUE work_done
+#define RTL_NAPI_ENABLE(dev, napi)          napi_enable(napi)
+#define RTL_NAPI_DISABLE(dev, napi)         napi_disable(napi)
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+#define RTL_NAPI_DEL(priv)
+#else
+#define RTL_NAPI_DEL(priv)   netif_napi_del(&priv->napi)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+
+/*****************************************************************************/
+#ifdef CONFIG_R8126_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          napi_consume_skb(skb, budget)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          dev_consume_skb_any(skb);
+#else
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          dev_kfree_skb_any(skb);
+#endif  //LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+#else   //CONFIG_R8126_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          dev_consume_skb_any(skb);
+#else
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          dev_kfree_skb_any(skb);
+#endif
+#endif  //CONFIG_R8126_NAPI
+
+/*****************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+#ifdef __CHECKER__
+#define __iomem __attribute__((noderef, address_space(2)))
+extern void __chk_io_ptr(void __iomem *);
+#define __bitwise __attribute__((bitwise))
+#else
+#define __iomem
+#define __chk_io_ptr(x) (void)0
+#define __bitwise
+#endif
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+
+/*****************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+#ifdef __CHECKER__
+#define __force __attribute__((force))
+#else
+#define __force
+#endif
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+
+#ifndef module_param
+#define module_param(v,t,p) MODULE_PARM(v, "i");
+#endif
+
+#ifndef PCI_DEVICE
+#define PCI_DEVICE(vend,dev) \
+    .vendor = (vend), .device = (dev), \
+    .subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID
+#endif
+
+/*****************************************************************************/
+/* 2.5.28 => 2.4.23 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,28))
+
+static inline void _kc_synchronize_irq(void)
+{
+        synchronize_irq();
+}
+#undef synchronize_irq
+#define synchronize_irq(X) _kc_synchronize_irq()
+
+#include <linux/tqueue.h>
+#define work_struct tq_struct
+#undef INIT_WORK
+#define INIT_WORK(a,b,c) INIT_TQUEUE(a,(void (*)(void *))b,c)
+#undef container_of
+#define container_of list_entry
+#define schedule_work schedule_task
+#define flush_scheduled_work flush_scheduled_tasks
+#endif /* 2.5.28 => 2.4.17 */
+
+/*****************************************************************************/
+/* 2.6.4 => 2.6.0 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4))
+#define MODULE_VERSION(_version) MODULE_INFO(version, _version)
+#endif /* 2.6.4 => 2.6.0 */
+/*****************************************************************************/
+/* 2.6.0 => 2.5.28 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+#define MODULE_INFO(version, _version)
+#ifndef CONFIG_E1000_DISABLE_PACKET_SPLIT
+#define CONFIG_E1000_DISABLE_PACKET_SPLIT 1
+#endif
+
+#define pci_set_consistent_dma_mask(dev,mask) 1
+
+#undef dev_put
+#define dev_put(dev) __dev_put(dev)
+
+#ifndef skb_fill_page_desc
+#define skb_fill_page_desc _kc_skb_fill_page_desc
+extern void _kc_skb_fill_page_desc(struct sk_buff *skb, int i, struct page *page, int off, int size);
+#endif
+
+#ifndef pci_dma_mapping_error
+#define pci_dma_mapping_error _kc_pci_dma_mapping_error
+static inline int _kc_pci_dma_mapping_error(dma_addr_t dma_addr)
+{
+        return dma_addr == 0;
+}
+#endif
+
+#undef ALIGN
+#define ALIGN(x,a) (((x)+(a)-1)&~((a)-1))
+
+#endif /* 2.6.0 => 2.5.28 */
+
+/*****************************************************************************/
+/* 2.4.22 => 2.4.17 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22))
+#define pci_name(x) ((x)->slot_name)
+#endif /* 2.4.22 => 2.4.17 */
+
+/*****************************************************************************/
+/* 2.6.5 => 2.6.0 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5))
+#define pci_dma_sync_single_for_cpu pci_dma_sync_single
+#define pci_dma_sync_single_for_device  pci_dma_sync_single_for_cpu
+#endif /* 2.6.5 => 2.6.0 */
+
+/*****************************************************************************/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+/*
+ * initialize a work-struct's func and data pointers:
+ */
+#define PREPARE_WORK(_work, _func, _data)           \
+    do {                            \
+        (_work)->func = _func;              \
+        (_work)->data = _data;              \
+    } while (0)
+
+#endif
+/*****************************************************************************/
+/* 2.6.4 => 2.6.0 */
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(2,4,25) && \
+     LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)) || \
+    (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) && \
+      LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4)))
+#define ETHTOOL_OPS_COMPAT
+#endif /* 2.6.4 => 2.6.0 */
+
+/*****************************************************************************/
+/* Installations with ethtool version without eeprom, adapter id, or statistics
+ * support */
+
+#ifndef ETH_GSTRING_LEN
+#define ETH_GSTRING_LEN 32
+#endif
+
+#ifndef ETHTOOL_GSTATS
+#define ETHTOOL_GSTATS 0x1d
+#undef ethtool_drvinfo
+#define ethtool_drvinfo k_ethtool_drvinfo
+struct k_ethtool_drvinfo {
+        u32 cmd;
+        char driver[32];
+        char version[32];
+        char fw_version[32];
+        char bus_info[32];
+        char reserved1[32];
+        char reserved2[16];
+        u32 n_stats;
+        u32 testinfo_len;
+        u32 eedump_len;
+        u32 regdump_len;
+};
+
+struct ethtool_stats {
+        u32 cmd;
+        u32 n_stats;
+        u64 data[0];
+};
+#endif /* ETHTOOL_GSTATS */
+
+#ifndef ETHTOOL_PHYS_ID
+#define ETHTOOL_PHYS_ID 0x1c
+#endif /* ETHTOOL_PHYS_ID */
+
+#ifndef ETHTOOL_GSTRINGS
+#define ETHTOOL_GSTRINGS 0x1b
+enum ethtool_stringset {
+        ETH_SS_TEST             = 0,
+        ETH_SS_STATS,
+};
+struct ethtool_gstrings {
+        u32 cmd;            /* ETHTOOL_GSTRINGS */
+        u32 string_set;     /* string set id e.c. ETH_SS_TEST, etc*/
+        u32 len;            /* number of strings in the string set */
+        u8 data[0];
+};
+#endif /* ETHTOOL_GSTRINGS */
+
+#ifndef ETHTOOL_TEST
+#define ETHTOOL_TEST 0x1a
+enum ethtool_test_flags {
+        ETH_TEST_FL_OFFLINE = (1 << 0),
+        ETH_TEST_FL_FAILED  = (1 << 1),
+};
+struct ethtool_test {
+        u32 cmd;
+        u32 flags;
+        u32 reserved;
+        u32 len;
+        u64 data[0];
+};
+#endif /* ETHTOOL_TEST */
+
+#ifndef ETHTOOL_GEEPROM
+#define ETHTOOL_GEEPROM 0xb
+#undef ETHTOOL_GREGS
+struct ethtool_eeprom {
+        u32 cmd;
+        u32 magic;
+        u32 offset;
+        u32 len;
+        u8 data[0];
+};
+
+struct ethtool_value {
+        u32 cmd;
+        u32 data;
+};
+#endif /* ETHTOOL_GEEPROM */
+
+#ifndef ETHTOOL_GLINK
+#define ETHTOOL_GLINK 0xa
+#endif /* ETHTOOL_GLINK */
+
+#ifndef ETHTOOL_GREGS
+#define ETHTOOL_GREGS       0x00000004 /* Get NIC registers */
+#define ethtool_regs _kc_ethtool_regs
+/* for passing big chunks of data */
+struct _kc_ethtool_regs {
+        u32 cmd;
+        u32 version; /* driver-specific, indicates different chips/revs */
+        u32 len; /* bytes */
+        u8 data[0];
+};
+#endif /* ETHTOOL_GREGS */
+
+#ifndef ETHTOOL_GMSGLVL
+#define ETHTOOL_GMSGLVL     0x00000007 /* Get driver message level */
+#endif
+#ifndef ETHTOOL_SMSGLVL
+#define ETHTOOL_SMSGLVL     0x00000008 /* Set driver msg level, priv. */
+#endif
+#ifndef ETHTOOL_NWAY_RST
+#define ETHTOOL_NWAY_RST    0x00000009 /* Restart autonegotiation, priv */
+#endif
+#ifndef ETHTOOL_GLINK
+#define ETHTOOL_GLINK       0x0000000a /* Get link status */
+#endif
+#ifndef ETHTOOL_GEEPROM
+#define ETHTOOL_GEEPROM     0x0000000b /* Get EEPROM data */
+#endif
+#ifndef ETHTOOL_SEEPROM
+#define ETHTOOL_SEEPROM     0x0000000c /* Set EEPROM data */
+#endif
+#ifndef ETHTOOL_GCOALESCE
+#define ETHTOOL_GCOALESCE   0x0000000e /* Get coalesce config */
+/* for configuring coalescing parameters of chip */
+#define ethtool_coalesce _kc_ethtool_coalesce
+struct _kc_ethtool_coalesce {
+        u32 cmd;    /* ETHTOOL_{G,S}COALESCE */
+
+        /* How many usecs to delay an RX interrupt after
+         * a packet arrives.  If 0, only rx_max_coalesced_frames
+         * is used.
+         */
+        u32 rx_coalesce_usecs;
+
+        /* How many packets to delay an RX interrupt after
+         * a packet arrives.  If 0, only rx_coalesce_usecs is
+         * used.  It is illegal to set both usecs and max frames
+         * to zero as this would cause RX interrupts to never be
+         * generated.
+         */
+        u32 rx_max_coalesced_frames;
+
+        /* Same as above two parameters, except that these values
+         * apply while an IRQ is being serviced by the host.  Not
+         * all cards support this feature and the values are ignored
+         * in that case.
+         */
+        u32 rx_coalesce_usecs_irq;
+        u32 rx_max_coalesced_frames_irq;
+
+        /* How many usecs to delay a TX interrupt after
+         * a packet is sent.  If 0, only tx_max_coalesced_frames
+         * is used.
+         */
+        u32 tx_coalesce_usecs;
+
+        /* How many packets to delay a TX interrupt after
+         * a packet is sent.  If 0, only tx_coalesce_usecs is
+         * used.  It is illegal to set both usecs and max frames
+         * to zero as this would cause TX interrupts to never be
+         * generated.
+         */
+        u32 tx_max_coalesced_frames;
+
+        /* Same as above two parameters, except that these values
+         * apply while an IRQ is being serviced by the host.  Not
+         * all cards support this feature and the values are ignored
+         * in that case.
+         */
+        u32 tx_coalesce_usecs_irq;
+        u32 tx_max_coalesced_frames_irq;
+
+        /* How many usecs to delay in-memory statistics
+         * block updates.  Some drivers do not have an in-memory
+         * statistic block, and in such cases this value is ignored.
+         * This value must not be zero.
+         */
+        u32 stats_block_coalesce_usecs;
+
+        /* Adaptive RX/TX coalescing is an algorithm implemented by
+         * some drivers to improve latency under low packet rates and
+         * improve throughput under high packet rates.  Some drivers
+         * only implement one of RX or TX adaptive coalescing.  Anything
+         * not implemented by the driver causes these values to be
+         * silently ignored.
+         */
+        u32 use_adaptive_rx_coalesce;
+        u32 use_adaptive_tx_coalesce;
+
+        /* When the packet rate (measured in packets per second)
+         * is below pkt_rate_low, the {rx,tx}_*_low parameters are
+         * used.
+         */
+        u32 pkt_rate_low;
+        u32 rx_coalesce_usecs_low;
+        u32 rx_max_coalesced_frames_low;
+        u32 tx_coalesce_usecs_low;
+        u32 tx_max_coalesced_frames_low;
+
+        /* When the packet rate is below pkt_rate_high but above
+         * pkt_rate_low (both measured in packets per second) the
+         * normal {rx,tx}_* coalescing parameters are used.
+         */
+
+        /* When the packet rate is (measured in packets per second)
+         * is above pkt_rate_high, the {rx,tx}_*_high parameters are
+         * used.
+         */
+        u32 pkt_rate_high;
+        u32 rx_coalesce_usecs_high;
+        u32 rx_max_coalesced_frames_high;
+        u32 tx_coalesce_usecs_high;
+        u32 tx_max_coalesced_frames_high;
+
+        /* How often to do adaptive coalescing packet rate sampling,
+         * measured in seconds.  Must not be zero.
+         */
+        u32 rate_sample_interval;
+};
+#endif /* ETHTOOL_GCOALESCE */
+
+#ifndef ETHTOOL_SCOALESCE
+#define ETHTOOL_SCOALESCE   0x0000000f /* Set coalesce config. */
+#endif
+#ifndef ETHTOOL_GRINGPARAM
+#define ETHTOOL_GRINGPARAM  0x00000010 /* Get ring parameters */
+/* for configuring RX/TX ring parameters */
+#define ethtool_ringparam _kc_ethtool_ringparam
+struct _kc_ethtool_ringparam {
+        u32 cmd;    /* ETHTOOL_{G,S}RINGPARAM */
+
+        /* Read only attributes.  These indicate the maximum number
+         * of pending RX/TX ring entries the driver will allow the
+         * user to set.
+         */
+        u32 rx_max_pending;
+        u32 rx_mini_max_pending;
+        u32 rx_jumbo_max_pending;
+        u32 tx_max_pending;
+
+        /* Values changeable by the user.  The valid values are
+         * in the range 1 to the "*_max_pending" counterpart above.
+         */
+        u32 rx_pending;
+        u32 rx_mini_pending;
+        u32 rx_jumbo_pending;
+        u32 tx_pending;
+};
+#endif /* ETHTOOL_GRINGPARAM */
+
+#ifndef ETHTOOL_SRINGPARAM
+#define ETHTOOL_SRINGPARAM  0x00000011 /* Set ring parameters, priv. */
+#endif
+#ifndef ETHTOOL_GPAUSEPARAM
+#define ETHTOOL_GPAUSEPARAM 0x00000012 /* Get pause parameters */
+/* for configuring link flow control parameters */
+#define ethtool_pauseparam _kc_ethtool_pauseparam
+struct _kc_ethtool_pauseparam {
+        u32 cmd;    /* ETHTOOL_{G,S}PAUSEPARAM */
+
+        /* If the link is being auto-negotiated (via ethtool_cmd.autoneg
+         * being true) the user may set 'autonet' here non-zero to have the
+         * pause parameters be auto-negotiated too.  In such a case, the
+         * {rx,tx}_pause values below determine what capabilities are
+         * advertised.
+         *
+         * If 'autoneg' is zero or the link is not being auto-negotiated,
+         * then {rx,tx}_pause force the driver to use/not-use pause
+         * flow control.
+         */
+        u32 autoneg;
+        u32 rx_pause;
+        u32 tx_pause;
+};
+#endif /* ETHTOOL_GPAUSEPARAM */
+
+#ifndef ETHTOOL_SPAUSEPARAM
+#define ETHTOOL_SPAUSEPARAM 0x00000013 /* Set pause parameters. */
+#endif
+#ifndef ETHTOOL_GRXCSUM
+#define ETHTOOL_GRXCSUM     0x00000014 /* Get RX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_SRXCSUM
+#define ETHTOOL_SRXCSUM     0x00000015 /* Set RX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_GTXCSUM
+#define ETHTOOL_GTXCSUM     0x00000016 /* Get TX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_STXCSUM
+#define ETHTOOL_STXCSUM     0x00000017 /* Set TX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_GSG
+#define ETHTOOL_GSG     0x00000018 /* Get scatter-gather enable
+* (ethtool_value) */
+#endif
+#ifndef ETHTOOL_SSG
+#define ETHTOOL_SSG     0x00000019 /* Set scatter-gather enable
+* (ethtool_value). */
+#endif
+#ifndef ETHTOOL_TEST
+#define ETHTOOL_TEST        0x0000001a /* execute NIC self-test, priv. */
+#endif
+#ifndef ETHTOOL_GSTRINGS
+#define ETHTOOL_GSTRINGS    0x0000001b /* get specified string set */
+#endif
+#ifndef ETHTOOL_PHYS_ID
+#define ETHTOOL_PHYS_ID     0x0000001c /* identify the NIC */
+#endif
+#ifndef ETHTOOL_GSTATS
+#define ETHTOOL_GSTATS      0x0000001d /* get NIC-specific statistics */
+#endif
+#ifndef ETHTOOL_GTSO
+#define ETHTOOL_GTSO        0x0000001e /* Get TSO enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_STSO
+#define ETHTOOL_STSO        0x0000001f /* Set TSO enable (ethtool_value) */
+#endif
+
+#ifndef ETHTOOL_BUSINFO_LEN
+#define ETHTOOL_BUSINFO_LEN 32
+#endif
+
+/*****************************************************************************/
+
+enum RTL8126_registers {
+        MAC0            = 0x00,     /* Ethernet hardware address. */
+        MAC4            = 0x04,
+        MAR0            = 0x08,     /* Multicast filter. */
+        CounterAddrLow      = 0x10,
+        CounterAddrHigh     = 0x14,
+        CustomLED       = 0x18,
+        TxDescStartAddrLow  = 0x20,
+        TxDescStartAddrHigh = 0x24,
+        TxHDescStartAddrLow = 0x28,
+        TxHDescStartAddrHigh    = 0x2c,
+        FLASH           = 0x30,
+        INT_CFG0_8125   = 0x34,
+        ERSR            = 0x36,
+        ChipCmd         = 0x37,
+        TxPoll          = 0x38,
+        IntrMask        = 0x3C,
+        IntrStatus      = 0x3E,
+        TxConfig        = 0x40,
+        RxConfig        = 0x44,
+        TCTR            = 0x48,
+        Cfg9346         = 0x50,
+        Config0         = 0x51,
+        Config1         = 0x52,
+        Config2         = 0x53,
+        Config3         = 0x54,
+        Config4         = 0x55,
+        Config5         = 0x56,
+        TDFNR           = 0x57,
+        TimeInt0        = 0x58,
+        TimeInt1        = 0x5C,
+        PHYAR           = 0x60,
+        CSIDR           = 0x64,
+        CSIAR           = 0x68,
+        PHYstatus       = 0x6C,
+        MACDBG          = 0x6D,
+        GPIO            = 0x6E,
+        PMCH            = 0x6F,
+        ERIDR           = 0x70,
+        ERIAR           = 0x74,
+        INT_CFG1_8125   = 0x7A,
+        EPHY_RXER_NUM   = 0x7C,
+        EPHYAR          = 0x80,
+        TimeInt2        = 0x8C,
+        OCPDR           = 0xB0,
+        MACOCP          = 0xB0,
+        OCPAR           = 0xB4,
+        SecMAC0         = 0xB4,
+        SecMAC4         = 0xB8,
+        PHYOCP          = 0xB8,
+        DBG_reg         = 0xD1,
+        TwiCmdReg       = 0xD2,
+        MCUCmd_reg      = 0xD3,
+        RxMaxSize       = 0xDA,
+        EFUSEAR         = 0xDC,
+        CPlusCmd        = 0xE0,
+        IntrMitigate    = 0xE2,
+        RxDescAddrLow   = 0xE4,
+        RxDescAddrHigh  = 0xE8,
+        MTPS            = 0xEC,
+        FuncEvent       = 0xF0,
+        PPSW            = 0xF2,
+        FuncEventMask   = 0xF4,
+        TimeInt3        = 0xF4,
+        FuncPresetState = 0xF8,
+        CMAC_IBCR0      = 0xF8,
+        CMAC_IBCR2      = 0xF9,
+        CMAC_IBIMR0     = 0xFA,
+        CMAC_IBISR0     = 0xFB,
+        FuncForceEvent  = 0xFC,
+        //8125
+        IMR0_8125          = 0x38,
+        ISR0_8125          = 0x3C,
+        TPPOLL_8125        = 0x90,
+        IMR1_8125          = 0x800,
+        ISR1_8125          = 0x802,
+        IMR2_8125          = 0x804,
+        ISR2_8125          = 0x806,
+        IMR3_8125          = 0x808,
+        ISR3_8125          = 0x80A,
+        BACKUP_ADDR0_8125  = 0x19E0,
+        BACKUP_ADDR1_8125  = 0X19E4,
+        TCTR0_8125         = 0x0048,
+        TCTR1_8125         = 0x004C,
+        TCTR2_8125         = 0x0088,
+        TCTR3_8125         = 0x001C,
+        TIMER_INT0_8125    = 0x0058,
+        TIMER_INT1_8125    = 0x005C,
+        TIMER_INT2_8125    = 0x008C,
+        TIMER_INT3_8125    = 0x00F4,
+        INT_MITI_V2_0_RX   = 0x0A00,
+        INT_MITI_V2_0_TX   = 0x0A02,
+        INT_MITI_V2_1_RX   = 0x0A08,
+        INT_MITI_V2_1_TX   = 0x0A0A,
+        IMR_V2_CLEAR_REG_8125 = 0x0D00,
+        ISR_V2_8125           = 0x0D04,
+        IMR_V2_SET_REG_8125   = 0x0D0C,
+        TDU_STA_8125       = 0x0D08,
+        RDU_STA_8125       = 0x0D0A,
+        IMR_V4_L2_CLEAR_REG_8125 = 0x0D10,
+        IMR_V4_L2_SET_REG_8125   = 0x0D18,
+        ISR_V4_L2_8125     = 0x0D14,
+        SW_TAIL_PTR0_8125BP = 0x0D30,
+        SW_TAIL_PTR1_8125BP = 0x0D38,
+        HW_CLO_PTR0_8125BP = 0x0D34,
+        HW_CLO_PTR1_8125BP = 0x0D3C,
+        DOUBLE_VLAN_CONFIG = 0x1000,
+        TX_NEW_CTRL        = 0x203E,
+        TNPDS_Q1_LOW_8125  = 0x2100,
+        PLA_TXQ0_IDLE_CREDIT = 0x2500,
+        PLA_TXQ1_IDLE_CREDIT = 0x2504,
+        SW_TAIL_PTR0_8125  = 0x2800,
+        HW_CLO_PTR0_8125   = 0x2802,
+        SW_TAIL_PTR0_8126  = 0x2800,
+        HW_CLO_PTR0_8126   = 0x2800,
+        RDSAR_Q1_LOW_8125  = 0x4000,
+        RSS_CTRL_8125      = 0x4500,
+        Q_NUM_CTRL_8125    = 0x4800,
+        RSS_KEY_8125       = 0x4600,
+        RSS_INDIRECTION_TBL_8125_V2 = 0x4700,
+        EEE_TXIDLE_TIMER_8125   = 0x6048,
+        PTP_CTRL_8125      = 0x6800,
+        PTP_STATUS_8125    = 0x6802,
+        PTP_ISR_8125       = 0x6804,
+        PTP_IMR_8125       = 0x6805,
+        PTP_TIME_CORRECT_CMD_8125    = 0x6806,
+        PTP_SOFT_CONFIG_Time_NS_8125 = 0x6808,
+        PTP_SOFT_CONFIG_Time_S_8125  = 0x680C,
+        PTP_SOFT_CONFIG_Time_Sign    = 0x6812,
+        PTP_LOCAL_Time_SUB_NS_8125   = 0x6814,
+        PTP_LOCAL_Time_NS_8125       = 0x6818,
+        PTP_LOCAL_Time_S_8125        = 0x681C,
+        PTP_Time_SHIFTER_S_8125      = 0x6856,
+        PPS_RISE_TIME_NS_8125        = 0x68A0,
+        PPS_RISE_TIME_S_8125         = 0x68A4,
+        PTP_EGRESS_TIME_BASE_NS_8125 = 0XCF20,
+        PTP_EGRESS_TIME_BASE_S_8125  = 0XCF24,
+        PTP_CTL                 = 0xE400,
+        PTP_INER                = 0xE402,
+        PTP_INSR                = 0xE404,
+        PTP_SYNCE_CTL           = 0xE406,
+        PTP_GEN_CFG             = 0xE408,
+        PTP_CLK_CFG_8126        = 0xE410,
+        PTP_CFG_NS_LO_8126      = 0xE412,
+        PTP_CFG_NS_HI_8126      = 0xE414,
+        PTP_CFG_S_LO_8126       = 0xE416,
+        PTP_CFG_S_MI_8126       = 0xE418,
+        PTP_CFG_S_HI_8126       = 0xE41A,
+        PTP_TAI_CFG             = 0xE420,
+        PTP_TAI_TS_S_LO         = 0xE42A,
+        PTP_TAI_TS_S_HI         = 0xE42C,
+        PTP_TRX_TS_STA          = 0xE430,
+        PTP_TRX_TS_NS_LO        = 0xE446,
+        PTP_TRX_TS_NS_HI        = 0xE448,
+        PTP_TRX_TS_S_LO         = 0xE44A,
+        PTP_TRX_TS_S_MI         = 0xE44C,
+        PTP_TRX_TS_S_HI         = 0xE44E,
+
+        //TCAM
+        TCAM_NOTVALID_ADDR           = 0xA000,
+        TCAM_VALID_ADDR              = 0xA800,
+        TCAM_MAC_ADDR                = 448,
+        TCAM_VLAN_TAG                = 496,
+        //TCAM V2
+        TCAM_NOTVALID_ADDR_V2           = 0xA000,
+        TCAM_VALID_ADDR_V2              = 0xB000,
+        TCAM_MAC_ADDR_V2                = 0x00,
+        TCAM_VLAN_TAG_V2                = 0x03,
+};
+
+enum RTL8126_register_content {
+        /* InterruptStatusBits */
+        SYSErr      = 0x8000,
+        PCSTimeout  = 0x4000,
+        SWInt       = 0x0100,
+        TxDescUnavail   = 0x0080,
+        RxFIFOOver  = 0x0040,
+        LinkChg     = 0x0020,
+        RxDescUnavail   = 0x0010,
+        TxErr       = 0x0008,
+        TxOK        = 0x0004,
+        RxErr       = 0x0002,
+        RxOK        = 0x0001,
+        RxDU1       = 0x0002,
+        RxOK1       = 0x0001,
+
+        /* RxStatusDesc */
+        RxRWT = (1 << 22),
+        RxRES = (1 << 21),
+        RxRUNT = (1 << 20),
+        RxCRC = (1 << 19),
+
+        RxRWT_V3 = (1 << 18),
+        RxRES_V3 = (1 << 20),
+        RxRUNT_V3 = (1 << 19),
+        RxCRC_V3 = (1 << 17),
+
+        RxRES_V4 = (1 << 22),
+        RxRUNT_V4 = (1 << 21),
+        RxCRC_V4 = (1 << 20),
+
+        /* ChipCmdBits */
+        StopReq  = 0x80,
+        CmdReset = 0x10,
+        CmdRxEnb = 0x08,
+        CmdTxEnb = 0x04,
+        RxBufEmpty = 0x01,
+
+        /* Cfg9346Bits */
+        Cfg9346_EEM_MASK = 0xC0,
+        Cfg9346_Lock = 0x00,
+        Cfg9346_Unlock = 0xC0,
+        Cfg9346_EEDO = (1 << 0),
+        Cfg9346_EEDI = (1 << 1),
+        Cfg9346_EESK = (1 << 2),
+        Cfg9346_EECS = (1 << 3),
+        Cfg9346_EEM0 = (1 << 6),
+        Cfg9346_EEM1 = (1 << 7),
+
+        /* rx_mode_bits */
+        AcceptErr = 0x20,
+        AcceptRunt = 0x10,
+        AcceptBroadcast = 0x08,
+        AcceptMulticast = 0x04,
+        AcceptMyPhys = 0x02,
+        AcceptAllPhys = 0x01,
+        AcceppVlanPhys = 0x8000,
+
+        /* Transmit Priority Polling*/
+        HPQ = 0x80,
+        NPQ = 0x40,
+        FSWInt = 0x01,
+
+        /* RxConfigBits */
+        Reserved2_shift = 13,
+        RxCfgDMAShift = 8,
+        EnableRxDescV3 = (1 << 24),
+        EnableRxDescV4_1 = (1 << 24),
+        EnableOuterVlan = (1 << 23),
+        EnableInnerVlan = (1 << 22),
+        RxCfg_128_int_en = (1 << 15),
+        RxCfg_fet_multi_en = (1 << 14),
+        RxCfg_half_refetch = (1 << 13),
+        RxCfg_pause_slot_en = (1 << 11),
+        RxCfg_9356SEL = (1 << 6),
+        EnableRxDescV4_0 = (1 << 1), //not in rcr
+
+        /* TxConfigBits */
+        TxInterFrameGapShift = 24,
+        TxDMAShift = 8, /* DMA burst value (0-7) is shift this many bits */
+        TxMACLoopBack = (1 << 17),  /* MAC loopback */
+
+        /* Config1 register */
+        LEDS1       = (1 << 7),
+        LEDS0       = (1 << 6),
+        Speed_down  = (1 << 4),
+        MEMMAP      = (1 << 3),
+        IOMAP       = (1 << 2),
+        VPD         = (1 << 1),
+        PMEnable    = (1 << 0), /* Power Management Enable */
+
+        /* Config2 register */
+        PMSTS_En    = (1 << 5),
+
+        /* Config3 register */
+        Isolate_en  = (1 << 12), /* Isolate enable */
+        MagicPacket = (1 << 5), /* Wake up when receives a Magic Packet */
+        LinkUp      = (1 << 4), /* This bit is reserved in RTL8125B.*/
+        /* Wake up when the cable connection is re-established */
+        ECRCEN      = (1 << 3), /* This bit is reserved in RTL8125B*/
+        Jumbo_En0   = (1 << 2), /* This bit is reserved in RTL8125B*/
+        RDY_TO_L23  = (1 << 1), /* This bit is reserved in RTL8125B*/
+        Beacon_en   = (1 << 0), /* This bit is reserved in RTL8125B*/
+
+        /* Config4 register */
+        Jumbo_En1   = (1 << 1), /* This bit is reserved in RTL8125B*/
+
+        /* Config5 register */
+        BWF     = (1 << 6), /* Accept Broadcast wakeup frame */
+        MWF     = (1 << 5), /* Accept Multicast wakeup frame */
+        UWF     = (1 << 4), /* Accept Unicast wakeup frame */
+        LanWake     = (1 << 1), /* LanWake enable/disable */
+        PMEStatus   = (1 << 0), /* PME status can be reset by PCI RST# */
+
+        /* CPlusCmd */
+        EnableBist  = (1 << 15),
+        Macdbgo_oe  = (1 << 14),
+        Normal_mode = (1 << 13),
+        Force_halfdup   = (1 << 12),
+        Force_rxflow_en = (1 << 11),
+        Force_txflow_en = (1 << 10),
+        Cxpl_dbg_sel    = (1 << 9),//This bit is reserved in RTL8125B
+        ASF     = (1 << 8),//This bit is reserved in RTL8125C
+        PktCntrDisable  = (1 << 7),
+        RxVlan      = (1 << 6),
+        RxChkSum    = (1 << 5),
+        Macdbgo_sel = 0x001C,
+        INTT_0      = 0x0000,
+        INTT_1      = 0x0001,
+        INTT_2      = 0x0002,
+        INTT_3      = 0x0003,
+
+        /* rtl8126_PHYstatus */
+        PowerSaveStatus = 0x80,
+        _1000bpsL = 0x80000,
+        _5000bpsF = 0x1000,
+        _5000bpsL = 0x800,
+        _2500bpsF = 0x400,
+        _2500bpsL = 0x200,
+        TxFlowCtrl = 0x40,
+        RxFlowCtrl = 0x20,
+        _1000bpsF = 0x10,
+        _100bps = 0x08,
+        _10bps = 0x04,
+        LinkStatus = 0x02,
+        FullDup = 0x01,
+
+        /* DBG_reg */
+        Fix_Nak_1 = (1 << 4),
+        Fix_Nak_2 = (1 << 3),
+        DBGPIN_E2 = (1 << 0),
+
+        /* ResetCounterCommand */
+        CounterReset = 0x1,
+        /* DumpCounterCommand */
+        CounterDump = 0x8,
+
+        /* PHY access */
+        PHYAR_Flag = 0x80000000,
+        PHYAR_Write = 0x80000000,
+        PHYAR_Read = 0x00000000,
+        PHYAR_Reg_Mask = 0x1f,
+        PHYAR_Reg_shift = 16,
+        PHYAR_Data_Mask = 0xffff,
+
+        /* EPHY access */
+        EPHYAR_Flag = 0x80000000,
+        EPHYAR_Write = 0x80000000,
+        EPHYAR_Read = 0x00000000,
+        EPHYAR_Reg_Mask = 0x3f,
+        EPHYAR_Reg_Mask_v2 = 0x7f,
+        EPHYAR_Reg_shift = 16,
+        EPHYAR_Data_Mask = 0xffff,
+
+        /* CSI access */
+        CSIAR_Flag = 0x80000000,
+        CSIAR_Write = 0x80000000,
+        CSIAR_Read = 0x00000000,
+        CSIAR_ByteEn = 0x0f,
+        CSIAR_ByteEn_shift = 12,
+        CSIAR_Addr_Mask = 0x0fff,
+
+        /* ERI access */
+        ERIAR_Flag = 0x80000000,
+        ERIAR_Write = 0x80000000,
+        ERIAR_Read = 0x00000000,
+        ERIAR_Addr_Align = 4, /* ERI access register address must be 4 byte alignment */
+        ERIAR_ExGMAC = 0,
+        ERIAR_MSIX = 1,
+        ERIAR_ASF = 2,
+        ERIAR_OOB = 2,
+        ERIAR_Type_shift = 16,
+        ERIAR_ByteEn = 0x0f,
+        ERIAR_ByteEn_shift = 12,
+
+        /* OCP GPHY access */
+        OCPDR_Write = 0x80000000,
+        OCPDR_Read = 0x00000000,
+        OCPDR_Reg_Mask = 0xFF,
+        OCPDR_Data_Mask = 0xFFFF,
+        OCPDR_GPHY_Reg_shift = 16,
+        OCPAR_Flag = 0x80000000,
+        OCPAR_GPHY_Write = 0x8000F060,
+        OCPAR_GPHY_Read = 0x0000F060,
+        OCPR_Write = 0x80000000,
+        OCPR_Read = 0x00000000,
+        OCPR_Addr_Reg_shift = 16,
+        OCPR_Flag = 0x80000000,
+        OCP_STD_PHY_BASE_PAGE = 0x0A40,
+
+        /* MCU Command */
+        Now_is_oob = (1 << 7),
+        Txfifo_empty = (1 << 5),
+        Rxfifo_empty = (1 << 4),
+
+        /* E-FUSE access */
+        EFUSE_WRITE = 0x80000000,
+        EFUSE_WRITE_OK  = 0x00000000,
+        EFUSE_READ  = 0x00000000,
+        EFUSE_READ_OK   = 0x80000000,
+        EFUSE_WRITE_V3 = 0x40000000,
+        EFUSE_WRITE_OK_V3  = 0x00000000,
+        EFUSE_READ_V3  = 0x80000000,
+        EFUSE_READ_OK_V3   = 0x00000000,
+        EFUSE_Reg_Mask  = 0x03FF,
+        EFUSE_Reg_Shift = 8,
+        EFUSE_Check_Cnt = 300,
+        EFUSE_READ_FAIL = 0xFF,
+        EFUSE_Data_Mask = 0x000000FF,
+
+        /* GPIO */
+        GPIO_en = (1 << 0),
+
+        /* PTP */
+        PTP_ISR_TOK = (1 << 1),
+        PTP_ISR_TER = (1 << 2),
+        PTP_EXEC_CMD = (1 << 7),
+        PTP_ADJUST_TIME_NS_NEGATIVE = (1 << 30),
+        PTP_ADJUST_TIME_S_NEGATIVE = (1ULL << 48),
+        PTP_SOFT_CONFIG_TIME_NS_NEGATIVE = (1 << 30),
+        PTP_SOFT_CONFIG_TIME_S_NEGATIVE = (1ULL << 48),
+
+        /* New Interrupt Bits */
+        INT_CFG0_ENABLE_8125 = (1 << 0),
+        INT_CFG0_TIMEOUT0_BYPASS_8125 = (1 << 1),
+        INT_CFG0_MITIGATION_BYPASS_8125 = (1 << 2),
+        INT_CFG0_RDU_BYPASS_8126 = (1 << 4),
+        INT_CFG0_MSIX_ENTRY_NUM_MODE = (1 << 5),
+        ISRIMR_V2_ROK_Q0     = (1 << 0),
+        ISRIMR_TOK_Q0        = (1 << 16),
+        ISRIMR_TOK_Q1        = (1 << 18),
+        ISRIMR_V2_LINKCHG    = (1 << 21),
+
+        ISRIMR_V4_ROK_Q0     = (1 << 0),
+        ISRIMR_V4_LINKCHG    = (1 << 29),
+
+        ISRIMR_V5_ROK_Q0     = (1 << 0),
+        ISRIMR_V5_TOK_Q0     = (1 << 16),
+        ISRIMR_V5_TOK_Q1     = (1 << 17),
+        ISRIMR_V5_LINKCHG    = (1 << 18),
+
+        /* Magic Number */
+        RTL8126_MAGIC_NUMBER = 0x0badbadbadbadbadull,
+};
+
+enum _DescStatusBit {
+        DescOwn     = (1 << 31), /* Descriptor is owned by NIC */
+        RingEnd     = (1 << 30), /* End of descriptor ring */
+        FirstFrag   = (1 << 29), /* First segment of a packet */
+        LastFrag    = (1 << 28), /* Final segment of a packet */
+
+        DescOwn_V3     = (DescOwn), /* Descriptor is owned by NIC */
+        RingEnd_V3     = (RingEnd), /* End of descriptor ring */
+        FirstFrag_V3   = (1 << 25), /* First segment of a packet */
+        LastFrag_V3    = (1 << 24), /* Final segment of a packet */
+
+        DescOwn_V4     = (DescOwn), /* Descriptor is owned by NIC */
+        RingEnd_V4     = (RingEnd), /* End of descriptor ring */
+        FirstFrag_V4   = (FirstFrag), /* First segment of a packet */
+        LastFrag_V4    = (LastFrag), /* Final segment of a packet */
+
+        /* Tx private */
+        /*------ offset 0 of tx descriptor ------*/
+        LargeSend   = (1 << 27), /* TCP Large Send Offload (TSO) */
+        GiantSendv4 = (1 << 26), /* TCP Giant Send Offload V4 (GSOv4) */
+        GiantSendv6 = (1 << 25), /* TCP Giant Send Offload V6 (GSOv6) */
+        LargeSend_DP = (1 << 16), /* TCP Large Send Offload (TSO) */
+        MSSShift    = 16,        /* MSS value position */
+        MSSMask     = 0x7FFU,    /* MSS value 11 bits */
+        TxIPCS      = (1 << 18), /* Calculate IP checksum */
+        TxUDPCS     = (1 << 17), /* Calculate UDP/IP checksum */
+        TxTCPCS     = (1 << 16), /* Calculate TCP/IP checksum */
+        TxVlanTag   = (1 << 17), /* Add VLAN tag */
+
+        /*@@@@@@ offset 4 of tx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        TxUDPCS_C   = (1 << 31), /* Calculate UDP/IP checksum */
+        TxTCPCS_C   = (1 << 30), /* Calculate TCP/IP checksum */
+        TxIPCS_C    = (1 << 29), /* Calculate IP checksum */
+        TxIPV6F_C   = (1 << 28), /* Indicate it is an IPv6 packet */
+        /*@@@@@@ offset 4 of tx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+
+        /* Rx private */
+        /*------ offset 0 of rx descriptor ------*/
+        PID1        = (1 << 18), /* Protocol ID bit 1/2 */
+        PID0        = (1 << 17), /* Protocol ID bit 2/2 */
+
+#define RxProtoUDP  (PID1)
+#define RxProtoTCP  (PID0)
+#define RxProtoIP   (PID1 | PID0)
+#define RxProtoMask RxProtoIP
+
+        RxIPF       = (1 << 16), /* IP checksum failed */
+        RxUDPF      = (1 << 15), /* UDP/IP checksum failed */
+        RxTCPF      = (1 << 14), /* TCP/IP checksum failed */
+        RxVlanTag   = (1 << 16), /* VLAN tag available */
+
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxUDPT      = (1 << 18),
+        RxTCPT      = (1 << 17),
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxV6F       = (1 << 31),
+        RxV4F       = (1 << 30),
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+
+        PID1_v3        = (1 << 29), /* Protocol ID bit 1/2 */
+        PID0_v3        = (1 << 28), /* Protocol ID bit 2/2 */
+
+#define RxProtoUDP_v3  (PID1_v3)
+#define RxProtoTCP_v3  (PID0_v3)
+#define RxProtoIP_v3   (PID1_v3 | PID0_v3)
+#define RxProtoMask_v3 RxProtoIP_v3
+
+        RxIPF_v3       = (1 << 26), /* IP checksum failed */
+        RxUDPF_v3      = (1 << 25), /* UDP/IP checksum failed */
+        RxTCPF_v3      = (1 << 24), /* TCP/IP checksum failed */
+        RxSCTPF_v3     = (1 << 23), /* SCTP  checksum failed */
+        RxVlanTag_v3   = (RxVlanTag), /* VLAN tag available */
+
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxUDPT_v3      = (1 << 29),
+        RxTCPT_v3      = (1 << 28),
+        RxSCTP_v3      = (1 << 27),
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxV6F_v3       = (RxV6F),
+        RxV4F_v3       = (RxV4F),
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+        RxIPF_v4       = (1 << 17), /* IP checksum failed */
+        RxUDPF_v4      = (1 << 16), /* UDP/IP checksum failed */
+        RxTCPF_v4      = (1 << 15), /* TCP/IP checksum failed */
+        RxSCTPF_v4     = (1 << 19), /* SCTP checksum failed */
+        RxVlanTag_v4   = (RxVlanTag), /* VLAN tag available */
+
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxUDPT_v4      = (1 << 19),
+        RxTCPT_v4      = (1 << 18),
+        RxSCTP_v4      = (1 << 19),
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxV6F_v4       = (RxV6F),
+        RxV4F_v4       = (RxV4F),
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+};
+
+enum features {
+//  RTL_FEATURE_WOL = (1 << 0),
+        RTL_FEATURE_MSI = (1 << 1),
+        RTL_FEATURE_MSIX = (1 << 2),
+};
+
+enum wol_capability {
+        WOL_DISABLED = 0,
+        WOL_ENABLED = 1
+};
+
+enum bits {
+        BIT_0 = (1 << 0),
+        BIT_1 = (1 << 1),
+        BIT_2 = (1 << 2),
+        BIT_3 = (1 << 3),
+        BIT_4 = (1 << 4),
+        BIT_5 = (1 << 5),
+        BIT_6 = (1 << 6),
+        BIT_7 = (1 << 7),
+        BIT_8 = (1 << 8),
+        BIT_9 = (1 << 9),
+        BIT_10 = (1 << 10),
+        BIT_11 = (1 << 11),
+        BIT_12 = (1 << 12),
+        BIT_13 = (1 << 13),
+        BIT_14 = (1 << 14),
+        BIT_15 = (1 << 15),
+        BIT_16 = (1 << 16),
+        BIT_17 = (1 << 17),
+        BIT_18 = (1 << 18),
+        BIT_19 = (1 << 19),
+        BIT_20 = (1 << 20),
+        BIT_21 = (1 << 21),
+        BIT_22 = (1 << 22),
+        BIT_23 = (1 << 23),
+        BIT_24 = (1 << 24),
+        BIT_25 = (1 << 25),
+        BIT_26 = (1 << 26),
+        BIT_27 = (1 << 27),
+        BIT_28 = (1 << 28),
+        BIT_29 = (1 << 29),
+        BIT_30 = (1 << 30),
+        BIT_31 = (1 << 31)
+};
+
+#define RTL8126_CP_NUM 4
+#define RTL8126_MAX_SUPPORT_CP_LEN 110
+
+enum rtl8126_cp_status {
+        rtl8126_cp_normal = 0,
+        rtl8126_cp_short,
+        rtl8126_cp_open,
+        rtl8126_cp_mismatch,
+        rtl8126_cp_unknown
+};
+
+enum efuse {
+        EFUSE_NOT_SUPPORT = 0,
+        EFUSE_SUPPORT_V1,
+        EFUSE_SUPPORT_V2,
+        EFUSE_SUPPORT_V3,
+        EFUSE_SUPPORT_V4,
+};
+#define RsvdMask    0x3fffc000
+#define RsvdMaskV3  0x3fff8000
+#define RsvdMaskV4  RsvdMaskV3
+
+struct TxDesc {
+        u32 opts1;
+        u32 opts2;
+        u64 addr;
+        u32 reserved0;
+        u32 reserved1;
+        u32 reserved2;
+        u32 reserved3;
+};
+
+struct RxDesc {
+        u32 opts1;
+        u32 opts2;
+        u64 addr;
+};
+
+struct RxDescV3 {
+        union {
+                struct {
+                        u32 rsv1;
+                        u32 rsv2;
+                } RxDescDDWord1;
+        };
+
+        union {
+                struct {
+                        u32 RSSResult;
+                        u16 HeaderBufferLen;
+                        u16 HeaderInfo;
+                } RxDescNormalDDWord2;
+
+                struct {
+                        u32 rsv5;
+                        u32 rsv6;
+                } RxDescDDWord2;
+        };
+
+        union {
+                u64   addr;
+
+                struct {
+                        u32 TimeStampLow;
+                        u32 TimeStampHigh;
+                } RxDescTimeStamp;
+
+                struct {
+                        u32 rsv8;
+                        u32 rsv9;
+                } RxDescDDWord3;
+        };
+
+        union {
+                struct {
+                        u32 opts2;
+                        u32 opts1;
+                } RxDescNormalDDWord4;
+
+                struct {
+                        u16 TimeStampHHigh;
+                        u16 rsv11;
+                        u32 opts1;
+                } RxDescPTPDDWord4;
+        };
+};
+
+struct RxDescV4 {
+        union {
+                u64   addr;
+
+                struct {
+                        u32 RSSInfo;
+                        u32 RSSResult;
+                } RxDescNormalDDWord1;
+        };
+
+        struct {
+                u32 opts2;
+                u32 opts1;
+        } RxDescNormalDDWord2;
+};
+
+enum rxdesc_type {
+        RXDESC_TYPE_NORMAL=0,
+        RXDESC_TYPE_NEXT,
+        RXDESC_TYPE_PTP,
+        RXDESC_TYPE_MAX
+};
+
+//Rx Desc Type
+enum rx_desc_ring_type {
+        RX_DESC_RING_TYPE_UNKNOWN=0,
+        RX_DESC_RING_TYPE_1,
+        RX_DESC_RING_TYPE_2,
+        RX_DESC_RING_TYPE_3,
+        RX_DESC_RING_TYPE_4,
+        RX_DESC_RING_TYPE_MAX
+};
+
+enum rx_desc_len {
+        RX_DESC_LEN_TYPE_1 = (sizeof(struct RxDesc)),
+        RX_DESC_LEN_TYPE_3 = (sizeof(struct RxDescV3)),
+        RX_DESC_LEN_TYPE_4 = (sizeof(struct RxDescV4))
+};
+
+struct ring_info {
+        struct sk_buff  *skb;
+        u32     len;
+        unsigned int   bytecount;
+        unsigned short gso_segs;
+        u8      __pad[sizeof(void *) - sizeof(u32)];
+};
+
+struct pci_resource {
+        u8  cmd;
+        u8  cls;
+        u16 io_base_h;
+        u16 io_base_l;
+        u16 mem_base_h;
+        u16 mem_base_l;
+        u8  ilr;
+        u16 resv_0x1c_h;
+        u16 resv_0x1c_l;
+        u16 resv_0x20_h;
+        u16 resv_0x20_l;
+        u16 resv_0x24_h;
+        u16 resv_0x24_l;
+        u16 resv_0x2c_h;
+        u16 resv_0x2c_l;
+        u32 pci_sn_l;
+        u32 pci_sn_h;
+};
+
+enum r8126_flag {
+        R8126_FLAG_DOWN = 0,
+        R8126_FLAG_TASK_RESET_PENDING,
+        R8126_FLAG_TASK_ESD_CHECK_PENDING,
+        R8126_FLAG_TASK_LINKCHG_CHECK_PENDING,
+        R8126_FLAG_TASK_LINK_CHECK_PENDING,
+        R8126_FLAG_MAX
+};
+
+enum r8126_sysfs_flag {
+        R8126_SYSFS_RTL_ADV = 0,
+        R8126_SYSFS_FLAG_MAX
+};
+
+struct rtl8126_tx_ring {
+        void* priv;
+        struct net_device *netdev;
+        u32 index;
+        u32 cur_tx; /* Index into the Tx descriptor buffer of next Rx pkt. */
+        u32 dirty_tx;
+        u32 num_tx_desc; /* Number of Tx descriptor registers */
+        struct TxDesc *TxDescArray; /* 256-aligned Tx descriptor ring */
+        dma_addr_t TxPhyAddr;
+        u32 TxDescAllocSize;
+        struct ring_info tx_skb[MAX_NUM_TX_DESC]; /* Tx data buffers */
+
+        u32 NextHwDesCloPtr;
+        u32 BeginHwDesCloPtr;
+
+        u16 hw_clo_ptr_reg;
+        u16 sw_tail_ptr_reg;
+
+        u16 tdsar_reg; /* Transmit Descriptor Start Address */
+};
+
+struct rtl8126_rx_buffer {
+        struct page *page;
+        u32 page_offset;
+        dma_addr_t dma;
+        void* data;
+        struct sk_buff *skb;
+};
+
+struct rtl8126_rx_ring {
+        void* priv;
+        struct net_device *netdev;
+        u32 index;
+        u32 cur_rx; /* Index into the Rx descriptor buffer of next Rx pkt. */
+        u32 dirty_rx;
+        u32 num_rx_desc; /* Number of Rx descriptor registers */
+        struct RxDesc *RxDescArray; /* 256-aligned Rx descriptor ring */
+        u32 RxDescAllocSize;
+        u64 RxDescPhyAddr[MAX_NUM_RX_DESC]; /* Rx desc physical address*/
+        dma_addr_t RxPhyAddr;
+#ifdef ENABLE_PAGE_REUSE
+        struct rtl8126_rx_buffer rx_buffer[MAX_NUM_RX_DESC];
+        u16 rx_offset;
+#else
+        struct sk_buff *Rx_skbuff[MAX_NUM_RX_DESC]; /* Rx data buffers */
+#endif //ENABLE_PAGE_REUSE
+
+        u16 rdsar_reg; /* Receive Descriptor Start Address */
+};
+
+struct r8126_napi {
+#ifdef CONFIG_R8126_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+        struct napi_struct napi;
+#endif
+#endif
+        void* priv;
+        int index;
+};
+
+struct r8126_irq {
+        irq_handler_t	handler;
+        unsigned int	vector;
+        u8		requested;
+        char		name[IFNAMSIZ + 10];
+};
+
+#pragma pack(1)
+struct rtl8126_regs {
+        //00
+        u8 mac_id[6];
+        u16 reg_06;
+        u8 mar[8];
+        //10
+        u64 dtccr;
+        u16 ledsel0;
+        u16 legreg;
+        u32 tctr3;
+        //20
+        u32 txq0_dsc_st_addr_0;
+        u32 txq0_dsc_st_addr_2;
+        u64 reg_28;
+        //30
+        u16 rit;
+        u16 ritc;
+        u16 reg_34;
+        u8 reg_36;
+        u8 command;
+        u32 imr0;
+        u32 isr0;
+        //40
+        u32 tcr;
+        u32 rcr;
+        u32 tctr0;
+        u32 tctr1;
+        //50
+        u8 cr93c46;
+        u8 config0;
+        u8 config1;
+        u8 config2;
+        u8 config3;
+        u8 config4;
+        u8 config5;
+        u8 tdfnr;
+        u32 timer_int0;
+        u32 timer_int1;
+        //60
+        u32 gphy_mdcmdio;
+        u32 csidr;
+        u32 csiar;
+        u16 phy_status;
+        u8 config6;
+        u8 pmch;
+        //70
+        u32 eridr;
+        u32 eriar;
+        u16 config7;
+        u16 reg_7a;
+        u32 ephy_rxerr_cnt;
+        //80
+        u32 ephy_mdcmdio;
+        u16 ledsel2;
+        u16 ledsel1;
+        u32 tctr2;
+        u32 timer_int2;
+        //90
+        u8 tppoll0;
+        u8 reg_91;
+        u16 reg_92;
+        u16 led_feature;
+        u16 ledsel3;
+        u16 eee_led_config;
+        u16 reg_9a;
+        u32 reg_9c;
+        //a0
+        u32 reg_a0;
+        u32 reg_a4;
+        u32 reg_a8;
+        u32 reg_ac;
+        //b0
+        u32 patch_dbg;
+        u32 reg_b4;
+        u32 gphy_ocp;
+        u32 reg_bc;
+        //c0
+        u32 reg_c0;
+        u32 reg_c4;
+        u32 reg_c8;
+        u16 otp_cmd;
+        u16 otp_pg_config;
+        //d0
+        u16 phy_pwr;
+        u8 twsi_ctrl;
+        u8 oob_ctrl;
+        u16 mac_dbgo;
+        u16 mac_dbg;
+        u16 reg_d8;
+        u16 rms;
+        u32 efuse_data;
+        //e0
+        u16 cplus_cmd;
+        u16 reg_e2;
+        u32 rxq0_dsc_st_addr_0;
+        u32 rxq0_dsc_st_addr_2;
+        u16 reg_ec;
+        u16 tx10midle_cnt;
+        //f0
+        u16 misc0;
+        u16 misc1;
+        u32 timer_int3;
+        u32 cmac_ib;
+        u16 reg_fc;
+        u16 sw_rst;
+};
+#pragma pack()
+
+struct rtl8126_regs_save {
+        union {
+                u8 mac_io[R8126_MAC_REGS_SIZE];
+
+                struct rtl8126_regs mac_reg;
+        };
+        u16 pcie_phy[R8126_EPHY_REGS_SIZE/2];
+        u16 eth_phy[R8126_PHY_REGS_SIZE/2];
+        u32 eri_reg[R8126_ERI_REGS_SIZE/4];
+        u32 pci_reg[R8126_PCI_REGS_SIZE/4];
+        u16 sw_tail_ptr_reg[R8126_MAX_TX_QUEUES];
+        u16 hw_clo_ptr_reg[R8126_MAX_TX_QUEUES];
+
+        //ktime_t begin_ktime;
+        //ktime_t end_ktime;
+        //u64 duration_ns;
+
+        u16 sw0_tail_ptr;
+        u16 next_hwq0_clo_ptr;
+        u16 sw1_tail_ptr;
+        u16 next_hwq1_clo_ptr;
+
+        u16 int_miti_rxq0;
+        u16 int_miti_txq0;
+        u16 int_miti_rxq1;
+        u16 int_miti_txq1;
+        u8 int_config;
+        u32 imr_new;
+        u32 isr_new;
+
+        u8 tdu_status;
+        u16 rdu_status;
+
+        u16 tc_mode;
+
+        u32 txq1_dsc_st_addr_0;
+        u32 txq1_dsc_st_addr_2;
+
+        u32 pla_tx_q0_idle_credit;
+        u32 pla_tx_q1_idle_credit;
+
+        u32 rxq1_dsc_st_addr_0;
+        u32 rxq1_dsc_st_addr_2;
+
+        u32 rss_ctrl;
+        u8 rss_key[RTL8126_RSS_KEY_SIZE];
+        u8 rss_i_table[RTL8126_MAX_INDIRECTION_TABLE_ENTRIES];
+        u16 rss_queue_num_sel_r;
+};
+
+struct rtl8126_counters {
+        /* legacy */
+        u64 tx_packets;
+        u64 rx_packets;
+        u64 tx_errors;
+        u32 rx_errors;
+        u16 rx_missed;
+        u16 align_errors;
+        u32 tx_one_collision;
+        u32 tx_multi_collision;
+        u64 rx_unicast;
+        u64 rx_broadcast;
+        u32 rx_multicast;
+        u16 tx_aborted;
+        u16 tx_underrun;
+
+        /* extended */
+        u64 tx_octets;
+        u64 rx_octets;
+        u64 rx_multicast64;
+        u64 tx_unicast64;
+        u64 tx_broadcast64;
+        u64 tx_multicast64;
+        u32 tx_pause_on;
+        u32 tx_pause_off;
+        u32 tx_pause_all;
+        u32 tx_deferred;
+        u32 tx_late_collision;
+        u32 tx_all_collision;
+        u32 tx_aborted32;
+        u32 align_errors32;
+        u32 rx_frame_too_long;
+        u32 rx_runt;
+        u32 rx_pause_on;
+        u32 rx_pause_off;
+        u32 rx_pause_all;
+        u32 rx_unknown_opcode;
+        u32 rx_mac_error;
+        u32 tx_underrun32;
+        u32 rx_mac_missed;
+        u32 rx_tcam_dropped;
+        u32 tdu;
+        u32 rdu;
+};
+
+/* Flow Control Settings */
+enum rtl8126_fc_mode {
+        rtl8126_fc_none = 0,
+        rtl8126_fc_rx_pause,
+        rtl8126_fc_tx_pause,
+        rtl8126_fc_full,
+        rtl8126_fc_default
+};
+
+enum rtl8126_state_t {
+        __RTL8126_TESTING = 0,
+        __RTL8126_RESETTING,
+        __RTL8126_DOWN,
+        __RTL8126_PTP_TX_IN_PROGRESS,
+};
+
+#define RTL_FLAG_RX_HWTSTAMP_ENABLED BIT_0
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+struct ethtool_eee {
+        __u32	cmd;
+        __u32	supported;
+        __u32	advertised;
+        __u32	lp_advertised;
+        __u32	eee_active;
+        __u32	eee_enabled;
+        __u32	tx_lpi_enabled;
+        __u32	tx_lpi_timer;
+        __u32	reserved[2];
+};
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0) */
+
+struct rtl8126_private {
+        void __iomem *mmio_addr;    /* memory map physical address */
+        struct pci_dev *pci_dev;    /* Index of PCI device */
+        struct net_device *dev;
+        struct r8126_napi r8126napi[R8126_MAX_MSIX_VEC];
+        struct r8126_irq irq_tbl[R8126_MAX_MSIX_VEC];
+        unsigned int irq_nvecs;
+        unsigned int max_irq_nvecs;
+        unsigned int min_irq_nvecs;
+        unsigned int hw_supp_irq_nvecs;
+        //struct msix_entry msix_entries[R8126_MAX_MSIX_VEC];
+        struct net_device_stats stats;  /* statistics of net device */
+        unsigned long state;
+        u32 flags;
+
+        u32 msg_enable;
+        u32 tx_tcp_csum_cmd;
+        u32 tx_udp_csum_cmd;
+        u32 tx_ip_csum_cmd;
+        u32 tx_ipv6_csum_cmd;
+        int max_jumbo_frame_size;
+        int chipset;
+        u32 mcfg;
+        //u32 cur_rx; /* Index into the Rx descriptor buffer of next Rx pkt. */
+        //u32 cur_tx; /* Index into the Tx descriptor buffer of next Rx pkt. */
+        //u32 dirty_rx;
+        //u32 dirty_tx;
+        //struct TxDesc *TxDescArray; /* 256-aligned Tx descriptor ring */
+        //struct RxDesc *RxDescArray; /* 256-aligned Rx descriptor ring */
+        //dma_addr_t TxPhyAddr;
+        //dma_addr_t RxPhyAddr;
+        //struct sk_buff *Rx_skbuff[MAX_NUM_RX_DESC]; /* Rx data buffers */
+        //struct ring_info tx_skb[MAX_NUM_TX_DESC];   /* Tx data buffers */
+        unsigned rx_buf_sz;
+#ifdef ENABLE_PAGE_REUSE
+        unsigned rx_buf_page_order;
+        unsigned rx_buf_page_size;
+        u32 page_reuse_fail_cnt;
+#endif //ENABLE_PAGE_REUSE
+        u16 HwSuppNumTxQueues;
+        u16 HwSuppNumRxQueues;
+        unsigned int num_tx_rings;
+        unsigned int num_rx_rings;
+        struct rtl8126_tx_ring tx_ring[R8126_MAX_TX_QUEUES];
+        struct rtl8126_rx_ring rx_ring[R8126_MAX_RX_QUEUES];
+#ifdef ENABLE_LIB_SUPPORT
+        struct blocking_notifier_head lib_nh;
+        struct rtl8126_ring lib_tx_ring[R8126_MAX_TX_QUEUES];
+        struct rtl8126_ring lib_rx_ring[R8126_MAX_RX_QUEUES];
+#endif
+        //struct timer_list esd_timer;
+        //struct timer_list link_timer;
+        struct pci_resource pci_cfg_space;
+        unsigned int esd_flag;
+        unsigned int pci_cfg_is_read;
+        unsigned int rtl8126_rx_config;
+        u16 rms;
+        u16 cp_cmd;
+        u32 intr_mask;
+        u32 timer_intr_mask;
+        u16 isr_reg[R8126_MAX_MSIX_VEC];
+        u16 imr_reg[R8126_MAX_MSIX_VEC];
+        int phy_auto_nego_reg;
+        int phy_1000_ctrl_reg;
+        int phy_2500_ctrl_reg;
+        u8 org_mac_addr[NODE_ADDRESS_SIZE];
+        struct rtl8126_counters *tally_vaddr;
+        dma_addr_t tally_paddr;
+
+#ifdef CONFIG_R8126_VLAN
+        struct vlan_group *vlgrp;
+#endif
+        u8  wol_enabled;
+        u32 wol_opts;
+        u8  efuse_ver;
+        u8  eeprom_type;
+        u8  autoneg;
+        u8  duplex;
+        u32 speed;
+        u64 advertising;
+        enum rtl8126_fc_mode fcpause;
+        u32 HwSuppMaxPhyLinkSpeed;
+        u16 eeprom_len;
+        u16 cur_page;
+        u32 bios_setting;
+
+        int (*set_speed)(struct net_device *, u8 autoneg, u32 speed, u8 duplex, u64 adv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+        void (*get_settings)(struct net_device *, struct ethtool_cmd *);
+#else
+        void (*get_settings)(struct net_device *, struct ethtool_link_ksettings *);
+#endif
+        void (*phy_reset_enable)(struct net_device *);
+        unsigned int (*phy_reset_pending)(struct net_device *);
+        unsigned int (*link_ok)(struct net_device *);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+        struct work_struct reset_task;
+        struct work_struct esd_task;
+        struct work_struct linkchg_task;
+        struct work_struct link_task;
+#else
+        struct delayed_work reset_task;
+        struct delayed_work esd_task;
+        struct delayed_work linkchg_task;
+        struct delayed_work link_task;
+#endif
+        DECLARE_BITMAP(task_flags, R8126_FLAG_MAX);
+        unsigned features;
+
+        u8 org_pci_offset_99;
+        u8 org_pci_offset_180;
+        u8 issue_offset_99_event;
+
+        u8 org_pci_offset_80;
+        u8 org_pci_offset_81;
+        u8 use_timer_interrupt;
+
+        u32 keep_intr_cnt;
+
+        u8  HwIcVerUnknown;
+        u8  NotWrRamCodeToMicroP;
+        u8  NotWrMcuPatchCode;
+        u8  HwHasWrRamCodeToMicroP;
+
+        u16 sw_ram_code_ver;
+        u16 hw_ram_code_ver;
+
+        u8 rtk_enable_diag;
+
+        u8 ShortPacketSwChecksum;
+
+        u8 UseSwPaddingShortPkt;
+
+        u8 RequireAdcBiasPatch;
+        u16 AdcBiasPatchIoffset;
+
+        u8 RequireAdjustUpsTxLinkPulseTiming;
+        u16 SwrCnt1msIni;
+
+        u8 HwSuppNowIsOobVer;
+
+        u8 RequiredSecLanDonglePatch;
+
+        u8 RequirePhyMdiSwapPatch;
+
+        u32 HwFiberModeVer;
+        u32 HwFiberStat;
+
+        u16 NicCustLedValue;
+
+        u8 HwSuppMagicPktVer;
+
+        u8 HwSuppLinkChgWakeUpVer;
+
+        u8 HwSuppCheckPhyDisableModeVer;
+
+        u8 random_mac;
+
+        u16 phy_reg_aner;
+        u16 phy_reg_anlpar;
+        u16 phy_reg_gbsr;
+        u16 phy_reg_status_2500;
+
+        u32 HwPcieSNOffset;
+
+        u32 MaxTxDescPtrMask;
+        u8 HwSuppTxNoCloseVer;
+        u8 EnableTxNoClose;
+
+        u8 HwSuppIsrVer;
+        u8 HwCurrIsrVer;
+
+        u8 HwSuppIntMitiVer;
+
+        u8 HwSuppExtendTallyCounterVer;
+
+        u8 check_keep_link_speed;
+        u8 resume_not_chg_speed;
+
+        u8 HwSuppD0SpeedUpVer;
+        u8 D0SpeedUpSpeed;
+
+        u8 ring_lib_enabled;
+
+        const char *fw_name;
+        struct rtl8126_fw *rtl_fw;
+        u32 ocp_base;
+
+        u8 HwPkgDet;
+
+        //Realwow++++++++++++++
+        u8 HwSuppKCPOffloadVer;
+
+        u8 EnableDhcpTimeoutWake;
+        u8 EnableTeredoOffload;
+        u8 EnableKCPOffload;
+#ifdef ENABLE_REALWOW_SUPPORT
+        u32 DhcpTimeout;
+        MP_KCP_INFO MpKCPInfo;
+        //Realwow--------------
+#endif //ENABLE_REALWOW_SUPPORT
+
+        struct ethtool_keee eee;
+
+#ifdef ENABLE_R8126_PROCFS
+        //Procfs support
+        struct proc_dir_entry *proc_dir;
+        struct proc_dir_entry *proc_dir_debug;
+        struct proc_dir_entry *proc_dir_test;
+#endif
+#ifdef ENABLE_R8126_SYSFS
+        //sysfs support
+        DECLARE_BITMAP(sysfs_flag, R8126_SYSFS_FLAG_MAX);
+        u32 testmode;
+#endif
+        u8 HwSuppRxDescType;
+        u8 InitRxDescType;
+        u16 RxDescLength; //V1 16 Byte V2 32 Bytes
+
+        spinlock_t phy_lock;
+
+        u8 HwSuppPtpVer;
+        u8 EnablePtp;
+#ifdef ENABLE_PTP_SUPPORT
+        u32 tx_hwtstamp_timeouts;
+        u32 tx_hwtstamp_skipped;
+        struct work_struct ptp_tx_work;
+        struct sk_buff *ptp_tx_skb;
+        struct hwtstamp_config hwtstamp_config;
+        unsigned long ptp_tx_start;
+        struct ptp_clock_info ptp_clock_info;
+        struct ptp_clock *ptp_clock;
+        u8 syncE_en;
+        u8 pps_enable;
+        struct hrtimer pps_timer;
+#endif
+
+        u8 HwSuppRssVer;
+        u8 EnableRss;
+        u16 HwSuppIndirTblEntries;
+#ifdef ENABLE_RSS_SUPPORT
+        u32 rss_flags;
+        /* Receive Side Scaling settings */
+        u8 rss_key[RTL8126_RSS_KEY_SIZE];
+        u8 rss_indir_tbl[RTL8126_MAX_INDIRECTION_TABLE_ENTRIES];
+        u32 rss_options;
+#endif
+
+        u8 HwSuppMacMcuVer;
+        u16 MacMcuPageSize;
+        u64 hw_mcu_patch_code_ver;
+        u64 bin_mcu_patch_code_ver;
+
+        u8 HwSuppTcamVer;
+
+        u16 TcamNotValidReg;
+        u16 TcamValidReg;
+        u16 TcamMaAddrcOffset;
+        u16 TcamVlanTagOffset;
+};
+
+#ifdef ENABLE_LIB_SUPPORT
+static inline unsigned int
+rtl8126_num_lib_tx_rings(struct rtl8126_private *tp)
+{
+        int count, i;
+
+        for (count = 0, i = tp->num_tx_rings; i < tp->HwSuppNumTxQueues; i++)
+                if(tp->lib_tx_ring[i].enabled)
+                        count++;
+
+        return count;
+}
+
+static inline unsigned int
+rtl8126_num_lib_rx_rings(struct rtl8126_private *tp)
+{
+        int count, i;
+
+        for (count = 0, i = tp->num_rx_rings; i < tp->HwSuppNumRxQueues; i++)
+                if(tp->lib_rx_ring[i].enabled)
+                        count++;
+
+        return count;
+}
+
+#else
+static inline unsigned int
+rtl8126_num_lib_tx_rings(struct rtl8126_private *tp)
+{
+        return 0;
+}
+
+static inline unsigned int
+rtl8126_num_lib_rx_rings(struct rtl8126_private *tp)
+{
+        return 0;
+}
+#endif
+
+static inline unsigned int
+rtl8126_tot_tx_rings(struct rtl8126_private *tp)
+{
+        return tp->num_tx_rings + rtl8126_num_lib_tx_rings(tp);
+}
+
+static inline unsigned int
+rtl8126_tot_rx_rings(struct rtl8126_private *tp)
+{
+        return tp->num_rx_rings + rtl8126_num_lib_rx_rings(tp);
+}
+
+static inline struct netdev_queue *txring_txq(const struct rtl8126_tx_ring *ring)
+{
+        return netdev_get_tx_queue(ring->netdev, ring->index);
+}
+
+enum eetype {
+        EEPROM_TYPE_NONE=0,
+        EEPROM_TYPE_93C46,
+        EEPROM_TYPE_93C56,
+        EEPROM_TWSI
+};
+
+enum mcfg {
+        CFG_METHOD_1=1,
+        CFG_METHOD_2,
+        CFG_METHOD_3,
+        CFG_METHOD_DEFAULT,
+        CFG_METHOD_MAX
+};
+
+#define LSO_32K 32000
+#define LSO_64K 64000
+
+#define NIC_MIN_PHYS_BUF_COUNT          (2)
+#define NIC_MAX_PHYS_BUF_COUNT_LSO_64K  (24)
+#define NIC_MAX_PHYS_BUF_COUNT_LSO2     (16*4)
+
+#define GTTCPHO_SHIFT                   18
+#define GTTCPHO_MAX                     0x70U
+#define GTPKTSIZE_MAX                   0x3ffffU
+#define TCPHO_SHIFT                     18
+#define TCPHO_MAX                       0x3ffU
+#define LSOPKTSIZE_MAX                  0xffffU
+#define MSS_MAX                         0x07ffu /* MSS value */
+
+#define OOB_CMD_RESET       0x00
+#define OOB_CMD_DRIVER_START    0x05
+#define OOB_CMD_DRIVER_STOP 0x06
+#define OOB_CMD_SET_IPMAC   0x41
+
+#define WAKEUP_MAGIC_PACKET_NOT_SUPPORT (0)
+#define WAKEUP_MAGIC_PACKET_V1 (1)
+#define WAKEUP_MAGIC_PACKET_V2 (2)
+#define WAKEUP_MAGIC_PACKET_V3 (3)
+
+//Ram Code Version
+#define NIC_RAMCODE_VERSION_CFG_METHOD_1 (0x0023)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_2 (0x0033)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_3 (0x0060)
+
+//hwoptimize
+#define HW_PATCH_SOC_LAN (BIT_0)
+#define HW_PATCH_SAMSUNG_LAN_DONGLE (BIT_2)
+
+static const u16 other_q_intr_mask = (RxOK1 | RxDU1);
+
+void rtl8126_mdio_write(struct rtl8126_private *tp, u16 RegAddr, u16 value);
+void rtl8126_mdio_prot_write(struct rtl8126_private *tp, u32 RegAddr, u32 value);
+void rtl8126_mdio_prot_direct_write_phy_ocp(struct rtl8126_private *tp, u32 RegAddr, u32 value);
+u32 rtl8126_mdio_read(struct rtl8126_private *tp, u16 RegAddr);
+u32 rtl8126_mdio_prot_read(struct rtl8126_private *tp, u32 RegAddr);
+u32 rtl8126_mdio_prot_direct_read_phy_ocp(struct rtl8126_private *tp, u32 RegAddr);
+void rtl8126_ephy_write(struct rtl8126_private *tp, int RegAddr, int value);
+void rtl8126_mac_ocp_write(struct rtl8126_private *tp, u16 reg_addr, u16 value);
+u16 rtl8126_mac_ocp_read(struct rtl8126_private *tp, u16 reg_addr);
+void rtl8126_clear_eth_phy_bit(struct rtl8126_private *tp, u8 addr, u16 mask);
+void rtl8126_set_eth_phy_bit(struct rtl8126_private *tp,  u8  addr, u16  mask);
+void rtl8126_init_ring_indexes(struct rtl8126_private *tp);
+u32 rtl8126_eri_read(struct rtl8126_private *tp, int addr, int len, int type);
+u32 rtl8126_eri_read_with_oob_base_address(struct rtl8126_private *tp, int addr, int len, int type, u32 base_address);
+int rtl8126_eri_write(struct rtl8126_private *tp, int addr, int len, u32 value, int type);
+int rtl8126_eri_write_with_oob_base_address(struct rtl8126_private *tp, int addr, int len, u32 value, int type, u32 base_address);
+u16 rtl8126_ephy_read(struct rtl8126_private *tp, int RegAddr);
+void rtl8126_wait_txrx_fifo_empty(struct net_device *dev);
+void rtl8126_enable_now_is_oob(struct rtl8126_private *tp);
+void rtl8126_disable_now_is_oob(struct rtl8126_private *tp);
+void rtl8126_hw_disable_mac_mcu_bps(struct net_device *dev);
+void rtl8126_mark_to_asic(struct rtl8126_private *tp, struct RxDesc *desc, u32 rx_buf_sz);
+void rtl8126_mark_as_last_descriptor(struct rtl8126_private *tp, struct RxDesc *desc);
+
+static inline void
+rtl8126_make_unusable_by_asic(struct rtl8126_private *tp,
+                              struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                ((struct RxDescV3 *)desc)->addr = RTL8126_MAGIC_NUMBER;
+                ((struct RxDescV3 *)desc)->RxDescNormalDDWord4.opts1 &= ~cpu_to_le32(DescOwn | RsvdMaskV3);
+                break;
+        case RX_DESC_RING_TYPE_4:
+                ((struct RxDescV4 *)desc)->addr = RTL8126_MAGIC_NUMBER;
+                ((struct RxDescV4 *)desc)->RxDescNormalDDWord2.opts1 &= ~cpu_to_le32(DescOwn | RsvdMaskV4);
+                break;
+        default:
+                desc->addr = RTL8126_MAGIC_NUMBER;
+                desc->opts1 &= ~cpu_to_le32(DescOwn | RsvdMask);
+                break;
+        }
+}
+
+static inline struct RxDesc*
+rtl8126_get_rxdesc(struct rtl8126_private *tp, struct RxDesc *RxDescBase, u32 const cur_rx)
+{
+        return (struct RxDesc*)((u8*)RxDescBase + (cur_rx * tp->RxDescLength));
+}
+
+static inline void
+rtl8126_disable_hw_interrupt_v2(struct rtl8126_private *tp,
+                                u32 message_id)
+{
+        RTL_W32(tp, IMR_V2_CLEAR_REG_8125, BIT(message_id));
+}
+
+static inline void
+rtl8126_enable_hw_interrupt_v2(struct rtl8126_private *tp, u32 message_id)
+{
+        RTL_W32(tp, IMR_V2_SET_REG_8125, BIT(message_id));
+}
+
+int rtl8126_open(struct net_device *dev);
+int rtl8126_close(struct net_device *dev);
+void rtl8126_hw_config(struct net_device *dev);
+void rtl8126_hw_set_timer_int(struct rtl8126_private *tp, u32 message_id, u8 timer_intmiti_val);
+void rtl8126_set_rx_q_num(struct rtl8126_private *tp, unsigned int num_rx_queues);
+void rtl8126_set_tx_q_num(struct rtl8126_private *tp, unsigned int num_tx_queues);
+void rtl8126_enable_mcu(struct rtl8126_private *tp, bool enable);
+void rtl8126_hw_start(struct net_device *dev);
+void rtl8126_hw_reset(struct net_device *dev);
+void rtl8126_tx_clear(struct rtl8126_private *tp);
+void rtl8126_rx_clear(struct rtl8126_private *tp);
+int rtl8126_init_ring(struct net_device *dev);
+void rtl8126_hw_set_rx_packet_filter(struct net_device *dev);
+void rtl8126_enable_hw_linkchg_interrupt(struct rtl8126_private *tp);
+int rtl8126_dump_tally_counter(struct rtl8126_private *tp, dma_addr_t paddr);
+void rtl8126_enable_napi(struct rtl8126_private *tp);
+void _rtl8126_wait_for_quiescence(struct net_device *dev);
+
+void rtl8126_mdio_direct_write_phy_ocp(struct rtl8126_private *tp, u16 RegAddr,u16 value);
+u32 rtl8126_mdio_direct_read_phy_ocp(struct rtl8126_private *tp, u16 RegAddr);
+void rtl8126_clear_and_set_eth_phy_ocp_bit(struct rtl8126_private *tp, u16 addr, u16 clearmask, u16 setmask);
+void rtl8126_clear_eth_phy_ocp_bit(struct rtl8126_private *tp, u16 addr, u16 mask);
+void rtl8126_set_eth_phy_ocp_bit(struct rtl8126_private *tp, u16 addr, u16 mask);
+
+void rtl8126_clear_mac_ocp_bit(struct rtl8126_private *tp, u16 addr, u16 mask);
+void rtl8126_set_mac_ocp_bit(struct rtl8126_private *tp, u16 addr, u16 mask);
+
+#ifndef ENABLE_LIB_SUPPORT
+static inline void rtl8126_lib_reset_prepare(struct rtl8126_private *tp) { }
+static inline void rtl8126_lib_reset_complete(struct rtl8126_private *tp) { }
+#endif
+
+#define HW_SUPPORT_CHECK_PHY_DISABLE_MODE(_M)        ((_M)->HwSuppCheckPhyDisableModeVer > 0)
+#define HW_HAS_WRITE_PHY_MCU_RAM_CODE(_M)        (((_M)->HwHasWrRamCodeToMicroP == TRUE) ? 1 : 0)
+#define HW_SUPPORT_D0_SPEED_UP(_M)        ((_M)->HwSuppD0SpeedUpVer > 0)
+#define HW_SUPPORT_MAC_MCU(_M)        ((_M)->HwSuppMacMcuVer > 0)
+#define HW_SUPPORT_TCAM(_M)        ((_M)->HwSuppTcamVer > 0)
+
+#define HW_SUPP_PHY_LINK_SPEED_GIGA(_M)        ((_M)->HwSuppMaxPhyLinkSpeed >= 1000)
+#define HW_SUPP_PHY_LINK_SPEED_2500M(_M)        ((_M)->HwSuppMaxPhyLinkSpeed >= 2500)
+#define HW_SUPP_PHY_LINK_SPEED_5000M(_M)        ((_M)->HwSuppMaxPhyLinkSpeed >= 5000)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)
+#define netdev_mc_count(dev) ((dev)->mc_count)
+#define netdev_mc_empty(dev) (netdev_mc_count(dev) == 0)
+#define netdev_for_each_mc_addr(mclist, dev) \
+    for (mclist = dev->mc_list; mclist; mclist = mclist->next)
+#endif
+
+#endif /* __R8126_H */
Index: drivers/net/ethernet/Kconfig
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
--- a/drivers/net/ethernet/Kconfig	(revision 7475d784169c7df48b0c55525fb862e06674d63c)
+++ b/drivers/net/ethernet/Kconfig	(date 1763109333415)
@@ -202,4 +202,19 @@
 source "drivers/net/ethernet/xilinx/Kconfig"
 source "drivers/net/ethernet/xircom/Kconfig"
 
+config R8125
+	tristate "Realtek RTL8125 PCIe 2.5GbE Ethernet driver"
+	depends on PCI
+    	default m
+
+config R8126
+	tristate "Realtek RTL8126 PCIe 5GbE Ethernet driver"
+	depends on PCI
+    	default m
+
+config R8152
+	tristate "Realtek RTL8152/RTL8153 USB 2.0/3.0 Ethernet driver"
+	depends on USB
+    	default n
+
 endif # ETHERNET
Index: drivers/net/ethernet/r8126-10.016.00/r8126_n.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/r8126_n.c b/drivers/net/ethernet/r8126-10.016.00/r8126_n.c
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/r8126_n.c	(date 1763109333415)
@@ -0,0 +1,17257 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+/*
+ * This driver is modified from r8169.c in Linux kernel 2.6.18
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/mii.h>
+#include <linux/if_vlan.h>
+#include <linux/crc32.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#include <linux/ipv6.h>
+#include <net/ip6_checksum.h>
+#endif
+#include <linux/tcp.h>
+#include <linux/init.h>
+#include <linux/rtnetlink.h>
+#include <linux/completion.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)
+#include <linux/pci-aspm.h>
+#endif
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
+#include <linux/prefetch.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define dev_printk(A,B,fmt,args...) printk(A fmt,##args)
+#else
+#include <linux/dma-mapping.h>
+#include <linux/moduleparam.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+#include <linux/mdio.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,4,10)
+#include <net/gso.h>
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,4,10) */
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "r8126.h"
+#include "rtl_eeprom.h"
+#include "rtltool.h"
+#include "r8126_firmware.h"
+
+#ifdef ENABLE_R8126_PROCFS
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#endif
+
+#define FIRMWARE_8126A_2	"rtl_nic/rtl8126a-2.fw"
+#define FIRMWARE_8126A_3	"rtl_nic/rtl8126a-3.fw"
+
+static const struct {
+        const char *name;
+        const char *fw_name;
+} rtl_chip_fw_infos[] = {
+        /* PCI-E devices. */
+        [CFG_METHOD_1] = {"RTL8126A",		},
+        [CFG_METHOD_2] = {"RTL8126A",		FIRMWARE_8126A_2},
+        [CFG_METHOD_3] = {"RTL8126A",		FIRMWARE_8126A_3},
+        [CFG_METHOD_DEFAULT] = {"Unknown",                  },
+};
+
+#define _R(NAME,MAC,RCR,MASK,JumFrameSz) \
+    { .name = NAME, .mcfg = MAC, .RCR_Cfg = RCR, .RxConfigMask = MASK, .jumbo_frame_sz = JumFrameSz }
+
+static const struct {
+        const char *name;
+        u8 mcfg;
+        u32 RCR_Cfg;
+        u32 RxConfigMask;   /* Clears the bits supported by this chip */
+        u32 jumbo_frame_sz;
+} rtl_chip_info[] = {
+        _R("RTL8126A",
+        CFG_METHOD_1,
+        Rx_Fetch_Number_8 | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_512 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8126A",
+        CFG_METHOD_2,
+        Rx_Fetch_Number_8 | Rx_Close_Multiple | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_512 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8126A",
+        CFG_METHOD_3,
+        Rx_Fetch_Number_8 | Rx_Close_Multiple | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST_512 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("Unknown",
+        CFG_METHOD_DEFAULT,
+        (RX_DMA_BURST_512 << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_1k)
+};
+#undef _R
+
+
+#ifndef PCI_VENDOR_ID_DLINK
+#define PCI_VENDOR_ID_DLINK 0x1186
+#endif
+
+static struct pci_device_id rtl8126_pci_tbl[] = {
+        { PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8126), },
+        { PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x5000), },
+        {0,},
+};
+
+MODULE_DEVICE_TABLE(pci, rtl8126_pci_tbl);
+
+static int use_dac = 1;
+static int timer_count = 0x2600;
+static int timer_count_v2 = (0x2600 / 0x100);
+
+static struct {
+        u32 msg_enable;
+} debug = { -1 };
+
+static unsigned int speed_mode = SPEED_5000;
+static unsigned int duplex_mode = DUPLEX_FULL;
+static unsigned int autoneg_mode = AUTONEG_ENABLE;
+#ifdef CONFIG_ASPM
+static int aspm = 1;
+#else
+static int aspm = 0;
+#endif
+#ifdef ENABLE_S5WOL
+static int s5wol = 1;
+#else
+static int s5wol = 0;
+#endif
+#ifdef ENABLE_S5_KEEP_CURR_MAC
+static int s5_keep_curr_mac = 1;
+#else
+static int s5_keep_curr_mac = 0;
+#endif
+#ifdef ENABLE_EEE
+static int eee_enable = 1;
+#else
+static int eee_enable = 0;
+#endif
+#ifdef CONFIG_SOC_LAN
+static ulong hwoptimize = HW_PATCH_SOC_LAN;
+#else
+static ulong hwoptimize = 0;
+#endif
+#ifdef ENABLE_S0_MAGIC_PACKET
+static int s0_magic_packet = 1;
+#else
+static int s0_magic_packet = 0;
+#endif
+#ifdef ENABLE_TX_NO_CLOSE
+static int tx_no_close_enable = 1;
+#else
+static int tx_no_close_enable = 0;
+#endif
+#ifdef DISABLE_WOL_SUPPORT
+static int disable_wol_support = 1;
+#else
+static int disable_wol_support = 0;
+#endif
+#ifdef ENABLE_DOUBLE_VLAN
+static int enable_double_vlan = 1;
+#else
+static int enable_double_vlan = 0;
+#endif
+#ifdef ENABLE_GIGA_LITE
+static int eee_giga_lite = 1;
+#else
+static int eee_giga_lite = 0;
+#endif
+
+MODULE_AUTHOR("Realtek and the Linux r8126 crew <netdev@vger.kernel.org>");
+MODULE_DESCRIPTION("Realtek r8126 Ethernet controller driver");
+
+module_param(speed_mode, uint, 0);
+MODULE_PARM_DESC(speed_mode, "force phy operation. Deprecated by ethtool (8).");
+
+module_param(duplex_mode, uint, 0);
+MODULE_PARM_DESC(duplex_mode, "force phy operation. Deprecated by ethtool (8).");
+
+module_param(autoneg_mode, uint, 0);
+MODULE_PARM_DESC(autoneg_mode, "force phy operation. Deprecated by ethtool (8).");
+
+module_param(aspm, int, 0);
+MODULE_PARM_DESC(aspm, "Enable ASPM.");
+
+module_param(s5wol, int, 0);
+MODULE_PARM_DESC(s5wol, "Enable Shutdown Wake On Lan.");
+
+module_param(s5_keep_curr_mac, int, 0);
+MODULE_PARM_DESC(s5_keep_curr_mac, "Enable Shutdown Keep Current MAC Address.");
+
+module_param(use_dac, int, 0);
+MODULE_PARM_DESC(use_dac, "Enable PCI DAC. Unsafe on 32 bit PCI slot.");
+
+module_param(timer_count, int, 0);
+MODULE_PARM_DESC(timer_count, "Timer Interrupt Interval.");
+
+module_param(eee_enable, int, 0);
+MODULE_PARM_DESC(eee_enable, "Enable Energy Efficient Ethernet.");
+
+module_param(hwoptimize, ulong, 0);
+MODULE_PARM_DESC(hwoptimize, "Enable HW optimization function.");
+
+module_param(s0_magic_packet, int, 0);
+MODULE_PARM_DESC(s0_magic_packet, "Enable S0 Magic Packet.");
+
+module_param(tx_no_close_enable, int, 0);
+MODULE_PARM_DESC(tx_no_close_enable, "Enable TX No Close.");
+
+module_param(disable_wol_support, int, 0);
+MODULE_PARM_DESC(disable_wol_support, "Disable PM support.");
+
+module_param(enable_double_vlan, int, 0);
+MODULE_PARM_DESC(enable_double_vlan, "Enable Double VLAN.");
+
+module_param(eee_giga_lite, int, 0);
+MODULE_PARM_DESC(eee_giga_lite, "Enable Giga Lite.");
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+module_param_named(debug, debug.msg_enable, int, 0);
+MODULE_PARM_DESC(debug, "Debug verbosity level (0=none, ..., 16=all)");
+#endif//LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+
+MODULE_LICENSE("GPL");
+#ifdef ENABLE_USE_FIRMWARE_FILE
+MODULE_FIRMWARE(FIRMWARE_8126A_2);
+MODULE_FIRMWARE(FIRMWARE_8126A_3);
+#endif
+
+MODULE_VERSION(RTL8126_VERSION);
+
+/*
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+static void rtl8126_esd_timer(unsigned long __opaque);
+#else
+static void rtl8126_esd_timer(struct timer_list *t);
+#endif
+*/
+/*
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+static void rtl8126_link_timer(unsigned long __opaque);
+#else
+static void rtl8126_link_timer(struct timer_list *t);
+#endif
+*/
+
+static netdev_tx_t rtl8126_start_xmit(struct sk_buff *skb, struct net_device *dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t rtl8126_interrupt(int irq, void *dev_instance, struct pt_regs *regs);
+#else
+static irqreturn_t rtl8126_interrupt(int irq, void *dev_instance);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t rtl8126_interrupt_msix(int irq, void *dev_instance, struct pt_regs *regs);
+#else
+static irqreturn_t rtl8126_interrupt_msix(int irq, void *dev_instance);
+#endif
+static void rtl8126_set_rx_mode(struct net_device *dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+static void rtl8126_tx_timeout(struct net_device *dev, unsigned int txqueue);
+#else
+static void rtl8126_tx_timeout(struct net_device *dev);
+#endif
+static int rtl8126_rx_interrupt(struct net_device *, struct rtl8126_private *, struct rtl8126_rx_ring *, napi_budget);
+static int rtl8126_tx_interrupt(struct rtl8126_tx_ring *ring, int budget);
+static int rtl8126_tx_interrupt_with_vector(struct rtl8126_private *tp, const int message_id, int budget);
+static void rtl8126_wait_for_quiescence(struct net_device *dev);
+static int rtl8126_change_mtu(struct net_device *dev, int new_mtu);
+static void rtl8126_down(struct net_device *dev);
+
+static int rtl8126_set_mac_address(struct net_device *dev, void *p);
+static void rtl8126_rar_set(struct rtl8126_private *tp, const u8 *addr);
+static void rtl8126_desc_addr_fill(struct rtl8126_private *);
+static void rtl8126_tx_desc_init(struct rtl8126_private *tp);
+static void rtl8126_rx_desc_init(struct rtl8126_private *tp);
+
+static u16 rtl8126_get_hw_phy_mcu_code_ver(struct rtl8126_private *tp);
+static void rtl8126_phy_power_up(struct net_device *dev);
+static void rtl8126_phy_power_down(struct net_device *dev);
+static int rtl8126_set_speed(struct net_device *dev, u8 autoneg, u32 speed, u8 duplex, u64 adv);
+static bool rtl8126_set_phy_mcu_patch_request(struct rtl8126_private *tp);
+static bool rtl8126_clear_phy_mcu_patch_request(struct rtl8126_private *tp);
+
+#ifdef CONFIG_R8126_NAPI
+static int rtl8126_poll(napi_ptr napi, napi_budget budget);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8126_reset_task(void *_data);
+static void rtl8126_esd_task(void *_data);
+static void rtl8126_linkchg_task(void *_data);
+static void rtl8126_link_task(void *_data);
+#else
+static void rtl8126_reset_task(struct work_struct *work);
+static void rtl8126_esd_task(struct work_struct *work);
+static void rtl8126_linkchg_task(struct work_struct *work);
+static void rtl8126_link_task(struct work_struct *work);
+#endif
+static void rtl8126_schedule_reset_work(struct rtl8126_private *tp);
+static void rtl8126_schedule_esd_work(struct rtl8126_private *tp);
+static void rtl8126_schedule_linkchg_work(struct rtl8126_private *tp);
+static void rtl8126_schedule_link_work(struct rtl8126_private *tp);
+static void rtl8126_init_all_schedule_work(struct rtl8126_private *tp);
+static void rtl8126_cancel_all_schedule_work(struct rtl8126_private *tp);
+
+static inline struct device *tp_to_dev(struct rtl8126_private *tp)
+{
+        return &tp->pci_dev->dev;
+}
+
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0) && \
+     LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,00)))
+void ethtool_convert_legacy_u32_to_link_mode(unsigned long *dst,
+                u32 legacy_u32)
+{
+        bitmap_zero(dst, __ETHTOOL_LINK_MODE_MASK_NBITS);
+        dst[0] = legacy_u32;
+}
+
+bool ethtool_convert_link_mode_to_legacy_u32(u32 *legacy_u32,
+                const unsigned long *src)
+{
+        bool retval = true;
+
+        /* TODO: following test will soon always be true */
+        if (__ETHTOOL_LINK_MODE_MASK_NBITS > 32) {
+                __ETHTOOL_DECLARE_LINK_MODE_MASK(ext);
+
+                bitmap_zero(ext, __ETHTOOL_LINK_MODE_MASK_NBITS);
+                bitmap_fill(ext, 32);
+                bitmap_complement(ext, ext, __ETHTOOL_LINK_MODE_MASK_NBITS);
+                if (bitmap_intersects(ext, src,
+                                      __ETHTOOL_LINK_MODE_MASK_NBITS)) {
+                        /* src mask goes beyond bit 31 */
+                        retval = false;
+                }
+        }
+        *legacy_u32 = src[0];
+        return retval;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+
+#ifndef LPA_1000FULL
+#define LPA_1000FULL            0x0800
+#endif
+
+#ifndef LPA_1000HALF
+#define LPA_1000HALF            0x0400
+#endif
+
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+static inline void eth_hw_addr_random(struct net_device *dev)
+{
+        random_ether_addr(dev->dev_addr);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#undef ethtool_ops
+#define ethtool_ops _kc_ethtool_ops
+
+struct _kc_ethtool_ops {
+        int  (*get_settings)(struct net_device *, struct ethtool_cmd *);
+        int  (*set_settings)(struct net_device *, struct ethtool_cmd *);
+        void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
+        int  (*get_regs_len)(struct net_device *);
+        void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
+        void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
+        int  (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
+        u32  (*get_msglevel)(struct net_device *);
+        void (*set_msglevel)(struct net_device *, u32);
+        int  (*nway_reset)(struct net_device *);
+        u32  (*get_link)(struct net_device *);
+        int  (*get_eeprom_len)(struct net_device *);
+        int  (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
+        int  (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
+        int  (*get_coalesce)(struct net_device *, struct ethtool_coalesce *);
+        int  (*set_coalesce)(struct net_device *, struct ethtool_coalesce *);
+        void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *);
+        int  (*set_ringparam)(struct net_device *, struct ethtool_ringparam *);
+        void (*get_pauseparam)(struct net_device *,
+                               struct ethtool_pauseparam*);
+        int  (*set_pauseparam)(struct net_device *,
+                               struct ethtool_pauseparam*);
+        u32  (*get_rx_csum)(struct net_device *);
+        int  (*set_rx_csum)(struct net_device *, u32);
+        u32  (*get_tx_csum)(struct net_device *);
+        int  (*set_tx_csum)(struct net_device *, u32);
+        u32  (*get_sg)(struct net_device *);
+        int  (*set_sg)(struct net_device *, u32);
+        u32  (*get_tso)(struct net_device *);
+        int  (*set_tso)(struct net_device *, u32);
+        int  (*self_test_count)(struct net_device *);
+        void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
+        void (*get_strings)(struct net_device *, u32 stringset, u8 *);
+        int  (*phys_id)(struct net_device *, u32);
+        int  (*get_stats_count)(struct net_device *);
+        void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *,
+                                  u64 *);
+} *ethtool_ops = NULL;
+
+#undef SET_ETHTOOL_OPS
+#define SET_ETHTOOL_OPS(netdev, ops) (ethtool_ops = (ops))
+
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0)
+#ifndef SET_ETHTOOL_OPS
+#define SET_ETHTOOL_OPS(netdev,ops) \
+         ((netdev)->ethtool_ops = (ops))
+#endif //SET_ETHTOOL_OPS
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0)
+
+//#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5)
+#ifndef netif_msg_init
+#define netif_msg_init _kc_netif_msg_init
+/* copied from linux kernel 2.6.20 include/linux/netdevice.h */
+static inline u32 netif_msg_init(int debug_value, int default_msg_enable_bits)
+{
+        /* use default */
+        if (debug_value < 0 || debug_value >= (sizeof(u32) * 8))
+                return default_msg_enable_bits;
+        if (debug_value == 0)   /* no output */
+                return 0;
+        /* set low N bits */
+        return (1 << debug_value) - 1;
+}
+
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5)
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+static inline void eth_copy_and_sum (struct sk_buff *dest,
+                                     const unsigned char *src,
+                                     int len, int base)
+{
+        skb_copy_to_linear_data(dest, src, len);
+}
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7)
+/* copied from linux kernel 2.6.20 /include/linux/time.h */
+/* Parameters used to convert the timespec values: */
+#define MSEC_PER_SEC    1000L
+
+/* copied from linux kernel 2.6.20 /include/linux/jiffies.h */
+/*
+ * Change timeval to jiffies, trying to avoid the
+ * most obvious overflows..
+ *
+ * And some not so obvious.
+ *
+ * Note that we don't want to return MAX_LONG, because
+ * for various timeout reasons we often end up having
+ * to wait "jiffies+1" in order to guarantee that we wait
+ * at _least_ "jiffies" - so "jiffies+1" had better still
+ * be positive.
+ */
+#define MAX_JIFFY_OFFSET ((~0UL >> 1)-1)
+
+/*
+ * Convert jiffies to milliseconds and back.
+ *
+ * Avoid unnecessary multiplications/divisions in the
+ * two most common HZ cases:
+ */
+static inline unsigned int _kc_jiffies_to_msecs(const unsigned long j)
+{
+#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)
+        return (MSEC_PER_SEC / HZ) * j;
+#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)
+        return (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);
+#else
+        return (j * MSEC_PER_SEC) / HZ;
+#endif
+}
+
+static inline unsigned long _kc_msecs_to_jiffies(const unsigned int m)
+{
+        if (m > _kc_jiffies_to_msecs(MAX_JIFFY_OFFSET))
+                return MAX_JIFFY_OFFSET;
+#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)
+        return (m + (MSEC_PER_SEC / HZ) - 1) / (MSEC_PER_SEC / HZ);
+#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)
+        return m * (HZ / MSEC_PER_SEC);
+#else
+        return (m * HZ + MSEC_PER_SEC - 1) / MSEC_PER_SEC;
+#endif
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7)
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+
+/* copied from linux kernel 2.6.12.6 /include/linux/pm.h */
+typedef int __bitwise pci_power_t;
+
+/* copied from linux kernel 2.6.12.6 /include/linux/pci.h */
+typedef u32 __bitwise pm_message_t;
+
+#define PCI_D0  ((pci_power_t __force) 0)
+#define PCI_D1  ((pci_power_t __force) 1)
+#define PCI_D2  ((pci_power_t __force) 2)
+#define PCI_D3hot   ((pci_power_t __force) 3)
+#define PCI_D3cold  ((pci_power_t __force) 4)
+#define PCI_POWER_ERROR ((pci_power_t __force) -1)
+
+/* copied from linux kernel 2.6.12.6 /drivers/pci/pci.c */
+/**
+ * pci_choose_state - Choose the power state of a PCI device
+ * @dev: PCI device to be suspended
+ * @state: target sleep state for the whole system. This is the value
+ *  that is passed to suspend() function.
+ *
+ * Returns PCI power state suitable for given device and given system
+ * message.
+ */
+
+pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
+{
+        if (!pci_find_capability(dev, PCI_CAP_ID_PM))
+                return PCI_D0;
+
+        switch (state) {
+        case 0:
+                return PCI_D0;
+        case 3:
+                return PCI_D3hot;
+        default:
+                printk("They asked me for state %d\n", state);
+//      BUG();
+        }
+        return PCI_D0;
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+/**
+ * msleep_interruptible - sleep waiting for waitqueue interruptions
+ * @msecs: Time in milliseconds to sleep for
+ */
+#define msleep_interruptible _kc_msleep_interruptible
+unsigned long _kc_msleep_interruptible(unsigned int msecs)
+{
+        unsigned long timeout = _kc_msecs_to_jiffies(msecs);
+
+        while (timeout && !signal_pending(current)) {
+                set_current_state(TASK_INTERRUPTIBLE);
+                timeout = schedule_timeout(timeout);
+        }
+        return _kc_jiffies_to_msecs(timeout);
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7)
+/* copied from linux kernel 2.6.20 include/linux/sched.h */
+#ifndef __sched
+#define __sched     __attribute__((__section__(".sched.text")))
+#endif
+
+/* copied from linux kernel 2.6.20 kernel/timer.c */
+signed long __sched schedule_timeout_uninterruptible(signed long timeout)
+{
+        __set_current_state(TASK_UNINTERRUPTIBLE);
+        return schedule_timeout(timeout);
+}
+
+/* copied from linux kernel 2.6.20 include/linux/mii.h */
+#undef if_mii
+#define if_mii _kc_if_mii
+static inline struct mii_ioctl_data *if_mii(struct ifreq *rq)
+{
+        return (struct mii_ioctl_data *) &rq->ifr_ifru;
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7)
+
+static u32 rtl8126_read_thermal_sensor(struct rtl8126_private *tp)
+{
+        u16 ts_digout;
+
+        ts_digout = rtl8126_mdio_direct_read_phy_ocp(tp, 0xBD84);
+        ts_digout &= 0x3ff;
+
+        return ts_digout;
+}
+
+int rtl8126_dump_tally_counter(struct rtl8126_private *tp, dma_addr_t paddr)
+{
+        u32 cmd;
+        u32 WaitCnt;
+        int retval = -1;
+
+        RTL_W32(tp, CounterAddrHigh, (u64)paddr >> 32);
+        cmd = (u64)paddr & DMA_BIT_MASK(32);
+        RTL_W32(tp, CounterAddrLow, cmd);
+        RTL_W32(tp, CounterAddrLow, cmd | CounterDump);
+
+        WaitCnt = 0;
+        while (RTL_R32(tp, CounterAddrLow) & CounterDump) {
+                udelay(10);
+
+                WaitCnt++;
+                if (WaitCnt > 20)
+                        break;
+        }
+
+        if (WaitCnt <= 20)
+                retval = 0;
+
+        return retval;
+}
+
+static u32
+rtl8126_get_hw_clo_ptr(struct rtl8126_tx_ring *ring)
+{
+        struct rtl8126_private *tp = ring->priv;
+
+        switch (tp->HwSuppTxNoCloseVer) {
+        case 3:
+                return RTL_R16(tp, ring->hw_clo_ptr_reg);
+        case 4:
+        case 5:
+        case 6:
+                return RTL_R32(tp, ring->hw_clo_ptr_reg);
+        default:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                WARN_ON(1);
+#endif
+                return 0;
+        }
+}
+
+static u32
+rtl8126_get_sw_tail_ptr(struct rtl8126_tx_ring *ring)
+{
+        struct rtl8126_private *tp = ring->priv;
+
+        switch (tp->HwSuppTxNoCloseVer) {
+        case 3:
+                return RTL_R16(tp, ring->sw_tail_ptr_reg);
+        case 4:
+        case 5:
+        case 6:
+                return RTL_R32(tp, ring->sw_tail_ptr_reg);
+        default:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                WARN_ON(1);
+#endif
+                return 0;
+        }
+}
+
+static u32
+rtl8126_get_phy_status(struct rtl8126_private *tp)
+{
+        return RTL_R32(tp, PHYstatus);
+}
+
+static bool
+rtl8126_sysfs_testmode_on(struct rtl8126_private *tp)
+{
+#ifdef ENABLE_R8126_SYSFS
+        return !!tp->testmode;
+#else
+        return 1;
+#endif
+}
+
+static u32 rtl8126_convert_link_speed(u32 status)
+{
+        u32 speed = SPEED_UNKNOWN;
+
+        if (status & LinkStatus) {
+                if (status & _5000bpsF)
+                        speed = SPEED_5000;
+                else if (status & (_2500bpsF | _5000bpsL))
+                        speed = SPEED_2500;
+                else if (status & (_1000bpsF | _2500bpsL | _1000bpsL))
+                        speed = SPEED_1000;
+                else if (status & _100bps)
+                        speed = SPEED_100;
+                else if (status & _10bps)
+                        speed = SPEED_10;
+        }
+
+        return speed;
+}
+
+static void rtl8126_mdi_swap(struct rtl8126_private *tp)
+{
+        int i;
+        u16 reg, val, mdi_reverse;
+        u16 tps_p0, tps_p1, tps_p2, tps_p3, tps_p3_p0;
+
+        switch (tp->mcfg) {
+        default:
+                return;
+        };
+
+        tps_p3_p0 = rtl8126_mac_ocp_read(tp, 0xD440) & 0xF000;
+        tps_p3 = !!(tps_p3_p0 & BIT_15);
+        tps_p2 = !!(tps_p3_p0 & BIT_14);
+        tps_p1 = !!(tps_p3_p0 & BIT_13);
+        tps_p0 = !!(tps_p3_p0 & BIT_12);
+        mdi_reverse = rtl8126_mac_ocp_read(tp, 0xD442);
+
+        if ((mdi_reverse & BIT_5) && tps_p3_p0 == 0xA000)
+                return;
+
+        if (!(mdi_reverse & BIT_5))
+                val = tps_p0 << 8 |
+                      tps_p1 << 9 |
+                      tps_p2 << 10 |
+                      tps_p3 << 11;
+        else
+                val = tps_p3 << 8 |
+                      tps_p2 << 9 |
+                      tps_p1 << 10 |
+                      tps_p0 << 11;
+
+        for (i=8; i<12; i++) {
+                rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, reg);
+                rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                                      0xA438,
+                                                      BIT(i),
+                                                      val & BIT(i));
+        }
+}
+
+static int rtl8126_vcd_test(struct rtl8126_private *tp)
+{
+        u16 val;
+        u32 wait_cnt;
+        int ret = -1;
+
+        rtl8126_mdi_swap(tp);
+
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA422, BIT(0));
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xA422, 0x00F0);
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xA422, BIT(0));
+
+        wait_cnt = 0;
+        do {
+                mdelay(1);
+                val = rtl8126_mdio_direct_read_phy_ocp(tp, 0xA422);
+                wait_cnt++;
+        } while (!(val & BIT_15) && (wait_cnt < 5000));
+
+        if (wait_cnt == 5000)
+                goto exit;
+
+        ret = 0;
+
+exit:
+        return ret;
+}
+
+static void rtl8126_get_cp_len(struct rtl8126_private *tp,
+                               int cp_len[RTL8126_CP_NUM])
+{
+        int i;
+        u32 status;
+        int tmp_cp_len;
+
+        status = rtl8126_get_phy_status(tp);
+        if (status & LinkStatus) {
+                if (status & _10bps) {
+                        tmp_cp_len = -1;
+                } else if (status & (_100bps | _1000bpsF)) {
+                        rtl8126_mdio_write(tp, 0x1f, 0x0a88);
+                        tmp_cp_len = rtl8126_mdio_read(tp, 0x10);
+                } else if (status & _2500bpsF) {
+                        rtl8126_mdio_write(tp, 0x1f, 0x0acb);
+                        tmp_cp_len = rtl8126_mdio_read(tp, 0x15);
+                        tmp_cp_len >>= 2;
+                } else
+                        tmp_cp_len = 0;
+        } else
+                tmp_cp_len = 0;
+
+        if (tmp_cp_len > 0)
+                tmp_cp_len &= 0xff;
+        for (i=0; i<RTL8126_CP_NUM; i++)
+                cp_len[i] = tmp_cp_len;
+
+        rtl8126_mdio_write(tp, 0x1f, 0x0000);
+
+        for (i=0; i<RTL8126_CP_NUM; i++)
+                if (cp_len[i] > RTL8126_MAX_SUPPORT_CP_LEN)
+                        cp_len[i] = RTL8126_MAX_SUPPORT_CP_LEN;
+
+        return;
+}
+
+static int __rtl8126_get_cp_status(u16 val)
+{
+        switch (val) {
+        case 0x0060:
+                return rtl8126_cp_normal;
+        case 0x0048:
+                return rtl8126_cp_open;
+        case 0x0050:
+                return rtl8126_cp_short;
+        case 0x0042:
+        case 0x0044:
+                return rtl8126_cp_mismatch;
+        default:
+                return rtl8126_cp_normal;
+        }
+}
+
+static int _rtl8126_get_cp_status(struct rtl8126_private *tp, u8 pair_num)
+{
+        u16 val;
+        int cp_status = rtl8126_cp_unknown;
+
+        if (pair_num > 3)
+                goto exit;
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8027 + 4 * pair_num);
+        val = rtl8126_mdio_direct_read_phy_ocp(tp, 0xA438);
+
+        cp_status = __rtl8126_get_cp_status(val);
+
+exit:
+        return cp_status;
+}
+
+static const char * rtl8126_get_cp_status_string(int cp_status)
+{
+        switch(cp_status) {
+        case rtl8126_cp_normal:
+                return "normal  ";
+        case rtl8126_cp_short:
+                return "short   ";
+        case rtl8126_cp_open:
+                return "open    ";
+        case rtl8126_cp_mismatch:
+                return "mismatch";
+        default:
+                return "unknown ";
+        }
+}
+
+static u16 rtl8126_get_cp_pp(struct rtl8126_private *tp, u8 pair_num)
+{
+        u16 pp = 0;
+
+        if (pair_num > 3)
+                goto exit;
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8029 + 4 * pair_num);
+        pp = rtl8126_mdio_direct_read_phy_ocp(tp, 0xA438);
+
+        pp &= 0x3fff;
+        pp /= 80;
+
+exit:
+        return pp;
+}
+
+static void rtl8126_get_cp_status(struct rtl8126_private *tp,
+                                  int cp_status[RTL8126_CP_NUM],
+                                  bool poe_mode)
+{
+        u32 status;
+        int i;
+
+        status = rtl8126_get_phy_status(tp);
+        if (status & LinkStatus && !(status & (_10bps | _100bps))) {
+                for (i=0; i<RTL8126_CP_NUM; i++)
+                        cp_status[i] = rtl8126_cp_normal;
+        } else {
+                /* cannot do vcd when link is on */
+                rtl8126_vcd_test(tp);
+
+                for (i=0; i<RTL8126_CP_NUM; i++)
+                        cp_status[i] = _rtl8126_get_cp_status(tp, i);
+        }
+
+        if (poe_mode) {
+                for (i=0; i<RTL8126_CP_NUM; i++) {
+                        if (cp_status[i] == rtl8126_cp_mismatch)
+                                cp_status[i] = rtl8126_cp_normal;
+                }
+        }
+}
+
+#ifdef ENABLE_R8126_PROCFS
+/****************************************************************************
+*   -----------------------------PROCFS STUFF-------------------------
+*****************************************************************************
+*/
+
+static struct proc_dir_entry *rtl8126_proc;
+static int proc_init_num = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+static int proc_get_driver_variable(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump Driver Variable\n");
+
+        rtnl_lock();
+
+        seq_puts(m, "Variable\tValue\n----------\t-----\n");
+        seq_printf(m, "MODULENAME\t%s\n", MODULENAME);
+        seq_printf(m, "driver version\t%s\n", RTL8126_VERSION);
+        seq_printf(m, "mcfg\t%d\n", tp->mcfg);
+        seq_printf(m, "chipset\t%d\n", tp->chipset);
+        seq_printf(m, "chipset_name\t%s\n", rtl_chip_info[tp->chipset].name);
+        seq_printf(m, "mtu\t%d\n", dev->mtu);
+        seq_printf(m, "NUM_RX_DESC\t0x%x\n", tp->rx_ring[0].num_rx_desc);
+        seq_printf(m, "cur_rx0\t0x%x\n", tp->rx_ring[0].cur_rx);
+        seq_printf(m, "dirty_rx0\t0x%x\n", tp->rx_ring[0].dirty_rx);
+        seq_printf(m, "cur_rx1\t0x%x\n", tp->rx_ring[1].cur_rx);
+        seq_printf(m, "dirty_rx1\t0x%x\n", tp->rx_ring[1].dirty_rx);
+        seq_printf(m, "cur_rx2\t0x%x\n", tp->rx_ring[2].cur_rx);
+        seq_printf(m, "dirty_rx2\t0x%x\n", tp->rx_ring[2].dirty_rx);
+        seq_printf(m, "cur_rx3\t0x%x\n", tp->rx_ring[3].cur_rx);
+        seq_printf(m, "dirty_rx3\t0x%x\n", tp->rx_ring[3].dirty_rx);
+        seq_printf(m, "NUM_TX_DESC\t0x%x\n", tp->tx_ring[0].num_tx_desc);
+        seq_printf(m, "cur_tx0\t0x%x\n", tp->tx_ring[0].cur_tx);
+        seq_printf(m, "dirty_tx0\t0x%x\n", tp->tx_ring[0].dirty_tx);
+        seq_printf(m, "cur_tx1\t0x%x\n", tp->tx_ring[1].cur_tx);
+        seq_printf(m, "dirty_tx1\t0x%x\n", tp->tx_ring[1].dirty_tx);
+        seq_printf(m, "rx_buf_sz\t0x%x\n", tp->rx_buf_sz);
+#ifdef ENABLE_PAGE_REUSE
+        seq_printf(m, "rx_buf_page_order\t0x%x\n", tp->rx_buf_page_order);
+        seq_printf(m, "rx_buf_page_size\t0x%x\n", tp->rx_buf_page_size);
+        seq_printf(m, "page_reuse_fail_cnt\t0x%x\n", tp->page_reuse_fail_cnt);
+#endif //ENABLE_PAGE_REUSE
+        seq_printf(m, "esd_flag\t0x%x\n", tp->esd_flag);
+        seq_printf(m, "pci_cfg_is_read\t0x%x\n", tp->pci_cfg_is_read);
+        seq_printf(m, "rtl8126_rx_config\t0x%x\n", tp->rtl8126_rx_config);
+        seq_printf(m, "cp_cmd\t0x%x\n", tp->cp_cmd);
+        seq_printf(m, "intr_mask\t0x%x\n", tp->intr_mask);
+        seq_printf(m, "timer_intr_mask\t0x%x\n", tp->timer_intr_mask);
+        seq_printf(m, "wol_enabled\t0x%x\n", tp->wol_enabled);
+        seq_printf(m, "wol_opts\t0x%x\n", tp->wol_opts);
+        seq_printf(m, "efuse_ver\t0x%x\n", tp->efuse_ver);
+        seq_printf(m, "eeprom_type\t0x%x\n", tp->eeprom_type);
+        seq_printf(m, "autoneg\t0x%x\n", tp->autoneg);
+        seq_printf(m, "duplex\t0x%x\n", tp->duplex);
+        seq_printf(m, "speed\t%d\n", tp->speed);
+        seq_printf(m, "advertising\t0x%llx\n", tp->advertising);
+        seq_printf(m, "eeprom_len\t0x%x\n", tp->eeprom_len);
+        seq_printf(m, "cur_page\t0x%x\n", tp->cur_page);
+        seq_printf(m, "features\t0x%x\n", tp->features);
+        seq_printf(m, "org_pci_offset_99\t0x%x\n", tp->org_pci_offset_99);
+        seq_printf(m, "org_pci_offset_180\t0x%x\n", tp->org_pci_offset_180);
+        seq_printf(m, "issue_offset_99_event\t0x%x\n", tp->issue_offset_99_event);
+        seq_printf(m, "org_pci_offset_80\t0x%x\n", tp->org_pci_offset_80);
+        seq_printf(m, "org_pci_offset_81\t0x%x\n", tp->org_pci_offset_81);
+        seq_printf(m, "use_timer_interrupt\t0x%x\n", tp->use_timer_interrupt);
+        seq_printf(m, "HwIcVerUnknown\t0x%x\n", tp->HwIcVerUnknown);
+        seq_printf(m, "NotWrRamCodeToMicroP\t0x%x\n", tp->NotWrRamCodeToMicroP);
+        seq_printf(m, "NotWrMcuPatchCode\t0x%x\n", tp->NotWrMcuPatchCode);
+        seq_printf(m, "HwHasWrRamCodeToMicroP\t0x%x\n", tp->HwHasWrRamCodeToMicroP);
+        seq_printf(m, "sw_ram_code_ver\t0x%x\n", tp->sw_ram_code_ver);
+        seq_printf(m, "hw_ram_code_ver\t0x%x\n", tp->hw_ram_code_ver);
+        seq_printf(m, "rtk_enable_diag\t0x%x\n", tp->rtk_enable_diag);
+        seq_printf(m, "ShortPacketSwChecksum\t0x%x\n", tp->ShortPacketSwChecksum);
+        seq_printf(m, "UseSwPaddingShortPkt\t0x%x\n", tp->UseSwPaddingShortPkt);
+        seq_printf(m, "RequireAdcBiasPatch\t0x%x\n", tp->RequireAdcBiasPatch);
+        seq_printf(m, "AdcBiasPatchIoffset\t0x%x\n", tp->AdcBiasPatchIoffset);
+        seq_printf(m, "RequireAdjustUpsTxLinkPulseTiming\t0x%x\n", tp->RequireAdjustUpsTxLinkPulseTiming);
+        seq_printf(m, "SwrCnt1msIni\t0x%x\n", tp->SwrCnt1msIni);
+        seq_printf(m, "HwSuppNowIsOobVer\t0x%x\n", tp->HwSuppNowIsOobVer);
+        seq_printf(m, "HwFiberModeVer\t0x%x\n", tp->HwFiberModeVer);
+        seq_printf(m, "HwFiberStat\t0x%x\n", tp->HwFiberStat);
+        seq_printf(m, "NicCustLedValue\t0x%x\n", tp->NicCustLedValue);
+        seq_printf(m, "RequiredSecLanDonglePatch\t0x%x\n", tp->RequiredSecLanDonglePatch);
+        seq_printf(m, "HwSuppKCPOffloadVer\t0x%x\n", tp->HwSuppKCPOffloadVer);
+        seq_printf(m, "speed_mode\t0x%x\n", speed_mode);
+        seq_printf(m, "duplex_mode\t0x%x\n", duplex_mode);
+        seq_printf(m, "autoneg_mode\t0x%x\n", autoneg_mode);
+        seq_printf(m, "aspm\t0x%x\n", aspm);
+        seq_printf(m, "s5wol\t0x%x\n", s5wol);
+        seq_printf(m, "s5_keep_curr_mac\t0x%x\n", s5_keep_curr_mac);
+        seq_printf(m, "eee_enable\t0x%x\n", tp->eee.eee_enabled);
+        seq_printf(m, "hwoptimize\t0x%lx\n", hwoptimize);
+        seq_printf(m, "proc_init_num\t0x%x\n", proc_init_num);
+        seq_printf(m, "s0_magic_packet\t0x%x\n", s0_magic_packet);
+        seq_printf(m, "disable_wol_support\t0x%x\n", disable_wol_support);
+        seq_printf(m, "enable_double_vlan\t0x%x\n", enable_double_vlan);
+        seq_printf(m, "eee_giga_lite\t0x%x\n", eee_giga_lite);
+        seq_printf(m, "HwSuppMagicPktVer\t0x%x\n", tp->HwSuppMagicPktVer);
+        seq_printf(m, "HwSuppLinkChgWakeUpVer\t0x%x\n", tp->HwSuppLinkChgWakeUpVer);
+        seq_printf(m, "HwSuppD0SpeedUpVer\t0x%x\n", tp->HwSuppD0SpeedUpVer);
+        seq_printf(m, "D0SpeedUpSpeed\t0x%x\n", tp->D0SpeedUpSpeed);
+        seq_printf(m, "HwSuppCheckPhyDisableModeVer\t0x%x\n", tp->HwSuppCheckPhyDisableModeVer);
+        seq_printf(m, "HwPkgDet\t0x%x\n", tp->HwPkgDet);
+        seq_printf(m, "HwSuppTxNoCloseVer\t0x%x\n", tp->HwSuppTxNoCloseVer);
+        seq_printf(m, "EnableTxNoClose\t0x%x\n", tp->EnableTxNoClose);
+        seq_printf(m, "NextHwDesCloPtr0\t0x%x\n", tp->tx_ring[0].NextHwDesCloPtr);
+        seq_printf(m, "BeginHwDesCloPtr0\t0x%x\n", tp->tx_ring[0].BeginHwDesCloPtr);
+        seq_printf(m, "hw_clo_ptr_reg0\t0x%x\n", rtl8126_get_hw_clo_ptr(&tp->tx_ring[0]));
+        seq_printf(m, "sw_tail_ptr_reg0\t0x%x\n", rtl8126_get_sw_tail_ptr(&tp->tx_ring[0]));
+        seq_printf(m, "NextHwDesCloPtr1\t0x%x\n", tp->tx_ring[1].NextHwDesCloPtr);
+        seq_printf(m, "BeginHwDesCloPtr1\t0x%x\n", tp->tx_ring[1].BeginHwDesCloPtr);
+        seq_printf(m, "hw_clo_ptr_reg1\t0x%x\n", rtl8126_get_hw_clo_ptr(&tp->tx_ring[1]));
+        seq_printf(m, "sw_tail_ptr_reg1\t0x%x\n", rtl8126_get_sw_tail_ptr(&tp->tx_ring[1]));
+        seq_printf(m, "InitRxDescType\t0x%x\n", tp->InitRxDescType);
+        seq_printf(m, "RxDescLength\t0x%x\n", tp->RxDescLength);
+        seq_printf(m, "num_rx_rings\t0x%x\n", tp->num_rx_rings);
+        seq_printf(m, "num_tx_rings\t0x%x\n", tp->num_tx_rings);
+        seq_printf(m, "tot_rx_rings\t0x%x\n", rtl8126_tot_rx_rings(tp));
+        seq_printf(m, "tot_tx_rings\t0x%x\n", rtl8126_tot_tx_rings(tp));
+        seq_printf(m, "HwSuppNumRxQueues\t0x%x\n", tp->HwSuppNumRxQueues);
+        seq_printf(m, "HwSuppNumTxQueues\t0x%x\n", tp->HwSuppNumTxQueues);
+        seq_printf(m, "EnableRss\t0x%x\n", tp->EnableRss);
+        seq_printf(m, "EnablePtp\t0x%x\n", tp->EnablePtp);
+        seq_printf(m, "min_irq_nvecs\t0x%x\n", tp->min_irq_nvecs);
+        seq_printf(m, "irq_nvecs\t0x%x\n", tp->irq_nvecs);
+        seq_printf(m, "hw_supp_irq_nvecs\t0x%x\n", tp->hw_supp_irq_nvecs);
+        seq_printf(m, "ring_lib_enabled\t0x%x\n", tp->ring_lib_enabled);
+        seq_printf(m, "HwSuppIsrVer\t0x%x\n", tp->HwSuppIsrVer);
+        seq_printf(m, "HwCurrIsrVer\t0x%x\n", tp->HwCurrIsrVer);
+        seq_printf(m, "HwSuppMacMcuVer\t0x%x\n", tp->HwSuppMacMcuVer);
+        seq_printf(m, "MacMcuPageSize\t0x%x\n", tp->MacMcuPageSize);
+        seq_printf(m, "hw_mcu_patch_code_ver\t0x%llx\n", tp->hw_mcu_patch_code_ver);
+        seq_printf(m, "bin_mcu_patch_code_ver\t0x%llx\n", tp->bin_mcu_patch_code_ver);
+#ifdef ENABLE_PTP_SUPPORT
+        seq_printf(m, "tx_hwtstamp_timeouts\t0x%x\n", tp->tx_hwtstamp_timeouts);
+        seq_printf(m, "tx_hwtstamp_skipped\t0x%x\n", tp->tx_hwtstamp_skipped);
+#endif
+        seq_printf(m, "random_mac\t0x%x\n", tp->random_mac);
+        seq_printf(m, "org_mac_addr\t%pM\n", tp->org_mac_addr);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+        seq_printf(m, "perm_addr\t%pM\n", dev->perm_addr);
+#endif
+        seq_printf(m, "dev_addr\t%pM\n", dev->dev_addr);
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_tally_counter(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        struct rtl8126_counters *counters;
+        dma_addr_t paddr;
+
+        seq_puts(m, "\nDump Tally Counter\n");
+
+        rtnl_lock();
+
+        counters = tp->tally_vaddr;
+        paddr = tp->tally_paddr;
+        if (!counters) {
+                seq_puts(m, "\nDump Tally Counter Fail\n");
+                goto out_unlock;
+        }
+
+        rtl8126_dump_tally_counter(tp, paddr);
+
+        seq_puts(m, "Statistics\tValue\n----------\t-----\n");
+        seq_printf(m, "tx_packets\t%lld\n", le64_to_cpu(counters->tx_packets));
+        seq_printf(m, "rx_packets\t%lld\n", le64_to_cpu(counters->rx_packets));
+        seq_printf(m, "tx_errors\t%lld\n", le64_to_cpu(counters->tx_errors));
+        seq_printf(m, "rx_errors\t%d\n", le32_to_cpu(counters->rx_errors));
+        seq_printf(m, "rx_missed\t%d\n", le16_to_cpu(counters->rx_missed));
+        seq_printf(m, "align_errors\t%d\n", le16_to_cpu(counters->align_errors));
+        seq_printf(m, "tx_one_collision\t%d\n", le32_to_cpu(counters->tx_one_collision));
+        seq_printf(m, "tx_multi_collision\t%d\n", le32_to_cpu(counters->tx_multi_collision));
+        seq_printf(m, "rx_unicast\t%lld\n", le64_to_cpu(counters->rx_unicast));
+        seq_printf(m, "rx_broadcast\t%lld\n", le64_to_cpu(counters->rx_broadcast));
+        seq_printf(m, "rx_multicast\t%d\n", le32_to_cpu(counters->rx_multicast));
+        seq_printf(m, "tx_aborted\t%d\n", le16_to_cpu(counters->tx_aborted));
+        seq_printf(m, "tx_underrun\t%d\n", le16_to_cpu(counters->tx_underrun));
+
+        seq_printf(m, "tx_octets\t%lld\n", le64_to_cpu(counters->tx_octets));
+        seq_printf(m, "rx_octets\t%lld\n", le64_to_cpu(counters->rx_octets));
+        seq_printf(m, "rx_multicast64\t%lld\n", le64_to_cpu(counters->rx_multicast64));
+        seq_printf(m, "tx_unicast64\t%lld\n", le64_to_cpu(counters->tx_unicast64));
+        seq_printf(m, "tx_broadcast64\t%lld\n", le64_to_cpu(counters->tx_broadcast64));
+        seq_printf(m, "tx_multicast64\t%lld\n", le64_to_cpu(counters->tx_multicast64));
+        seq_printf(m, "tx_pause_on\t%d\n", le32_to_cpu(counters->tx_pause_on));
+        seq_printf(m, "tx_pause_off\t%d\n", le32_to_cpu(counters->tx_pause_off));
+        seq_printf(m, "tx_pause_all\t%d\n", le32_to_cpu(counters->tx_pause_all));
+        seq_printf(m, "tx_deferred\t%d\n", le32_to_cpu(counters->tx_deferred));
+        seq_printf(m, "tx_late_collision\t%d\n", le32_to_cpu(counters->tx_late_collision));
+        seq_printf(m, "tx_all_collision\t%d\n", le32_to_cpu(counters->tx_all_collision));
+        seq_printf(m, "tx_aborted32\t%d\n", le32_to_cpu(counters->tx_aborted32));
+        seq_printf(m, "align_errors32\t%d\n", le32_to_cpu(counters->align_errors32));
+        seq_printf(m, "rx_frame_too_long\t%d\n", le32_to_cpu(counters->rx_frame_too_long));
+        seq_printf(m, "rx_runt\t%d\n", le32_to_cpu(counters->rx_runt));
+        seq_printf(m, "rx_pause_on\t%d\n", le32_to_cpu(counters->rx_pause_on));
+        seq_printf(m, "rx_pause_off\t%d\n", le32_to_cpu(counters->rx_pause_off));
+        seq_printf(m, "rx_pause_all\t%d\n", le32_to_cpu(counters->rx_pause_all));
+        seq_printf(m, "rx_unknown_opcode\t%d\n", le32_to_cpu(counters->rx_unknown_opcode));
+        seq_printf(m, "rx_mac_error\t%d\n", le32_to_cpu(counters->rx_mac_error));
+        seq_printf(m, "tx_underrun32\t%d\n", le32_to_cpu(counters->tx_underrun32));
+        seq_printf(m, "rx_mac_missed\t%d\n", le32_to_cpu(counters->rx_mac_missed));
+        seq_printf(m, "rx_tcam_dropped\t%d\n", le32_to_cpu(counters->rx_tcam_dropped));
+        seq_printf(m, "tdu\t%d\n", le32_to_cpu(counters->tdu));
+        seq_printf(m, "rdu\t%d\n", le32_to_cpu(counters->rdu));
+
+        seq_putc(m, '\n');
+
+out_unlock:
+        rtnl_unlock();
+
+        return 0;
+}
+
+static int proc_get_registers(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8126_MAC_REGS_SIZE;
+        u8 byte_rd;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+
+        seq_puts(m, "\nDump MAC Registers\n");
+        seq_puts(m, "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%04x:\t", n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        seq_printf(m, "%02x ", byte_rd);
+                }
+        }
+
+        max = 0xB00;
+        for (n = 0xA00; n < max;) {
+                seq_printf(m, "\n0x%04x:\t", n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        seq_printf(m, "%02x ", byte_rd);
+                }
+        }
+
+        max = 0xD40;
+        for (n = 0xD00; n < max;) {
+                seq_printf(m, "\n0x%04x:\t", n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        seq_printf(m, "%02x ", byte_rd);
+                }
+        }
+
+        max = 0x2840;
+        for (n = 0x2800; n < max;) {
+                seq_printf(m, "\n0x%04x:\t", n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        seq_printf(m, "%02x ", byte_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_all_registers(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max;
+        u8 byte_rd;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+        struct pci_dev *pdev = tp->pci_dev;
+
+        seq_puts(m, "\nDump All MAC Registers\n");
+        seq_puts(m, "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        max = pci_resource_len(pdev, 2);
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%04x:\t", n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        seq_printf(m, "%02x ", byte_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        seq_printf(m, "\nTotal length:0x%X", max);
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_pcie_phy(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8126_EPHY_REGS_SIZE/2;
+        u16 word_rd;
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump PCIE PHY\n");
+        seq_puts(m, "\nOffset\tValue\n------\t-----\n ");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%02x:\t", n);
+
+                for (i = 0; i < 8 && n < max; i++, n++) {
+                        word_rd = rtl8126_ephy_read(tp, n);
+                        seq_printf(m, "%04x ", word_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_eth_phy(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8126_PHY_REGS_SIZE/2;
+        unsigned long flags;
+        u16 word_rd;
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump Ethernet PHY\n");
+        seq_puts(m, "\nOffset\tValue\n------\t-----\n ");
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        seq_puts(m, "\n####################page 0##################\n ");
+        rtl8126_mdio_write(tp, 0x1f, 0x0000);
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%02x:\t", n);
+
+                for (i = 0; i < 8 && n < max; i++, n++) {
+                        word_rd = rtl8126_mdio_read(tp, n);
+                        seq_printf(m, "%04x ", word_rd);
+                }
+        }
+
+        seq_puts(m, "\n####################extra reg##################\n ");
+        n = 0xA400;
+        seq_printf(m, "\n0x%02x:\t", n);
+        for (i = 0; i < 8; i++, n+=2) {
+                word_rd = rtl8126_mdio_direct_read_phy_ocp(tp, n);
+                seq_printf(m, "%04x ", word_rd);
+        }
+
+        n = 0xA410;
+        seq_printf(m, "\n0x%02x:\t", n);
+        for (i = 0; i < 3; i++, n+=2) {
+                word_rd = rtl8126_mdio_direct_read_phy_ocp(tp, n);
+                seq_printf(m, "%04x ", word_rd);
+        }
+
+        n = 0xA434;
+        seq_printf(m, "\n0x%02x:\t", n);
+        word_rd = rtl8126_mdio_direct_read_phy_ocp(tp, n);
+        seq_printf(m, "%04x ", word_rd);
+
+        n = 0xA5D0;
+        seq_printf(m, "\n0x%02x:\t", n);
+        for (i = 0; i < 4; i++, n+=2) {
+                word_rd = rtl8126_mdio_direct_read_phy_ocp(tp, n);
+                seq_printf(m, "%04x ", word_rd);
+        }
+
+        n = 0xA61A;
+        seq_printf(m, "\n0x%02x:\t", n);
+        word_rd = rtl8126_mdio_direct_read_phy_ocp(tp, n);
+        seq_printf(m, "%04x ", word_rd);
+
+        n = 0xA6D0;
+        seq_printf(m, "\n0x%02x:\t", n);
+        for (i = 0; i < 3; i++, n+=2) {
+                word_rd = rtl8126_mdio_direct_read_phy_ocp(tp, n);
+                seq_printf(m, "%04x ", word_rd);
+        }
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_extended_registers(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8126_ERI_REGS_SIZE;
+        u32 dword_rd;
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump Extended Registers\n");
+        seq_puts(m, "\nOffset\tValue\n------\t-----\n ");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%02x:\t", n);
+
+                for (i = 0; i < 4 && n < max; i++, n+=4) {
+                        dword_rd = rtl8126_eri_read(tp, n, 4, ERIAR_ExGMAC);
+                        seq_printf(m, "%08x ", dword_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_pci_registers(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8126_PCI_REGS_SIZE;
+        u32 dword_rd;
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump PCI Registers\n");
+        seq_puts(m, "\nOffset\tValue\n------\t-----\n ");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%03x:\t", n);
+
+                for (i = 0; i < 4 && n < max; i++, n+=4) {
+                        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+                        seq_printf(m, "%08x ", dword_rd);
+                }
+        }
+
+        n = 0x110;
+        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+        seq_printf(m, "\n0x%03x:\t%08x ", n, dword_rd);
+        n = 0x70c;
+        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+        seq_printf(m, "\n0x%03x:\t%08x ", n, dword_rd);
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_temperature(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u16 ts_digout, tj, fah;
+        unsigned long flags;
+
+        rtnl_lock();
+
+        if (!rtl8126_sysfs_testmode_on(tp)) {
+                seq_puts(m, "\nPlease turn on ""/sys/class/net/<iface>/rtk_adv/testmode"".\n\n");
+                rtnl_unlock();
+                return 0;
+        }
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        netif_testing_on(dev);
+        ts_digout = rtl8126_read_thermal_sensor(tp);
+        netif_testing_off(dev);
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        rtnl_unlock();
+
+        if (ts_digout <= 512) {
+                tj = ts_digout / 2;
+                seq_printf(m, "Cel:%d\n", tj);
+                fah = tj * (9/5) + 32;
+                seq_printf(m, "Fah:%d\n", fah);
+        } else {
+                tj = (512 - (ts_digout - 512)) / 2;
+                seq_printf(m, "Cel:-%d\n", tj);
+                fah = tj * (9/5) + 32;
+                seq_printf(m, "Fah:-%d\n", fah);
+        }
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int _proc_get_cable_info(struct seq_file *m, void *v, bool poe_mode)
+{
+        int i;
+        u32 status;
+        int cp_status[RTL8126_CP_NUM];
+        int cp_len[RTL8126_CP_NUM] = {0};
+        struct net_device *dev = m->private;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        const char *pair_str[RTL8126_CP_NUM] = {"1-2", "3-6", "4-5", "7-8"};
+        unsigned long flags;
+        int ret;
+
+        switch (tp->mcfg) {
+        default:
+                ret = -EOPNOTSUPP;
+                goto error_out;
+        }
+
+        rtnl_lock();
+
+        if (!rtl8126_sysfs_testmode_on(tp)) {
+                seq_puts(m, "\nPlease turn on ""/sys/class/net/<iface>/rtk_adv/testmode"".\n\n");
+                ret = 0;
+                goto error_unlock;
+        }
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        rtl8126_mdio_write(tp, 0x1F, 0x0000);
+        if (rtl8126_mdio_read(tp, MII_BMCR) & BMCR_PDOWN) {
+                r8126_spin_unlock(&tp->phy_lock, flags);
+                ret = -EIO;
+                goto error_unlock;
+        }
+
+        netif_testing_on(dev);
+
+        status = rtl8126_get_phy_status(tp);
+        if (status & LinkStatus)
+                seq_printf(m, "\nlink speed:%d",
+                           rtl8126_convert_link_speed(status));
+        else
+                seq_puts(m, "\nlink status:off");
+
+        rtl8126_get_cp_len(tp, cp_len);
+
+        rtl8126_get_cp_status(tp, cp_status, poe_mode);
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        seq_puts(m, "\npair\tlength\tstatus   \tpp\n");
+
+        for (i=0; i<RTL8126_CP_NUM; i++) {
+                if (cp_len[i] < 0)
+                        seq_printf(m, "%s\t%s\t%s\t",
+                                   pair_str[i], "none",
+                                   rtl8126_get_cp_status_string(cp_status[i]));
+                else
+                        seq_printf(m, "%s\t%d\t%s\t",
+                                   pair_str[i], cp_len[i],
+                                   rtl8126_get_cp_status_string(cp_status[i]));
+                if (cp_status[i] == rtl8126_cp_normal)
+                        seq_printf(m, "none\n");
+                else
+                        seq_printf(m, "%dm\n", rtl8126_get_cp_pp(tp, i));
+        }
+
+        netif_testing_off(dev);
+
+        seq_putc(m, '\n');
+
+        ret = 0;
+
+error_unlock:
+        rtnl_unlock();
+
+error_out:
+        return ret;
+}
+
+static int proc_get_cable_info(struct seq_file *m, void *v)
+{
+        return _proc_get_cable_info(m, v, 0);
+}
+
+static int proc_get_poe_cable_info(struct seq_file *m, void *v)
+{
+        return _proc_get_cable_info(m, v, 1);
+}
+
+static void _proc_dump_desc(struct seq_file *m, void *desc_base, u32 alloc_size)
+{
+        u32 *pdword;
+        int i;
+
+        if (desc_base == NULL ||
+            alloc_size == 0)
+                return;
+
+        pdword = (u32*)desc_base;
+        for (i=0; i<(alloc_size/4); i++) {
+                if (!(i % 4))
+                        seq_printf(m, "\n%04x ", i);
+                seq_printf(m, "%08x ", pdword[i]);
+        }
+
+        seq_putc(m, '\n');
+        return;
+}
+
+static int proc_dump_rx_desc(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i;
+
+        rtnl_lock();
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8126_rx_ring *ring = &tp->rx_ring[i];
+
+                if (!ring)
+                        continue;
+
+                seq_printf(m, "\ndump rx %d desc:%d\n", i, ring->num_rx_desc);
+
+                _proc_dump_desc(m, (void*)ring->RxDescArray, ring->RxDescAllocSize);
+        }
+
+#ifdef ENABLE_LIB_SUPPORT
+        if (rtl8126_num_lib_rx_rings(tp) > 0) {
+                for (i = 0; i < tp->HwSuppNumRxQueues; i++) {
+                        struct rtl8126_ring *lib_ring = &tp->lib_rx_ring[i];
+                        if (lib_ring->enabled) {
+                                seq_printf(m, "\ndump lib rx %d desc:%d\n", i,
+                                           lib_ring->ring_size);
+                                _proc_dump_desc(m, (void*)lib_ring->desc_addr,
+                                                lib_ring->desc_size);
+                        }
+                }
+        }
+#endif //ENABLE_LIB_SUPPORT
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_dump_tx_desc(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i;
+
+        rtnl_lock();
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8126_tx_ring *ring = &tp->tx_ring[i];
+
+                if (!ring)
+                        continue;
+
+                seq_printf(m, "\ndump tx %d desc:%d\n", i, ring->num_tx_desc);
+
+                _proc_dump_desc(m, (void*)ring->TxDescArray, ring->TxDescAllocSize);
+        }
+
+#ifdef ENABLE_LIB_SUPPORT
+        if (rtl8126_num_lib_tx_rings(tp) > 0) {
+                for (i = 0; i < tp->HwSuppNumTxQueues; i++) {
+                        struct rtl8126_ring *lib_ring = &tp->lib_tx_ring[i];
+                        if (lib_ring->enabled) {
+                                seq_printf(m, "\ndump lib tx %d desc:%d\n", i,
+                                           lib_ring->ring_size);
+                                _proc_dump_desc(m, (void*)lib_ring->desc_addr,
+                                                lib_ring->desc_size);
+                        }
+                }
+        }
+#endif //ENABLE_LIB_SUPPORT
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_dump_msix_tbl(struct seq_file *m, void *v)
+{
+        int i, j;
+        void __iomem *ioaddr;
+        struct net_device *dev = m->private;
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        /* ioremap MMIO region */
+        ioaddr = ioremap(pci_resource_start(tp->pci_dev, 4), pci_resource_len(tp->pci_dev, 4));
+        if (!ioaddr)
+                return -EFAULT;
+
+        rtnl_lock();
+
+        seq_printf(m, "\ndump MSI-X Table. Total Entry %d. \n", tp->hw_supp_irq_nvecs);
+
+        for (i=0; i<tp->hw_supp_irq_nvecs; i++) {
+                seq_printf(m, "\n%04x ", i);
+                for (j=0; j<4; j++)
+                        seq_printf(m, "%08x ",
+                                   readl(ioaddr + i*0x10 + 4*j));
+        }
+
+        rtnl_unlock();
+
+        iounmap(ioaddr);
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+#else //LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+
+static int proc_get_driver_variable(char *page, char **start,
+                                    off_t offset, int count,
+                                    int *eof, void *data)
+{
+        struct net_device *dev = data;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump Driver Driver\n");
+
+        rtnl_lock();
+
+        len += snprintf(page + len, count - len,
+                        "Variable\tValue\n----------\t-----\n");
+
+        len += snprintf(page + len, count - len,
+                        "MODULENAME\t%s\n"
+                        "driver version\t%s\n"
+                        "mcfg\t%d\n"
+                        "chipset\t%d\n"
+                        "chipset_name\t%s\n"
+                        "mtu\t%d\n"
+                        "NUM_RX_DESC\t0x%x\n"
+                        "cur_rx0\t0x%x\n"
+                        "dirty_rx0\t0x%x\n"
+                        "cur_rx1\t0x%x\n"
+                        "dirty_rx1\t0x%x\n"
+                        "cur_rx2\t0x%x\n"
+                        "dirty_rx2\t0x%x\n"
+                        "cur_rx3\t0x%x\n"
+                        "dirty_rx3\t0x%x\n"
+                        "NUM_TX_DESC\t0x%x\n"
+                        "cur_tx0\t0x%x\n"
+                        "dirty_tx0\t0x%x\n"
+                        "cur_tx1\t0x%x\n"
+                        "dirty_tx1\t0x%x\n"
+                        "rx_buf_sz\t0x%x\n"
+#ifdef ENABLE_PAGE_REUSE
+                        "rx_buf_page_order\t0x%x\n"
+                        "rx_buf_page_size\t0x%x\n"
+                        "page_reuse_fail_cnt\t0x%x\n"
+#endif //ENABLE_PAGE_REUSE
+                        "esd_flag\t0x%x\n"
+                        "pci_cfg_is_read\t0x%x\n"
+                        "rtl8126_rx_config\t0x%x\n"
+                        "cp_cmd\t0x%x\n"
+                        "intr_mask\t0x%x\n"
+                        "timer_intr_mask\t0x%x\n"
+                        "wol_enabled\t0x%x\n"
+                        "wol_opts\t0x%x\n"
+                        "efuse_ver\t0x%x\n"
+                        "eeprom_type\t0x%x\n"
+                        "autoneg\t0x%x\n"
+                        "duplex\t0x%x\n"
+                        "speed\t%d\n"
+                        "advertising\t0x%llx\n"
+                        "eeprom_len\t0x%x\n"
+                        "cur_page\t0x%x\n"
+                        "features\t0x%x\n"
+                        "org_pci_offset_99\t0x%x\n"
+                        "org_pci_offset_180\t0x%x\n"
+                        "issue_offset_99_event\t0x%x\n"
+                        "org_pci_offset_80\t0x%x\n"
+                        "org_pci_offset_81\t0x%x\n"
+                        "use_timer_interrupt\t0x%x\n"
+                        "HwIcVerUnknown\t0x%x\n"
+                        "NotWrRamCodeToMicroP\t0x%x\n"
+                        "NotWrMcuPatchCode\t0x%x\n"
+                        "HwHasWrRamCodeToMicroP\t0x%x\n"
+                        "sw_ram_code_ver\t0x%x\n"
+                        "hw_ram_code_ver\t0x%x\n"
+                        "rtk_enable_diag\t0x%x\n"
+                        "ShortPacketSwChecksum\t0x%x\n"
+                        "UseSwPaddingShortPkt\t0x%x\n"
+                        "RequireAdcBiasPatch\t0x%x\n"
+                        "AdcBiasPatchIoffset\t0x%x\n"
+                        "RequireAdjustUpsTxLinkPulseTiming\t0x%x\n"
+                        "SwrCnt1msIni\t0x%x\n"
+                        "HwSuppNowIsOobVer\t0x%x\n"
+                        "HwFiberModeVer\t0x%x\n"
+                        "HwFiberStat\t0x%x\n"
+                        "NicCustLedValue\t0x%x\n"
+                        "RequiredSecLanDonglePatch\t0x%x\n"
+                        "HwSuppKCPOffloadVer\t0x%x\n"
+                        "speed_mode\t0x%x\n"
+                        "duplex_mode\t0x%x\n"
+                        "autoneg_mode\t0x%x\n"
+                        "aspm\t0x%x\n"
+                        "s5wol\t0x%x\n"
+                        "s5_keep_curr_mac\t0x%x\n"
+                        "eee_enable\t0x%x\n"
+                        "hwoptimize\t0x%lx\n"
+                        "proc_init_num\t0x%x\n"
+                        "s0_magic_packet\t0x%x\n"
+                        "disable_wol_support\t0x%x\n"
+                        "enable_double_vlan\t0x%x\n"
+                        "eee_giga_lite\t0x%x\n"
+                        "HwSuppMagicPktVer\t0x%x\n"
+                        "HwSuppLinkChgWakeUpVer\t0x%x\n"
+                        "HwSuppD0SpeedUpVer\t0x%x\n"
+                        "D0SpeedUpSpeed\t0x%x\n"
+                        "HwSuppCheckPhyDisableModeVer\t0x%x\n"
+                        "HwPkgDet\t0x%x\n"
+                        "HwSuppTxNoCloseVer\t0x%x\n"
+                        "EnableTxNoClose\t0x%x\n"
+                        "NextHwDesCloPtr0\t0x%x\n"
+                        "BeginHwDesCloPtr0\t0x%x\n"
+                        "hw_clo_ptr_reg0\t0x%x\n"
+                        "sw_tail_ptr_reg0\t0x%x\n"
+                        "NextHwDesCloPtr1\t0x%x\n"
+                        "BeginHwDesCloPtr1\t0x%x\n"
+                        "hw_clo_ptr_reg1\t0x%x\n"
+                        "sw_tail_ptr_reg1\t0x%x\n"
+                        "InitRxDescType\t0x%x\n"
+                        "RxDescLength\t0x%x\n"
+                        "num_rx_rings\t0x%x\n"
+                        "num_tx_rings\t0x%x\n"
+                        "tot_rx_rings\t0x%x\n"
+                        "tot_tx_rings\t0x%x\n"
+                        "HwSuppNumRxQueues\t0x%x\n"
+                        "HwSuppNumTxQueues\t0x%x\n"
+                        "EnableRss\t0x%x\n"
+                        "EnablePtp\t0x%x\n"
+                        "min_irq_nvecs\t0x%x\n"
+                        "irq_nvecs\t0x%x\n"
+                        "hw_supp_irq_nvecs\t0x%x\n"
+                        "ring_lib_enabled\t0x%x\n"
+                        "HwSuppIsrVer\t0x%x\n"
+                        "HwCurrIsrVer\t0x%x\n"
+                        "HwSuppMacMcuVer\t0x%x\n"
+                        "MacMcuPageSize\t0x%x\n"
+                        "hw_mcu_patch_code_ver\t0x%llx\n"
+                        "bin_mcu_patch_code_ver\t0x%llx\n"
+#ifdef ENABLE_PTP_SUPPORT
+                        "tx_hwtstamp_timeouts\t0x%x\n"
+                        "tx_hwtstamp_skipped\t0x%x\n"
+#endif
+                        "random_mac\t0x%x\n"
+                        "org_mac_addr\t%pM\n"
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+                        "perm_addr\t%pM\n"
+#endif
+                        "dev_addr\t%pM\n",
+                        MODULENAME,
+                        RTL8126_VERSION,
+                        tp->mcfg,
+                        tp->chipset,
+                        rtl_chip_info[tp->chipset].name,
+                        dev->mtu,
+                        tp->rx_ring[0].num_rx_desc,
+                        tp->rx_ring[0].cur_rx,
+                        tp->rx_ring[0].dirty_rx,
+                        tp->rx_ring[1].cur_rx,
+                        tp->rx_ring[1].dirty_rx,
+                        tp->rx_ring[2].cur_rx,
+                        tp->rx_ring[2].dirty_rx,
+                        tp->rx_ring[3].cur_rx,
+                        tp->rx_ring[3].dirty_rx,
+                        tp->tx_ring[0].num_tx_desc,
+                        tp->tx_ring[0].cur_tx,
+                        tp->tx_ring[0].dirty_tx,
+                        tp->tx_ring[1].cur_tx,
+                        tp->tx_ring[1].dirty_tx,
+                        tp->rx_buf_sz,
+#ifdef ENABLE_PAGE_REUSE
+                        tp->rx_buf_page_order,
+                        tp->rx_buf_page_size,
+                        tp->page_reuse_fail_cnt,
+#endif //ENABLE_PAGE_REUSE
+                        tp->esd_flag,
+                        tp->pci_cfg_is_read,
+                        tp->rtl8126_rx_config,
+                        tp->cp_cmd,
+                        tp->intr_mask,
+                        tp->timer_intr_mask,
+                        tp->wol_enabled,
+                        tp->wol_opts,
+                        tp->efuse_ver,
+                        tp->eeprom_type,
+                        tp->autoneg,
+                        tp->duplex,
+                        tp->speed,
+                        tp->advertising,
+                        tp->eeprom_len,
+                        tp->cur_page,
+                        tp->features,
+                        tp->org_pci_offset_99,
+                        tp->org_pci_offset_180,
+                        tp->issue_offset_99_event,
+                        tp->org_pci_offset_80,
+                        tp->org_pci_offset_81,
+                        tp->use_timer_interrupt,
+                        tp->HwIcVerUnknown,
+                        tp->NotWrRamCodeToMicroP,
+                        tp->NotWrMcuPatchCode,
+                        tp->HwHasWrRamCodeToMicroP,
+                        tp->sw_ram_code_ver,
+                        tp->hw_ram_code_ver,
+                        tp->rtk_enable_diag,
+                        tp->ShortPacketSwChecksum,
+                        tp->UseSwPaddingShortPkt,
+                        tp->RequireAdcBiasPatch,
+                        tp->AdcBiasPatchIoffset,
+                        tp->RequireAdjustUpsTxLinkPulseTiming,
+                        tp->SwrCnt1msIni,
+                        tp->HwSuppNowIsOobVer,
+                        tp->HwFiberModeVer,
+                        tp->HwFiberStat,
+                        tp->NicCustLedValue,
+                        tp->RequiredSecLanDonglePatch,
+                        tp->HwSuppKCPOffloadVer,
+                        speed_mode,
+                        duplex_mode,
+                        autoneg_mode,
+                        aspm,
+                        s5wol,
+                        s5_keep_curr_mac,
+                        tp->eee.eee_enabled,
+                        hwoptimize,
+                        proc_init_num,
+                        s0_magic_packet,
+                        disable_wol_support,
+                        enable_double_vlan,
+                        eee_giga_lite,
+                        tp->HwSuppMagicPktVer,
+                        tp->HwSuppLinkChgWakeUpVer,
+                        tp->HwSuppD0SpeedUpVer,
+                        tp->D0SpeedUpSpeed,
+                        tp->HwSuppCheckPhyDisableModeVer,
+                        tp->HwPkgDet,
+                        tp->HwSuppTxNoCloseVer,
+                        tp->EnableTxNoClose,
+                        tp->tx_ring[0].NextHwDesCloPtr,
+                        tp->tx_ring[0].BeginHwDesCloPtr,
+                        rtl8126_get_hw_clo_ptr(&tp->tx_ring[0]),
+                        rtl8126_get_sw_tail_ptr(&tp->tx_ring[0]),
+                        tp->tx_ring[1].NextHwDesCloPtr,
+                        tp->tx_ring[1].BeginHwDesCloPtr,
+                        rtl8126_get_hw_clo_ptr(&tp->tx_ring[1]),
+                        rtl8126_get_sw_tail_ptr(&tp->tx_ring[1]),
+                        tp->InitRxDescType,
+                        tp->RxDescLength,
+                        tp->num_rx_rings,
+                        tp->num_tx_rings,
+                        rtl8126_tot_rx_rings(tp),
+                        rtl8126_tot_tx_rings(tp),
+                        tp->HwSuppNumRxQueues,
+                        tp->HwSuppNumTxQueues,
+                        tp->EnableRss,
+                        tp->EnablePtp,
+                        tp->min_irq_nvecs,
+                        tp->irq_nvecs,
+                        tp->hw_supp_irq_nvecs,
+                        tp->ring_lib_enabled,
+                        tp->HwSuppIsrVer,
+                        tp->HwCurrIsrVer,
+                        tp->HwSuppMacMcuVer,
+                        tp->MacMcuPageSize,
+                        tp->hw_mcu_patch_code_ver,
+                        tp->bin_mcu_patch_code_ver,
+#ifdef ENABLE_PTP_SUPPORT
+                        tp->tx_hwtstamp_timeouts,
+                        tp->tx_hwtstamp_skipped,
+#endif
+                        tp->random_mac,
+                        tp->org_mac_addr,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+                        dev->perm_addr,
+#endif
+                        dev->dev_addr);
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_tally_counter(char *page, char **start,
+                                  off_t offset, int count,
+                                  int *eof, void *data)
+{
+        struct net_device *dev = data;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        struct rtl8126_counters *counters;
+        dma_addr_t paddr;
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump Tally Counter\n");
+
+        rtnl_lock();
+
+        counters = tp->tally_vaddr;
+        paddr = tp->tally_paddr;
+        if (!counters) {
+                len += snprintf(page + len, count - len,
+                                "\nDump Tally Counter Fail\n");
+                goto out_unlock;
+        }
+
+        rtl8126_dump_tally_counter(tp, paddr);
+
+        len += snprintf(page + len, count - len,
+                        "Statistics\tValue\n----------\t-----\n");
+
+        len += snprintf(page + len, count - len,
+                        "tx_packets\t%lld\n"
+                        "rx_packets\t%lld\n"
+                        "tx_errors\t%lld\n"
+                        "rx_errors\t%d\n"
+                        "rx_missed\t%d\n"
+                        "align_errors\t%d\n"
+                        "tx_one_collision\t%d\n"
+                        "tx_multi_collision\t%d\n"
+                        "rx_unicast\t%lld\n"
+                        "rx_broadcast\t%lld\n"
+                        "rx_multicast\t%d\n"
+                        "tx_aborted\t%d\n"
+                        "tx_underrun\t%d\n"
+
+                        "tx_octets\t%lld\n"
+                        "rx_octets\t%lld\n"
+                        "rx_multicast64\t%lld\n"
+                        "tx_unicast64\t%lld\n"
+                        "tx_broadcast64\t%lld\n"
+                        "tx_multicast64\t%lld\n"
+                        "tx_pause_on\t%d\n"
+                        "tx_pause_off\t%d\n"
+                        "tx_pause_all\t%d\n"
+                        "tx_deferred\t%d\n"
+                        "tx_late_collision\t%d\n"
+                        "tx_all_collision\t%d\n"
+                        "tx_aborted32\t%d\n"
+                        "align_errors32\t%d\n"
+                        "rx_frame_too_long\t%d\n"
+                        "rx_runt\t%d\n"
+                        "rx_pause_on\t%d\n"
+                        "rx_pause_off\t%d\n"
+                        "rx_pause_all\t%d\n"
+                        "rx_unknown_opcode\t%d\n"
+                        "rx_mac_error\t%d\n"
+                        "tx_underrun32\t%d\n"
+                        "rx_mac_missed\t%d\n"
+                        "rx_tcam_dropped\t%d\n"
+                        "tdu\t%d\n"
+                        "rdu\t%d\n",
+                        le64_to_cpu(counters->tx_packets),
+                        le64_to_cpu(counters->rx_packets),
+                        le64_to_cpu(counters->tx_errors),
+                        le32_to_cpu(counters->rx_errors),
+                        le16_to_cpu(counters->rx_missed),
+                        le16_to_cpu(counters->align_errors),
+                        le32_to_cpu(counters->tx_one_collision),
+                        le32_to_cpu(counters->tx_multi_collision),
+                        le64_to_cpu(counters->rx_unicast),
+                        le64_to_cpu(counters->rx_broadcast),
+                        le32_to_cpu(counters->rx_multicast),
+                        le16_to_cpu(counters->tx_aborted),
+                        le16_to_cpu(counters->tx_underrun),
+
+                        le64_to_cpu(counters->tx_octets),
+                        le64_to_cpu(counters->rx_octets),
+                        le64_to_cpu(counters->rx_multicast64),
+                        le64_to_cpu(counters->tx_unicast64),
+                        le64_to_cpu(counters->tx_broadcast64),
+                        le64_to_cpu(counters->tx_multicast64),
+                        le32_to_cpu(counters->tx_pause_on),
+                        le32_to_cpu(counters->tx_pause_off),
+                        le32_to_cpu(counters->tx_pause_all),
+                        le32_to_cpu(counters->tx_deferred),
+                        le32_to_cpu(counters->tx_late_collision),
+                        le32_to_cpu(counters->tx_all_collision),
+                        le32_to_cpu(counters->tx_aborted32),
+                        le32_to_cpu(counters->align_errors32),
+                        le32_to_cpu(counters->rx_frame_too_long),
+                        le32_to_cpu(counters->rx_runt),
+                        le32_to_cpu(counters->rx_pause_on),
+                        le32_to_cpu(counters->rx_pause_off),
+                        le32_to_cpu(counters->rx_pause_all),
+                        le32_to_cpu(counters->rx_unknown_opcode),
+                        le32_to_cpu(counters->rx_mac_error),
+                        le32_to_cpu(counters->tx_underrun32),
+                        le32_to_cpu(counters->rx_mac_missed),
+                        le32_to_cpu(counters->rx_tcam_dropped),
+                        le32_to_cpu(counters->tdu),
+                        le32_to_cpu(counters->rdu));
+
+        len += snprintf(page + len, count - len, "\n");
+out_unlock:
+        rtnl_unlock();
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_registers(char *page, char **start,
+                              off_t offset, int count,
+                              int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8126_MAC_REGS_SIZE;
+        u8 byte_rd;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump MAC Registers\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%04x:\t",
+                                n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        len += snprintf(page + len, count - len,
+                                        "%02x ",
+                                        byte_rd);
+                }
+        }
+
+        max = 0xB00;
+        for (n = 0xA00; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%04x:\t",
+                                n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        len += snprintf(page + len, count - len,
+                                        "%02x ",
+                                        byte_rd);
+                }
+        }
+
+        max = 0xD40;
+        for (n = 0xD00; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%04x:\t",
+                                n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        len += snprintf(page + len, count - len,
+                                        "%02x ",
+                                        byte_rd);
+                }
+        }
+
+        max = 0x2840;
+        for (n = 0x2800; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%04x:\t",
+                                n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        len += snprintf(page + len, count - len,
+                                        "%02x ",
+                                        byte_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_all_registers(char *page, char **start,
+                                  off_t offset, int count,
+                                  int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max;
+        u8 byte_rd;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+        struct pci_dev *pdev = tp->pci_dev;
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump All MAC Registers\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        max = pci_resource_len(pdev, 2);
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%04x:\t",
+                                n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        len += snprintf(page + len, count - len,
+                                        "%02x ",
+                                        byte_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\nTotal length:0x%X", max);
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_pcie_phy(char *page, char **start,
+                             off_t offset, int count,
+                             int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8126_EPHY_REGS_SIZE/2;
+        u16 word_rd;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump PCIE PHY\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%02x:\t",
+                                n);
+
+                for (i = 0; i < 8 && n < max; i++, n++) {
+                        word_rd = rtl8126_ephy_read(tp, n);
+                        len += snprintf(page + len, count - len,
+                                        "%04x ",
+                                        word_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_eth_phy(char *page, char **start,
+                            off_t offset, int count,
+                            int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8126_PHY_REGS_SIZE/2;
+        unsigned long flags;
+        u16 word_rd;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump Ethernet PHY\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        len += snprintf(page + len, count - len,
+                        "\n####################page 0##################\n");
+        rtl8126_mdio_write(tp, 0x1f, 0x0000);
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%02x:\t",
+                                n);
+
+                for (i = 0; i < 8 && n < max; i++, n++) {
+                        word_rd = rtl8126_mdio_read(tp, n);
+                        len += snprintf(page + len, count - len,
+                                        "%04x ",
+                                        word_rd);
+                }
+        }
+
+        len += snprintf(page + len, count - len,
+                        "\n####################extra reg##################\n");
+        n = 0xA400;
+        len += snprintf(page + len, count - len,
+                        "\n0x%02x:\t",
+                        n);
+        for (i = 0; i < 8; i++, n+=2) {
+                word_rd = rtl8126_mdio_direct_read_phy_ocp(tp, n);
+                len += snprintf(page + len, count - len,
+                                "%04x ",
+                                word_rd);
+        }
+
+        n = 0xA410;
+        len += snprintf(page + len, count - len,
+                        "\n0x%02x:\t",
+                        n);
+        for (i = 0; i < 3; i++, n+=2) {
+                word_rd = rtl8126_mdio_direct_read_phy_ocp(tp, n);
+                len += snprintf(page + len, count - len,
+                                "%04x ",
+                                word_rd);
+        }
+
+        n = 0xA434;
+        len += snprintf(page + len, count - len,
+                        "\n0x%02x:\t",
+                        n);
+        word_rd = rtl8126_mdio_direct_read_phy_ocp(tp, n);
+        len += snprintf(page + len, count - len,
+                        "%04x ",
+                        word_rd);
+
+        n = 0xA5D0;
+        len += snprintf(page + len, count - len,
+                        "\n0x%02x:\t",
+                        n);
+        for (i = 0; i < 4; i++, n+=2) {
+                word_rd = rtl8126_mdio_direct_read_phy_ocp(tp, n);
+                len += snprintf(page + len, count - len,
+                                "%04x ",
+                                word_rd);
+        }
+
+        n = 0xA61A;
+        len += snprintf(page + len, count - len,
+                        "\n0x%02x:\t",
+                        n);
+        word_rd = rtl8126_mdio_direct_read_phy_ocp(tp, n);
+        len += snprintf(page + len, count - len,
+                        "%04x ",
+                        word_rd);
+
+        n = 0xA6D0;
+        len += snprintf(page + len, count - len,
+                        "\n0x%02x:\t",
+                        n);
+        for (i = 0; i < 3; i++, n+=2) {
+                word_rd = rtl8126_mdio_direct_read_phy_ocp(tp, n);
+                len += snprintf(page + len, count - len,
+                                "%04x ",
+                                word_rd);
+        }
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_extended_registers(char *page, char **start,
+                                       off_t offset, int count,
+                                       int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8126_ERI_REGS_SIZE;
+        u32 dword_rd;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump Extended Registers\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%02x:\t",
+                                n);
+
+                for (i = 0; i < 4 && n < max; i++, n+=4) {
+                        dword_rd = rtl8126_eri_read(tp, n, 4, ERIAR_ExGMAC);
+                        len += snprintf(page + len, count - len,
+                                        "%08x ",
+                                        dword_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_pci_registers(char *page, char **start,
+                                  off_t offset, int count,
+                                  int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8126_PCI_REGS_SIZE;
+        u32 dword_rd;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump PCI Registers\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%03x:\t",
+                                n);
+
+                for (i = 0; i < 4 && n < max; i++, n+=4) {
+                        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+                        len += snprintf(page + len, count - len,
+                                        "%08x ",
+                                        dword_rd);
+                }
+        }
+
+        n = 0x110;
+        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+        len += snprintf(page + len, count - len,
+                        "\n0x%03x:\t%08x ",
+                        n,
+                        dword_rd);
+        n = 0x70c;
+        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+        len += snprintf(page + len, count - len,
+                        "\n0x%03x:\t%08x ",
+                        n,
+                        dword_rd);
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_temperature(char *page, char **start,
+                                off_t offset, int count,
+                                int *eof, void *data)
+{
+        struct net_device *dev = data;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u16 ts_digout, tj, fah;
+        unsigned long flags;
+        int len = 0;
+
+        rtnl_lock();
+
+        if (!rtl8126_sysfs_testmode_on(tp)) {
+                len += snprintf(page + len, count - len,
+                                "\nPlease turn on ""/sys/class/net/<iface>/rtk_adv/testmode"".\n\n");
+                goto out_unlock;
+        }
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+        ts_digout = rtl8126_read_thermal_sensor(tp);
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        if (ts_digout <= 512) {
+                tj = ts_digout / 2;
+                len += snprintf(page + len, count - len,
+                                "Cel:%d\n",
+                                tj);
+                fah = tj * (9/5) + 32;
+                len += snprintf(page + len, count - len,
+                                "Fah:%d\n",
+                                fah);
+
+        } else {
+                tj = (512 - (ts_digout - 512)) / 2;
+                len += snprintf(page + len, count - len,
+                                "Cel:-%d\n",
+                                tj);
+                fah = tj * (9/5) + 32;
+                len += snprintf(page + len, count - len,
+                                "Fah:-%d\n",
+                                fah);
+        }
+
+        len += snprintf(page + len, count - len, "\n");
+
+out_unlock:
+        rtnl_unlock();
+
+        *eof = 1;
+        return len;
+}
+
+static int _proc_get_cable_info(char *page, char **start,
+                                off_t offset, int count,
+                                int *eof, void *data,
+                                bool poe_mode)
+{
+        int i;
+        u32 status;
+        int len = 0;
+        struct net_device *dev = data;
+        int cp_status[RTL8126_CP_NUM] = {0};
+        int cp_len[RTL8126_CP_NUM] = {0};
+        struct rtl8126_private *tp = netdev_priv(dev);
+        const char *pair_str[RTL8126_CP_NUM] = {"1-2", "3-6", "4-5", "7-8"};
+        unsigned long flags;
+
+        switch (tp->mcfg) {
+        default:
+                return -EOPNOTSUPP;
+        }
+
+        rtnl_lock();
+
+        if (!rtl8126_sysfs_testmode_on(tp)) {
+                len += snprintf(page + len, count - len,
+                                "\nPlease turn on ""/sys/class/net/<iface>/rtk_adv/testmode"".\n\n");
+                goto out_unlock;
+        }
+
+        status = rtl8126_get_phy_status(tp);
+        if (status & LinkStatus)
+                len += snprintf(page + len, count - len,
+                                "\nlink speed:%d",
+                                rtl8126_convert_link_speed(status));
+        else
+                len += snprintf(page + len, count - len,
+                                "\nlink status:off");
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        rtl8126_get_cp_len(tp, cp_len);
+
+        rtl8126_get_cp_status(tp, cp_status, poe_mode);
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        len += snprintf(page + len, count - len,
+                        "\npair\tlength\tstatus   \tpp\n");
+
+        for (i=0; i<RTL8126_CP_NUM; i++) {
+                if (cp_len[i] < 0)
+                        len += snprintf(page + len, count - len,
+                                        "%s\t%s\t%s\t",
+                                        pair_str[i], "none",
+                                        rtl8126_get_cp_status_string(cp_status[i]));
+                else
+                        len += snprintf(page + len, count - len,
+                                        "%s\t%d\t%s\t",
+                                        pair_str[i], cp_len[i],
+                                        rtl8126_get_cp_status_string(cp_status[i]));
+                if (cp_status[i] == rtl8126_cp_normal)
+                        len += snprintf(page + len, count - len, "none\n");
+                else
+                        len += snprintf(page + len, count - len, "%dm\n",
+                                        rtl8126_get_cp_pp(tp, i));
+        }
+
+        len += snprintf(page + len, count - len, "\n");
+
+out_unlock:
+        rtnl_unlock();
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_cable_info(char *page, char **start,
+                               off_t offset, int count,
+                               int *eof, void *data)
+{
+        return _proc_get_cable_info(page, start, offset, count, eof, data, 0);
+}
+
+static int proc_get_poe_cable_info(char *page, char **start,
+                                   off_t offset, int count,
+                                   int *eof, void *data)
+{
+        return _proc_get_cable_info(page, start, offset, count, eof, data, 1);
+}
+
+static void _proc_dump_desc(char *page, int *page_len, int *count, void *desc_base,
+                            u32 alloc_size)
+{
+        u32 *pdword;
+        int i, len;
+
+        if (desc_base == NULL ||
+            alloc_size == 0)
+                return;
+
+        len = *page_len;
+        pdword = (u32*)desc_base;
+        for (i=0; i<(alloc_size/4); i++) {
+                if (!(i % 4))
+                        len += snprintf(page + len, *count - len,
+                                        "\n%04x ",
+                                        i);
+                len += snprintf(page + len, *count - len,
+                                "%08x ",
+                                pdword[i]);
+        }
+
+        len += snprintf(page + len, *count - len, "\n");
+
+        *page_len = len;
+        return;
+}
+
+static int proc_dump_rx_desc(char *page, char **start,
+                             off_t offset, int count,
+                             int *eof, void *data)
+{
+        int i;
+        int len = 0;
+        struct net_device *dev = data;
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        rtnl_lock();
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8126_rx_ring *ring = &tp->rx_ring[i];
+
+                if (!ring)
+                        continue;
+
+                len += snprintf(page + len, count - len,
+                                "\ndump rx %d desc:%d",
+                                i, ring->num_rx_desc);
+
+                _proc_dump_desc(page, &len, &count,
+                                ring->RxDescArray,
+                                ring->RxDescAllocSize);
+        }
+
+#ifdef ENABLE_LIB_SUPPORT
+        if (rtl8126_num_lib_rx_rings(tp) > 0) {
+                for (i = 0; i < tp->HwSuppNumRxQueues; i++) {
+                        struct rtl8126_ring *lib_ring = &tp->lib_rx_ring[i];
+                        if (lib_ring->enabled) {
+                                len += snprintf(page + len, count - len,
+                                                "\ndump lib rx %d desc:%d",
+                                                i,
+                                                ring->ring_size);
+                                _proc_dump_desc(page, &len, &count,
+                                                (void*)lib_ring->desc_addr,
+                                                lib_ring->desc_size);
+                        }
+                }
+        }
+#endif //ENABLE_LIB_SUPPORT
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+
+        return len;
+}
+
+static int proc_dump_tx_desc(char *page, char **start,
+                             off_t offset, int count,
+                             int *eof, void *data)
+{
+        int len = 0;
+        struct net_device *dev = data;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i;
+
+        rtnl_lock();
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8126_tx_ring *ring = &tp->tx_ring[i];
+
+                if (!ring)
+                        continue;
+
+                len += snprintf(page + len, count - len,
+                                "\ndump tx desc:%d",
+                                ring->num_tx_desc);
+
+                _proc_dump_desc(page, &len, &count,
+                                ring->TxDescArray,
+                                ring->TxDescAllocSize);
+        }
+
+#ifdef ENABLE_LIB_SUPPORT
+        if (rtl8126_num_lib_tx_rings(tp) > 0) {
+                for (i = 0; i < tp->HwSuppNumTxQueues; i++) {
+                        struct rtl8126_ring *lib_ring = &tp->lib_tx_ring[i];
+                        if (lib_ring->enabled) {
+                                len += snprintf(page + len, count - len,
+                                                "\ndump lib tx %d desc:%d",
+                                                i,
+                                                ring->ring_size);
+                                _proc_dump_desc(page, &len, &count,
+                                                (void*)lib_ring->desc_addr,
+                                                lib_ring->desc_size);
+                        }
+                }
+        }
+#endif //ENABLE_LIB_SUPPORT
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+
+        return len;
+}
+
+static int proc_dump_msix_tbl(char *page, char **start,
+                              off_t offset, int count,
+                              int *eof, void *data)
+{
+        int i, j;
+        int len = 0;
+        void __iomem *ioaddr;
+        struct net_device *dev = data;
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        /* ioremap MMIO region */
+        ioaddr = ioremap(pci_resource_start(tp->pci_dev, 4), pci_resource_len(tp->pci_dev, 4));
+        if (!ioaddr)
+                return -EFAULT;
+
+        rtnl_lock();
+
+        len += snprintf(page + len, count - len,
+                        "\ndump MSI-X Table. Total Entry %d. \n",
+                        tp->hw_supp_irq_nvecs);
+
+        for (i=0; i<tp->hw_supp_irq_nvecs; i++) {
+                len += snprintf(page + len, count - len,
+                                "\n%04x ", i);
+                for (j=0; j<4; j++)
+                        len += snprintf(page + len, count - len, "%08x ",
+                                        readl(ioaddr + i*0x10 + 4*j));
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return 0;
+}
+
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+
+static void rtl8126_proc_module_init(void)
+{
+        //create /proc/net/r8126
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+        rtl8126_proc = proc_mkdir(MODULENAME, init_net.proc_net);
+#else
+        rtl8126_proc = proc_mkdir(MODULENAME, proc_net);
+#endif
+        if (!rtl8126_proc)
+                dprintk("cannot create %s proc entry \n", MODULENAME);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+/*
+ * seq_file wrappers for procfile show routines.
+ */
+static int rtl8126_proc_open(struct inode *inode, struct file *file)
+{
+        struct net_device *dev = proc_get_parent_data(inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+        int (*show)(struct seq_file *, void *) = pde_data(inode);
+#else
+        int (*show)(struct seq_file *, void *) = PDE_DATA(inode);
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+
+        return single_open(file, show, dev);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+static const struct proc_ops rtl8126_proc_fops = {
+        .proc_open           = rtl8126_proc_open,
+        .proc_read           = seq_read,
+        .proc_lseek          = seq_lseek,
+        .proc_release        = single_release,
+};
+#else
+static const struct file_operations rtl8126_proc_fops = {
+        .open           = rtl8126_proc_open,
+        .read           = seq_read,
+        .llseek         = seq_lseek,
+        .release        = single_release,
+};
+#endif
+
+#endif
+
+/*
+ * Table of proc files we need to create.
+ */
+struct rtl8126_proc_file {
+        char name[16];
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+        int (*show)(struct seq_file *, void *);
+#else
+        int (*show)(char *, char **, off_t, int, int *, void *);
+#endif
+};
+
+static const struct rtl8126_proc_file rtl8126_debug_proc_files[] = {
+        { "driver_var", &proc_get_driver_variable },
+        { "tally", &proc_get_tally_counter },
+        { "registers", &proc_get_registers },
+        { "registers2", &proc_get_all_registers },
+        { "pcie_phy", &proc_get_pcie_phy },
+        { "eth_phy", &proc_get_eth_phy },
+        { "ext_regs", &proc_get_extended_registers },
+        { "pci_regs", &proc_get_pci_registers },
+        { "tx_desc", &proc_dump_tx_desc },
+        { "rx_desc", &proc_dump_rx_desc },
+        { "msix_tbl", &proc_dump_msix_tbl },
+        { "", NULL }
+};
+
+static const struct rtl8126_proc_file rtl8126_test_proc_files[] = {
+        { "temp", &proc_get_temperature },
+        { "cdt", &proc_get_cable_info },
+        { "cdt_poe", &proc_get_poe_cable_info },
+        { "", NULL }
+};
+
+#define R8126_PROC_DEBUG_DIR "debug"
+#define R8126_PROC_TEST_DIR "test"
+
+static void rtl8126_proc_init(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        const struct rtl8126_proc_file *f;
+        struct proc_dir_entry *dir;
+
+        if (!rtl8126_proc)
+                return;
+
+        if (tp->proc_dir_debug || tp->proc_dir_test)
+                return;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+        dir = proc_mkdir_data(dev->name, 0, rtl8126_proc, dev);
+        if (!dir) {
+                printk("Unable to initialize /proc/net/%s/%s\n",
+                       MODULENAME, dev->name);
+                return;
+        }
+        tp->proc_dir = dir;
+        proc_init_num++;
+
+        /* create debug entry */
+        dir = proc_mkdir_data(R8126_PROC_DEBUG_DIR, 0, tp->proc_dir, dev);
+        if (!dir) {
+                printk("Unable to initialize /proc/net/%s/%s/%s\n",
+                       MODULENAME, dev->name, R8126_PROC_DEBUG_DIR);
+                return;
+        }
+
+        tp->proc_dir_debug = dir;
+        for (f = rtl8126_debug_proc_files; f->name[0]; f++) {
+                if (!proc_create_data(f->name, S_IFREG | S_IRUGO, dir,
+                                      &rtl8126_proc_fops, f->show)) {
+                        printk("Unable to initialize "
+                               "/proc/net/%s/%s/%s/%s\n",
+                               MODULENAME, dev->name, R8126_PROC_DEBUG_DIR,
+                               f->name);
+                        return;
+                }
+        }
+
+        /* create test entry */
+        dir = proc_mkdir_data(R8126_PROC_TEST_DIR, 0, tp->proc_dir, dev);
+        if (!dir) {
+                printk("Unable to initialize /proc/net/%s/%s/%s\n",
+                       MODULENAME, dev->name, R8126_PROC_TEST_DIR);
+                return;
+        }
+
+        tp->proc_dir_test = dir;
+        for (f = rtl8126_test_proc_files; f->name[0]; f++) {
+                if (!proc_create_data(f->name, S_IFREG | S_IRUGO, dir,
+                                      &rtl8126_proc_fops, f->show)) {
+                        printk("Unable to initialize "
+                               "/proc/net/%s/%s/%s/%s\n",
+                               MODULENAME, dev->name, R8126_PROC_TEST_DIR,
+                               f->name);
+                        return;
+                }
+        }
+#else
+        dir = proc_mkdir(dev->name, rtl8126_proc);
+        if (!dir) {
+                printk("Unable to initialize /proc/net/%s/%s\n",
+                       MODULENAME, dev->name);
+                return;
+        }
+
+        tp->proc_dir = dir;
+        proc_init_num++;
+
+        /* create debug entry */
+        dir = proc_mkdir(R8126_PROC_DEBUG_DIR, tp->proc_dir);
+        if (!dir) {
+                printk("Unable to initialize /proc/net/%s/%s/%s\n",
+                       MODULENAME, dev->name, R8126_PROC_DEBUG_DIR);
+                return;
+        }
+
+        tp->proc_dir_debug = dir;
+        for (f = rtl8126_debug_proc_files; f->name[0]; f++) {
+                if (!create_proc_read_entry(f->name, S_IFREG | S_IRUGO,
+                                            dir, f->show, dev)) {
+                        printk("Unable to initialize "
+                               "/proc/net/%s/%s/%s/%s\n",
+                               MODULENAME, dev->name, R8126_PROC_DEBUG_DIR,
+                               f->name);
+                        return;
+                }
+        }
+
+        /* create test entry */
+        dir = proc_mkdir(R8126_PROC_TEST_DIR, tp->proc_dir);
+        if (!dir) {
+                printk("Unable to initialize /proc/net/%s/%s/%s\n",
+                       MODULENAME, dev->name, R8126_PROC_TEST_DIR);
+                return;
+        }
+
+        tp->proc_dir_test = dir;
+        for (f = rtl8126_test_proc_files; f->name[0]; f++) {
+                if (!create_proc_read_entry(f->name, S_IFREG | S_IRUGO,
+                                            dir, f->show, dev)) {
+                        printk("Unable to initialize "
+                               "/proc/net/%s/%s/%s/%s\n",
+                               MODULENAME, dev->name, R8126_PROC_TEST_DIR,
+                               f->name);
+                        return;
+                }
+        }
+#endif
+}
+
+static void rtl8126_proc_remove(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (tp->proc_dir) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+                remove_proc_subtree(dev->name, rtl8126_proc);
+#else
+                const struct rtl8126_proc_file *f;
+                struct rtl8126_private *tp = netdev_priv(dev);
+
+                if (tp->proc_dir_debug) {
+                        for (f = rtl8126_debug_proc_files; f->name[0]; f++)
+                                remove_proc_entry(f->name, tp->proc_dir_debug);
+                        remove_proc_entry(R8126_PROC_DEBUG_DIR, tp->proc_dir);
+                }
+
+                if (tp->proc_dir_test) {
+                        for (f = rtl8126_test_proc_files; f->name[0]; f++)
+                                remove_proc_entry(f->name, tp->proc_dir_test);
+                        remove_proc_entry(R8126_PROC_TEST_DIR, tp->proc_dir);
+                }
+
+                remove_proc_entry(dev->name, rtl8126_proc);
+#endif
+                proc_init_num--;
+
+                tp->proc_dir_debug = NULL;
+                tp->proc_dir_test = NULL;
+                tp->proc_dir = NULL;
+        }
+}
+
+#endif //ENABLE_R8126_PROCFS
+
+#ifdef ENABLE_R8126_SYSFS
+/****************************************************************************
+*   -----------------------------SYSFS STUFF-------------------------
+*****************************************************************************
+*/
+static ssize_t testmode_show(struct device *dev,
+                             struct device_attribute *attr, char *buf)
+{
+        struct net_device *netdev = to_net_dev(dev);
+        struct rtl8126_private *tp = netdev_priv(netdev);
+
+        sprintf(buf, "%u\n", tp->testmode);
+
+        return strlen(buf);
+}
+
+static ssize_t testmode_store(struct device *dev,
+                              struct device_attribute *attr,
+                              const char *buf, size_t count)
+{
+        struct net_device *netdev = to_net_dev(dev);
+        struct rtl8126_private *tp = netdev_priv(netdev);
+        u32 testmode;
+
+        if (sscanf(buf, "%u\n", &testmode) != 1)
+                return -EINVAL;
+
+        if (tp->testmode != testmode) {
+                rtnl_lock();
+                tp->testmode = testmode;
+                rtnl_unlock();
+        }
+
+        return count;
+}
+
+static DEVICE_ATTR_RW(testmode);
+
+static struct attribute *rtk_adv_attrs[] = {
+        &dev_attr_testmode.attr,
+        NULL
+};
+
+static struct attribute_group rtk_adv_grp = {
+        .name = "rtl_adv",
+        .attrs = rtk_adv_attrs,
+};
+
+static void rtl8126_sysfs_init(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int ret;
+
+        /* init rtl_adv */
+#ifdef ENABLE_LIB_SUPPORT
+        tp->testmode = 0;
+#else
+        tp->testmode = 1;
+#endif //ENABLE_LIB_SUPPORT
+
+        ret = sysfs_create_group(&dev->dev.kobj, &rtk_adv_grp);
+        if (ret < 0)
+                netif_warn(tp, probe, dev, "create rtk_adv_grp fail\n");
+        else
+                set_bit(R8126_SYSFS_RTL_ADV, tp->sysfs_flag);
+}
+
+static void rtl8126_sysfs_remove(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (test_and_clear_bit(R8126_SYSFS_RTL_ADV, tp->sysfs_flag))
+                sysfs_remove_group(&dev->dev.kobj, &rtk_adv_grp);
+}
+#endif //ENABLE_R8126_SYSFS
+
+static inline u16 map_phy_ocp_addr(u16 PageNum, u8 RegNum)
+{
+        u16 OcpPageNum = 0;
+        u8 OcpRegNum = 0;
+        u16 OcpPhyAddress = 0;
+
+        if (PageNum == 0) {
+                OcpPageNum = OCP_STD_PHY_BASE_PAGE + (RegNum / 8);
+                OcpRegNum = 0x10 + (RegNum % 8);
+        } else {
+                OcpPageNum = PageNum;
+                OcpRegNum = RegNum;
+        }
+
+        OcpPageNum <<= 4;
+
+        if (OcpRegNum < 16) {
+                OcpPhyAddress = 0;
+        } else {
+                OcpRegNum -= 16;
+                OcpRegNum <<= 1;
+
+                OcpPhyAddress = OcpPageNum + OcpRegNum;
+        }
+
+
+        return OcpPhyAddress;
+}
+
+static void mdio_real_direct_write_phy_ocp(struct rtl8126_private *tp,
+                u16 RegAddr,
+                u16 value)
+{
+        u32 data32;
+        int i;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(RegAddr % 2);
+#endif
+        data32 = RegAddr/2;
+        data32 <<= OCPR_Addr_Reg_shift;
+        data32 |= OCPR_Write | value;
+
+        RTL_W32(tp, PHYOCP, data32);
+        for (i = 0; i < R8126_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8126_CHANNEL_WAIT_TIME);
+
+                if (!(RTL_R32(tp, PHYOCP) & OCPR_Flag))
+                        break;
+        }
+}
+
+void rtl8126_mdio_direct_write_phy_ocp(struct rtl8126_private *tp,
+                                       u16 RegAddr,
+                                       u16 value)
+{
+        if (tp->rtk_enable_diag)
+                return;
+
+        mdio_real_direct_write_phy_ocp(tp, RegAddr, value);
+}
+
+/*
+static void rtl8126_mdio_write_phy_ocp(struct rtl8126_private *tp,
+                                       u16 PageNum,
+                                       u32 RegAddr,
+                                       u32 value)
+{
+        u16 ocp_addr;
+
+        ocp_addr = map_phy_ocp_addr(PageNum, RegAddr);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, ocp_addr, value);
+}
+*/
+
+static void rtl8126_mdio_real_write_phy_ocp(struct rtl8126_private *tp,
+                u16 PageNum,
+                u32 RegAddr,
+                u32 value)
+{
+        u16 ocp_addr;
+
+        ocp_addr = map_phy_ocp_addr(PageNum, RegAddr);
+
+        mdio_real_direct_write_phy_ocp(tp, ocp_addr, value);
+}
+
+static void mdio_real_write(struct rtl8126_private *tp,
+                            u16 RegAddr,
+                            u16 value)
+{
+        if (RegAddr == 0x1F) {
+                tp->cur_page = value;
+                return;
+        }
+        rtl8126_mdio_real_write_phy_ocp(tp, tp->cur_page, RegAddr, value);
+}
+
+void rtl8126_mdio_write(struct rtl8126_private *tp,
+                        u16 RegAddr,
+                        u16 value)
+{
+        if (tp->rtk_enable_diag)
+                return;
+
+        mdio_real_write(tp, RegAddr, value);
+}
+
+void rtl8126_mdio_prot_write(struct rtl8126_private *tp,
+                             u32 RegAddr,
+                             u32 value)
+{
+        mdio_real_write(tp, RegAddr, value);
+}
+
+void rtl8126_mdio_prot_direct_write_phy_ocp(struct rtl8126_private *tp,
+                u32 RegAddr,
+                u32 value)
+{
+        mdio_real_direct_write_phy_ocp(tp, RegAddr, value);
+}
+
+static u32 mdio_real_direct_read_phy_ocp(struct rtl8126_private *tp,
+                u16 RegAddr)
+{
+        u32 data32;
+        int i, value = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(RegAddr % 2);
+#endif
+        data32 = RegAddr/2;
+        data32 <<= OCPR_Addr_Reg_shift;
+
+        RTL_W32(tp, PHYOCP, data32);
+        for (i = 0; i < R8126_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8126_CHANNEL_WAIT_TIME);
+
+                if (RTL_R32(tp, PHYOCP) & OCPR_Flag)
+                        break;
+        }
+        value = RTL_R32(tp, PHYOCP) & OCPDR_Data_Mask;
+
+        return value;
+}
+
+u32 rtl8126_mdio_direct_read_phy_ocp(struct rtl8126_private *tp,
+                                     u16 RegAddr)
+{
+        if (tp->rtk_enable_diag)
+                return 0xffffffff;
+
+        return mdio_real_direct_read_phy_ocp(tp, RegAddr);
+}
+
+/*
+static u32 rtl8126_mdio_read_phy_ocp(struct rtl8126_private *tp,
+                                     u16 PageNum,
+                                     u32 RegAddr)
+{
+        u16 ocp_addr;
+
+        ocp_addr = map_phy_ocp_addr(PageNum, RegAddr);
+
+        return rtl8126_mdio_direct_read_phy_ocp(tp, ocp_addr);
+}
+*/
+
+static u32 rtl8126_mdio_real_read_phy_ocp(struct rtl8126_private *tp,
+                u16 PageNum,
+                u32 RegAddr)
+{
+        u16 ocp_addr;
+
+        ocp_addr = map_phy_ocp_addr(PageNum, RegAddr);
+
+        return mdio_real_direct_read_phy_ocp(tp, ocp_addr);
+}
+
+static u32 mdio_real_read(struct rtl8126_private *tp,
+                          u16 RegAddr)
+{
+        return rtl8126_mdio_real_read_phy_ocp(tp, tp->cur_page, RegAddr);
+}
+
+u32 rtl8126_mdio_read(struct rtl8126_private *tp,
+                      u16 RegAddr)
+{
+        if (tp->rtk_enable_diag)
+                return 0xffffffff;
+
+        return mdio_real_read(tp, RegAddr);
+}
+
+u32 rtl8126_mdio_prot_read(struct rtl8126_private *tp,
+                           u32 RegAddr)
+{
+        return mdio_real_read(tp, RegAddr);
+}
+
+u32 rtl8126_mdio_prot_direct_read_phy_ocp(struct rtl8126_private *tp,
+                u32 RegAddr)
+{
+        return mdio_real_direct_read_phy_ocp(tp, RegAddr);
+}
+
+static void rtl8126_clear_and_set_eth_phy_bit(struct rtl8126_private *tp, u8  addr, u16 clearmask, u16 setmask)
+{
+        u16 PhyRegValue;
+
+        PhyRegValue = rtl8126_mdio_read(tp, addr);
+        PhyRegValue &= ~clearmask;
+        PhyRegValue |= setmask;
+        rtl8126_mdio_write(tp, addr, PhyRegValue);
+}
+
+void rtl8126_clear_eth_phy_bit(struct rtl8126_private *tp, u8 addr, u16 mask)
+{
+        rtl8126_clear_and_set_eth_phy_bit(tp,
+                                          addr,
+                                          mask,
+                                          0);
+}
+
+void rtl8126_set_eth_phy_bit(struct rtl8126_private *tp,  u8  addr, u16  mask)
+{
+        rtl8126_clear_and_set_eth_phy_bit(tp,
+                                          addr,
+                                          0,
+                                          mask);
+}
+
+void rtl8126_clear_and_set_eth_phy_ocp_bit(struct rtl8126_private *tp, u16 addr, u16 clearmask, u16 setmask)
+{
+        u16 PhyRegValue;
+
+        PhyRegValue = rtl8126_mdio_direct_read_phy_ocp(tp, addr);
+        PhyRegValue &= ~clearmask;
+        PhyRegValue |= setmask;
+        rtl8126_mdio_direct_write_phy_ocp(tp, addr, PhyRegValue);
+}
+
+void rtl8126_clear_eth_phy_ocp_bit(struct rtl8126_private *tp, u16 addr, u16 mask)
+{
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              addr,
+                                              mask,
+                                              0);
+}
+
+void rtl8126_set_eth_phy_ocp_bit(struct rtl8126_private *tp,  u16 addr, u16 mask)
+{
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              addr,
+                                              0,
+                                              mask);
+}
+
+void rtl8126_mac_ocp_write(struct rtl8126_private *tp, u16 reg_addr, u16 value)
+{
+        u32 data32;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(reg_addr % 2);
+#endif
+
+        data32 = reg_addr/2;
+        data32 <<= OCPR_Addr_Reg_shift;
+        data32 += value;
+        data32 |= OCPR_Write;
+
+        RTL_W32(tp, MACOCP, data32);
+}
+
+u16 rtl8126_mac_ocp_read(struct rtl8126_private *tp, u16 reg_addr)
+{
+        u32 data32;
+        u16 data16 = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(reg_addr % 2);
+#endif
+
+        data32 = reg_addr/2;
+        data32 <<= OCPR_Addr_Reg_shift;
+
+        RTL_W32(tp, MACOCP, data32);
+        data16 = (u16)RTL_R32(tp, MACOCP);
+
+        return data16;
+}
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+static void mac_mcu_write(struct rtl8126_private *tp, u16 reg, u16 value)
+{
+        if (reg == 0x1f) {
+                tp->ocp_base = value << 4;
+                return;
+        }
+
+        rtl8126_mac_ocp_write(tp, tp->ocp_base + reg, value);
+}
+
+static u32 mac_mcu_read(struct rtl8126_private *tp, u16 reg)
+{
+        return rtl8126_mac_ocp_read(tp, tp->ocp_base + reg);
+}
+#endif
+
+static void
+rtl8126_clear_set_mac_ocp_bit(
+        struct rtl8126_private *tp,
+        u16   addr,
+        u16   clearmask,
+        u16   setmask
+)
+{
+        u16 PhyRegValue;
+
+        PhyRegValue = rtl8126_mac_ocp_read(tp, addr);
+        PhyRegValue &= ~clearmask;
+        PhyRegValue |= setmask;
+        rtl8126_mac_ocp_write(tp, addr, PhyRegValue);
+}
+
+void
+rtl8126_clear_mac_ocp_bit(
+        struct rtl8126_private *tp,
+        u16   addr,
+        u16   mask
+)
+{
+        rtl8126_clear_set_mac_ocp_bit(tp,
+                                      addr,
+                                      mask,
+                                      0);
+}
+
+void
+rtl8126_set_mac_ocp_bit(
+        struct rtl8126_private *tp,
+        u16   addr,
+        u16   mask
+)
+{
+        rtl8126_clear_set_mac_ocp_bit(tp,
+                                      addr,
+                                      0,
+                                      mask);
+}
+
+void rtl8126_ephy_write(struct rtl8126_private *tp, int RegAddr, int value)
+{
+        int i;
+
+        RTL_W32(tp, EPHYAR,
+                EPHYAR_Write |
+                (RegAddr & EPHYAR_Reg_Mask_v2) << EPHYAR_Reg_shift |
+                (value & EPHYAR_Data_Mask));
+
+        for (i = 0; i < R8126_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8126_CHANNEL_WAIT_TIME);
+
+                /* Check if the RTL8125 has completed EPHY write */
+                if (!(RTL_R32(tp, EPHYAR) & EPHYAR_Flag))
+                        break;
+        }
+
+        udelay(R8126_CHANNEL_EXIT_DELAY_TIME);
+}
+
+u16 rtl8126_ephy_read(struct rtl8126_private *tp, int RegAddr)
+{
+        int i;
+        u16 value = 0xffff;
+
+        RTL_W32(tp, EPHYAR,
+                EPHYAR_Read | (RegAddr & EPHYAR_Reg_Mask_v2) << EPHYAR_Reg_shift);
+
+        for (i = 0; i < R8126_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8126_CHANNEL_WAIT_TIME);
+
+                /* Check if the RTL8125 has completed EPHY read */
+                if (RTL_R32(tp, EPHYAR) & EPHYAR_Flag) {
+                        value = (u16) (RTL_R32(tp, EPHYAR) & EPHYAR_Data_Mask);
+                        break;
+                }
+        }
+
+        udelay(R8126_CHANNEL_EXIT_DELAY_TIME);
+
+        return value;
+}
+
+/*
+static void ClearAndSetPCIePhyBit(struct rtl8126_private *tp, u8 addr, u16 clearmask, u16 setmask)
+{
+        u16 EphyValue;
+
+        EphyValue = rtl8126_ephy_read(tp, addr);
+        EphyValue &= ~clearmask;
+        EphyValue |= setmask;
+        rtl8126_ephy_write(tp, addr, EphyValue);
+}
+
+static void ClearPCIePhyBit(struct rtl8126_private *tp, u8 addr, u16 mask)
+{
+        ClearAndSetPCIePhyBit(tp,
+                              addr,
+                              mask,
+                              0);
+}
+
+static void SetPCIePhyBit(struct rtl8126_private *tp, u8 addr, u16 mask)
+{
+        ClearAndSetPCIePhyBit(tp,
+                              addr,
+                              0,
+                              mask);
+}
+*/
+
+static u32
+rtl8126_csi_other_fun_read(struct rtl8126_private *tp,
+                           u8 multi_fun_sel_bit,
+                           u32 addr)
+{
+        u32 cmd;
+        int i;
+        u32 value = 0xffffffff;
+
+        cmd = CSIAR_Read | CSIAR_ByteEn << CSIAR_ByteEn_shift | (addr & CSIAR_Addr_Mask);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                multi_fun_sel_bit = 0;
+
+        if (multi_fun_sel_bit > 7)
+                goto exit;
+
+        cmd |= multi_fun_sel_bit << 16;
+
+        RTL_W32(tp, CSIAR, cmd);
+
+        for (i = 0; i < R8126_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8126_CHANNEL_WAIT_TIME);
+
+                /* Check if the RTL8125 has completed CSI read */
+                if (RTL_R32(tp, CSIAR) & CSIAR_Flag) {
+                        value = (u32)RTL_R32(tp, CSIDR);
+                        break;
+                }
+        }
+
+        udelay(R8126_CHANNEL_EXIT_DELAY_TIME);
+
+exit:
+        return value;
+}
+
+static void
+rtl8126_csi_other_fun_write(struct rtl8126_private *tp,
+                            u8 multi_fun_sel_bit,
+                            u32 addr,
+                            u32 value)
+{
+        u32 cmd;
+        int i;
+
+        RTL_W32(tp, CSIDR, value);
+        cmd = CSIAR_Write | CSIAR_ByteEn << CSIAR_ByteEn_shift | (addr & CSIAR_Addr_Mask);
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                multi_fun_sel_bit = 0;
+
+        if (multi_fun_sel_bit > 7)
+                return;
+
+        cmd |= multi_fun_sel_bit << 16;
+
+        RTL_W32(tp, CSIAR, cmd);
+
+        for (i = 0; i < R8126_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8126_CHANNEL_WAIT_TIME);
+
+                /* Check if the RTL8125 has completed CSI write */
+                if (!(RTL_R32(tp, CSIAR) & CSIAR_Flag))
+                        break;
+        }
+
+        udelay(R8126_CHANNEL_EXIT_DELAY_TIME);
+}
+
+static u32
+rtl8126_csi_read(struct rtl8126_private *tp,
+                 u32 addr)
+{
+        u8 multi_fun_sel_bit;
+
+        multi_fun_sel_bit = 0;
+
+        return rtl8126_csi_other_fun_read(tp, multi_fun_sel_bit, addr);
+}
+
+static void
+rtl8126_csi_write(struct rtl8126_private *tp,
+                  u32 addr,
+                  u32 value)
+{
+        u8 multi_fun_sel_bit;
+
+        multi_fun_sel_bit = 0;
+
+        rtl8126_csi_other_fun_write(tp, multi_fun_sel_bit, addr, value);
+}
+
+static u8
+rtl8126_csi_fun0_read_byte(struct rtl8126_private *tp,
+                           u32 addr)
+{
+        u8 RetVal = 0;
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT) {
+                struct pci_dev *pdev = tp->pci_dev;
+
+                pci_read_config_byte(pdev, addr, &RetVal);
+        } else {
+                u32 TmpUlong;
+                u16 RegAlignAddr;
+                u8 ShiftByte;
+
+                RegAlignAddr = addr & ~(0x3);
+                ShiftByte = addr & (0x3);
+                TmpUlong = rtl8126_csi_other_fun_read(tp, 0, RegAlignAddr);
+                TmpUlong >>= (8*ShiftByte);
+                RetVal = (u8)TmpUlong;
+        }
+
+        udelay(R8126_CHANNEL_EXIT_DELAY_TIME);
+
+        return RetVal;
+}
+
+static void
+rtl8126_csi_fun0_write_byte(struct rtl8126_private *tp,
+                            u32 addr,
+                            u8 value)
+{
+        if (tp->mcfg == CFG_METHOD_DEFAULT) {
+                struct pci_dev *pdev = tp->pci_dev;
+
+                pci_write_config_byte(pdev, addr, value);
+        } else {
+                u32 TmpUlong;
+                u16 RegAlignAddr;
+                u8 ShiftByte;
+
+                RegAlignAddr = addr & ~(0x3);
+                ShiftByte = addr & (0x3);
+                TmpUlong = rtl8126_csi_other_fun_read(tp, 0, RegAlignAddr);
+                TmpUlong &= ~(0xFF << (8*ShiftByte));
+                TmpUlong |= (value << (8*ShiftByte));
+                rtl8126_csi_other_fun_write(tp, 0, RegAlignAddr, TmpUlong);
+        }
+
+        udelay(R8126_CHANNEL_EXIT_DELAY_TIME);
+}
+
+u32 rtl8126_eri_read_with_oob_base_address(struct rtl8126_private *tp, int addr, int len, int type, const u32 base_address)
+{
+        int i, val_shift, shift = 0;
+        u32 value1 = 0, value2 = 0, mask;
+        u32 eri_cmd;
+        const u32 transformed_base_address = ((base_address & 0x00FFF000) << 6) | (base_address & 0x000FFF);
+
+        if (len > 4 || len <= 0)
+                return -1;
+
+        while (len > 0) {
+                val_shift = addr % ERIAR_Addr_Align;
+                addr = addr & ~0x3;
+
+                eri_cmd = ERIAR_Read |
+                          transformed_base_address |
+                          type << ERIAR_Type_shift |
+                          ERIAR_ByteEn << ERIAR_ByteEn_shift |
+                          (addr & 0x0FFF);
+                if (addr & 0xF000) {
+                        u32 tmp;
+
+                        tmp = addr & 0xF000;
+                        tmp >>= 12;
+                        eri_cmd |= (tmp << 20) & 0x00F00000;
+                }
+
+                RTL_W32(tp, ERIAR, eri_cmd);
+
+                for (i = 0; i < R8126_CHANNEL_WAIT_COUNT; i++) {
+                        udelay(R8126_CHANNEL_WAIT_TIME);
+
+                        /* Check if the RTL8125 has completed ERI read */
+                        if (RTL_R32(tp, ERIAR) & ERIAR_Flag)
+                                break;
+                }
+
+                if (len == 1)       mask = (0xFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else if (len == 2)  mask = (0xFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else if (len == 3)  mask = (0xFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else            mask = (0xFFFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+
+                value1 = RTL_R32(tp, ERIDR) & mask;
+                value2 |= (value1 >> val_shift * 8) << shift * 8;
+
+                if (len <= 4 - val_shift) {
+                        len = 0;
+                } else {
+                        len -= (4 - val_shift);
+                        shift = 4 - val_shift;
+                        addr += 4;
+                }
+        }
+
+        udelay(R8126_CHANNEL_EXIT_DELAY_TIME);
+
+        return value2;
+}
+
+u32 rtl8126_eri_read(struct rtl8126_private *tp, int addr, int len, int type)
+{
+        return rtl8126_eri_read_with_oob_base_address(tp, addr, len, type, 0);
+}
+
+int rtl8126_eri_write_with_oob_base_address(struct rtl8126_private *tp, int addr, int len, u32 value, int type, const u32 base_address)
+{
+        int i, val_shift, shift = 0;
+        u32 value1 = 0, mask;
+        u32 eri_cmd;
+        const u32 transformed_base_address = ((base_address & 0x00FFF000) << 6) | (base_address & 0x000FFF);
+
+        if (len > 4 || len <= 0)
+                return -1;
+
+        while (len > 0) {
+                val_shift = addr % ERIAR_Addr_Align;
+                addr = addr & ~0x3;
+
+                if (len == 1)       mask = (0xFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else if (len == 2)  mask = (0xFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else if (len == 3)  mask = (0xFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else            mask = (0xFFFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+
+                value1 = rtl8126_eri_read_with_oob_base_address(tp, addr, 4, type, base_address) & ~mask;
+                value1 |= ((value << val_shift * 8) >> shift * 8);
+
+                RTL_W32(tp, ERIDR, value1);
+
+                eri_cmd = ERIAR_Write |
+                          transformed_base_address |
+                          type << ERIAR_Type_shift |
+                          ERIAR_ByteEn << ERIAR_ByteEn_shift |
+                          (addr & 0x0FFF);
+                if (addr & 0xF000) {
+                        u32 tmp;
+
+                        tmp = addr & 0xF000;
+                        tmp >>= 12;
+                        eri_cmd |= (tmp << 20) & 0x00F00000;
+                }
+
+                RTL_W32(tp, ERIAR, eri_cmd);
+
+                for (i = 0; i < R8126_CHANNEL_WAIT_COUNT; i++) {
+                        udelay(R8126_CHANNEL_WAIT_TIME);
+
+                        /* Check if the RTL8125 has completed ERI write */
+                        if (!(RTL_R32(tp, ERIAR) & ERIAR_Flag))
+                                break;
+                }
+
+                if (len <= 4 - val_shift) {
+                        len = 0;
+                } else {
+                        len -= (4 - val_shift);
+                        shift = 4 - val_shift;
+                        addr += 4;
+                }
+        }
+
+        udelay(R8126_CHANNEL_EXIT_DELAY_TIME);
+
+        return 0;
+}
+
+int rtl8126_eri_write(struct rtl8126_private *tp, int addr, int len, u32 value, int type)
+{
+#define NO_BASE_ADDRESS 0x00000000
+        return rtl8126_eri_write_with_oob_base_address(tp, addr, len, value, type, NO_BASE_ADDRESS);
+}
+
+static void
+rtl8126_enable_rxdvgate(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) | BIT_3);
+}
+
+static void
+rtl8126_disable_rxdvgate(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) & ~BIT_3);
+}
+
+static u8
+rtl8126_is_gpio_low(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u8 gpio_low = FALSE;
+
+        switch (tp->HwSuppCheckPhyDisableModeVer) {
+        case 3:
+                if (!(rtl8126_mac_ocp_read(tp, 0xDC04) & BIT_13))
+                        gpio_low = TRUE;
+                break;
+        }
+
+        if (gpio_low)
+                dprintk("gpio is low.\n");
+
+        return gpio_low;
+}
+
+static u8
+rtl8126_is_phy_disable_mode_enabled(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u8 phy_disable_mode_enabled = FALSE;
+
+        switch (tp->HwSuppCheckPhyDisableModeVer) {
+        case 3:
+                if (RTL_R8(tp, 0xF2) & BIT_5)
+                        phy_disable_mode_enabled = TRUE;
+                break;
+        }
+
+        if (phy_disable_mode_enabled)
+                dprintk("phy disable mode enabled.\n");
+
+        return phy_disable_mode_enabled;
+}
+
+static u8
+rtl8126_is_in_phy_disable_mode(struct net_device *dev)
+{
+        u8 in_phy_disable_mode = FALSE;
+
+        if (rtl8126_is_phy_disable_mode_enabled(dev) && rtl8126_is_gpio_low(dev))
+                in_phy_disable_mode = TRUE;
+
+        if (in_phy_disable_mode)
+                dprintk("Hardware is in phy disable mode.\n");
+
+        return in_phy_disable_mode;
+}
+
+static void
+rtl8126_stop_all_request(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        RTL_W8(tp, ChipCmd, RTL_R8(tp, ChipCmd) | StopReq);
+        udelay(200);
+}
+
+static void
+rtl8126_clear_stop_all_request(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        RTL_W8(tp, ChipCmd, RTL_R8(tp, ChipCmd) & (CmdTxEnb | CmdRxEnb));
+}
+
+void
+rtl8126_wait_txrx_fifo_empty(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i;
+
+        /* Txfifo_empty require StopReq been set */
+        for (i = 0; i < 3000; i++) {
+                udelay(50);
+                if ((RTL_R8(tp, MCUCmd_reg) & (Txfifo_empty | Rxfifo_empty)) == (Txfifo_empty | Rxfifo_empty))
+                        break;
+        }
+
+        for (i = 0; i < 3000; i++) {
+                udelay(50);
+                if ((RTL_R16(tp, IntrMitigate) & (BIT_0 | BIT_1 | BIT_8)) == (BIT_0 | BIT_1 | BIT_8))
+                        break;
+        }
+}
+
+void
+rtl8126_enable_hw_linkchg_interrupt(struct rtl8126_private *tp)
+{
+        switch (tp->HwCurrIsrVer) {
+        case 5:
+                RTL_W32(tp, IMR_V2_SET_REG_8125, ISRIMR_V5_LINKCHG);
+                break;
+        case 4:
+                RTL_W32(tp, IMR_V2_SET_REG_8125, ISRIMR_V4_LINKCHG);
+                break;
+        case 2:
+        case 3:
+                RTL_W32(tp, IMR_V2_SET_REG_8125, ISRIMR_V2_LINKCHG);
+                break;
+        case 1:
+                RTL_W32(tp, tp->imr_reg[0], LinkChg | RTL_R32(tp, tp->imr_reg[0]));
+                break;
+        }
+}
+
+static inline void
+rtl8126_enable_hw_interrupt(struct rtl8126_private *tp)
+{
+        switch (tp->HwCurrIsrVer) {
+        case 2:
+        case 3:
+        case 4:
+        case 5:
+                RTL_W32(tp, IMR_V2_SET_REG_8125, tp->intr_mask);
+                break;
+        case 1:
+                RTL_W32(tp, tp->imr_reg[0], tp->intr_mask);
+
+                if (R8126_MULTI_RX_Q(tp)) {
+                        int i;
+                        for (i=1; i<tp->num_rx_rings; i++)
+                                RTL_W16(tp, tp->imr_reg[i], other_q_intr_mask);
+                }
+                break;
+        }
+}
+
+static inline void rtl8126_clear_hw_isr_v2(struct rtl8126_private *tp,
+                u32 message_id)
+{
+        RTL_W32(tp, ISR_V2_8125, BIT(message_id));
+}
+
+static inline void
+rtl8126_disable_hw_interrupt(struct rtl8126_private *tp)
+{
+        if (tp->HwCurrIsrVer > 1) {
+                RTL_W32(tp, IMR_V2_CLEAR_REG_8125, 0xFFFFFFFF);
+                if (tp->HwCurrIsrVer > 3)
+                        RTL_W32(tp, IMR_V4_L2_CLEAR_REG_8125, 0xFFFFFFFF);
+        } else {
+                RTL_W32(tp, tp->imr_reg[0], 0x0000);
+
+                if (R8126_MULTI_RX_Q(tp)) {
+                        int i;
+                        for (i=1; i<tp->num_rx_rings; i++)
+                                RTL_W16(tp, tp->imr_reg[i], 0);
+                }
+        }
+}
+
+static inline void
+rtl8126_switch_to_hw_interrupt(struct rtl8126_private *tp)
+{
+        RTL_W32(tp, TIMER_INT0_8125, 0x0000);
+
+        rtl8126_enable_hw_interrupt(tp);
+}
+
+static inline void
+rtl8126_switch_to_timer_interrupt(struct rtl8126_private *tp)
+{
+        if (tp->use_timer_interrupt) {
+                RTL_W32(tp, TIMER_INT0_8125, timer_count);
+                RTL_W32(tp, TCTR0_8125, timer_count);
+                RTL_W32(tp, tp->imr_reg[0], tp->timer_intr_mask);
+        } else {
+                rtl8126_switch_to_hw_interrupt(tp);
+        }
+}
+
+static void
+rtl8126_irq_mask_and_ack(struct rtl8126_private *tp)
+{
+        rtl8126_disable_hw_interrupt(tp);
+
+        if (tp->HwCurrIsrVer > 1) {
+                RTL_W32(tp, ISR_V2_8125, 0xFFFFFFFF);
+                if (tp->HwCurrIsrVer > 3)
+                        RTL_W32(tp, ISR_V4_L2_8125, 0xFFFFFFFF);
+        } else {
+                RTL_W32(tp, tp->isr_reg[0], RTL_R32(tp, tp->isr_reg[0]));
+                if (R8126_MULTI_RX_Q(tp)) {
+                        int i;
+                        for (i=1; i<tp->num_rx_rings; i++)
+                                RTL_W16(tp, tp->isr_reg[i], RTL_R16(tp, tp->isr_reg[i]));
+                }
+        }
+}
+
+static void
+rtl8126_disable_rx_packet_filter(struct rtl8126_private *tp)
+{
+
+        RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) &
+                ~(AcceptErr | AcceptRunt |AcceptBroadcast | AcceptMulticast |
+                  AcceptMyPhys |  AcceptAllPhys));
+}
+
+static void
+rtl8126_nic_reset(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i;
+
+        rtl8126_disable_rx_packet_filter(tp);
+
+        rtl8126_enable_rxdvgate(dev);
+
+        rtl8126_stop_all_request(dev);
+
+        rtl8126_wait_txrx_fifo_empty(dev);
+
+        rtl8126_clear_stop_all_request(dev);
+
+        /* Soft reset the chip. */
+        RTL_W8(tp, ChipCmd, CmdReset);
+
+        /* Check that the chip has finished the reset. */
+        for (i = 100; i > 0; i--) {
+                udelay(100);
+                if ((RTL_R8(tp, ChipCmd) & CmdReset) == 0)
+                        break;
+        }
+
+        /* reset rcr */
+        RTL_W32(tp, RxConfig, (RX_DMA_BURST_512 << RxCfgDMAShift));
+}
+
+static void
+rtl8126_hw_set_interrupt_type(struct rtl8126_private *tp, u8 isr_ver)
+{
+        u8 tmp;
+
+        if (tp->HwSuppIsrVer < 2)
+                return;
+
+        tmp = RTL_R8(tp, INT_CFG0_8125);
+
+        switch (tp->HwSuppIsrVer) {
+        case 4:
+        case 5:
+                tmp &= ~INT_CFG0_MSIX_ENTRY_NUM_MODE;
+                fallthrough;
+        case 2:
+        case 3:
+                tmp &= ~(INT_CFG0_ENABLE_8125);
+                if (isr_ver > 1)
+                        tmp |= INT_CFG0_ENABLE_8125;
+                break;
+        default:
+                return;
+        }
+
+        RTL_W8(tp, INT_CFG0_8125, tmp);
+}
+
+static void
+rtl8126_hw_clear_timer_int(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        RTL_W32(tp, TIMER_INT0_8125, 0x0000);
+        RTL_W32(tp, TIMER_INT1_8125, 0x0000);
+        RTL_W32(tp, TIMER_INT2_8125, 0x0000);
+        RTL_W32(tp, TIMER_INT3_8125, 0x0000);
+}
+
+static void
+rtl8126_hw_clear_int_miti(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i;
+
+        switch (tp->HwSuppIntMitiVer) {
+        case 3:
+        case 6:
+                //IntMITI_0-IntMITI_31
+                for (i=0xA00; i<0xB00; i+=4)
+                        RTL_W32(tp, i, 0x0000);
+                break;
+        case 4:
+        case 5:
+                //IntMITI_0-IntMITI_15
+                for (i = 0xA00; i < 0xA80; i += 4)
+                        RTL_W32(tp, i, 0x0000);
+
+                if (tp->HwSuppIntMitiVer == 5)
+                        RTL_W8(tp, INT_CFG0_8125, RTL_R8(tp, INT_CFG0_8125) &
+                               ~(INT_CFG0_TIMEOUT0_BYPASS_8125 |
+                                 INT_CFG0_MITIGATION_BYPASS_8125 |
+                                 INT_CFG0_RDU_BYPASS_8126));
+                else
+                        RTL_W8(tp, INT_CFG0_8125, RTL_R8(tp, INT_CFG0_8125) &
+                               ~(INT_CFG0_TIMEOUT0_BYPASS_8125 | INT_CFG0_MITIGATION_BYPASS_8125));
+
+                RTL_W16(tp, INT_CFG1_8125, 0x0000);
+                break;
+        }
+}
+
+static bool
+rtl8126_vec_2_tx_q_num(
+        struct rtl8126_private *tp,
+        u32 messageId,
+        u32 *qnum
+)
+{
+        u32 whichQ = 0xffffffff;
+        bool rc = false;
+
+        switch (tp->HwSuppIsrVer) {
+        case 2:
+                if (messageId == 0x10)
+                        whichQ = 0;
+                else if (messageId == 0x12 && tp->num_tx_rings > 1)
+                        whichQ = 1;
+                break;
+        case 3:
+        case 4:
+                if (messageId == 0x00)
+                        whichQ = 0;
+                else if (messageId == 0x01 && tp->num_tx_rings > 1)
+                        whichQ = 1;
+                break;
+        case 5:
+                if (messageId == 0x10)
+                        whichQ = 0;
+                else if (messageId == 0x11 && tp->num_tx_rings > 1)
+                        whichQ = 1;
+                break;
+        case 6:
+                if (messageId == 0x08)
+                        whichQ = 0;
+                else if (messageId == 0x09 && tp->num_tx_rings > 1)
+                        whichQ = 1;
+                break;
+        case 7:
+                if (messageId == 0x1B)
+                        whichQ = 0;
+                else if (messageId == 0x1C && tp->num_tx_rings > 1)
+                        whichQ = 1;
+                break;
+        }
+
+        if (whichQ != 0xffffffff) {
+                *qnum = whichQ;
+                rc = true;
+        }
+
+        return rc;
+}
+
+static bool
+rtl8126_vec_2_rx_q_num(
+        struct rtl8126_private *tp,
+        u32 messageId,
+        u32 *qnum
+)
+{
+        u32 whichQ = 0xffffffff;
+        bool rc = false;
+
+        switch (tp->HwSuppIsrVer) {
+        case 2:
+        case 3:
+        case 4:
+        case 5:
+        case 6:
+        case 7:
+                if (messageId < tp->HwSuppNumRxQueues)
+                        whichQ = messageId;
+                break;
+        }
+
+        if (whichQ != 0xffffffff) {
+                *qnum = whichQ;
+                rc = true;
+        }
+
+        return rc;
+}
+
+void
+rtl8126_hw_set_timer_int(struct rtl8126_private *tp,
+                         u32 message_id,
+                         u8 timer_intmiti_val)
+{
+        u32 qnum;
+
+        switch (tp->HwSuppIntMitiVer) {
+        case 4:
+        case 5:
+        case 6:
+                //ROK
+                if (rtl8126_vec_2_rx_q_num(tp, message_id, &qnum))
+                        RTL_W8(tp,INT_MITI_V2_0_RX + 8 * qnum, timer_intmiti_val);
+                //TOK
+                if (rtl8126_vec_2_tx_q_num(tp, message_id, &qnum))
+                        RTL_W8(tp,INT_MITI_V2_0_TX + 8 * qnum, timer_intmiti_val);
+                break;
+        }
+}
+
+void
+rtl8126_hw_reset(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        rtl8126_lib_reset_prepare(tp);
+
+        /* Disable interrupts */
+        rtl8126_irq_mask_and_ack(tp);
+
+        rtl8126_hw_clear_timer_int(dev);
+
+        rtl8126_nic_reset(dev);
+}
+
+static unsigned int
+rtl8126_xmii_reset_pending(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        unsigned int retval;
+        unsigned long flags;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+        rtl8126_mdio_write(tp, 0x1f, 0x0000);
+        retval = rtl8126_mdio_read(tp, MII_BMCR) & BMCR_RESET;
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        return retval;
+}
+
+static unsigned int
+_rtl8126_xmii_link_ok(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u32 status;
+
+        status = rtl8126_get_phy_status(tp);
+        if (status == UINT_MAX)
+                return 0;
+
+        return (status & LinkStatus) ? 1 : 0;
+}
+
+static unsigned int
+rtl8126_xmii_link_ok(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        unsigned int link_state;
+
+        link_state = _rtl8126_xmii_link_ok(dev);
+#ifdef ENABLE_FIBER_SUPPORT
+        if (HW_FIBER_MODE_ENABLED(tp) &&
+            (link_state == R8126_LINK_STATE_ON))
+                return rtl8126_fiber_link_ok(dev);
+#else
+        (void)tp;
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        return link_state;
+}
+
+static int
+rtl8126_wait_phy_reset_complete(struct rtl8126_private *tp)
+{
+        int i, val;
+
+        for (i = 0; i < 2500; i++) {
+                val = rtl8126_mdio_read(tp, MII_BMCR) & BMCR_RESET;
+                if (!val)
+                        return 0;
+
+                mdelay(1);
+        }
+
+        return -1;
+}
+
+static void
+rtl8126_xmii_reset_enable(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        unsigned long flags;
+        int ret;
+
+        if (rtl8126_is_in_phy_disable_mode(dev))
+                return;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        rtl8126_mdio_write(tp, 0x1f, 0x0000);
+        rtl8126_mdio_write(tp, MII_ADVERTISE, rtl8126_mdio_read(tp, MII_ADVERTISE) &
+                           ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
+                             ADVERTISE_100HALF | ADVERTISE_100FULL));
+        rtl8126_mdio_write(tp, MII_CTRL1000, rtl8126_mdio_read(tp, MII_CTRL1000) &
+                           ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL));
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA5D4, rtl8126_mdio_direct_read_phy_ocp(tp, 0xA5D4) &
+                                          ~(RTK_ADVERTISE_2500FULL | RTK_ADVERTISE_5000FULL));
+        rtl8126_mdio_write(tp, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
+
+        ret = rtl8126_wait_phy_reset_complete(tp);
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        if (ret != 0 && netif_msg_link(tp))
+                printk(KERN_ERR "%s: PHY reset failed.\n", dev->name);
+}
+
+void
+rtl8126_init_ring_indexes(struct rtl8126_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->HwSuppNumTxQueues; i++) {
+                struct rtl8126_tx_ring *ring = &tp->tx_ring[i];
+                ring->dirty_tx = ring->cur_tx = 0;
+                ring->NextHwDesCloPtr = 0;
+                ring->BeginHwDesCloPtr = 0;
+                ring->index = i;
+                ring->priv = tp;
+                ring->netdev = tp->dev;
+
+                /* reset BQL for queue */
+                netdev_tx_reset_queue(txring_txq(ring));
+        }
+
+        for (i = 0; i < tp->HwSuppNumRxQueues; i++) {
+                struct rtl8126_rx_ring *ring = &tp->rx_ring[i];
+                ring->dirty_rx = ring->cur_rx = 0;
+                ring->index = i;
+                ring->priv = tp;
+                ring->netdev = tp->dev;
+        }
+
+#ifdef ENABLE_LIB_SUPPORT
+        for (i = 0; i < tp->HwSuppNumTxQueues; i++) {
+                struct rtl8126_ring *ring = &tp->lib_tx_ring[i];
+                ring->direction = RTL8126_CH_DIR_TX;
+                ring->queue_num = i;
+                ring->private = tp;
+        }
+
+        for (i = 0; i < tp->HwSuppNumRxQueues; i++) {
+                struct rtl8126_ring *ring = &tp->lib_rx_ring[i];
+                ring->direction = RTL8126_CH_DIR_RX;
+                ring->queue_num = i;
+                ring->private = tp;
+        }
+#endif
+}
+
+static void
+rtl8126_issue_offset_99_event(struct rtl8126_private *tp)
+{
+        rtl8126_mac_ocp_write(tp, 0xE09A,  rtl8126_mac_ocp_read(tp, 0xE09A) | BIT_0);
+}
+
+static int rtl8126_enable_eee_plus(struct rtl8126_private *tp)
+{
+        rtl8126_mac_ocp_write(tp, 0xE080, rtl8126_mac_ocp_read(tp, 0xE080)|BIT_1);
+
+        return 0;
+}
+
+static int rtl8126_disable_eee_plus(struct rtl8126_private *tp)
+{
+        rtl8126_mac_ocp_write(tp, 0xE080, rtl8126_mac_ocp_read(tp, 0xE080)&~BIT_1);
+
+        return 0;
+}
+
+static void rtl8126_enable_double_vlan(struct rtl8126_private *tp)
+{
+        RTL_W16(tp, DOUBLE_VLAN_CONFIG, 0xf002);
+}
+
+static void rtl8126_disable_double_vlan(struct rtl8126_private *tp)
+{
+        RTL_W16(tp, DOUBLE_VLAN_CONFIG, 0);
+}
+
+static void
+rtl8126_link_on_patch(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        unsigned long flags;
+        u32 status;
+
+        rtl8126_hw_config(dev);
+
+        status = rtl8126_get_phy_status(tp);
+        if (status & _10bps)
+                rtl8126_enable_eee_plus(tp);
+
+        rtl8126_hw_start(dev);
+
+        netif_carrier_on(dev);
+
+        netif_tx_wake_all_queues(dev);
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+        tp->phy_reg_aner = rtl8126_mdio_read(tp, MII_EXPANSION);
+        tp->phy_reg_anlpar = rtl8126_mdio_read(tp, MII_LPA);
+        tp->phy_reg_gbsr = rtl8126_mdio_read(tp, MII_STAT1000);
+        tp->phy_reg_status_2500 = rtl8126_mdio_direct_read_phy_ocp(tp, 0xA5D6);
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+#ifdef ENABLE_PTP_SUPPORT
+        if (tp->EnablePtp)
+                rtl8126_set_local_time(tp);
+#endif // ENABLE_PTP_SUPPORT
+}
+
+static void
+rtl8126_link_down_patch(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        unsigned long flags;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+        tp->phy_reg_aner = 0;
+        tp->phy_reg_anlpar = 0;
+        tp->phy_reg_gbsr = 0;
+        tp->phy_reg_status_2500 = 0;
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        rtl8126_disable_eee_plus(tp);
+
+        netif_carrier_off(dev);
+
+        netif_tx_disable(dev);
+
+        rtl8126_hw_reset(dev);
+
+        rtl8126_tx_clear(tp);
+
+        rtl8126_rx_clear(tp);
+
+        rtl8126_init_ring(dev);
+
+        rtl8126_enable_hw_linkchg_interrupt(tp);
+
+        //rtl8126_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+}
+
+static void
+_rtl8126_check_link_status(struct net_device *dev, unsigned int link_state)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (link_state != R8126_LINK_STATE_OFF &&
+            link_state != R8126_LINK_STATE_ON)
+                link_state = tp->link_ok(dev);
+
+        if (link_state == R8126_LINK_STATE_ON) {
+                rtl8126_link_on_patch(dev);
+
+                if (netif_msg_ifup(tp))
+                        printk(KERN_INFO PFX "%s: link up\n", dev->name);
+        } else {
+                if (netif_msg_ifdown(tp))
+                        printk(KERN_INFO PFX "%s: link down\n", dev->name);
+
+                rtl8126_link_down_patch(dev);
+        }
+}
+
+static void
+rtl8126_check_link_status(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        unsigned int link_status_on;
+
+        tp->resume_not_chg_speed = 0;
+
+        link_status_on = tp->link_ok(dev);
+        if (netif_carrier_ok(dev) == link_status_on)
+                rtl8126_enable_hw_linkchg_interrupt(tp);
+        else
+                _rtl8126_check_link_status(dev, link_status_on);
+}
+
+static bool
+rtl8126_is_autoneg_mode_valid(u32 autoneg)
+{
+        switch(autoneg) {
+        case AUTONEG_ENABLE:
+        case AUTONEG_DISABLE:
+                return true;
+        default:
+                return false;
+        }
+}
+
+static bool
+rtl8126_is_speed_mode_valid(u32 speed)
+{
+        switch(speed) {
+        case SPEED_5000:
+        case SPEED_2500:
+        case SPEED_1000:
+        case SPEED_100:
+        case SPEED_10:
+                return true;
+        default:
+                return false;
+        }
+}
+
+static bool
+rtl8126_is_duplex_mode_valid(u8 duplex)
+{
+        switch(duplex) {
+        case DUPLEX_FULL:
+        case DUPLEX_HALF:
+                return true;
+        default:
+                return false;
+        }
+}
+
+static void
+rtl8126_set_link_option(struct rtl8126_private *tp,
+                        u8 autoneg,
+                        u32 speed,
+                        u8 duplex,
+                        enum rtl8126_fc_mode fc)
+{
+        u64 adv;
+
+        if (!rtl8126_is_speed_mode_valid(speed))
+                speed = SPEED_5000;
+
+        if (!rtl8126_is_duplex_mode_valid(duplex))
+                duplex = DUPLEX_FULL;
+
+        if (!rtl8126_is_autoneg_mode_valid(autoneg))
+                autoneg = AUTONEG_ENABLE;
+
+        speed = min(speed, tp->HwSuppMaxPhyLinkSpeed);
+
+        adv = 0;
+        switch(speed) {
+        case SPEED_5000:
+                adv |= RTK_ADVERTISED_5000baseX_Full;
+                fallthrough;
+        case SPEED_2500:
+                adv |= ADVERTISED_2500baseX_Full;
+                fallthrough;
+        default:
+                adv |= (ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
+                        ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
+                        ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full);
+                break;
+        }
+
+        tp->autoneg = autoneg;
+        tp->speed = speed;
+        tp->duplex = duplex;
+        tp->advertising = adv;
+        tp->fcpause = fc;
+}
+
+static void
+rtl8126_wait_ll_share_fifo_ready(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i;
+
+        for (i = 0; i < 10; i++) {
+                udelay(100);
+                if (RTL_R16(tp, 0xD2) & BIT_9)
+                        break;
+        }
+}
+
+static void
+rtl8126_disable_pci_offset_99(struct rtl8126_private *tp)
+{
+        rtl8126_mac_ocp_write(tp, 0xE032,  rtl8126_mac_ocp_read(tp, 0xE032) & ~(BIT_0 | BIT_1));
+
+        rtl8126_csi_fun0_write_byte(tp, 0x99, 0x00);
+}
+
+static void
+rtl8126_enable_pci_offset_99(struct rtl8126_private *tp)
+{
+        u32 csi_tmp;
+
+        rtl8126_csi_fun0_write_byte(tp, 0x99, tp->org_pci_offset_99);
+
+        csi_tmp = rtl8126_mac_ocp_read(tp, 0xE032);
+        csi_tmp &= ~(BIT_0 | BIT_1);
+        if (tp->org_pci_offset_99 & (BIT_5 | BIT_6))
+                csi_tmp |= BIT_1;
+        if (tp->org_pci_offset_99 & BIT_2)
+                csi_tmp |= BIT_0;
+        rtl8126_mac_ocp_write(tp, 0xE032, csi_tmp);
+}
+
+static void
+rtl8126_init_pci_offset_99(struct rtl8126_private *tp)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_1:
+                rtl8126_mac_ocp_write(tp, 0xCDD0, 0x9003);
+                rtl8126_set_mac_ocp_bit(tp, 0xE034, (BIT_15 | BIT_14));
+                rtl8126_mac_ocp_write(tp, 0xCDD2, 0x889C);
+                rtl8126_mac_ocp_write(tp, 0xCDD8, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDD4, 0x8C30);
+                rtl8126_mac_ocp_write(tp, 0xCDDA, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDD6, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDDC, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDE8, 0x883E);
+                rtl8126_mac_ocp_write(tp, 0xCDEA, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDEC, 0x889C);
+                rtl8126_mac_ocp_write(tp, 0xCDEE, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDF0, 0x8C09);
+                rtl8126_mac_ocp_write(tp, 0xCDF2, 0x9003);
+                rtl8126_set_mac_ocp_bit(tp, 0xE032, BIT_14);
+                rtl8126_set_mac_ocp_bit(tp, 0xE0A2, BIT_0);
+                break;
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+                rtl8126_mac_ocp_write(tp, 0xCDD0, 0x9003);
+                rtl8126_set_mac_ocp_bit(tp, 0xE034, (BIT_15 | BIT_14));
+                rtl8126_mac_ocp_write(tp, 0xCDD2, 0x8C09);
+                rtl8126_mac_ocp_write(tp, 0xCDD8, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDD4, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDDA, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDD6, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDDC, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDE8, 0x887A);
+                rtl8126_mac_ocp_write(tp, 0xCDEA, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDEC, 0x8C09);
+                rtl8126_mac_ocp_write(tp, 0xCDEE, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDF0, 0x8A62);
+                rtl8126_mac_ocp_write(tp, 0xCDF2, 0x9003);
+                rtl8126_mac_ocp_write(tp, 0xCDF4, 0x883E);
+                rtl8126_mac_ocp_write(tp, 0xCDF6, 0x9003);
+                rtl8126_set_mac_ocp_bit(tp, 0xE032, BIT_14);
+                rtl8126_set_mac_ocp_bit(tp, 0xE0A2, BIT_0);
+                break;
+        }
+
+        rtl8126_enable_pci_offset_99(tp);
+}
+
+static void
+rtl8126_disable_pci_offset_180(struct rtl8126_private *tp)
+{
+        rtl8126_clear_mac_ocp_bit(tp, 0xE092, 0x00FF);
+}
+
+static void
+rtl8126_enable_pci_offset_180(struct rtl8126_private *tp)
+{
+        rtl8126_clear_mac_ocp_bit(tp, 0xE094, 0xFF00);
+
+        rtl8126_clear_set_mac_ocp_bit(tp, 0xE092, 0x00FF, BIT_2);
+}
+
+static void
+rtl8126_init_pci_offset_180(struct rtl8126_private *tp)
+{
+        rtl8126_enable_pci_offset_180(tp);
+}
+
+static void
+rtl8126_set_pci_99_exit_driver_para(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (tp->org_pci_offset_99 & BIT_2)
+                rtl8126_issue_offset_99_event(tp);
+        rtl8126_disable_pci_offset_99(tp);
+}
+
+static void
+rtl8126_enable_cfg9346_write(struct rtl8126_private *tp)
+{
+        RTL_W8(tp, Cfg9346, RTL_R8(tp, Cfg9346) | Cfg9346_Unlock);
+}
+
+static void
+rtl8126_disable_cfg9346_write(struct rtl8126_private *tp)
+{
+        RTL_W8(tp, Cfg9346, RTL_R8(tp, Cfg9346) & ~Cfg9346_Unlock);
+}
+
+static void
+rtl8126_enable_exit_l1_mask(struct rtl8126_private *tp)
+{
+        //(1)ERI(0xD4)(OCP 0xC0AC).bit[7:12]=6'b111111, L1 Mask
+        rtl8126_set_mac_ocp_bit(tp, 0xC0AC, (BIT_7 | BIT_8 | BIT_9 | BIT_10 | BIT_11 | BIT_12));
+}
+
+static void
+rtl8126_disable_exit_l1_mask(struct rtl8126_private *tp)
+{
+        //(1)ERI(0xD4)(OCP 0xC0AC).bit[7:12]=6'b000000, L1 Mask
+        rtl8126_clear_mac_ocp_bit(tp, 0xC0AC, (BIT_7 | BIT_8 | BIT_9 | BIT_10 | BIT_11 | BIT_12));
+}
+
+static void
+rtl8126_enable_extend_tally_couter(struct rtl8126_private *tp)
+{
+        switch (tp->HwSuppExtendTallyCounterVer) {
+        case 1:
+                rtl8126_set_mac_ocp_bit(tp, 0xEA84, (BIT_1 | BIT_0));
+                break;
+        }
+}
+
+static void
+rtl8126_disable_extend_tally_couter(struct rtl8126_private *tp)
+{
+        switch (tp->HwSuppExtendTallyCounterVer) {
+        case 1:
+                rtl8126_clear_mac_ocp_bit(tp, 0xEA84, (BIT_1 | BIT_0));
+                break;
+        }
+}
+
+static void
+rtl8126_enable_force_clkreq(struct rtl8126_private *tp, bool enable)
+{
+        if (enable)
+                RTL_W8(tp, 0xF1, RTL_R8(tp, 0xF1) | BIT_7);
+        else
+                RTL_W8(tp, 0xF1, RTL_R8(tp, 0xF1) & ~BIT_7);
+}
+
+static void
+rtl8126_enable_aspm_clkreq_lock(struct rtl8126_private *tp, bool enable)
+{
+        bool unlock_cfg_wr;
+
+        if ((RTL_R8(tp, Cfg9346) & Cfg9346_EEM_MASK) == Cfg9346_Unlock)
+                unlock_cfg_wr = false;
+        else
+                unlock_cfg_wr = true;
+
+        if (unlock_cfg_wr)
+                rtl8126_enable_cfg9346_write(tp);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_1:
+                if (enable) {
+                        RTL_W8(tp, Config2, RTL_R8(tp, Config2) | BIT_7);
+                        RTL_W8(tp, Config5, RTL_R8(tp, Config5) | BIT_0);
+                } else {
+                        RTL_W8(tp, Config2, RTL_R8(tp, Config2) & ~BIT_7);
+                        RTL_W8(tp, Config5, RTL_R8(tp, Config5) & ~BIT_0);
+                }
+                break;
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+                if (enable) {
+                        RTL_W8(tp, INT_CFG0_8125, RTL_R8(tp, INT_CFG0_8125) | BIT_3);
+                        RTL_W8(tp, Config5, RTL_R8(tp, Config5) | BIT_0);
+                } else {
+                        RTL_W8(tp, INT_CFG0_8125, RTL_R8(tp, INT_CFG0_8125) & ~BIT_3);
+                        RTL_W8(tp, Config5, RTL_R8(tp, Config5) & ~BIT_0);
+                }
+                break;
+        }
+
+        if (unlock_cfg_wr)
+                rtl8126_disable_cfg9346_write(tp);
+}
+
+static void
+rtl8126_hw_d3_para(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        RTL_W16(tp, RxMaxSize, RX_BUF_SIZE);
+
+        rtl8126_enable_force_clkreq(tp, 0);
+        rtl8126_enable_aspm_clkreq_lock(tp, 0);
+
+        rtl8126_disable_exit_l1_mask(tp);
+
+#ifdef ENABLE_REALWOW_SUPPORT
+        rtl8126_set_realwow_d3_para(dev);
+#endif
+        rtl8126_set_pci_99_exit_driver_para(dev);
+
+        rtl8126_disable_rxdvgate(dev);
+
+        rtl8126_disable_extend_tally_couter(tp);
+}
+
+static void
+rtl8126_enable_magic_packet(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppMagicPktVer) {
+        case WAKEUP_MAGIC_PACKET_V3:
+                rtl8126_mac_ocp_write(tp, 0xC0B6, rtl8126_mac_ocp_read(tp, 0xC0B6) | BIT_0);
+                break;
+        }
+}
+static void
+rtl8126_disable_magic_packet(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppMagicPktVer) {
+        case WAKEUP_MAGIC_PACKET_V3:
+                rtl8126_mac_ocp_write(tp, 0xC0B6, rtl8126_mac_ocp_read(tp, 0xC0B6) & ~BIT_0);
+                break;
+        }
+}
+
+static void
+rtl8126_enable_linkchg_wakeup(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppLinkChgWakeUpVer) {
+        case 3:
+                RTL_W8(tp, Config3, RTL_R8(tp, Config3) | LinkUp);
+                rtl8126_clear_set_mac_ocp_bit(tp, 0xE0C6, (BIT_5 | BIT_3 | BIT_2), (BIT_4 | BIT_1 | BIT_0));
+                break;
+        }
+}
+
+static void
+rtl8126_disable_linkchg_wakeup(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppLinkChgWakeUpVer) {
+        case 3:
+                RTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~LinkUp);
+                if (!(rtl8126_mac_ocp_read(tp, 0xE0C6) & BIT_0))
+                        rtl8126_clear_set_mac_ocp_bit(tp, 0xE0C6, (BIT_5 | BIT_3 | BIT_2 | BIT_1), BIT_4);
+                break;
+        }
+}
+
+#define WAKE_ANY (WAKE_PHY | WAKE_MAGIC | WAKE_UCAST | WAKE_BCAST | WAKE_MCAST)
+
+static u32
+rtl8126_get_hw_wol(struct rtl8126_private *tp)
+{
+        u8 options;
+        u32 csi_tmp;
+        u32 wol_opts = 0;
+
+        if (disable_wol_support)
+                goto out;
+
+        options = RTL_R8(tp, Config1);
+        if (!(options & PMEnable))
+                goto out;
+
+        options = RTL_R8(tp, Config3);
+        if (options & LinkUp)
+                wol_opts |= WAKE_PHY;
+
+        switch (tp->HwSuppMagicPktVer) {
+        case WAKEUP_MAGIC_PACKET_V3:
+                csi_tmp = rtl8126_mac_ocp_read(tp, 0xC0B6);
+                if (csi_tmp & BIT_0)
+                        wol_opts |= WAKE_MAGIC;
+                break;
+        }
+
+        options = RTL_R8(tp, Config5);
+        if (options & UWF)
+                wol_opts |= WAKE_UCAST;
+        if (options & BWF)
+                wol_opts |= WAKE_BCAST;
+        if (options & MWF)
+                wol_opts |= WAKE_MCAST;
+
+out:
+        return wol_opts;
+}
+
+static void
+rtl8126_enable_d0_speedup(struct rtl8126_private *tp)
+{
+        u16 clearmask;
+        u16 setmask;
+
+        if (FALSE == HW_SUPPORT_D0_SPEED_UP(tp))
+                return;
+
+        if (tp->D0SpeedUpSpeed == D0_SPEED_UP_SPEED_DISABLE)
+                return;
+
+        if (tp->HwSuppD0SpeedUpVer == 1 || tp->HwSuppD0SpeedUpVer == 2) {
+                //speed up speed
+                clearmask = (BIT_10 | BIT_9 | BIT_8 | BIT_7);
+                if (tp->D0SpeedUpSpeed == D0_SPEED_UP_SPEED_2500)
+                        setmask = BIT_7;
+                else if (tp->D0SpeedUpSpeed == D0_SPEED_UP_SPEED_5000)
+                        setmask = BIT_8;
+                else
+                        setmask = 0;
+                rtl8126_clear_set_mac_ocp_bit(tp, 0xE10A, clearmask, setmask);
+
+                //speed up flowcontrol
+                clearmask = (BIT_15 | BIT_14);
+                if (tp->HwSuppD0SpeedUpVer == 2)
+                        clearmask |= BIT_13;
+
+                if (tp->fcpause == rtl8126_fc_full) {
+                        setmask = (BIT_15 | BIT_14);
+                        if (tp->HwSuppD0SpeedUpVer == 2)
+                                setmask |= BIT_13;
+                } else
+                        setmask = 0;
+                rtl8126_clear_set_mac_ocp_bit(tp, 0xE860, clearmask, setmask);
+        }
+
+        RTL_W8(tp, 0xD0, RTL_R8(tp, 0xD0) | BIT_3);
+}
+
+static void
+rtl8126_disable_d0_speedup(struct rtl8126_private *tp)
+{
+        if (FALSE == HW_SUPPORT_D0_SPEED_UP(tp))
+                return;
+
+        RTL_W8(tp, 0xD0, RTL_R8(tp, 0xD0) & ~BIT_3);
+}
+
+static void
+rtl8126_set_hw_wol(struct net_device *dev, u32 wolopts)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i,tmp = 0;
+        static struct {
+                u32 opt;
+                u16 reg;
+                u8  mask;
+        } cfg[] = {
+                { WAKE_PHY,   Config3, LinkUp },
+                { WAKE_UCAST, Config5, UWF },
+                { WAKE_BCAST, Config5, BWF },
+                { WAKE_MCAST, Config5, MWF },
+                { WAKE_ANY,   Config5, LanWake },
+                { WAKE_MAGIC, Config3, MagicPacket },
+        };
+
+        switch (tp->HwSuppMagicPktVer) {
+        case WAKEUP_MAGIC_PACKET_V3:
+                tmp = ARRAY_SIZE(cfg) - 1;
+
+                if (wolopts & WAKE_MAGIC)
+                        rtl8126_enable_magic_packet(dev);
+                else
+                        rtl8126_disable_magic_packet(dev);
+                break;
+        default:
+                break;
+        }
+
+        rtl8126_enable_cfg9346_write(tp);
+
+        for (i = 0; i < tmp; i++) {
+                u8 options = RTL_R8(tp, cfg[i].reg) & ~cfg[i].mask;
+                if (wolopts & cfg[i].opt)
+                        options |= cfg[i].mask;
+                RTL_W8(tp, cfg[i].reg, options);
+        }
+
+        switch (tp->HwSuppLinkChgWakeUpVer) {
+        case 3:
+                if (wolopts & WAKE_PHY)
+                        rtl8126_enable_linkchg_wakeup(dev);
+                else
+                        rtl8126_disable_linkchg_wakeup(dev);
+                break;
+        }
+
+        rtl8126_disable_cfg9346_write(tp);
+}
+
+static void
+rtl8126_phy_restart_nway(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (rtl8126_is_in_phy_disable_mode(dev))
+                return;
+
+        rtl8126_mdio_write(tp, 0x1F, 0x0000);
+        rtl8126_mdio_write(tp, MII_BMCR, BMCR_ANENABLE | BMCR_ANRESTART);
+}
+
+static void
+rtl8126_phy_setup_force_mode(struct net_device *dev, u32 speed, u8 duplex)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u16 bmcr_true_force = 0;
+
+        if (rtl8126_is_in_phy_disable_mode(dev))
+                return;
+
+        if ((speed == SPEED_10) && (duplex == DUPLEX_HALF)) {
+                bmcr_true_force = BMCR_SPEED10;
+        } else if ((speed == SPEED_10) && (duplex == DUPLEX_FULL)) {
+                bmcr_true_force = BMCR_SPEED10 | BMCR_FULLDPLX;
+        } else if ((speed == SPEED_100) && (duplex == DUPLEX_HALF)) {
+                bmcr_true_force = BMCR_SPEED100;
+        } else if ((speed == SPEED_100) && (duplex == DUPLEX_FULL)) {
+                bmcr_true_force = BMCR_SPEED100 | BMCR_FULLDPLX;
+        } else {
+                netif_err(tp, drv, dev, "Failed to set phy force mode!\n");
+                return;
+        }
+
+        rtl8126_mdio_write(tp, 0x1F, 0x0000);
+        rtl8126_mdio_write(tp, MII_BMCR, bmcr_true_force);
+}
+
+static void
+rtl8126_set_pci_pme(struct rtl8126_private *tp, int set)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+        u16 pmc;
+
+        if (!pdev->pm_cap)
+                return;
+
+        pci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &pmc);
+        pmc |= PCI_PM_CTRL_PME_STATUS;
+        if (set)
+                pmc |= PCI_PM_CTRL_PME_ENABLE;
+        else
+                pmc &= ~PCI_PM_CTRL_PME_ENABLE;
+        pci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, pmc);
+}
+
+static void
+rtl8126_enable_giga_lite(struct rtl8126_private *tp, u64 adv)
+{
+        if (adv & ADVERTISED_1000baseT_Full)
+                rtl8126_set_eth_phy_ocp_bit(tp, 0xA428, BIT_9);
+        else
+                rtl8126_clear_eth_phy_ocp_bit(tp, 0xA428, BIT_9);
+
+        if (adv & ADVERTISED_2500baseX_Full)
+                rtl8126_set_eth_phy_ocp_bit(tp, 0xA5EA, BIT_0);
+        else
+                rtl8126_clear_eth_phy_ocp_bit(tp, 0xA5EA, BIT_0);
+
+        if (adv & RTK_ADVERTISED_5000baseX_Full)
+                rtl8126_set_eth_phy_ocp_bit(tp, 0xA5EA, BIT_1);
+        else
+                rtl8126_clear_eth_phy_ocp_bit(tp, 0xA5EA, BIT_1);
+}
+
+static void
+rtl8126_disable_giga_lite(struct rtl8126_private *tp)
+{
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA428, BIT_9);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA5EA, BIT_0 | BIT_1 | BIT_2);
+}
+
+static void
+rtl8126_set_wol_link_speed(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        unsigned long flags;
+        int auto_nego;
+        int giga_ctrl;
+        int ctrl_2500;
+        u64 adv;
+        u16 anlpar;
+        u16 gbsr;
+        u16 status_2500;
+        u16 aner;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        if (tp->autoneg != AUTONEG_ENABLE)
+                goto exit;
+
+        rtl8126_mdio_write(tp, 0x1F, 0x0000);
+
+        auto_nego = rtl8126_mdio_read(tp, MII_ADVERTISE);
+        auto_nego &= ~(ADVERTISE_10HALF | ADVERTISE_10FULL
+                       | ADVERTISE_100HALF | ADVERTISE_100FULL);
+
+        giga_ctrl = rtl8126_mdio_read(tp, MII_CTRL1000);
+        giga_ctrl &= ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL);
+
+        ctrl_2500 = rtl8126_mdio_direct_read_phy_ocp(tp, 0xA5D4);
+        ctrl_2500 &= ~(RTK_ADVERTISE_2500FULL | RTK_ADVERTISE_5000FULL);
+
+        aner = tp->phy_reg_aner;
+        anlpar = tp->phy_reg_anlpar;
+        gbsr = tp->phy_reg_gbsr;
+        status_2500 = tp->phy_reg_status_2500;
+        if (tp->link_ok(dev)) {
+                aner = rtl8126_mdio_read(tp, MII_EXPANSION);
+                anlpar = rtl8126_mdio_read(tp, MII_LPA);
+                gbsr = rtl8126_mdio_read(tp, MII_STAT1000);
+                status_2500 = rtl8126_mdio_direct_read_phy_ocp(tp, 0xA5D6);
+        }
+
+        adv = tp->advertising;
+        if ((aner | anlpar | gbsr | status_2500) == 0) {
+                int auto_nego_tmp = 0;
+                if (adv & ADVERTISED_10baseT_Half)
+                        auto_nego_tmp |= ADVERTISE_10HALF;
+                if (adv & ADVERTISED_10baseT_Full)
+                        auto_nego_tmp |= ADVERTISE_10FULL;
+                if (adv & ADVERTISED_100baseT_Half)
+                        auto_nego_tmp |= ADVERTISE_100HALF;
+                if (adv & ADVERTISED_100baseT_Full)
+                        auto_nego_tmp |= ADVERTISE_100FULL;
+
+                if (auto_nego_tmp == 0)
+                        goto exit;
+
+                auto_nego |= auto_nego_tmp;
+                goto skip_check_lpa;
+        }
+        if (!(aner & EXPANSION_NWAY))
+                goto exit;
+
+        if ((adv & ADVERTISED_10baseT_Half) && (anlpar & LPA_10HALF))
+                auto_nego |= ADVERTISE_10HALF;
+        else if ((adv & ADVERTISED_10baseT_Full) && (anlpar & LPA_10FULL))
+                auto_nego |= ADVERTISE_10FULL;
+        else if ((adv & ADVERTISED_100baseT_Half) && (anlpar & LPA_100HALF))
+                auto_nego |= ADVERTISE_100HALF;
+        else if ((adv & ADVERTISED_100baseT_Full) && (anlpar & LPA_100FULL))
+                auto_nego |= ADVERTISE_100FULL;
+        else if (adv & ADVERTISED_1000baseT_Half && (gbsr & LPA_1000HALF))
+                giga_ctrl |= ADVERTISE_1000HALF;
+        else if (adv & ADVERTISED_1000baseT_Full && (gbsr & LPA_1000FULL))
+                giga_ctrl |= ADVERTISE_1000FULL;
+        else if (adv & ADVERTISED_2500baseX_Full && (status_2500 & RTK_LPA_ADVERTISE_2500FULL))
+                ctrl_2500 |= RTK_ADVERTISE_2500FULL;
+        else if (adv & RTK_ADVERTISED_5000baseX_Full && (status_2500 & RTK_LPA_ADVERTISE_5000FULL))
+                ctrl_2500 |= RTK_ADVERTISE_5000FULL;
+        else
+                goto exit;
+
+skip_check_lpa:
+
+#ifdef CONFIG_DOWN_SPEED_100
+        auto_nego |= (ADVERTISE_100FULL | ADVERTISE_100HALF | ADVERTISE_10HALF | ADVERTISE_10FULL);
+#endif
+
+        rtl8126_mdio_write(tp, MII_ADVERTISE, auto_nego);
+        rtl8126_mdio_write(tp, MII_CTRL1000, giga_ctrl);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA5D4, ctrl_2500);
+
+        rtl8126_disable_giga_lite(tp);
+
+        rtl8126_phy_restart_nway(dev);
+
+exit:
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        return;
+}
+
+static bool
+rtl8126_keep_wol_link_speed(struct net_device *dev, u8 from_suspend)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (from_suspend && tp->link_ok(dev) && (tp->wol_opts & WAKE_PHY))
+                return 1;
+
+        if (!from_suspend && tp->resume_not_chg_speed)
+                return 1;
+
+        return 0;
+}
+static void
+rtl8126_powerdown_pll(struct net_device *dev, u8 from_suspend)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        /* Reboot not set wol link speed */
+        if (system_state == SYSTEM_RESTART)
+                return;
+
+        tp->check_keep_link_speed = 0;
+        if (tp->wol_enabled == WOL_ENABLED || tp->EnableKCPOffload) {
+                rtl8126_set_hw_wol(dev, tp->wol_opts);
+
+                rtl8126_enable_cfg9346_write(tp);
+                RTL_W8(tp, Config2, RTL_R8(tp, Config2) | PMSTS_En);
+                rtl8126_disable_cfg9346_write(tp);
+
+                /* Enable the PME and clear the status */
+                rtl8126_set_pci_pme(tp, 1);
+
+#ifdef ENABLE_FIBER_SUPPORT
+                if (HW_FIBER_MODE_ENABLED(tp))
+                        return;
+#endif /* ENABLE_FIBER_SUPPORT */
+
+                if (rtl8126_keep_wol_link_speed(dev, from_suspend)) {
+                        tp->check_keep_link_speed = 1;
+                } else {
+                        if (tp->D0SpeedUpSpeed != D0_SPEED_UP_SPEED_DISABLE) {
+                                rtl8126_enable_d0_speedup(tp);
+                                tp->check_keep_link_speed = 1;
+                        }
+
+                        rtl8126_set_wol_link_speed(dev);
+                }
+
+                RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) | AcceptBroadcast | AcceptMulticast | AcceptMyPhys);
+
+                return;
+        }
+
+#ifdef ENABLE_FIBER_SUPPORT
+        if (HW_FIBER_MODE_ENABLED(tp))
+                return;
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        rtl8126_phy_power_down(dev);
+
+        if (!tp->HwIcVerUnknown)
+                RTL_W8(tp, PMCH, RTL_R8(tp, PMCH) & ~BIT_7);
+
+        RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) & ~BIT_6);
+}
+
+static void rtl8126_powerup_pll(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        RTL_W8(tp, PMCH, RTL_R8(tp, PMCH) | BIT_7 | BIT_6);
+
+        if (tp->resume_not_chg_speed)
+                return;
+
+        rtl8126_phy_power_up(dev);
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static void
+rtl8126_get_wol(struct net_device *dev,
+                struct ethtool_wolinfo *wol)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u8 options;
+
+        wol->wolopts = 0;
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT || disable_wol_support) {
+                wol->supported = 0;
+                return;
+        } else {
+                wol->supported = WAKE_ANY;
+        }
+
+        options = RTL_R8(tp, Config1);
+        if (!(options & PMEnable))
+                return;
+
+        wol->wolopts = tp->wol_opts;
+}
+
+static int
+rtl8126_set_wol(struct net_device *dev,
+                struct ethtool_wolinfo *wol)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT || disable_wol_support)
+                return -EOPNOTSUPP;
+
+        tp->wol_opts = wol->wolopts;
+
+        tp->wol_enabled = (tp->wol_opts) ? WOL_ENABLED : WOL_DISABLED;
+
+        device_set_wakeup_enable(tp_to_dev(tp), wol->wolopts);
+
+        return 0;
+}
+
+static void
+rtl8126_get_drvinfo(struct net_device *dev,
+                    struct ethtool_drvinfo *info)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        struct rtl8126_fw *rtl_fw = tp->rtl_fw;
+
+        strscpy(info->driver, MODULENAME, sizeof(info->driver));
+        strscpy(info->version, RTL8126_VERSION, sizeof(info->version));
+        strscpy(info->bus_info, pci_name(tp->pci_dev), sizeof(info->bus_info));
+        info->regdump_len = R8126_REGS_DUMP_SIZE;
+        info->eedump_len = tp->eeprom_len;
+        BUILD_BUG_ON(sizeof(info->fw_version) < sizeof(rtl_fw->version));
+        if (rtl_fw)
+                strscpy(info->fw_version, rtl_fw->version,
+                        sizeof(info->fw_version));
+}
+
+static int
+rtl8126_get_regs_len(struct net_device *dev)
+{
+        return R8126_REGS_DUMP_SIZE;
+}
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+static void
+rtl8126_set_d0_speedup_speed(struct rtl8126_private *tp)
+{
+        if (FALSE == HW_SUPPORT_D0_SPEED_UP(tp))
+                return;
+
+        tp->D0SpeedUpSpeed = D0_SPEED_UP_SPEED_DISABLE;
+        if (tp->autoneg == AUTONEG_ENABLE) {
+                if (tp->speed == SPEED_5000)
+                        tp->D0SpeedUpSpeed = D0_SPEED_UP_SPEED_5000;
+                else if (tp->speed == SPEED_2500)
+                        tp->D0SpeedUpSpeed = D0_SPEED_UP_SPEED_2500;
+                else if (tp->speed == SPEED_1000)
+                        tp->D0SpeedUpSpeed = D0_SPEED_UP_SPEED_1000;
+        }
+}
+
+static int
+rtl8126_set_speed_xmii(struct net_device *dev,
+                       u8 autoneg,
+                       u32 speed,
+                       u8 duplex,
+                       u64 adv)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        unsigned long flags;
+        int auto_nego = 0;
+        int giga_ctrl = 0;
+        int ctrl_2500 = 0;
+        int rc = -EINVAL;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        if (!rtl8126_is_speed_mode_valid(speed)) {
+                speed = SPEED_5000;
+                duplex = DUPLEX_FULL;
+                adv |= tp->advertising;
+        }
+
+        if (eee_giga_lite && (autoneg == AUTONEG_ENABLE))
+                rtl8126_enable_giga_lite(tp, adv);
+        else
+                rtl8126_disable_giga_lite(tp);
+
+        giga_ctrl = rtl8126_mdio_read(tp, MII_CTRL1000);
+        giga_ctrl &= ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL);
+        ctrl_2500 = rtl8126_mdio_direct_read_phy_ocp(tp, 0xA5D4);
+        ctrl_2500 &= ~(RTK_ADVERTISE_2500FULL | RTK_ADVERTISE_5000FULL);
+
+        if (autoneg == AUTONEG_ENABLE) {
+                /*n-way force*/
+                auto_nego = rtl8126_mdio_read(tp, MII_ADVERTISE);
+                auto_nego &= ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
+                               ADVERTISE_100HALF | ADVERTISE_100FULL |
+                               ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+
+                if (adv & ADVERTISED_10baseT_Half)
+                        auto_nego |= ADVERTISE_10HALF;
+                if (adv & ADVERTISED_10baseT_Full)
+                        auto_nego |= ADVERTISE_10FULL;
+                if (adv & ADVERTISED_100baseT_Half)
+                        auto_nego |= ADVERTISE_100HALF;
+                if (adv & ADVERTISED_100baseT_Full)
+                        auto_nego |= ADVERTISE_100FULL;
+                if (adv & ADVERTISED_1000baseT_Half)
+                        giga_ctrl |= ADVERTISE_1000HALF;
+                if (adv & ADVERTISED_1000baseT_Full)
+                        giga_ctrl |= ADVERTISE_1000FULL;
+                if (adv & ADVERTISED_2500baseX_Full)
+                        ctrl_2500 |= RTK_ADVERTISE_2500FULL;
+                if (HW_SUPP_PHY_LINK_SPEED_5000M(tp)) {
+                        if (adv & RTK_ADVERTISED_5000baseX_Full)
+                                ctrl_2500 |= RTK_ADVERTISE_5000FULL;
+                }
+
+                //flow control
+                if (tp->fcpause == rtl8126_fc_full)
+                        auto_nego |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;
+
+                tp->phy_auto_nego_reg = auto_nego;
+                tp->phy_1000_ctrl_reg = giga_ctrl;
+
+                tp->phy_2500_ctrl_reg = ctrl_2500;
+
+                rtl8126_mdio_write(tp, 0x1f, 0x0000);
+                rtl8126_mdio_write(tp, MII_ADVERTISE, auto_nego);
+                rtl8126_mdio_write(tp, MII_CTRL1000, giga_ctrl);
+                rtl8126_mdio_direct_write_phy_ocp(tp, 0xA5D4, ctrl_2500);
+                rtl8126_phy_restart_nway(dev);
+        } else {
+                /*true force*/
+                if (speed == SPEED_10 || speed == SPEED_100)
+                        rtl8126_phy_setup_force_mode(dev, speed, duplex);
+                else
+                        goto out;
+        }
+
+        tp->autoneg = autoneg;
+        tp->speed = speed;
+        tp->duplex = duplex;
+        tp->advertising = adv;
+
+        rtl8126_set_d0_speedup_speed(tp);
+
+        rc = 0;
+out:
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        return rc;
+}
+
+static int
+rtl8126_set_speed(struct net_device *dev,
+                  u8 autoneg,
+                  u32 speed,
+                  u8 duplex,
+                  u64 adv)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int ret;
+
+        if (tp->resume_not_chg_speed)
+                return 0;
+
+        ret = tp->set_speed(dev, autoneg, speed, duplex, adv);
+
+        return ret;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static int
+rtl8126_set_settings(struct net_device *dev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+                     struct ethtool_cmd *cmd
+#else
+                     const struct ethtool_link_ksettings *cmd
+#endif
+                    )
+{
+        int ret;
+        u8 autoneg;
+        u32 speed;
+        u8 duplex;
+        u64 supported = 0, advertising = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+        autoneg = cmd->autoneg;
+        speed = cmd->speed;
+        duplex = cmd->duplex;
+        supported = cmd->supported;
+        advertising = cmd->advertising;
+#else
+        struct rtl8126_private *tp = netdev_priv(dev);
+        const struct ethtool_link_settings *base = &cmd->base;
+        autoneg = base->autoneg;
+        speed = base->speed;
+        duplex = base->duplex;
+        ethtool_convert_link_mode_to_legacy_u32((u32*)&supported,
+                                                cmd->link_modes.supported);
+        ethtool_convert_link_mode_to_legacy_u32((u32*)&advertising,
+                                                cmd->link_modes.advertising);
+        if (test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                     cmd->link_modes.supported))
+                supported |= ADVERTISED_2500baseX_Full;
+        if (test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                     cmd->link_modes.advertising))
+                advertising |= ADVERTISED_2500baseX_Full;
+        if (HW_SUPP_PHY_LINK_SPEED_5000M(tp)) {
+                if (test_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+                             cmd->link_modes.supported))
+                        supported |= RTK_ADVERTISED_5000baseX_Full;
+                if (test_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+                             cmd->link_modes.advertising))
+                        advertising |= RTK_ADVERTISED_5000baseX_Full;
+        }
+#endif
+        if (advertising & ~supported)
+                return -EINVAL;
+
+        ret = rtl8126_set_speed(dev, autoneg, speed, duplex, advertising);
+
+        return ret;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+static u32
+rtl8126_get_tx_csum(struct net_device *dev)
+{
+        u32 ret;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        ret = ((dev->features & NETIF_F_IP_CSUM) != 0);
+#else
+        ret = ((dev->features & (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM)) != 0);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+        return ret;
+}
+
+static u32
+rtl8126_get_rx_csum(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u32 ret;
+
+        ret = tp->cp_cmd & RxChkSum;
+
+        return ret;
+}
+
+static int
+rtl8126_set_tx_csum(struct net_device *dev,
+                    u32 data)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                return -EOPNOTSUPP;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        if (data)
+                dev->features |= NETIF_F_IP_CSUM;
+        else
+                dev->features &= ~NETIF_F_IP_CSUM;
+#else
+        if (data)
+                dev->features |= (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+        else
+                dev->features &= ~(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+        return 0;
+}
+
+static int
+rtl8126_set_rx_csum(struct net_device *dev,
+                    u32 data)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                return -EOPNOTSUPP;
+
+        if (data)
+                tp->cp_cmd |= RxChkSum;
+        else
+                tp->cp_cmd &= ~RxChkSum;
+
+        RTL_W16(tp, CPlusCmd, tp->cp_cmd);
+
+        return 0;
+}
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+static u32
+rtl8126_rx_desc_opts1(struct rtl8126_private *tp,
+                      struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                return READ_ONCE(((struct RxDescV3 *)desc)->RxDescNormalDDWord4.opts1);
+        case RX_DESC_RING_TYPE_4:
+                return READ_ONCE(((struct RxDescV4 *)desc)->RxDescNormalDDWord2.opts1);
+        default:
+                return READ_ONCE(desc->opts1);
+        }
+}
+
+static u32
+rtl8126_rx_desc_opts2(struct rtl8126_private *tp,
+                      struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                return ((struct RxDescV3 *)desc)->RxDescNormalDDWord4.opts2;
+        case RX_DESC_RING_TYPE_4:
+                return ((struct RxDescV4 *)desc)->RxDescNormalDDWord2.opts2;
+        default:
+                return desc->opts2;
+        }
+}
+
+#ifdef CONFIG_R8126_VLAN
+
+static void
+rtl8126_clear_rx_desc_opts2(struct rtl8126_private *tp,
+                            struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                ((struct RxDescV3 *)desc)->RxDescNormalDDWord4.opts2 = 0;
+                break;
+        case RX_DESC_RING_TYPE_4:
+                ((struct RxDescV4 *)desc)->RxDescNormalDDWord2.opts2 = 0;
+                break;
+        default:
+                desc->opts2 = 0;
+                break;
+        }
+}
+
+
+static inline u32
+rtl8126_tx_vlan_tag(struct rtl8126_private *tp,
+                    struct sk_buff *skb)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        return (tp->vlgrp && vlan_tx_tag_present(skb)) ?
+               TxVlanTag | swab16(vlan_tx_tag_get(skb)) : 0x00;
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+        return (vlan_tx_tag_present(skb)) ?
+               TxVlanTag | swab16(vlan_tx_tag_get(skb)) : 0x00;
+#else
+        return (skb_vlan_tag_present(skb)) ?
+               TxVlanTag | swab16(skb_vlan_tag_get(skb)) : 0x00;
+#endif
+
+        return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+static void
+rtl8126_vlan_rx_register(struct net_device *dev,
+                         struct vlan_group *grp)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        tp->vlgrp = grp;
+
+        if (tp->vlgrp) {
+                tp->rtl8126_rx_config |= (EnableInnerVlan | EnableOuterVlan);
+                RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) | (EnableInnerVlan | EnableOuterVlan))
+        } else {
+                tp->rtl8126_rx_config &= ~(EnableInnerVlan | EnableOuterVlan);
+                RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) & ~(EnableInnerVlan | EnableOuterVlan))
+        }
+}
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+static void
+rtl8126_vlan_rx_kill_vid(struct net_device *dev,
+                         unsigned short vid)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+        if (tp->vlgrp)
+                tp->vlgrp->vlan_devices[vid] = NULL;
+#else
+        vlan_group_set_device(tp->vlgrp, vid, NULL);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+}
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+
+static int
+rtl8126_rx_vlan_skb(struct rtl8126_private *tp,
+                    struct RxDesc *desc,
+                    struct sk_buff *skb)
+{
+        u32 opts2 = le32_to_cpu(rtl8126_rx_desc_opts2(tp, desc));
+        int ret = -1;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        if (tp->vlgrp && (opts2 & RxVlanTag)) {
+                rtl8126_rx_hwaccel_skb(skb, tp->vlgrp,
+                                       swab16(opts2 & 0xffff));
+                ret = 0;
+        }
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+        if (opts2 & RxVlanTag)
+                __vlan_hwaccel_put_tag(skb, swab16(opts2 & 0xffff));
+#else
+        if (opts2 & RxVlanTag)
+                __vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), swab16(opts2 & 0xffff));
+#endif
+
+        rtl8126_clear_rx_desc_opts2(tp, desc);
+        return ret;
+}
+
+#else /* !CONFIG_R8126_VLAN */
+
+static inline u32
+rtl8126_tx_vlan_tag(struct rtl8126_private *tp,
+                    struct sk_buff *skb)
+{
+        return 0;
+}
+
+static int
+rtl8126_rx_vlan_skb(struct rtl8126_private *tp,
+                    struct RxDesc *desc,
+                    struct sk_buff *skb)
+{
+        return -1;
+}
+
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+
+static netdev_features_t rtl8126_fix_features(struct net_device *dev,
+                netdev_features_t features)
+{
+        if (dev->mtu > MSS_MAX || dev->mtu > ETH_DATA_LEN)
+                features &= ~NETIF_F_ALL_TSO;
+#ifndef CONFIG_R8126_VLAN
+        features &= ~NETIF_F_ALL_CSUM;
+#endif
+
+        return features;
+}
+
+static int rtl8126_hw_set_features(struct net_device *dev,
+                                   netdev_features_t features)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u32 rx_config;
+
+        rx_config = RTL_R32(tp, RxConfig);
+        if (features & NETIF_F_RXALL) {
+                tp->rtl8126_rx_config |= (AcceptErr | AcceptRunt);
+                rx_config |= (AcceptErr | AcceptRunt);
+        } else {
+                tp->rtl8126_rx_config &= ~(AcceptErr | AcceptRunt);
+                rx_config &= ~(AcceptErr | AcceptRunt);
+        }
+
+        if (features & NETIF_F_HW_VLAN_RX) {
+                tp->rtl8126_rx_config |= (EnableInnerVlan | EnableOuterVlan);
+                rx_config |= (EnableInnerVlan | EnableOuterVlan);
+        } else {
+                tp->rtl8126_rx_config &= ~(EnableInnerVlan | EnableOuterVlan);
+                rx_config &= ~(EnableInnerVlan | EnableOuterVlan);
+        }
+
+        RTL_W32(tp, RxConfig, rx_config);
+
+        if (features & NETIF_F_RXCSUM)
+                tp->cp_cmd |= RxChkSum;
+        else
+                tp->cp_cmd &= ~RxChkSum;
+
+        RTL_W16(tp, CPlusCmd, tp->cp_cmd);
+        RTL_R16(tp, CPlusCmd);
+
+        return 0;
+}
+
+static int rtl8126_set_features(struct net_device *dev,
+                                netdev_features_t features)
+{
+        features &= NETIF_F_RXALL | NETIF_F_RXCSUM | NETIF_F_HW_VLAN_RX;
+
+        rtl8126_hw_set_features(dev, features);
+
+        return 0;
+}
+
+#endif
+
+static u8 rtl8126_get_mdi_status(struct rtl8126_private *tp)
+{
+        if (!tp->link_ok(tp->dev))
+                return ETH_TP_MDI_INVALID;
+
+        if (rtl8126_mdio_direct_read_phy_ocp(tp, 0xA444) & BIT_1)
+                return ETH_TP_MDI;
+        else
+                return ETH_TP_MDI_X;
+}
+
+static void rtl8126_gset_xmii(struct net_device *dev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+                              struct ethtool_cmd *cmd
+#else
+                              struct ethtool_link_ksettings *cmd
+#endif
+                             )
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u16 aner = tp->phy_reg_aner;
+        u16 anlpar = tp->phy_reg_anlpar;
+        u16 gbsr = tp->phy_reg_gbsr;
+        u16 status_2500 = tp->phy_reg_status_2500;
+        unsigned long flags;
+        u64 lpa_adv = 0;
+        u32 status;
+        u8 autoneg, duplex;
+        u32 speed = 0;
+        u16 bmcr;
+        u64 supported, advertising;
+        u8 report_lpa = 0;
+
+        supported = SUPPORTED_10baseT_Half |
+                    SUPPORTED_10baseT_Full |
+                    SUPPORTED_100baseT_Half |
+                    SUPPORTED_100baseT_Full |
+                    SUPPORTED_1000baseT_Full |
+                    SUPPORTED_2500baseX_Full |
+                    RTK_SUPPORTED_5000baseX_Full |
+                    SUPPORTED_Autoneg |
+                    SUPPORTED_TP |
+                    SUPPORTED_Pause |
+                    SUPPORTED_Asym_Pause;
+
+        if (!HW_SUPP_PHY_LINK_SPEED_2500M(tp))
+                supported &= ~SUPPORTED_2500baseX_Full;
+
+        if (!HW_SUPP_PHY_LINK_SPEED_5000M(tp))
+                supported &= ~RTK_SUPPORTED_5000baseX_Full;
+
+        advertising = tp->advertising;
+        if (tp->phy_auto_nego_reg || tp->phy_1000_ctrl_reg ||
+            tp->phy_2500_ctrl_reg) {
+                advertising = 0;
+                if (tp->phy_auto_nego_reg & ADVERTISE_10HALF)
+                        advertising |= ADVERTISED_10baseT_Half;
+                if (tp->phy_auto_nego_reg & ADVERTISE_10FULL)
+                        advertising |= ADVERTISED_10baseT_Full;
+                if (tp->phy_auto_nego_reg & ADVERTISE_100HALF)
+                        advertising |= ADVERTISED_100baseT_Half;
+                if (tp->phy_auto_nego_reg & ADVERTISE_100FULL)
+                        advertising |= ADVERTISED_100baseT_Full;
+                if (tp->phy_1000_ctrl_reg & ADVERTISE_1000FULL)
+                        advertising |= ADVERTISED_1000baseT_Full;
+                if (tp->phy_2500_ctrl_reg & RTK_ADVERTISE_2500FULL)
+                        advertising |= ADVERTISED_2500baseX_Full;
+                if (tp->phy_2500_ctrl_reg & RTK_ADVERTISE_5000FULL)
+                        advertising |= RTK_ADVERTISED_5000baseX_Full;
+        }
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        rtl8126_mdio_write(tp, 0x1F, 0x0000);
+        bmcr = rtl8126_mdio_read(tp, MII_BMCR);
+        if (bmcr & BMCR_ANENABLE) {
+                autoneg = AUTONEG_ENABLE;
+                advertising |= ADVERTISED_Autoneg;
+        } else {
+                autoneg = AUTONEG_DISABLE;
+        }
+
+        advertising |= ADVERTISED_TP;
+
+        status = rtl8126_get_phy_status(tp);
+        if (netif_running(dev) && (status & LinkStatus))
+                report_lpa = 1;
+#ifdef ENABLE_FIBER_SUPPORT
+        if (HW_FIBER_MODE_ENABLED(tp) &&
+            (rtl8126_fiber_link_ok(dev) != R8126_LINK_STATE_ON))
+                report_lpa = 0;
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        if (report_lpa) {
+                /*link on*/
+                speed = rtl8126_convert_link_speed(status);
+
+                if (status & TxFlowCtrl)
+                        advertising |= ADVERTISED_Asym_Pause;
+
+                if (status & RxFlowCtrl)
+                        advertising |= ADVERTISED_Pause;
+
+                duplex = ((status & (_1000bpsF | _2500bpsF | _5000bpsF)) ||
+                          (status & FullDup)) ?
+                         DUPLEX_FULL : DUPLEX_HALF;
+
+                /*link partner*/
+                if (aner & EXPANSION_NWAY)
+                        lpa_adv |= ADVERTISED_Autoneg;
+                if (anlpar & LPA_10HALF)
+                        lpa_adv |= ADVERTISED_10baseT_Half;
+                if (anlpar & LPA_10FULL)
+                        lpa_adv |= ADVERTISED_10baseT_Full;
+                if (anlpar & LPA_100HALF)
+                        lpa_adv |= ADVERTISED_100baseT_Half;
+                if (anlpar & LPA_100FULL)
+                        lpa_adv |= ADVERTISED_100baseT_Full;
+                if (anlpar & LPA_PAUSE_CAP)
+                        lpa_adv |= ADVERTISED_Pause;
+                if (anlpar & LPA_PAUSE_ASYM)
+                        lpa_adv |= ADVERTISED_Asym_Pause;
+                if (gbsr & LPA_1000HALF)
+                        lpa_adv |= ADVERTISED_1000baseT_Half;
+                if (gbsr & LPA_1000FULL)
+                        lpa_adv |= ADVERTISED_1000baseT_Full;
+                if (status_2500 & RTK_LPA_ADVERTISE_2500FULL)
+                        lpa_adv |= ADVERTISED_2500baseX_Full;
+                if (status_2500 & RTK_LPA_ADVERTISE_5000FULL)
+                        lpa_adv |= RTK_ADVERTISED_5000baseX_Full;
+        } else {
+                /*link down*/
+                speed = SPEED_UNKNOWN;
+                duplex = DUPLEX_UNKNOWN;
+                lpa_adv = 0;
+        }
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+        cmd->supported = (u32)supported;
+        cmd->advertising = (u32)advertising;
+        cmd->autoneg = autoneg;
+        cmd->speed = speed;
+        cmd->duplex = duplex;
+        cmd->port = PORT_TP;
+        cmd->lp_advertising = (u32)lpa_adv;
+        cmd->eth_tp_mdix = rtl8126_get_mdi_status(tp);
+#else
+        ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,
+                                                supported);
+        ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,
+                                                advertising);
+        ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.lp_advertising,
+                                                lpa_adv);
+
+        if (supported & SUPPORTED_2500baseX_Full) {
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                                 cmd->link_modes.supported, 1);
+        }
+        if (advertising & ADVERTISED_2500baseX_Full) {
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                                 cmd->link_modes.advertising, 1);
+        }
+        if (supported & RTK_SUPPORTED_5000baseX_Full) {
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+                                 cmd->link_modes.supported, 1);
+        }
+        if (advertising & RTK_ADVERTISED_5000baseX_Full) {
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+                                 cmd->link_modes.advertising, 1);
+        }
+        if (report_lpa) {
+                if (lpa_adv & ADVERTISED_2500baseX_Full) {
+                        linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                                         cmd->link_modes.lp_advertising, 1);
+                }
+                if (lpa_adv & RTK_ADVERTISED_5000baseX_Full)
+                        linkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+                                         cmd->link_modes.lp_advertising, 1);
+        }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+        /* Use ETHTOOL_LINK_MODE_2500baseT_Full_BIT instead of
+           ETHTOOL_LINK_MODE_2500baseX_Full_BIT. */
+        linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT,
+                         cmd->link_modes.supported, 0);
+
+        linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT,
+                         cmd->link_modes.advertising, 0);
+
+        linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT,
+                         cmd->link_modes.lp_advertising, 0);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0) */
+
+        cmd->base.autoneg = autoneg;
+        cmd->base.speed = speed;
+        cmd->base.duplex = duplex;
+        cmd->base.port = PORT_TP;
+        cmd->base.eth_tp_mdix = rtl8126_get_mdi_status(tp);
+#endif
+        r8126_spin_unlock(&tp->phy_lock, flags);
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static int
+rtl8126_get_settings(struct net_device *dev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+                     struct ethtool_cmd *cmd
+#else
+                     struct ethtool_link_ksettings *cmd
+#endif
+                    )
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        tp->get_settings(dev, cmd);
+
+        return 0;
+}
+
+static void rtl8126_get_regs(struct net_device *dev, struct ethtool_regs *regs,
+                             void *p)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+        unsigned int i;
+        u8 *data = p;
+
+        if (regs->len < R8126_REGS_DUMP_SIZE)
+                return /* -EINVAL */;
+
+        memset(p, 0, regs->len);
+
+        for (i = 0; i < R8126_MAC_REGS_SIZE; i++)
+                *data++ = readb(ioaddr + i);
+        data = (u8*)p + 256;
+
+        rtl8126_mdio_write(tp, 0x1F, 0x0000);
+        for (i = 0; i < R8126_PHY_REGS_SIZE/2; i++) {
+                *(u16*)data = rtl8126_mdio_read(tp, i);
+                data += 2;
+        }
+        data = (u8*)p + 256 * 2;
+
+        for (i = 0; i < R8126_EPHY_REGS_SIZE/2; i++) {
+                *(u16*)data = rtl8126_ephy_read(tp, i);
+                data += 2;
+        }
+        data = (u8*)p + 256 * 3;
+
+        for (i = 0; i < R8126_ERI_REGS_SIZE; i+=4) {
+                *(u32*)data = rtl8126_eri_read(tp, i , 4, ERIAR_ExGMAC);
+                data += 4;
+        }
+}
+
+static void rtl8126_get_pauseparam(struct net_device *dev,
+                                   struct ethtool_pauseparam *pause)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        pause->autoneg = (tp->autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE);
+        if (tp->fcpause == rtl8126_fc_rx_pause)
+                pause->rx_pause = 1;
+        else if (tp->fcpause == rtl8126_fc_tx_pause)
+                pause->tx_pause = 1;
+        else if (tp->fcpause == rtl8126_fc_full) {
+                pause->rx_pause = 1;
+                pause->tx_pause = 1;
+        }
+}
+
+static int rtl8126_set_pauseparam(struct net_device *dev,
+                                  struct ethtool_pauseparam *pause)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        enum rtl8126_fc_mode newfc;
+
+        if (pause->tx_pause || pause->rx_pause)
+                newfc = rtl8126_fc_full;
+        else
+                newfc = rtl8126_fc_none;
+
+        if (tp->fcpause != newfc) {
+                tp->fcpause = newfc;
+
+                rtl8126_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+        }
+
+        return 0;
+
+}
+
+static u32
+rtl8126_get_msglevel(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        return tp->msg_enable;
+}
+
+static void
+rtl8126_set_msglevel(struct net_device *dev,
+                     u32 value)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        tp->msg_enable = value;
+}
+
+static const char rtl8126_gstrings[][ETH_GSTRING_LEN] = {
+        /* legacy */
+        "tx_packets",
+        "rx_packets",
+        "tx_errors",
+        "rx_errors",
+        "rx_missed",
+        "align_errors",
+        "tx_single_collisions",
+        "tx_multi_collisions",
+        "unicast",
+        "broadcast",
+        "multicast",
+        "tx_aborted",
+        "tx_underrun",
+
+        /* extended */
+        "tx_octets",
+        "rx_octets",
+        "rx_multicast64",
+        "tx_unicast64",
+        "tx_broadcast64",
+        "tx_multicast64",
+        "tx_pause_on",
+        "tx_pause_off",
+        "tx_pause_all",
+        "tx_deferred",
+        "tx_late_collision",
+        "tx_all_collision",
+        "tx_aborted32",
+        "align_errors32",
+        "rx_frame_too_long",
+        "rx_runt",
+        "rx_pause_on",
+        "rx_pause_off",
+        "rx_pause_all",
+        "rx_unknown_opcode",
+        "rx_mac_error",
+        "tx_underrun32",
+        "rx_mac_missed",
+        "rx_tcam_dropped",
+        "tdu",
+        "rdu",
+};
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static int rtl8126_get_stats_count(struct net_device *dev)
+{
+        return ARRAY_SIZE(rtl8126_gstrings);
+}
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+#else
+static int rtl8126_get_sset_count(struct net_device *dev, int sset)
+{
+        switch (sset) {
+        case ETH_SS_STATS:
+                return ARRAY_SIZE(rtl8126_gstrings);
+        default:
+                return -EOPNOTSUPP;
+        }
+}
+#endif
+
+static void
+rtl8126_set_ring_size(struct rtl8126_private *tp, u32 rx, u32 tx)
+{
+        int i;
+
+        for (i = 0; i < R8126_MAX_RX_QUEUES; i++)
+                tp->rx_ring[i].num_rx_desc = rx;
+
+        for (i = 0; i < R8126_MAX_TX_QUEUES; i++)
+                tp->tx_ring[i].num_tx_desc = tx;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+static void rtl8126_get_ringparam(struct net_device *dev,
+                                  struct ethtool_ringparam *ring,
+                                  struct kernel_ethtool_ringparam *kernel_ring,
+                                  struct netlink_ext_ack *extack)
+#else
+static void rtl8126_get_ringparam(struct net_device *dev,
+                                  struct ethtool_ringparam *ring)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        ring->rx_max_pending = MAX_NUM_TX_DESC;
+        ring->tx_max_pending = MAX_NUM_RX_DESC;
+        ring->rx_pending = tp->rx_ring[0].num_rx_desc;
+        ring->tx_pending = tp->tx_ring[0].num_tx_desc;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+static int rtl8126_set_ringparam(struct net_device *dev,
+                                 struct ethtool_ringparam *ring,
+                                 struct kernel_ethtool_ringparam *kernel_ring,
+                                 struct netlink_ext_ack *extack)
+#else
+static int rtl8126_set_ringparam(struct net_device *dev,
+                                 struct ethtool_ringparam *ring)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u32 new_rx_count, new_tx_count;
+        int rc = 0;
+
+        if ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))
+                return -EINVAL;
+
+        new_tx_count = clamp_t(u32, ring->tx_pending,
+                               MIN_NUM_TX_DESC, MAX_NUM_TX_DESC);
+
+        new_rx_count = clamp_t(u32, ring->rx_pending,
+                               MIN_NUM_RX_DESC, MAX_NUM_RX_DESC);
+
+        if ((new_rx_count == tp->rx_ring[0].num_rx_desc) &&
+            (new_tx_count == tp->tx_ring[0].num_tx_desc)) {
+                /* nothing to do */
+                return 0;
+        }
+
+        if (netif_running(dev)) {
+                rtl8126_wait_for_quiescence(dev);
+                rtl8126_close(dev);
+        }
+
+        rtl8126_set_ring_size(tp, new_rx_count, new_tx_count);
+
+        if (netif_running(dev))
+                rc = rtl8126_open(dev);
+
+        return rc;
+}
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static void
+rtl8126_get_ethtool_stats(struct net_device *dev,
+                          struct ethtool_stats *stats,
+                          u64 *data)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        struct rtl8126_counters *counters;
+        dma_addr_t paddr;
+
+        ASSERT_RTNL();
+
+        counters = tp->tally_vaddr;
+        paddr = tp->tally_paddr;
+        if (!counters)
+                return;
+
+        rtl8126_dump_tally_counter(tp, paddr);
+
+        data[0] = le64_to_cpu(counters->tx_packets);
+        data[1] = le64_to_cpu(counters->rx_packets);
+        data[2] = le64_to_cpu(counters->tx_errors);
+        data[3] = le32_to_cpu(counters->rx_errors);
+        data[4] = le16_to_cpu(counters->rx_missed);
+        data[5] = le16_to_cpu(counters->align_errors);
+        data[6] = le32_to_cpu(counters->tx_one_collision);
+        data[7] = le32_to_cpu(counters->tx_multi_collision);
+        data[8] = le64_to_cpu(counters->rx_unicast);
+        data[9] = le64_to_cpu(counters->rx_broadcast);
+        data[10] = le32_to_cpu(counters->rx_multicast);
+        data[11] = le16_to_cpu(counters->tx_aborted);
+        data[12] = le16_to_cpu(counters->tx_underrun);
+
+        data[13] = le64_to_cpu(counters->tx_octets);
+        data[14] = le64_to_cpu(counters->rx_octets);
+        data[15] = le64_to_cpu(counters->rx_multicast64);
+        data[16] = le64_to_cpu(counters->tx_unicast64);
+        data[17] = le64_to_cpu(counters->tx_broadcast64);
+        data[18] = le64_to_cpu(counters->tx_multicast64);
+        data[19] = le32_to_cpu(counters->tx_pause_on);
+        data[20] = le32_to_cpu(counters->tx_pause_off);
+        data[21] = le32_to_cpu(counters->tx_pause_all);
+        data[22] = le32_to_cpu(counters->tx_deferred);
+        data[23] = le32_to_cpu(counters->tx_late_collision);
+        data[24] = le32_to_cpu(counters->tx_all_collision);
+        data[25] = le32_to_cpu(counters->tx_aborted32);
+        data[26] = le32_to_cpu(counters->align_errors32);
+        data[27] = le32_to_cpu(counters->rx_frame_too_long);
+        data[28] = le32_to_cpu(counters->rx_runt);
+        data[29] = le32_to_cpu(counters->rx_pause_on);
+        data[30] = le32_to_cpu(counters->rx_pause_off);
+        data[31] = le32_to_cpu(counters->rx_pause_all);
+        data[32] = le32_to_cpu(counters->rx_unknown_opcode);
+        data[33] = le32_to_cpu(counters->rx_mac_error);
+        data[34] = le32_to_cpu(counters->tx_underrun32);
+        data[35] = le32_to_cpu(counters->rx_mac_missed);
+        data[36] = le32_to_cpu(counters->rx_tcam_dropped);
+        data[37] = le32_to_cpu(counters->tdu);
+        data[38] = le32_to_cpu(counters->rdu);
+}
+
+static void
+rtl8126_get_strings(struct net_device *dev,
+                    u32 stringset,
+                    u8 *data)
+{
+        switch (stringset) {
+        case ETH_SS_STATS:
+                memcpy(data, rtl8126_gstrings, sizeof(rtl8126_gstrings));
+                break;
+        }
+}
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+static int rtl_get_eeprom_len(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        return tp->eeprom_len;
+}
+
+static int rtl_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *buf)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i,j,ret;
+        int start_w, end_w;
+        int VPD_addr, VPD_data;
+        u32 *eeprom_buff;
+        u16 tmp;
+
+        if (tp->eeprom_type == EEPROM_TYPE_NONE) {
+                dev_printk(KERN_DEBUG, tp_to_dev(tp), "Detect none EEPROM\n");
+                return -EOPNOTSUPP;
+        } else if (eeprom->len == 0 || (eeprom->offset+eeprom->len) > tp->eeprom_len) {
+                dev_printk(KERN_DEBUG, tp_to_dev(tp), "Invalid parameter\n");
+                return -EINVAL;
+        }
+
+        VPD_addr = 0xD2;
+        VPD_data = 0xD4;
+
+        start_w = eeprom->offset >> 2;
+        end_w = (eeprom->offset + eeprom->len - 1) >> 2;
+
+        eeprom_buff = kmalloc(sizeof(u32)*(end_w - start_w + 1), GFP_KERNEL);
+        if (!eeprom_buff)
+                return -ENOMEM;
+
+        rtl8126_enable_cfg9346_write(tp);
+        ret = -EFAULT;
+        for (i=start_w; i<=end_w; i++) {
+                pci_write_config_word(tp->pci_dev, VPD_addr, (u16)i*4);
+                ret = -EFAULT;
+                for (j = 0; j < 10; j++) {
+                        udelay(400);
+                        pci_read_config_word(tp->pci_dev, VPD_addr, &tmp);
+                        if (tmp&0x8000) {
+                                ret = 0;
+                                break;
+                        }
+                }
+
+                if (ret)
+                        break;
+
+                pci_read_config_dword(tp->pci_dev, VPD_data, &eeprom_buff[i-start_w]);
+        }
+        rtl8126_disable_cfg9346_write(tp);
+
+        if (!ret)
+                memcpy(buf, (u8 *)eeprom_buff + (eeprom->offset & 3), eeprom->len);
+
+        kfree(eeprom_buff);
+
+        return ret;
+}
+
+#undef ethtool_op_get_link
+#define ethtool_op_get_link _kc_ethtool_op_get_link
+static u32 _kc_ethtool_op_get_link(struct net_device *dev)
+{
+        return netif_carrier_ok(dev) ? 1 : 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+#undef ethtool_op_get_sg
+#define ethtool_op_get_sg _kc_ethtool_op_get_sg
+static u32 _kc_ethtool_op_get_sg(struct net_device *dev)
+{
+#ifdef NETIF_F_SG
+        return (dev->features & NETIF_F_SG) != 0;
+#else
+        return 0;
+#endif
+}
+
+#undef ethtool_op_set_sg
+#define ethtool_op_set_sg _kc_ethtool_op_set_sg
+static int _kc_ethtool_op_set_sg(struct net_device *dev, u32 data)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                return -EOPNOTSUPP;
+
+#ifdef NETIF_F_SG
+        if (data)
+                dev->features |= NETIF_F_SG;
+        else
+                dev->features &= ~NETIF_F_SG;
+#endif
+
+        return 0;
+}
+#endif
+
+static void
+rtl8126_set_eee_lpi_timer(struct rtl8126_private *tp)
+{
+        u16 dev_lpi_timer;
+
+        dev_lpi_timer = tp->eee.tx_lpi_timer;
+
+        RTL_W16(tp, EEE_TXIDLE_TIMER_8125, dev_lpi_timer);
+}
+
+static bool rtl8126_is_adv_eee_enabled(struct rtl8126_private *tp)
+{
+        if (rtl8126_mdio_direct_read_phy_ocp(tp, 0xA430) & BIT_15)
+                return true;
+        else
+                return false;
+}
+
+static void rtl8126_disable_adv_eee(struct rtl8126_private *tp)
+{
+        bool lock;
+
+        if (rtl8126_is_adv_eee_enabled(tp))
+                lock = true;
+        else
+                lock = false;
+
+        if (lock)
+                rtl8126_set_phy_mcu_patch_request(tp);
+
+        rtl8126_clear_mac_ocp_bit(tp, 0xE052, BIT_0);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA442, BIT_12 | BIT_13);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA430, BIT_15);
+
+        if (lock)
+                rtl8126_clear_phy_mcu_patch_request(tp);
+}
+
+static int rtl8126_enable_eee(struct rtl8126_private *tp)
+{
+        struct ethtool_keee *eee = &tp->eee;
+        u16 eee_adv_cap1_t = rtl8126_ethtool_adv_to_mmd_eee_adv_cap1_t(eee->advertised);
+        u16 eee_adv_cap2_t = rtl8126_ethtool_adv_to_mmd_eee_adv_cap2_t(eee->advertised);
+
+        rtl8126_set_mac_ocp_bit(tp, 0xE040, (BIT_1|BIT_0));
+
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA5D0,
+                                              MDIO_EEE_100TX | MDIO_EEE_1000T,
+                                              eee_adv_cap1_t);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA6D4,
+                                              MDIO_EEE_2_5GT | MDIO_EEE_5GT,
+                                              eee_adv_cap2_t);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA6D8, BIT_4);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA428, BIT_7);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA4A2, BIT_9);
+
+        /*Advanced EEE*/
+        rtl8126_disable_adv_eee(tp);
+
+        return 0;
+}
+
+static int rtl8126_disable_eee(struct rtl8126_private *tp)
+{
+        rtl8126_clear_mac_ocp_bit(tp, 0xE040, (BIT_1|BIT_0));
+
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA5D0, (MDIO_EEE_100TX | MDIO_EEE_1000T));
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA6D4, MDIO_EEE_2_5GT | MDIO_EEE_5GT);
+
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA6D8, BIT_4);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA428, BIT_7);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA4A2, BIT_9);
+
+        /*Advanced EEE*/
+        rtl8126_disable_adv_eee(tp);
+
+        return 0;
+}
+
+static int rtl_nway_reset(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int ret, bmcr;
+
+        if (unlikely(tp->rtk_enable_diag))
+                return -EBUSY;
+
+        /* if autoneg is off, it's an error */
+        rtl8126_mdio_write(tp, 0x1F, 0x0000);
+        bmcr = rtl8126_mdio_read(tp, MII_BMCR);
+
+        if (bmcr & BMCR_ANENABLE) {
+                bmcr |= BMCR_ANRESTART;
+                rtl8126_mdio_write(tp, MII_BMCR, bmcr);
+                ret = 0;
+        } else {
+                ret = -EINVAL;
+        }
+
+        return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+static u32
+rtl8126_device_lpi_t_to_ethtool_lpi_t(struct rtl8126_private *tp , u32 lpi_timer)
+{
+        u32 to_us;
+        u32 status;
+
+        to_us = lpi_timer * 80;
+        status = rtl8126_get_phy_status(tp);
+        if (status & LinkStatus) {
+                /*link on*/
+                if (HW_SUPP_PHY_LINK_SPEED_5000M(tp)) {
+                        //5G : lpi_timer * 12.8ns
+                        //2.5G : lpi_timer * 25.6ns
+                        //Giga: lpi_timer * 8ns
+                        //100M : lpi_timer * 80ns
+                        if (status & (_5000bpsF))
+                                to_us = (lpi_timer * 128) / 10;
+                        else if (status & _2500bpsF)
+                                to_us = (lpi_timer * 256) / 10;
+                        else if (status & _1000bpsF)
+                                to_us = lpi_timer * 8;
+                } else {
+                        //2.5G : lpi_timer * 3.2ns
+                        //Giga: lpi_timer * 8ns
+                        //100M : lpi_timer * 80ns
+                        if (status & _2500bpsF)
+                                to_us = (lpi_timer * 32) / 10;
+                        else if (status & _1000bpsF)
+                                to_us = lpi_timer * 8;
+                }
+        }
+
+        //ns to us
+        to_us /= 1000;
+
+        return to_us;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,9,0)
+static void
+rtl8126_adv_to_linkmode(unsigned long *mode, u64 adv)
+{
+        linkmode_zero(mode);
+
+        if (adv & ADVERTISED_10baseT_Half)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, mode);
+        if (adv & ADVERTISED_10baseT_Full)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, mode);
+        if (adv & ADVERTISED_100baseT_Half)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, mode);
+        if (adv & ADVERTISED_100baseT_Full)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, mode);
+        if (adv & ADVERTISED_1000baseT_Half)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT, mode);
+        if (adv & ADVERTISED_1000baseT_Full)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, mode);
+        if (adv & ADVERTISED_2500baseX_Full)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, mode);
+        if (adv & RTK_ADVERTISED_5000baseX_Full)
+                linkmode_set_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT, mode);
+}
+
+static int
+rtl_ethtool_get_eee(struct net_device *net, struct ethtool_keee *edata)
+{
+        __ETHTOOL_DECLARE_LINK_MODE_MASK(common);
+        struct rtl8126_private *tp = netdev_priv(net);
+        struct ethtool_keee *eee = &tp->eee;
+        unsigned long flags;
+        u32 tx_lpi_timer;
+        u16 val;
+
+        if (unlikely(tp->rtk_enable_diag))
+                return -EBUSY;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        /* Get LP advertisement EEE */
+        val = rtl8126_mdio_direct_read_phy_ocp(tp, 0xA5D2);
+        mii_eee_cap1_mod_linkmode_t(edata->lp_advertised, val);
+        val = rtl8126_mdio_direct_read_phy_ocp(tp, 0xA6D0);
+        mii_eee_cap2_mod_linkmode_sup_t(edata->lp_advertised, val);
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        /* Get EEE Tx LPI timer*/
+        tx_lpi_timer = rtl8126_device_lpi_t_to_ethtool_lpi_t(tp, eee->tx_lpi_timer);
+
+        val = rtl8126_mac_ocp_read(tp, 0xE040);
+        val &= BIT_1 | BIT_0;
+
+        edata->eee_enabled = !!val;
+        linkmode_copy(edata->supported, eee->supported);
+        linkmode_copy(edata->advertised, eee->advertised);
+        edata->tx_lpi_enabled = edata->eee_enabled;
+        edata->tx_lpi_timer = tx_lpi_timer;
+        linkmode_and(common, edata->advertised, edata->lp_advertised);
+        edata->eee_active = !linkmode_empty(common);
+
+        return 0;
+}
+
+static int
+rtl_ethtool_set_eee(struct net_device *net, struct ethtool_keee *edata)
+{
+        __ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);
+        __ETHTOOL_DECLARE_LINK_MODE_MASK(tmp);
+        struct rtl8126_private *tp = netdev_priv(net);
+        struct ethtool_keee *eee = &tp->eee;
+        unsigned long flags;
+        int rc = 0;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        if (!HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                rc = -EOPNOTSUPP;
+                goto out;
+        }
+
+        if (unlikely(tp->rtk_enable_diag)) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "Diag Enabled\n");
+                rc = -EBUSY;
+                goto out;
+        }
+
+        if (tp->autoneg != AUTONEG_ENABLE) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE requires autoneg\n");
+                rc = -EINVAL;
+                goto out;
+        }
+
+        /*
+        if (edata->tx_lpi_enabled) {
+        if (edata->tx_lpi_timer > tp->max_jumbo_frame_size ||
+            edata->tx_lpi_timer < ETH_MIN_MTU) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "Valid LPI timer range is %d to %d. \n",
+                           ETH_MIN_MTU, tp->max_jumbo_frame_size);
+                rc = -EINVAL;
+                goto out;
+        }
+        }
+        */
+
+        rtl8126_adv_to_linkmode(advertising, tp->advertising);
+        if (linkmode_empty(edata->advertised)) {
+                linkmode_and(edata->advertised, advertising, eee->supported);
+        } else if (linkmode_andnot(tmp, edata->advertised, advertising)) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE advertised must be a subset of autoneg advertised speeds\n");
+                rc = -EINVAL;
+                goto out;
+        }
+
+        if (linkmode_andnot(tmp, edata->advertised, eee->supported)) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE advertised must be a subset of support \n");
+                rc = -EINVAL;
+                goto out;
+        }
+
+        //tp->eee.eee_enabled = edata->eee_enabled;
+        //tp->eee_adv_t = rtl8126_ethtool_adv_to_mmd_eee_adv_cap1_t(edata->advertised);
+
+        linkmode_copy(eee->advertised, edata->advertised);
+        //eee->tx_lpi_enabled = edata->tx_lpi_enabled;
+        //eee->tx_lpi_timer = edata->tx_lpi_timer;
+        eee->eee_enabled = edata->eee_enabled;
+
+        if (eee->eee_enabled)
+                rtl8126_enable_eee(tp);
+        else
+                rtl8126_disable_eee(tp);
+
+        rtl_nway_reset(net);
+
+out:
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        return rc;
+}
+#else
+static int
+rtl_ethtool_get_eee(struct net_device *net, struct ethtool_eee *edata)
+{
+        struct rtl8126_private *tp = netdev_priv(net);
+        struct ethtool_eee *eee = &tp->eee;
+        u32 lp, adv, tx_lpi_timer, supported = 0;
+        unsigned long flags;
+        u16 val;
+
+        if (unlikely(tp->rtk_enable_diag))
+                return -EBUSY;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        /* Get Supported EEE */
+        //val = rtl8126_mdio_direct_read_phy_ocp(tp, 0xA5C4);
+        //supported = mmd_eee_cap_to_ethtool_sup_t(val);
+        supported = eee->supported;
+
+        /* Get advertisement EEE */
+        adv = eee->advertised;
+
+        /* Get LP advertisement EEE */
+        val = rtl8126_mdio_direct_read_phy_ocp(tp, 0xA5D2);
+        lp = mmd_eee_adv_to_ethtool_adv_t(val);
+        val = rtl8126_mdio_direct_read_phy_ocp(tp, 0xA6D0);
+        if (val & RTK_LPA_EEE_ADVERTISE_2500FULL)
+                lp |= ADVERTISED_2500baseX_Full;
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        /* Get EEE Tx LPI timer*/
+        tx_lpi_timer = rtl8126_device_lpi_t_to_ethtool_lpi_t(tp, eee->tx_lpi_timer);
+
+        val = rtl8126_mac_ocp_read(tp, 0xE040);
+        val &= BIT_1 | BIT_0;
+
+        edata->eee_enabled = !!val;
+        edata->eee_active = !!(supported & adv & lp);
+        edata->supported = supported;
+        edata->advertised = adv;
+        edata->lp_advertised = lp;
+        edata->tx_lpi_enabled = edata->eee_enabled;
+        edata->tx_lpi_timer = tx_lpi_timer;
+
+        return 0;
+}
+
+static int
+rtl_ethtool_set_eee(struct net_device *net, struct ethtool_eee *edata)
+{
+        struct rtl8126_private *tp = netdev_priv(net);
+        struct ethtool_eee *eee = &tp->eee;
+        unsigned long flags;
+        u32 advertising;
+        int rc = 0;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        if (!HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                rc = -EOPNOTSUPP;
+                goto out;
+        }
+
+        if (unlikely(tp->rtk_enable_diag)) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "Diag Enabled\n");
+                rc = -EBUSY;
+                goto out;
+        }
+
+        if (tp->autoneg != AUTONEG_ENABLE) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE requires autoneg\n");
+                rc = -EINVAL;
+                goto out;
+        }
+
+        /*
+        if (edata->tx_lpi_enabled) {
+        if (edata->tx_lpi_timer > tp->max_jumbo_frame_size ||
+            edata->tx_lpi_timer < ETH_MIN_MTU) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "Valid LPI timer range is %d to %d. \n",
+                           ETH_MIN_MTU, tp->max_jumbo_frame_size);
+                rc = -EINVAL;
+                goto out;
+        }
+        }
+        */
+
+        advertising = tp->advertising;
+        if (!edata->advertised) {
+                edata->advertised = advertising & eee->supported;
+        } else if (edata->advertised & ~advertising) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE advertised %x must be a subset of autoneg advertised speeds %x\n",
+                           edata->advertised, advertising);
+                rc = -EINVAL;
+                goto out;
+        }
+
+        if (edata->advertised & ~eee->supported) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE advertised %x must be a subset of support %x\n",
+                           edata->advertised, eee->supported);
+                rc = -EINVAL;
+                goto out;
+        }
+
+        //tp->eee.eee_enabled = edata->eee_enabled;
+        //tp->eee_adv_t = ethtool_adv_to_mmd_eee_adv_t(edata->advertised);
+
+        eee->advertised = edata->advertised;
+        //eee->tx_lpi_enabled = edata->tx_lpi_enabled;
+        //eee->tx_lpi_timer = edata->tx_lpi_timer;
+        eee->eee_enabled = edata->eee_enabled;
+
+        if (eee->eee_enabled)
+                rtl8126_enable_eee(tp);
+        else
+                rtl8126_disable_eee(tp);
+
+        rtl_nway_reset(net);
+
+out:
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        return rc;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6,9,0) */
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+static void rtl8126_get_channels(struct net_device *dev,
+                                 struct ethtool_channels *channel)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        channel->max_rx = tp->HwSuppNumRxQueues;
+        channel->max_tx = tp->HwSuppNumTxQueues;
+        channel->rx_count = tp->num_rx_rings;
+        channel->tx_count = tp->num_tx_rings;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0) */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static const struct ethtool_ops rtl8126_ethtool_ops = {
+        .get_drvinfo        = rtl8126_get_drvinfo,
+        .get_regs_len       = rtl8126_get_regs_len,
+        .get_link       = ethtool_op_get_link,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        .get_ringparam      = rtl8126_get_ringparam,
+        .set_ringparam      = rtl8126_set_ringparam,
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+        .get_settings       = rtl8126_get_settings,
+        .set_settings       = rtl8126_set_settings,
+#else
+        .get_link_ksettings       = rtl8126_get_settings,
+        .set_link_ksettings       = rtl8126_set_settings,
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        .get_pauseparam     = rtl8126_get_pauseparam,
+        .set_pauseparam     = rtl8126_set_pauseparam,
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        .get_msglevel       = rtl8126_get_msglevel,
+        .set_msglevel       = rtl8126_set_msglevel,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+        .get_rx_csum        = rtl8126_get_rx_csum,
+        .set_rx_csum        = rtl8126_set_rx_csum,
+        .get_tx_csum        = rtl8126_get_tx_csum,
+        .set_tx_csum        = rtl8126_set_tx_csum,
+        .get_sg         = ethtool_op_get_sg,
+        .set_sg         = ethtool_op_set_sg,
+#ifdef NETIF_F_TSO
+        .get_tso        = ethtool_op_get_tso,
+        .set_tso        = ethtool_op_set_tso,
+#endif //NETIF_F_TSO
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+        .get_regs       = rtl8126_get_regs,
+        .get_wol        = rtl8126_get_wol,
+        .set_wol        = rtl8126_set_wol,
+        .get_strings        = rtl8126_get_strings,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+        .get_stats_count    = rtl8126_get_stats_count,
+#else
+        .get_sset_count     = rtl8126_get_sset_count,
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+        .get_ethtool_stats  = rtl8126_get_ethtool_stats,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+#ifdef ETHTOOL_GPERMADDR
+        .get_perm_addr      = ethtool_op_get_perm_addr,
+#endif //ETHTOOL_GPERMADDR
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+        .get_eeprom     = rtl_get_eeprom,
+        .get_eeprom_len     = rtl_get_eeprom_len,
+#ifdef ENABLE_RSS_SUPPORT
+        .get_rxnfc		= rtl8126_get_rxnfc,
+        .set_rxnfc		= rtl8126_set_rxnfc,
+        .get_rxfh_indir_size	= rtl8126_rss_indir_size,
+        .get_rxfh_key_size	= rtl8126_get_rxfh_key_size,
+        .get_rxfh		= rtl8126_get_rxfh,
+        .set_rxfh		= rtl8126_set_rxfh,
+#endif //ENABLE_RSS_SUPPORT
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+#ifdef ENABLE_PTP_SUPPORT
+        .get_ts_info        = rtl8126_get_ts_info,
+#else
+        .get_ts_info        = ethtool_op_get_ts_info,
+#endif //ENABLE_PTP_SUPPORT
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+        .get_eee = rtl_ethtool_get_eee,
+        .set_eee = rtl_ethtool_set_eee,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+        .get_channels		= rtl8126_get_channels,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0) */
+        .nway_reset = rtl_nway_reset,
+
+};
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+static void rtl8126_get_mac_version(struct rtl8126_private *tp)
+{
+        u32 reg,val32;
+        u32 ICVerID;
+
+        val32 = RTL_R32(tp, TxConfig);
+        reg = val32 & 0x7c800000;
+        ICVerID = val32 & 0x00700000;
+
+        switch (reg) {
+        case 0x64800000:
+                if (ICVerID == 0x00000000) {
+                        tp->mcfg = CFG_METHOD_1;
+                } else if (ICVerID == 0x100000) {
+                        tp->mcfg = CFG_METHOD_2;
+                } else if (ICVerID == 0x200000) {
+                        tp->mcfg = CFG_METHOD_3;
+                } else {
+                        tp->mcfg = CFG_METHOD_3;
+                        tp->HwIcVerUnknown = TRUE;
+                }
+
+                tp->efuse_ver = EFUSE_SUPPORT_V4;
+                break;
+        default:
+                printk("unknown chip version (%x)\n",reg);
+                tp->mcfg = CFG_METHOD_DEFAULT;
+                tp->HwIcVerUnknown = TRUE;
+                tp->efuse_ver = EFUSE_NOT_SUPPORT;
+                break;
+        }
+}
+
+static void
+rtl8126_print_mac_version(struct rtl8126_private *tp)
+{
+        int i;
+        for (i = ARRAY_SIZE(rtl_chip_info) - 1; i >= 0; i--) {
+                if (tp->mcfg == rtl_chip_info[i].mcfg) {
+                        dprintk("Realtek %s Ethernet controller mcfg = %04d\n",
+                                MODULENAME, rtl_chip_info[i].mcfg);
+                        return;
+                }
+        }
+
+        dprintk("mac_version == Unknown\n");
+}
+
+static void
+rtl8126_tally_counter_addr_fill(struct rtl8126_private *tp)
+{
+        if (!tp->tally_paddr)
+                return;
+
+        RTL_W32(tp, CounterAddrHigh, (u64)tp->tally_paddr >> 32);
+        RTL_W32(tp, CounterAddrLow, (u64)tp->tally_paddr & (DMA_BIT_MASK(32)));
+}
+
+static void
+rtl8126_tally_counter_clear(struct rtl8126_private *tp)
+{
+        if (!tp->tally_paddr)
+                return;
+
+        RTL_W32(tp, CounterAddrHigh, (u64)tp->tally_paddr >> 32);
+        RTL_W32(tp, CounterAddrLow, ((u64)tp->tally_paddr & (DMA_BIT_MASK(32))) | CounterReset);
+}
+
+static void
+rtl8126_clear_phy_ups_reg(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA466, BIT_0);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA468, BIT_3 | BIT_1);
+}
+
+static int
+rtl8126_is_ups_resume(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        return (rtl8126_mac_ocp_read(tp, 0xD42C) & BIT_8);
+}
+
+static void
+rtl8126_clear_ups_resume_bit(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        rtl8126_clear_mac_ocp_bit(tp, 0xD42C, BIT_8);
+}
+
+static u8
+rtl8126_get_phy_state(struct rtl8126_private *tp)
+{
+        return (rtl8126_mdio_direct_read_phy_ocp(tp, 0xA420) & 0x7);
+}
+
+static void
+rtl8126_wait_phy_ups_resume(struct net_device *dev, u16 PhyState)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i;
+
+        for (i=0; i< 100; i++) {
+                if (rtl8126_get_phy_state(tp) == PhyState)
+                        break;
+                else
+                        mdelay(1);
+        }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(i == 100);
+#endif
+}
+
+static void
+rtl8126_set_mcu_d3_stack(struct rtl8126_private *tp)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+                rtl8126_mac_ocp_write(tp, 0xD018, 0xD116);
+                rtl8126_mac_ocp_write(tp, 0xD116, 0x4E22);
+                break;
+        case CFG_METHOD_3:
+                rtl8126_mac_ocp_write(tp, 0xD018, 0xD116);
+                rtl8126_mac_ocp_write(tp, 0xD116, 0x59EC);
+                break;
+        default:
+                return;
+        }
+}
+
+static void
+_rtl8126_enable_now_is_oob(struct rtl8126_private *tp)
+{
+        if (tp->HwSuppNowIsOobVer == 1)
+                RTL_W8(tp, MCUCmd_reg, RTL_R8(tp, MCUCmd_reg) | Now_is_oob);
+}
+
+void
+rtl8126_enable_now_is_oob(struct rtl8126_private *tp)
+{
+        rtl8126_set_mcu_d3_stack(tp);
+        _rtl8126_enable_now_is_oob(tp);
+}
+
+void
+rtl8126_disable_now_is_oob(struct rtl8126_private *tp)
+{
+        if (tp->HwSuppNowIsOobVer == 1)
+                RTL_W8(tp, MCUCmd_reg, RTL_R8(tp, MCUCmd_reg) & ~Now_is_oob);
+}
+
+static void
+rtl8126_exit_oob(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u16 data16;
+
+        rtl8126_disable_rx_packet_filter(tp);
+
+#ifdef ENABLE_REALWOW_SUPPORT
+        rtl8126_realwow_hw_init(dev);
+#else
+        //Disable realwow  function
+        rtl8126_mac_ocp_write(tp, 0xC0BC, 0x00FF);
+#endif //ENABLE_REALWOW_SUPPORT
+
+        rtl8126_nic_reset(dev);
+
+        rtl8126_disable_now_is_oob(tp);
+
+        data16 = rtl8126_mac_ocp_read(tp, 0xE8DE) & ~BIT_14;
+        rtl8126_mac_ocp_write(tp, 0xE8DE, data16);
+        rtl8126_wait_ll_share_fifo_ready(dev);
+
+        rtl8126_mac_ocp_write(tp, 0xC0AA, 0x07D0);
+#ifdef ENABLE_LIB_SUPPORT
+        rtl8126_mac_ocp_write(tp, 0xC0A6, 0x04E2);
+#else
+        rtl8126_mac_ocp_write(tp, 0xC0A6, 0x01B5);
+#endif
+        rtl8126_mac_ocp_write(tp, 0xC01E, 0x5555);
+
+        rtl8126_wait_ll_share_fifo_ready(dev);
+
+        //wait ups resume (phy state 2)
+        if (rtl8126_is_ups_resume(dev)) {
+                rtl8126_wait_phy_ups_resume(dev, 2);
+                rtl8126_clear_ups_resume_bit(dev);
+                rtl8126_clear_phy_ups_reg(dev);
+        }
+}
+
+void
+rtl8126_hw_disable_mac_mcu_bps(struct net_device *dev)
+{
+        u16 regAddr;
+
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        rtl8126_enable_aspm_clkreq_lock(tp, 0);
+
+        rtl8126_mac_ocp_write(tp, 0xFC48, 0x0000);
+
+        for (regAddr = 0xFC28; regAddr < 0xFC48; regAddr += 2) {
+                rtl8126_mac_ocp_write(tp, regAddr, 0x0000);
+        }
+
+        fsleep(3000);
+
+        rtl8126_mac_ocp_write(tp, 0xFC26, 0x0000);
+}
+
+#ifndef ENABLE_USE_FIRMWARE_FILE
+static void
+rtl8126_switch_mac_mcu_ram_code_page(struct rtl8126_private *tp, u16 page)
+{
+        u16 tmpUshort;
+
+        page &= (BIT_1 | BIT_0);
+        tmpUshort = rtl8126_mac_ocp_read(tp, 0xE446);
+        tmpUshort &= ~(BIT_1 | BIT_0);
+        tmpUshort |= page;
+        rtl8126_mac_ocp_write(tp, 0xE446, tmpUshort);
+}
+
+static void
+_rtl8126_set_hw_mcu_patch_code_ver(struct rtl8126_private *tp, u64 ver)
+{
+        int i;
+
+        /* Switch to page 2 */
+        rtl8126_switch_mac_mcu_ram_code_page(tp, 2);
+
+        for (i = 0; i < 8; i += 2) {
+                rtl8126_mac_ocp_write(tp, 0xF9F8 + 6 - i, (u16)ver);
+                ver >>= 16;
+        }
+
+        /* Switch back to page 0 */
+        rtl8126_switch_mac_mcu_ram_code_page(tp, 0);
+}
+
+static void
+rtl8126_set_hw_mcu_patch_code_ver(struct rtl8126_private *tp, u64 ver)
+{
+        _rtl8126_set_hw_mcu_patch_code_ver(tp, ver);
+
+        tp->hw_mcu_patch_code_ver = ver;
+}
+
+static u64
+rtl8126_get_hw_mcu_patch_code_ver(struct rtl8126_private *tp)
+{
+        u64 ver;
+        int i;
+
+        /* Switch to page 2 */
+        rtl8126_switch_mac_mcu_ram_code_page(tp, 2);
+
+        ver = 0;
+        for (i = 0; i < 8; i += 2) {
+                ver <<= 16;
+                ver |= rtl8126_mac_ocp_read(tp, 0xF9F8 + i);
+        }
+
+        /* Switch back to page 0 */
+        rtl8126_switch_mac_mcu_ram_code_page(tp, 0);
+
+        return ver;
+}
+
+static u64
+rtl8126_get_bin_mcu_patch_code_ver(const u16 *entry, u16 entry_cnt)
+{
+        u64 ver;
+        int i;
+
+        if (entry == NULL || entry_cnt == 0 || entry_cnt < 4)
+                return 0;
+
+        ver = 0;
+        for (i = 0; i < 4; i++) {
+                ver <<= 16;
+                ver |= entry[entry_cnt - 4 + i];
+        }
+
+        return ver;
+}
+
+static void
+_rtl8126_write_mac_mcu_ram_code(struct rtl8126_private *tp, const u16 *entry, u16 entry_cnt)
+{
+        u16 i;
+
+        for (i = 0; i < entry_cnt; i++)
+                rtl8126_mac_ocp_write(tp, 0xF800 + i * 2, entry[i]);
+}
+
+static void
+_rtl8126_write_mac_mcu_ram_code_with_page(struct rtl8126_private *tp, const u16 *entry, u16 entry_cnt, u16 page_size)
+{
+        u16 i;
+        u16 offset;
+
+        if (page_size == 0)
+                return;
+
+        for (i = 0; i < entry_cnt; i++) {
+                offset = i % page_size;
+                if (offset == 0) {
+                        u16 page = (i / page_size);
+                        rtl8126_switch_mac_mcu_ram_code_page(tp, page);
+                }
+                rtl8126_mac_ocp_write(tp, 0xF800 + offset * 2, entry[i]);
+        }
+}
+
+static void
+rtl8126_write_mac_mcu_ram_code(struct rtl8126_private *tp, const u16 *entry, u16 entry_cnt)
+{
+        if (FALSE == HW_SUPPORT_MAC_MCU(tp))
+                return;
+
+        if (entry == NULL || entry_cnt == 0)
+                return;
+
+        if (tp->MacMcuPageSize > 0)
+                _rtl8126_write_mac_mcu_ram_code_with_page(tp, entry, entry_cnt, tp->MacMcuPageSize);
+        else
+                _rtl8126_write_mac_mcu_ram_code(tp, entry, entry_cnt);
+
+        if (tp->bin_mcu_patch_code_ver > 0)
+                rtl8126_set_hw_mcu_patch_code_ver(tp, tp->bin_mcu_patch_code_ver);
+}
+
+static void
+rtl8126_set_mac_mcu_8126a_1(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        static const u16 mcu_patch_code[] =  {
+                0xE010, 0xE019, 0xE01B, 0xE01D, 0xE01F, 0xE021, 0xE023, 0xE025, 0xE027,
+                0xE029, 0xE02B, 0xE02D, 0xE02F, 0xE031, 0xE033, 0xE035, 0x48C0, 0x9C66,
+                0x7446, 0x4840, 0x48C1, 0x48C2, 0x9C46, 0xC402, 0xBC00, 0x0AD6, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000
+        };
+
+        rtl8126_write_mac_mcu_ram_code(tp, mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        rtl8126_mac_ocp_write(tp, 0xFC26, 0x8000);
+
+        rtl8126_mac_ocp_write(tp, 0xFC28, 0x0AAA);
+
+        rtl8126_mac_ocp_write(tp, 0xFC48, 0x0001);
+}
+
+static void
+rtl8126_set_mac_mcu_8126a_2(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        static const u16 mcu_patch_code[] =  {
+                0xE010, 0xE02C, 0xE04E, 0xE0A4, 0xE0A8, 0xE0AB, 0xE0AE, 0xE0B1, 0xE0B5,
+                0xE0B7, 0xE0B9, 0xE0BB, 0xE0BD, 0xE0BF, 0xE0C1, 0xE0C3, 0xC716, 0xC616,
+                0x9EE0, 0xC616, 0x65C0, 0x1500, 0xF009, 0xC714, 0x66E0, 0x41B5, 0x8EE0,
+                0xC611, 0x75C0, 0x4858, 0x9DC0, 0xC707, 0xC608, 0x9EE0, 0xC608, 0xC502,
+                0xBD00, 0x0100, 0xE86C, 0xE000, 0xA000, 0xB404, 0xB430, 0xC070, 0xE926,
+                0xC2FE, 0x400A, 0xF11A, 0x63A4, 0x1A00, 0x49B0, 0xF002, 0x4820, 0x49B1,
+                0xF002, 0x4821, 0x49B2, 0xF002, 0x4822, 0x49B3, 0xF002, 0x4823, 0xC411,
+                0x6380, 0x48B0, 0x8B80, 0x6320, 0x41DA, 0x8B20, 0x6380, 0x4830, 0x8B80,
+                0xE003, 0x73A4, 0x9B20, 0xC302, 0xBB00, 0x4A18, 0xC070, 0xE022, 0xC054,
+                0x7102, 0x4992, 0xF149, 0x4893, 0x9902, 0x1B1F, 0xC74E, 0x72E0, 0x2521,
+                0x48A5, 0x0B01, 0x1C4F, 0x9C00, 0x2121, 0x1D01, 0x41AA, 0x2521, 0x9DE0,
+                0x4856, 0x9DE0, 0x1CCF, 0xE839, 0x48D6, 0x9DE0, 0x7102, 0x4996, 0xF1FE,
+                0x4814, 0x9902, 0x1CFF, 0x0C01, 0x1400, 0xF00C, 0x7102, 0x4996, 0xF0FB,
+                0x7102, 0x4990, 0xF0FE, 0x1C1F, 0xE826, 0x7102, 0x4992, 0xF004, 0x4813,
+                0x9902, 0xE01D, 0x1300, 0xF104, 0x4817, 0x9902, 0xE018, 0x4894, 0x9902,
+                0x4995, 0xF00B, 0x121F, 0xF0F3, 0x131E, 0xF003, 0x4998, 0xF0EF, 0x0201,
+                0x4818, 0x9902, 0xE7C9, 0x1200, 0xF0E9, 0x4998, 0xF002, 0x1B01, 0x0A01,
+                0x4898, 0x9902, 0xE7C0, 0xC00A, 0xC606, 0xBE00, 0x0C01, 0x1400, 0xF1FE,
+                0xFF80, 0x2362, 0xD456, 0xD404, 0xE400, 0x4166, 0x9CF6, 0xC002, 0xB800,
+                0x14A6, 0x49D1, 0xC602, 0xBE00, 0x4160, 0x49D1, 0xC602, 0xBE00, 0x41E6,
+                0x49D1, 0xC602, 0xBE00, 0x4282, 0xC104, 0xC202, 0xBA00, 0x234C, 0xD116,
+                0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0x6847, 0x0019, 0x041C,
+                0x1322
+        };
+
+        /* Get BIN mac mcu patch code version */
+        tp->bin_mcu_patch_code_ver = rtl8126_get_bin_mcu_patch_code_ver(mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        if (tp->hw_mcu_patch_code_ver != tp->bin_mcu_patch_code_ver)
+                rtl8126_write_mac_mcu_ram_code(tp, mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        rtl8126_mac_ocp_write(tp, 0xFC26, 0x8000);
+
+        //rtl8126_mac_ocp_write(tp, 0xFC28, 0x00FE);
+        //rtl8126_mac_ocp_write(tp, 0xFC2A, 0x4A14);
+        rtl8126_mac_ocp_write(tp, 0xFC2C, 0x2360);
+        rtl8126_mac_ocp_write(tp, 0xFC2E, 0x14A4);
+        rtl8126_mac_ocp_write(tp, 0xFC30, 0x415E);
+        rtl8126_mac_ocp_write(tp, 0xFC32, 0x41E4);
+        rtl8126_mac_ocp_write(tp, 0xFC34, 0x4280);
+        rtl8126_mac_ocp_write(tp, 0xFC36, 0x234A);
+
+        rtl8126_mac_ocp_write(tp, 0xFC48, 0x00FC);
+}
+
+static void
+rtl8126_set_mac_mcu_8126a_3(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        static const u16 mcu_patch_code[] =  {
+                0xE00A, 0xE026, 0xE048, 0xE04C, 0xE04F, 0xE052, 0xE055, 0xE0AB, 0xE0F8,
+                0xE141, 0xC716, 0xC616, 0x9EE0, 0xC616, 0x65C0, 0x1500, 0xF009, 0xC714,
+                0x66E0, 0x41B5, 0x8EE0, 0xC611, 0x75C0, 0x4858, 0x9DC0, 0xC707, 0xC608,
+                0x9EE0, 0xC608, 0xC502, 0xBD00, 0x0100, 0xE86C, 0xE000, 0xA000, 0xB404,
+                0xB430, 0xC070, 0xE926, 0xC2FE, 0x400A, 0xF11A, 0x63A4, 0x1A00, 0x49B0,
+                0xF002, 0x4820, 0x49B1, 0xF002, 0x4821, 0x49B2, 0xF002, 0x4822, 0x49B3,
+                0xF002, 0x4823, 0xC411, 0x6380, 0x48B0, 0x8B80, 0x6320, 0x41DA, 0x8B20,
+                0x6380, 0x4830, 0x8B80, 0xE003, 0x73A4, 0x9B20, 0xC302, 0xBB00, 0x55E2,
+                0xC070, 0xE022, 0x4166, 0x9CF6, 0xC602, 0xBE00, 0x14A6, 0x49D1, 0xC602,
+                0xBE00, 0x4178, 0x49D1, 0xC602, 0xBE00, 0x41FE, 0x49D1, 0xC602, 0xBE00,
+                0x429A, 0xC74B, 0x76E2, 0xC54A, 0x402E, 0xF034, 0x76E0, 0x402E, 0xF006,
+                0xC503, 0xC403, 0xBC00, 0xC0BC, 0x0AAE, 0x76F0, 0x1601, 0xF023, 0xC741,
+                0x1E04, 0x9EE0, 0x1E40, 0x9EE4, 0xC63D, 0x9EE8, 0xC73D, 0x76E0, 0x4863,
+                0x9EE0, 0xC73A, 0x76E0, 0x48EA, 0x48EB, 0x9EE0, 0xC736, 0x1E01, 0x9EE2,
+                0xC72D, 0x76E0, 0x486F, 0x9EE0, 0xC72D, 0x76E0, 0x48E3, 0x9EE0, 0xC728,
+                0x1E0E, 0x9EE0, 0xC71D, 0x1E01, 0x9EE4, 0xE00D, 0x1E00, 0x9EF0, 0x1E05,
+                0xC715, 0x9EE0, 0xE00A, 0x1E00, 0x9EE2, 0xC614, 0x75CC, 0x48D2, 0x9DCC,
+                0x1E04, 0xC70B, 0x9EE0, 0xB000, 0xB001, 0xB002, 0xB003, 0xB004, 0xB005,
+                0xB006, 0xB007, 0xFFC0, 0xE428, 0xD3C0, 0xBEEF, 0x5B4A, 0xDC46, 0xE0CC,
+                0xE84E, 0xC0A2, 0x0100, 0xC010, 0xE85A, 0xE812, 0xC0B4, 0xC5F4, 0x74A0,
+                0xC6F3, 0x4026, 0xF107, 0x74A2, 0xC6EF, 0x4026, 0xF107, 0xC6ED, 0xBE00,
+                0x753A, 0xC602, 0xBE00, 0x5A3A, 0x7520, 0x49DE, 0xF102, 0xE7F9, 0xC6A1,
+                0x67C6, 0x7520, 0x22D2, 0x26DD, 0x1500, 0xF002, 0xE7F1, 0x7532, 0x26D5,
+                0x0530, 0x0D6C, 0xC42D, 0x308D, 0x7540, 0x4025, 0xF11E, 0x7542, 0x4025,
+                0xF11B, 0x7544, 0x4025, 0xF118, 0xC423, 0x7546, 0x4025, 0xF114, 0x7548,
+                0x4025, 0xF111, 0x754A, 0x4025, 0xF10E, 0xC5C0, 0xC4C0, 0x9CA2, 0xC6C0,
+                0x75CC, 0x4852, 0x9DCC, 0xC6B8, 0x1D7D, 0x9DC2, 0x1D01, 0x9DC0, 0xE7C9,
+                0xC40B, 0x7546, 0x4025, 0xF1FC, 0x7548, 0x4025, 0xF1F9, 0x754A, 0x4025,
+                0xF1F6, 0xE7C0, 0xFFFF, 0xEEEE, 0xC2A6, 0x7340, 0xC2A5, 0x4013, 0xF013,
+                0xC2AC, 0x7340, 0x4835, 0x9B40, 0xC240, 0x7358, 0x48B7, 0x48B2, 0x9B58,
+                0x7346, 0x48B7, 0x48B2, 0x9B46, 0x7340, 0x48B7, 0x48B2, 0x9B40, 0xE012,
+                0xC29A, 0x7340, 0x48B5, 0x9B40, 0xC22E, 0x7358, 0x4837, 0x4832, 0x9B58,
+                0x7346, 0x4837, 0x4832, 0x9B46, 0x7340, 0x4837, 0x4832, 0x9B40, 0xC283,
+                0x7340, 0x49BF, 0xF010, 0xC21B, 0x7344, 0x1300, 0xF104, 0x1B00, 0xC217,
+                0x9B40, 0x1B01, 0xC213, 0x9B44, 0xC213, 0x734C, 0x48B7, 0x9B4C, 0xE008,
+                0xC20C, 0x1B00, 0x9B44, 0xC20B, 0x734C, 0x4837, 0x9B4C, 0xC204, 0xC302,
+                0xBB00, 0x2384, 0xE092, 0xD3C0, 0xE428, 0xDC46, 0xC104, 0xC202, 0xBA00,
+                0x234C, 0xD116, 0x6847, 0x0119, 0x041C, 0x1134
+        };
+
+        /* Get BIN mac mcu patch code version */
+        tp->bin_mcu_patch_code_ver = rtl8126_get_bin_mcu_patch_code_ver(mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        if (tp->hw_mcu_patch_code_ver != tp->bin_mcu_patch_code_ver)
+                rtl8126_write_mac_mcu_ram_code(tp, mcu_patch_code, ARRAY_SIZE(mcu_patch_code));
+
+        rtl8126_mac_ocp_write(tp, 0xFC26, 0x8000);
+
+        //rtl8126_mac_ocp_write(tp, 0xFC28, 0x00FE);
+        //rtl8126_mac_ocp_write(tp, 0xFC2A, 0x55DE);
+        rtl8126_mac_ocp_write(tp, 0xFC2C, 0x14A4);
+        rtl8126_mac_ocp_write(tp, 0xFC2E, 0x4176);
+        rtl8126_mac_ocp_write(tp, 0xFC30, 0x41FC);
+        rtl8126_mac_ocp_write(tp, 0xFC32, 0x4298);
+        //rtl8126_mac_ocp_write(tp, 0xFC34, 0x0AAC);
+        //rtl8126_mac_ocp_write(tp, 0xFC36, 0x5A38);
+        //rtl8126_mac_ocp_write(tp, 0xFC38, 0x2382);
+        rtl8126_mac_ocp_write(tp, 0xFC3A, 0x234A);
+
+        rtl8126_mac_ocp_write(tp, 0xFC48, 0x023C);
+}
+
+static void
+rtl8126_hw_mac_mcu_config(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (tp->NotWrMcuPatchCode == TRUE)
+                return;
+
+        rtl8126_hw_disable_mac_mcu_bps(dev);
+
+        /* Get H/W mac mcu patch code version */
+        tp->hw_mcu_patch_code_ver = rtl8126_get_hw_mcu_patch_code_ver(tp);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_1:
+                rtl8126_set_mac_mcu_8126a_1(dev);
+                break;
+        case CFG_METHOD_2:
+                rtl8126_set_mac_mcu_8126a_2(dev);
+                break;
+        case CFG_METHOD_3:
+                rtl8126_set_mac_mcu_8126a_3(dev);
+                break;
+        }
+}
+#endif
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+static void rtl8126_release_firmware(struct rtl8126_private *tp)
+{
+        if (tp->rtl_fw) {
+                rtl8126_fw_release_firmware(tp->rtl_fw);
+                kfree(tp->rtl_fw);
+                tp->rtl_fw = NULL;
+        }
+}
+
+static void rtl8126_apply_firmware(struct rtl8126_private *tp)
+{
+        unsigned long flags;
+
+        /* TODO: release firmware if rtl_fw_write_firmware signals failure. */
+        if (tp->rtl_fw) {
+                r8126_spin_lock(&tp->phy_lock, flags);
+
+                rtl8126_fw_write_firmware(tp, tp->rtl_fw);
+                /* At least one firmware doesn't reset tp->ocp_base. */
+                tp->ocp_base = OCP_STD_PHY_BASE;
+
+                /* PHY soft reset may still be in progress */
+                //phy_read_poll_timeout(tp->phydev, MII_BMCR, val,
+                //		      !(val & BMCR_RESET),
+                //		      50000, 600000, true);
+                rtl8126_wait_phy_reset_complete(tp);
+
+                tp->hw_ram_code_ver = rtl8126_get_hw_phy_mcu_code_ver(tp);
+                tp->sw_ram_code_ver = tp->hw_ram_code_ver;
+                tp->HwHasWrRamCodeToMicroP = TRUE;
+
+                r8126_spin_unlock(&tp->phy_lock, flags);
+        }
+}
+#endif
+
+static void
+rtl8126_hw_init(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u32 csi_tmp;
+
+        rtl8126_enable_aspm_clkreq_lock(tp, 0);
+        rtl8126_enable_force_clkreq(tp, 0);
+
+        //Disable UPS
+        rtl8126_mac_ocp_write(tp, 0xD40A, rtl8126_mac_ocp_read(tp, 0xD40A) & ~(BIT_4));
+
+#ifndef ENABLE_USE_FIRMWARE_FILE
+        if (!tp->rtl_fw)
+                rtl8126_hw_mac_mcu_config(dev);
+#endif
+
+        //Set PCIE uncorrectable error status mask pcie 0x108
+        csi_tmp = rtl8126_csi_read(tp, 0x108);
+        csi_tmp |= BIT_20;
+        rtl8126_csi_write(tp, 0x108, csi_tmp);
+
+        rtl8126_enable_cfg9346_write(tp);
+        rtl8126_disable_linkchg_wakeup(dev);
+        rtl8126_disable_cfg9346_write(tp);
+        rtl8126_disable_magic_packet(dev);
+        rtl8126_disable_d0_speedup(tp);
+        rtl8126_set_pci_pme(tp, 0);
+        if (s0_magic_packet == 1)
+                rtl8126_enable_magic_packet(dev);
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+        if (tp->rtl_fw && !tp->resume_not_chg_speed)
+                rtl8126_apply_firmware(tp);
+#endif
+}
+
+static void
+rtl8126_hw_ephy_config(struct net_device *dev)
+{
+        (void)dev;
+        /* nothing to do */
+}
+
+static u16
+rtl8126_get_hw_phy_mcu_code_ver(struct rtl8126_private *tp)
+{
+        u16 hw_ram_code_ver;
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x801E);
+        hw_ram_code_ver = rtl8126_mdio_direct_read_phy_ocp(tp, 0xA438);
+
+        return hw_ram_code_ver;
+}
+
+static int
+rtl8126_check_hw_phy_mcu_code_ver(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int ram_code_ver_match = 0;
+
+        tp->hw_ram_code_ver = rtl8126_get_hw_phy_mcu_code_ver(tp);
+
+        if (tp->hw_ram_code_ver == tp->sw_ram_code_ver) {
+                ram_code_ver_match = 1;
+                tp->HwHasWrRamCodeToMicroP = TRUE;
+        }
+
+        return ram_code_ver_match;
+}
+
+bool
+rtl8126_set_phy_mcu_patch_request(struct rtl8126_private *tp)
+{
+        u16 gphy_val;
+        u16 WaitCount;
+        bool bSuccess = TRUE;
+
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xB820, BIT_4);
+
+        WaitCount = 0;
+        do {
+                gphy_val = rtl8126_mdio_direct_read_phy_ocp(tp, 0xB800);
+                udelay(100);
+                WaitCount++;
+        } while (!(gphy_val & BIT_6) && (WaitCount < 1000));
+
+        if (!(gphy_val & BIT_6) && (WaitCount == 1000))
+                bSuccess = FALSE;
+
+        if (!bSuccess)
+                dprintk("rtl8126_set_phy_mcu_patch_request fail.\n");
+
+        return bSuccess;
+}
+
+bool
+rtl8126_clear_phy_mcu_patch_request(struct rtl8126_private *tp)
+{
+        u16 gphy_val;
+        u16 WaitCount;
+        bool bSuccess = TRUE;
+
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xB820, BIT_4);
+
+        WaitCount = 0;
+        do {
+                gphy_val = rtl8126_mdio_direct_read_phy_ocp(tp, 0xB800);
+                udelay(100);
+                WaitCount++;
+        } while ((gphy_val & BIT_6) && (WaitCount < 1000));
+
+        if ((gphy_val & BIT_6) && (WaitCount == 1000))
+                bSuccess = FALSE;
+
+        if (!bSuccess)
+                dprintk("rtl8126_clear_phy_mcu_patch_request fail.\n");
+
+        return bSuccess;
+}
+
+#ifndef ENABLE_USE_FIRMWARE_FILE
+static void
+rtl8126_write_hw_phy_mcu_code_ver(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x801E);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, tp->sw_ram_code_ver);
+        tp->hw_ram_code_ver = tp->sw_ram_code_ver;
+}
+
+static void
+rtl8126_set_phy_mcu_ram_code(struct net_device *dev, const u16 *ramcode, u16 codesize)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u16 i;
+        u16 addr;
+        u16 val;
+
+        if (ramcode == NULL || codesize % 2)
+                goto out;
+
+        for (i = 0; i < codesize; i += 2) {
+                addr = ramcode[i];
+                val = ramcode[i + 1];
+                if (addr == 0xFFFF && val == 0xFFFF)
+                        break;
+                rtl8126_mdio_direct_write_phy_ocp(tp, addr, val);
+        }
+
+out:
+        return;
+}
+
+static void
+rtl8126_enable_phy_disable_mode(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppCheckPhyDisableModeVer) {
+        case 3:
+                RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) | BIT_5);
+                break;
+        }
+
+        dprintk("enable phy disable mode.\n");
+}
+
+static void
+rtl8126_disable_phy_disable_mode(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppCheckPhyDisableModeVer) {
+        case 3:
+                RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) & ~BIT_5);
+                break;
+        }
+
+        mdelay(1);
+
+        dprintk("disable phy disable mode.\n");
+}
+
+static const u16 phy_mcu_ram_code_8126a_1_1[] = {
+        0xa436, 0x8023, 0xa438, 0x4900, 0xa436, 0xB82E, 0xa438, 0x0001,
+        0xBFBA, 0xE000, 0xBF1A, 0xC1B9, 0xBFA8, 0x10F0, 0xBFB0, 0x0210,
+        0xBFB4, 0xE7E4, 0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000,
+        0xa436, 0xA012, 0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800,
+        0xa438, 0x8010, 0xa438, 0x1800, 0xa438, 0x8062, 0xa438, 0x1800,
+        0xa438, 0x8069, 0xa438, 0x1800, 0xa438, 0x80e2, 0xa438, 0x1800,
+        0xa438, 0x80eb, 0xa438, 0x1800, 0xa438, 0x80f5, 0xa438, 0x1800,
+        0xa438, 0x811b, 0xa438, 0x1800, 0xa438, 0x8120, 0xa438, 0xd500,
+        0xa438, 0xd049, 0xa438, 0xd1b9, 0xa438, 0xa208, 0xa438, 0x8208,
+        0xa438, 0xd503, 0xa438, 0xa104, 0xa438, 0x0c07, 0xa438, 0x0902,
+        0xa438, 0xd500, 0xa438, 0xbc10, 0xa438, 0xc484, 0xa438, 0xd503,
+        0xa438, 0xcc02, 0xa438, 0xcd0d, 0xa438, 0xaf01, 0xa438, 0xd500,
+        0xa438, 0xd703, 0xa438, 0x4531, 0xa438, 0xbd08, 0xa438, 0x1000,
+        0xa438, 0x16bb, 0xa438, 0xd75e, 0xa438, 0x5fb3, 0xa438, 0xd503,
+        0xa438, 0xd04d, 0xa438, 0xd1c7, 0xa438, 0x0cf0, 0xa438, 0x0e10,
+        0xa438, 0xd704, 0xa438, 0x5ffc, 0xa438, 0xd04d, 0xa438, 0xd1c7,
+        0xa438, 0x0cf0, 0xa438, 0x0e20, 0xa438, 0xd704, 0xa438, 0x5ffc,
+        0xa438, 0xd04d, 0xa438, 0xd1c7, 0xa438, 0x0cf0, 0xa438, 0x0e40,
+        0xa438, 0xd704, 0xa438, 0x5ffc, 0xa438, 0xd04d, 0xa438, 0xd1c7,
+        0xa438, 0x0cf0, 0xa438, 0x0e80, 0xa438, 0xd704, 0xa438, 0x5ffc,
+        0xa438, 0xd07b, 0xa438, 0xd1c5, 0xa438, 0x8ef0, 0xa438, 0xd704,
+        0xa438, 0x5ffc, 0xa438, 0x9d08, 0xa438, 0x1000, 0xa438, 0x16bb,
+        0xa438, 0xd75e, 0xa438, 0x7fb3, 0xa438, 0x1000, 0xa438, 0x16bb,
+        0xa438, 0xd75e, 0xa438, 0x5fad, 0xa438, 0x1000, 0xa438, 0x181f,
+        0xa438, 0xd703, 0xa438, 0x3181, 0xa438, 0x8059, 0xa438, 0x60ad,
+        0xa438, 0x1000, 0xa438, 0x16bb, 0xa438, 0xd703, 0xa438, 0x5fbb,
+        0xa438, 0x1000, 0xa438, 0x16bb, 0xa438, 0xd719, 0xa438, 0x7fa8,
+        0xa438, 0xd500, 0xa438, 0xd049, 0xa438, 0xd1b9, 0xa438, 0x1800,
+        0xa438, 0x0f0b, 0xa438, 0xd500, 0xa438, 0xd07b, 0xa438, 0xd1b5,
+        0xa438, 0xd0f6, 0xa438, 0xd1c5, 0xa438, 0x1800, 0xa438, 0x1049,
+        0xa438, 0xd707, 0xa438, 0x4121, 0xa438, 0xd706, 0xa438, 0x40fa,
+        0xa438, 0xd099, 0xa438, 0xd1c6, 0xa438, 0x1000, 0xa438, 0x16bb,
+        0xa438, 0xd704, 0xa438, 0x5fbc, 0xa438, 0xbc80, 0xa438, 0xc489,
+        0xa438, 0xd503, 0xa438, 0xcc08, 0xa438, 0xcd46, 0xa438, 0xaf01,
+        0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x0903, 0xa438, 0x1000,
+        0xa438, 0x16bb, 0xa438, 0xd75e, 0xa438, 0x5f6d, 0xa438, 0x1000,
+        0xa438, 0x181f, 0xa438, 0xd504, 0xa438, 0xa210, 0xa438, 0xd500,
+        0xa438, 0x1000, 0xa438, 0x16bb, 0xa438, 0xd719, 0xa438, 0x5fbc,
+        0xa438, 0xd504, 0xa438, 0x8210, 0xa438, 0xd503, 0xa438, 0xc6d0,
+        0xa438, 0xa521, 0xa438, 0xcd49, 0xa438, 0xaf01, 0xa438, 0xd504,
+        0xa438, 0xa220, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x16bb,
+        0xa438, 0xd75e, 0xa438, 0x5fad, 0xa438, 0x1000, 0xa438, 0x181f,
+        0xa438, 0xd503, 0xa438, 0xa704, 0xa438, 0x0c07, 0xa438, 0x0904,
+        0xa438, 0xd504, 0xa438, 0xa102, 0xa438, 0xd500, 0xa438, 0x1000,
+        0xa438, 0x16bb, 0xa438, 0xd718, 0xa438, 0x5fab, 0xa438, 0xd503,
+        0xa438, 0xc6f0, 0xa438, 0xa521, 0xa438, 0xd505, 0xa438, 0xa404,
+        0xa438, 0xd500, 0xa438, 0xd701, 0xa438, 0x6085, 0xa438, 0xd504,
+        0xa438, 0xc9f1, 0xa438, 0xf003, 0xa438, 0xd504, 0xa438, 0xc9f0,
+        0xa438, 0xd503, 0xa438, 0xcd4a, 0xa438, 0xaf01, 0xa438, 0xd500,
+        0xa438, 0xd504, 0xa438, 0xa802, 0xa438, 0xd500, 0xa438, 0x1000,
+        0xa438, 0x16bb, 0xa438, 0xd707, 0xa438, 0x5fb1, 0xa438, 0xd707,
+        0xa438, 0x5f10, 0xa438, 0xd505, 0xa438, 0xa402, 0xa438, 0xd503,
+        0xa438, 0xd707, 0xa438, 0x41a1, 0xa438, 0xd706, 0xa438, 0x60ba,
+        0xa438, 0x60fc, 0xa438, 0x0c07, 0xa438, 0x0204, 0xa438, 0xf009,
+        0xa438, 0x0c07, 0xa438, 0x0202, 0xa438, 0xf006, 0xa438, 0x0c07,
+        0xa438, 0x0206, 0xa438, 0xf003, 0xa438, 0x0c07, 0xa438, 0x0202,
+        0xa438, 0xd500, 0xa438, 0xd703, 0xa438, 0x3181, 0xa438, 0x80e0,
+        0xa438, 0x616d, 0xa438, 0xd701, 0xa438, 0x6065, 0xa438, 0x1800,
+        0xa438, 0x1229, 0xa438, 0x1000, 0xa438, 0x16bb, 0xa438, 0xd707,
+        0xa438, 0x6061, 0xa438, 0xd704, 0xa438, 0x5f7c, 0xa438, 0x1800,
+        0xa438, 0x124a, 0xa438, 0xd504, 0xa438, 0x8c0f, 0xa438, 0xd505,
+        0xa438, 0xa20e, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1871,
+        0xa438, 0x1800, 0xa438, 0x1899, 0xa438, 0xd70b, 0xa438, 0x60b0,
+        0xa438, 0xd05a, 0xa438, 0xd19a, 0xa438, 0x1800, 0xa438, 0x1aef,
+        0xa438, 0xd0ef, 0xa438, 0xd19a, 0xa438, 0x1800, 0xa438, 0x1aef,
+        0xa438, 0x1000, 0xa438, 0x1d09, 0xa438, 0xd708, 0xa438, 0x3399,
+        0xa438, 0x1b63, 0xa438, 0xd709, 0xa438, 0x5f5d, 0xa438, 0xd70b,
+        0xa438, 0x6130, 0xa438, 0xd70d, 0xa438, 0x6163, 0xa438, 0xd709,
+        0xa438, 0x430b, 0xa438, 0xd71e, 0xa438, 0x62c2, 0xa438, 0xb401,
+        0xa438, 0xf014, 0xa438, 0xc901, 0xa438, 0x1000, 0xa438, 0x810e,
+        0xa438, 0xf010, 0xa438, 0xc902, 0xa438, 0x1000, 0xa438, 0x810e,
+        0xa438, 0xf00c, 0xa438, 0xce04, 0xa438, 0xcf01, 0xa438, 0xd70a,
+        0xa438, 0x5fe2, 0xa438, 0xce04, 0xa438, 0xcf02, 0xa438, 0xc900,
+        0xa438, 0xd70a, 0xa438, 0x4057, 0xa438, 0xb401, 0xa438, 0x0800,
+        0xa438, 0x1800, 0xa438, 0x1b5d, 0xa438, 0xa480, 0xa438, 0xa2b0,
+        0xa438, 0xa806, 0xa438, 0x1800, 0xa438, 0x225c, 0xa438, 0xa7e8,
+        0xa438, 0xac08, 0xa438, 0x1800, 0xa438, 0x1a4e, 0xa436, 0xA026,
+        0xa438, 0x1a4d, 0xa436, 0xA024, 0xa438, 0x225a, 0xa436, 0xA022,
+        0xa438, 0x1b53, 0xa436, 0xA020, 0xa438, 0x1aed, 0xa436, 0xA006,
+        0xa438, 0x1892, 0xa436, 0xA004, 0xa438, 0x11a4, 0xa436, 0xA002,
+        0xa438, 0x103c, 0xa436, 0xA000, 0xa438, 0x0ea6, 0xa436, 0xA008,
+        0xa438, 0xff00, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+        0xa438, 0x0ff8, 0xa436, 0xA014, 0xa438, 0x0000, 0xa438, 0xD098,
+        0xa438, 0xc483, 0xa438, 0xc483, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa436, 0xA152, 0xa438, 0x3fff,
+        0xa436, 0xA154, 0xa438, 0x0413, 0xa436, 0xA156, 0xa438, 0x1A32,
+        0xa436, 0xA158, 0xa438, 0x1CC0, 0xa436, 0xA15A, 0xa438, 0x3fff,
+        0xa436, 0xA15C, 0xa438, 0x3fff, 0xa436, 0xA15E, 0xa438, 0x3fff,
+        0xa436, 0xA160, 0xa438, 0x3fff, 0xa436, 0xA150, 0xa438, 0x000E,
+        0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x0000,
+        0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010, 0xa438, 0x1800,
+        0xa438, 0x8021, 0xa438, 0x1800, 0xa438, 0x8037, 0xa438, 0x1800,
+        0xa438, 0x803f, 0xa438, 0x1800, 0xa438, 0x8084, 0xa438, 0x1800,
+        0xa438, 0x80c5, 0xa438, 0x1800, 0xa438, 0x80cc, 0xa438, 0x1800,
+        0xa438, 0x80d5, 0xa438, 0xa00a, 0xa438, 0xa280, 0xa438, 0xa404,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x1800, 0xa438, 0x099b, 0xa438, 0x1000, 0xa438, 0x1021,
+        0xa438, 0xd700, 0xa438, 0x5fab, 0xa438, 0xa208, 0xa438, 0x8204,
+        0xa438, 0xcb38, 0xa438, 0xaa40, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x1800, 0xa438, 0x0b2a,
+        0xa438, 0x82a0, 0xa438, 0x8404, 0xa438, 0xa110, 0xa438, 0xd706,
+        0xa438, 0x4041, 0xa438, 0xa180, 0xa438, 0x1800, 0xa438, 0x0e7f,
+        0xa438, 0x8190, 0xa438, 0xcb93, 0xa438, 0x1000, 0xa438, 0x0ef4,
+        0xa438, 0xd704, 0xa438, 0x7fb8, 0xa438, 0xa008, 0xa438, 0xd706,
+        0xa438, 0x4040, 0xa438, 0xa002, 0xa438, 0xd705, 0xa438, 0x4079,
+        0xa438, 0x1000, 0xa438, 0x10ad, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x85f0, 0xa438, 0x9503, 0xa438, 0xd705, 0xa438, 0x40d9,
+        0xa438, 0xd70c, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d09,
+        0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d0a, 0xa438, 0x0cc0,
+        0xa438, 0x0d80, 0xa438, 0x1000, 0xa438, 0x104f, 0xa438, 0x1000,
+        0xa438, 0x0ef4, 0xa438, 0x8020, 0xa438, 0xd705, 0xa438, 0x40d9,
+        0xa438, 0xd704, 0xa438, 0x609f, 0xa438, 0xd70c, 0xa438, 0x6043,
+        0xa438, 0x8504, 0xa438, 0xcb94, 0xa438, 0x1000, 0xa438, 0x0ef4,
+        0xa438, 0xd706, 0xa438, 0x7fa2, 0xa438, 0x800a, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x0cf0, 0xa438, 0x05a0, 0xa438, 0x9503,
+        0xa438, 0xd705, 0xa438, 0x40b9, 0xa438, 0x0c1f, 0xa438, 0x0d00,
+        0xa438, 0x8dc0, 0xa438, 0xf005, 0xa438, 0xa190, 0xa438, 0x0c1f,
+        0xa438, 0x0d17, 0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x104f,
+        0xa438, 0xd705, 0xa438, 0x39cc, 0xa438, 0x0c7d, 0xa438, 0x1800,
+        0xa438, 0x0e67, 0xa438, 0xcb96, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xab05, 0xa438, 0xac04, 0xa438, 0xac08, 0xa438, 0x9503,
+        0xa438, 0x0c1f, 0xa438, 0x0d00, 0xa438, 0x8dc0, 0xa438, 0x1000,
+        0xa438, 0x104f, 0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xd706,
+        0xa438, 0x2215, 0xa438, 0x8099, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xae02, 0xa438, 0x9503, 0xa438, 0xd706, 0xa438, 0x6451,
+        0xa438, 0xd71f, 0xa438, 0x2e70, 0xa438, 0x0f00, 0xa438, 0xd706,
+        0xa438, 0x3290, 0xa438, 0x80be, 0xa438, 0xd704, 0xa438, 0x2e70,
+        0xa438, 0x8090, 0xa438, 0xd706, 0xa438, 0x339c, 0xa438, 0x8090,
+        0xa438, 0x8718, 0xa438, 0x8910, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xc500, 0xa438, 0x9503, 0xa438, 0x0c1f, 0xa438, 0x0d17,
+        0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x104f, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8c04, 0xa438, 0x9503, 0xa438, 0xa00a,
+        0xa438, 0xa190, 0xa438, 0xa280, 0xa438, 0xa404, 0xa438, 0x1800,
+        0xa438, 0x0f35, 0xa438, 0x1800, 0xa438, 0x0f07, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8c08, 0xa438, 0x8c04, 0xa438, 0x9503,
+        0xa438, 0x1800, 0xa438, 0x0f02, 0xa438, 0x1000, 0xa438, 0x1021,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xaa10, 0xa438, 0x1800,
+        0xa438, 0x0c6b, 0xa438, 0x82a0, 0xa438, 0x8406, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xac04, 0xa438, 0x8602, 0xa438, 0x9503,
+        0xa438, 0x1800, 0xa438, 0x0e09, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x8308, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xc555, 0xa438, 0x9503, 0xa438, 0xa728,
+        0xa438, 0x8440, 0xa438, 0x0c03, 0xa438, 0x0901, 0xa438, 0x8801,
+        0xa438, 0xd700, 0xa438, 0x4040, 0xa438, 0xa801, 0xa438, 0xd701,
+        0xa438, 0x4052, 0xa438, 0xa810, 0xa438, 0xd701, 0xa438, 0x4054,
+        0xa438, 0xa820, 0xa438, 0xd701, 0xa438, 0x4057, 0xa438, 0xa640,
+        0xa438, 0xd704, 0xa438, 0x4046, 0xa438, 0xa840, 0xa438, 0xd706,
+        0xa438, 0x40b5, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xae20,
+        0xa438, 0x9503, 0xa438, 0xd401, 0xa438, 0x1000, 0xa438, 0x0fcf,
+        0xa438, 0x1000, 0xa438, 0x0fda, 0xa438, 0x1000, 0xa438, 0x1008,
+        0xa438, 0x1000, 0xa438, 0x0fe3, 0xa438, 0xcc00, 0xa438, 0x80c0,
+        0xa438, 0x8103, 0xa438, 0x83e0, 0xa438, 0xd71e, 0xa438, 0x2318,
+        0xa438, 0x01ae, 0xa438, 0xd704, 0xa438, 0x40bc, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8302, 0xa438, 0x9503, 0xa438, 0xb801,
+        0xa438, 0xd706, 0xa438, 0x2b59, 0xa438, 0x07f8, 0xa438, 0xd700,
+        0xa438, 0x2109, 0xa438, 0x04ab, 0xa438, 0xa508, 0xa438, 0xcb15,
+        0xa438, 0xd70c, 0xa438, 0x430c, 0xa438, 0x1000, 0xa438, 0x10ca,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa108, 0xa438, 0x9503,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0c1f, 0xa438, 0x0f13,
+        0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xd70c,
+        0xa438, 0x5fb3, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8f1f,
+        0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xd70c,
+        0xa438, 0x7f33, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0c0f,
+        0xa438, 0x0d00, 0xa438, 0x0c70, 0xa438, 0x0b00, 0xa438, 0xab08,
+        0xa438, 0x9503, 0xa438, 0xd704, 0xa438, 0x3cf1, 0xa438, 0x01f9,
+        0xa438, 0x0c1f, 0xa438, 0x0d11, 0xa438, 0xf003, 0xa438, 0x0c1f,
+        0xa438, 0x0d0d, 0xa438, 0x0cc0, 0xa438, 0x0d40, 0xa438, 0x1000,
+        0xa438, 0x104f, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xab80,
+        0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xa940,
+        0xa438, 0xd700, 0xa438, 0x5f99, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8b80, 0xa438, 0x9503, 0xa438, 0x8940, 0xa438, 0xd700,
+        0xa438, 0x5bbf, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8b08,
+        0xa438, 0x9503, 0xa438, 0xba20, 0xa438, 0xd704, 0xa438, 0x4100,
+        0xa438, 0xd115, 0xa438, 0xd04f, 0xa438, 0xf001, 0xa438, 0x1000,
+        0xa438, 0x1021, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x0c0f, 0xa438, 0x0d00, 0xa438, 0x0c70,
+        0xa438, 0x0b10, 0xa438, 0xab08, 0xa438, 0x9503, 0xa438, 0xd704,
+        0xa438, 0x3cf1, 0xa438, 0x8178, 0xa438, 0x0c1f, 0xa438, 0x0d11,
+        0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d0d, 0xa438, 0x0cc0,
+        0xa438, 0x0d40, 0xa438, 0x1000, 0xa438, 0x104f, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xab80, 0xa438, 0x9503, 0xa438, 0x1000,
+        0xa438, 0x1021, 0xa438, 0xd706, 0xa438, 0x5fad, 0xa438, 0xd407,
+        0xa438, 0x1000, 0xa438, 0x0fcf, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8b88, 0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1021,
+        0xa438, 0xd702, 0xa438, 0x7fa4, 0xa438, 0xd706, 0xa438, 0x61bf,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0c30, 0xa438, 0x0110,
+        0xa438, 0xa304, 0xa438, 0x9503, 0xa438, 0xd199, 0xa438, 0xd04b,
+        0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0xd704, 0xa438, 0x3cf1, 0xa438, 0x81a5, 0xa438, 0x0c1f,
+        0xa438, 0x0d02, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d01,
+        0xa438, 0x0cc0, 0xa438, 0x0d40, 0xa438, 0xa420, 0xa438, 0x8720,
+        0xa438, 0x1000, 0xa438, 0x104f, 0xa438, 0x1000, 0xa438, 0x0fda,
+        0xa438, 0xd70c, 0xa438, 0x41ac, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8108, 0xa438, 0x9503, 0xa438, 0x0cc0, 0xa438, 0x0040,
+        0xa438, 0x0c03, 0xa438, 0x0102, 0xa438, 0x0ce0, 0xa438, 0x03e0,
+        0xa438, 0xccce, 0xa438, 0xf008, 0xa438, 0x0cc0, 0xa438, 0x0040,
+        0xa438, 0x0c03, 0xa438, 0x0100, 0xa438, 0x0ce0, 0xa438, 0x0380,
+        0xa438, 0xcc9c, 0xa438, 0x1000, 0xa438, 0x103f, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xa640, 0xa438, 0x9503, 0xa438, 0xcb16,
+        0xa438, 0xd706, 0xa438, 0x6129, 0xa438, 0xd70c, 0xa438, 0x608c,
+        0xa438, 0xd17a, 0xa438, 0xd04a, 0xa438, 0xf006, 0xa438, 0xd17a,
+        0xa438, 0xd04b, 0xa438, 0xf003, 0xa438, 0xd13d, 0xa438, 0xd04b,
+        0xa438, 0x0c1f, 0xa438, 0x0f14, 0xa438, 0xcb17, 0xa438, 0x8fc0,
+        0xa438, 0x1000, 0xa438, 0x0fbd, 0xa438, 0xaf40, 0xa438, 0x1000,
+        0xa438, 0x0fbd, 0xa438, 0x0cc0, 0xa438, 0x0f80, 0xa438, 0x1000,
+        0xa438, 0x0fbd, 0xa438, 0xafc0, 0xa438, 0x1000, 0xa438, 0x0fbd,
+        0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xd701, 0xa438, 0x652e,
+        0xa438, 0xd700, 0xa438, 0x5db4, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8640, 0xa438, 0xa702, 0xa438, 0x9503, 0xa438, 0xa720,
+        0xa438, 0x1000, 0xa438, 0x0fda, 0xa438, 0xa108, 0xa438, 0x1000,
+        0xa438, 0x0fec, 0xa438, 0x8108, 0xa438, 0x1000, 0xa438, 0x0fe3,
+        0xa438, 0xa202, 0xa438, 0xa308, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x8308, 0xa438, 0xcb18,
+        0xa438, 0x1000, 0xa438, 0x10c2, 0xa438, 0x1000, 0xa438, 0x1021,
+        0xa438, 0xd70c, 0xa438, 0x2c60, 0xa438, 0x02bd, 0xa438, 0xff58,
+        0xa438, 0x8f1f, 0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xd701,
+        0xa438, 0x7f8e, 0xa438, 0x1000, 0xa438, 0x0fe3, 0xa438, 0xa130,
+        0xa438, 0xaa2f, 0xa438, 0xa2d5, 0xa438, 0xa407, 0xa438, 0xa720,
+        0xa438, 0x8310, 0xa438, 0xa308, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x8308, 0xa438, 0x1800,
+        0xa438, 0x02d2, 0xa436, 0xA10E, 0xa438, 0x017f, 0xa436, 0xA10C,
+        0xa438, 0x0e04, 0xa436, 0xA10A, 0xa438, 0x0c67, 0xa436, 0xA108,
+        0xa438, 0x0f13, 0xa436, 0xA106, 0xa438, 0x0eb1, 0xa436, 0xA104,
+        0xa438, 0x0e79, 0xa436, 0xA102, 0xa438, 0x0b23, 0xa436, 0xA100,
+        0xa438, 0x0908, 0xa436, 0xA110, 0xa438, 0x00ff, 0xa436, 0xb87c,
+        0xa438, 0x8ad8, 0xa436, 0xb87e, 0xa438, 0xaf8a, 0xa438, 0xf0af,
+        0xa438, 0x8af9, 0xa438, 0xaf8d, 0xa438, 0xdaaf, 0xa438, 0x8e1c,
+        0xa438, 0xaf8f, 0xa438, 0x03af, 0xa438, 0x8f06, 0xa438, 0xaf8f,
+        0xa438, 0x06af, 0xa438, 0x8f06, 0xa438, 0x0265, 0xa438, 0xa002,
+        0xa438, 0x8d78, 0xa438, 0xaf23, 0xa438, 0x47a1, 0xa438, 0x0d06,
+        0xa438, 0x028b, 0xa438, 0x05af, 0xa438, 0x225a, 0xa438, 0xaf22,
+        0xa438, 0x66f8, 0xa438, 0xe08a, 0xa438, 0x33a0, 0xa438, 0x0005,
+        0xa438, 0x028b, 0xa438, 0x21ae, 0xa438, 0x0ea0, 0xa438, 0x0105,
+        0xa438, 0x028b, 0xa438, 0xb3ae, 0xa438, 0x06a0, 0xa438, 0x0203,
+        0xa438, 0x028c, 0xa438, 0x9dfc, 0xa438, 0x04f8, 0xa438, 0xfbfa,
+        0xa438, 0xef69, 0xa438, 0xe080, 0xa438, 0x13ad, 0xa438, 0x267e,
+        0xa438, 0xd067, 0xa438, 0xe48a, 0xa438, 0x34e4, 0xa438, 0x8a36,
+        0xa438, 0xe48a, 0xa438, 0x38e4, 0xa438, 0x8a3a, 0xa438, 0xd0ae,
+        0xa438, 0xe48a, 0xa438, 0x35e4, 0xa438, 0x8a37, 0xa438, 0xe48a,
+        0xa438, 0x39e4, 0xa438, 0x8a3b, 0xa438, 0xd000, 0xa438, 0xe48a,
+        0xa438, 0x3ce4, 0xa438, 0x8a3d, 0xa438, 0xe48a, 0xa438, 0x3ee4,
+        0xa438, 0x8a3f, 0xa438, 0xe48a, 0xa438, 0x40e4, 0xa438, 0x8a41,
+        0xa438, 0xe48a, 0xa438, 0x42e4, 0xa438, 0x8a43, 0xa438, 0xe48a,
+        0xa438, 0x44d0, 0xa438, 0x02e4, 0xa438, 0x8a45, 0xa438, 0xd00a,
+        0xa438, 0xe48a, 0xa438, 0x46d0, 0xa438, 0x16e4, 0xa438, 0x8a47,
+        0xa438, 0xd01e, 0xa438, 0xe48a, 0xa438, 0x48d1, 0xa438, 0x02bf,
+        0xa438, 0x8dce, 0xa438, 0x026b, 0xa438, 0xd0d1, 0xa438, 0x0abf,
+        0xa438, 0x8dd1, 0xa438, 0x026b, 0xa438, 0xd0d1, 0xa438, 0x16bf,
+        0xa438, 0x8dd4, 0xa438, 0x026b, 0xa438, 0xd0d1, 0xa438, 0x1ebf,
+        0xa438, 0x8dd7, 0xa438, 0x026b, 0xa438, 0xd002, 0xa438, 0x73ab,
+        0xa438, 0xef47, 0xa438, 0xe585, 0xa438, 0x5de4, 0xa438, 0x855c,
+        0xa438, 0xee8a, 0xa438, 0x3301, 0xa438, 0xae03, 0xa438, 0x0224,
+        0xa438, 0x95ef, 0xa438, 0x96fe, 0xa438, 0xfffc, 0xa438, 0x04f8,
+        0xa438, 0xf9fa, 0xa438, 0xcefa, 0xa438, 0xef69, 0xa438, 0xfb02,
+        0xa438, 0x8dab, 0xa438, 0xad50, 0xa438, 0x2ee1, 0xa438, 0x8a44,
+        0xa438, 0xa104, 0xa438, 0x2bee, 0xa438, 0x8a33, 0xa438, 0x02e1,
+        0xa438, 0x8a45, 0xa438, 0xbf8d, 0xa438, 0xce02, 0xa438, 0x6bd0,
+        0xa438, 0xe18a, 0xa438, 0x46bf, 0xa438, 0x8dd1, 0xa438, 0x026b,
+        0xa438, 0xd0e1, 0xa438, 0x8a47, 0xa438, 0xbf8d, 0xa438, 0xd402,
+        0xa438, 0x6bd0, 0xa438, 0xe18a, 0xa438, 0x48bf, 0xa438, 0x8dd7,
+        0xa438, 0x026b, 0xa438, 0xd0af, 0xa438, 0x8c94, 0xa438, 0xd200,
+        0xa438, 0xbe00, 0xa438, 0x0002, 0xa438, 0x8ca5, 0xa438, 0x12a2,
+        0xa438, 0x04f6, 0xa438, 0xe18a, 0xa438, 0x44a1, 0xa438, 0x0020,
+        0xa438, 0xd129, 0xa438, 0xbf8d, 0xa438, 0xce02, 0xa438, 0x6bd0,
+        0xa438, 0xd121, 0xa438, 0xbf8d, 0xa438, 0xd102, 0xa438, 0x6bd0,
+        0xa438, 0xd125, 0xa438, 0xbf8d, 0xa438, 0xd402, 0xa438, 0x6bd0,
+        0xa438, 0xbf8d, 0xa438, 0xd702, 0xa438, 0x6bd0, 0xa438, 0xae44,
+        0xa438, 0xa101, 0xa438, 0x1ed1, 0xa438, 0x31bf, 0xa438, 0x8dce,
+        0xa438, 0x026b, 0xa438, 0xd0bf, 0xa438, 0x8dd1, 0xa438, 0x026b,
+        0xa438, 0xd0d1, 0xa438, 0x2dbf, 0xa438, 0x8dd4, 0xa438, 0x026b,
+        0xa438, 0xd0bf, 0xa438, 0x8dd7, 0xa438, 0x026b, 0xa438, 0xd0ae,
+        0xa438, 0x23a1, 0xa438, 0x0220, 0xa438, 0xd139, 0xa438, 0xbf8d,
+        0xa438, 0xce02, 0xa438, 0x6bd0, 0xa438, 0xbf8d, 0xa438, 0xd102,
+        0xa438, 0x6bd0, 0xa438, 0xd13d, 0xa438, 0xbf8d, 0xa438, 0xd402,
+        0xa438, 0x6bd0, 0xa438, 0xd135, 0xa438, 0xbf8d, 0xa438, 0xd702,
+        0xa438, 0x6bd0, 0xa438, 0xae00, 0xa438, 0xe18a, 0xa438, 0x4411,
+        0xa438, 0xe58a, 0xa438, 0x44d0, 0xa438, 0x00e4, 0xa438, 0x8a3c,
+        0xa438, 0xe48a, 0xa438, 0x3de4, 0xa438, 0x8a3e, 0xa438, 0xe48a,
+        0xa438, 0x3fe4, 0xa438, 0x8a40, 0xa438, 0xe48a, 0xa438, 0x41e4,
+        0xa438, 0x8a42, 0xa438, 0xe48a, 0xa438, 0x4302, 0xa438, 0x73ab,
+        0xa438, 0xef47, 0xa438, 0xe585, 0xa438, 0x5de4, 0xa438, 0x855c,
+        0xa438, 0xffef, 0xa438, 0x96fe, 0xa438, 0xc6fe, 0xa438, 0xfdfc,
+        0xa438, 0x0402, 0xa438, 0x2495, 0xa438, 0xee8a, 0xa438, 0x3300,
+        0xa438, 0x04f8, 0xa438, 0xf9fa, 0xa438, 0xfbef, 0xa438, 0x79fb,
+        0xa438, 0xcffb, 0xa438, 0xd300, 0xa438, 0xa200, 0xa438, 0x09bf,
+        0xa438, 0x8dc2, 0xa438, 0x026b, 0xa438, 0xefaf, 0xa438, 0x8cda,
+        0xa438, 0xa201, 0xa438, 0x09bf, 0xa438, 0x8dc5, 0xa438, 0x026b,
+        0xa438, 0xefaf, 0xa438, 0x8cda, 0xa438, 0xa202, 0xa438, 0x09bf,
+        0xa438, 0x8dc8, 0xa438, 0x026b, 0xa438, 0xefaf, 0xa438, 0x8cda,
+        0xa438, 0xbf8d, 0xa438, 0xcb02, 0xa438, 0x6bef, 0xa438, 0xef64,
+        0xa438, 0xbf8a, 0xa438, 0x3c1a, 0xa438, 0x921a, 0xa438, 0x92d8,
+        0xa438, 0x19d9, 0xa438, 0xef74, 0xa438, 0x0273, 0xa438, 0x93ef,
+        0xa438, 0x47bf, 0xa438, 0x8a3c, 0xa438, 0x1a92, 0xa438, 0x1a92,
+        0xa438, 0xdc19, 0xa438, 0xddd1, 0xa438, 0x0011, 0xa438, 0xa1ff,
+        0xa438, 0xfc13, 0xa438, 0xa310, 0xa438, 0xaf02, 0xa438, 0x8d0e,
+        0xa438, 0xffc7, 0xa438, 0xffef, 0xa438, 0x97ff, 0xa438, 0xfefd,
+        0xa438, 0xfc04, 0xa438, 0xf8fa, 0xa438, 0xfbef, 0xa438, 0x79fb,
+        0xa438, 0xcffb, 0xa438, 0xbf8a, 0xa438, 0x3c1a, 0xa438, 0x921a,
+        0xa438, 0x92d8, 0xa438, 0x19d9, 0xa438, 0xef64, 0xa438, 0xbf8a,
+        0xa438, 0x341a, 0xa438, 0x921a, 0xa438, 0x92d8, 0xa438, 0x19d9,
+        0xa438, 0xef74, 0xa438, 0x0273, 0xa438, 0x78a2, 0xa438, 0x0005,
+        0xa438, 0xbe8d, 0xa438, 0xceae, 0xa438, 0x13a2, 0xa438, 0x0105,
+        0xa438, 0xbe8d, 0xa438, 0xd1ae, 0xa438, 0x0ba2, 0xa438, 0x0205,
+        0xa438, 0xbe8d, 0xa438, 0xd4ae, 0xa438, 0x03be, 0xa438, 0x8dd7,
+        0xa438, 0xad50, 0xa438, 0x17bf, 0xa438, 0x8a45, 0xa438, 0x1a92,
+        0xa438, 0x0702, 0xa438, 0x6bef, 0xa438, 0x07dd, 0xa438, 0xef46,
+        0xa438, 0xbf8a, 0xa438, 0x341a, 0xa438, 0x921a, 0xa438, 0x92dc,
+        0xa438, 0x19dd, 0xa438, 0xffc7, 0xa438, 0xffef, 0xa438, 0x97ff,
+        0xa438, 0xfefc, 0xa438, 0x04ee, 0xa438, 0x8a33, 0xa438, 0x00ee,
+        0xa438, 0x8a32, 0xa438, 0x0404, 0xa438, 0xf8fa, 0xa438, 0xef69,
+        0xa438, 0xe080, 0xa438, 0x13ad, 0xa438, 0x2624, 0xa438, 0xd102,
+        0xa438, 0xbf8d, 0xa438, 0xce02, 0xa438, 0x6bd0, 0xa438, 0xd10a,
+        0xa438, 0xbf8d, 0xa438, 0xd102, 0xa438, 0x6bd0, 0xa438, 0xd116,
+        0xa438, 0xbf8d, 0xa438, 0xd402, 0xa438, 0x6bd0, 0xa438, 0xd11e,
+        0xa438, 0xbf8d, 0xa438, 0xd702, 0xa438, 0x6bd0, 0xa438, 0xee8a,
+        0xa438, 0x3300, 0xa438, 0xef96, 0xa438, 0xfefc, 0xa438, 0x04f8,
+        0xa438, 0xfae0, 0xa438, 0x855c, 0xa438, 0xe185, 0xa438, 0x5def,
+        0xa438, 0x64d0, 0xa438, 0x00e1, 0xa438, 0x8a32, 0xa438, 0xef74,
+        0xa438, 0x0273, 0xa438, 0xc6fe, 0xa438, 0xfc04, 0xa438, 0xf0b2,
+        0xa438, 0x02f0, 0xa438, 0xb282, 0xa438, 0xf0b3, 0xa438, 0x02f0,
+        0xa438, 0xb382, 0xa438, 0x50ac, 0xa438, 0xd450, 0xa438, 0xacd6,
+        0xa438, 0xb6ac, 0xa438, 0xd4b6, 0xa438, 0xacd6, 0xa438, 0xbf8e,
+        0xa438, 0x0d02, 0xa438, 0x6bd0, 0xa438, 0xd0ff, 0xa438, 0xd1fe,
+        0xa438, 0xbf8e, 0xa438, 0x1002, 0xa438, 0x6bd0, 0xa438, 0xd004,
+        0xa438, 0xd14d, 0xa438, 0xbf8e, 0xa438, 0x1302, 0xa438, 0x6bd0,
+        0xa438, 0xd0fc, 0xa438, 0xd1c6, 0xa438, 0xbf8e, 0xa438, 0x1602,
+        0xa438, 0x6bd0, 0xa438, 0xd009, 0xa438, 0xd146, 0xa438, 0xbf8e,
+        0xa438, 0x1902, 0xa438, 0x6bd0, 0xa438, 0xef13, 0xa438, 0xaf2d,
+        0xa438, 0xbdf0, 0xa438, 0xac1c, 0xa438, 0xf0ac, 0xa438, 0x2af0,
+        0xa438, 0xac2c, 0xa438, 0xf0ac, 0xa438, 0x2ef0, 0xa438, 0xac30,
+        0xa438, 0xbf8e, 0xa438, 0xf102, 0xa438, 0x6bef, 0xa438, 0xac28,
+        0xa438, 0x70bf, 0xa438, 0x8eeb, 0xa438, 0x026b, 0xa438, 0xefac,
+        0xa438, 0x2867, 0xa438, 0xbf8e, 0xa438, 0xee02, 0xa438, 0x6bef,
+        0xa438, 0xad28, 0xa438, 0x5bbf, 0xa438, 0x8ff2, 0xa438, 0xd8bf,
+        0xa438, 0x8ff3, 0xa438, 0xd9bf, 0xa438, 0x8ef4, 0xa438, 0x026b,
+        0xa438, 0xd0bf, 0xa438, 0x8ff0, 0xa438, 0xd8bf, 0xa438, 0x8ff1,
+        0xa438, 0xd9bf, 0xa438, 0x8ef7, 0xa438, 0x026b, 0xa438, 0xd0bf,
+        0xa438, 0x8fee, 0xa438, 0xd8bf, 0xa438, 0x8fef, 0xa438, 0xd9bf,
+        0xa438, 0x8efa, 0xa438, 0x026b, 0xa438, 0xd0bf, 0xa438, 0x8fec,
+        0xa438, 0xd8bf, 0xa438, 0x8fed, 0xa438, 0xd9bf, 0xa438, 0x8efd,
+        0xa438, 0x026b, 0xa438, 0xd0bf, 0xa438, 0x8fea, 0xa438, 0xd8bf,
+        0xa438, 0x8feb, 0xa438, 0xd9bf, 0xa438, 0x8f00, 0xa438, 0x026b,
+        0xa438, 0xd0bf, 0xa438, 0x8fe8, 0xa438, 0xd8bf, 0xa438, 0x8fe9,
+        0xa438, 0xd9bf, 0xa438, 0x8e0d, 0xa438, 0x026b, 0xa438, 0xd01f,
+        0xa438, 0x00e1, 0xa438, 0x86ee, 0xa438, 0x1b64, 0xa438, 0xaf3d,
+        0xa438, 0x7abf, 0xa438, 0x8ffe, 0xa438, 0xd8bf, 0xa438, 0x8fff,
+        0xa438, 0xd9bf, 0xa438, 0x8ef4, 0xa438, 0x026b, 0xa438, 0xd0bf,
+        0xa438, 0x8ffc, 0xa438, 0xd8bf, 0xa438, 0x8ffd, 0xa438, 0xd9bf,
+        0xa438, 0x8ef7, 0xa438, 0x026b, 0xa438, 0xd0bf, 0xa438, 0x8ffa,
+        0xa438, 0xd8bf, 0xa438, 0x8ffb, 0xa438, 0xd9bf, 0xa438, 0x8efa,
+        0xa438, 0x026b, 0xa438, 0xd0bf, 0xa438, 0x8ff8, 0xa438, 0xd8bf,
+        0xa438, 0x8ff9, 0xa438, 0xd9bf, 0xa438, 0x8efd, 0xa438, 0x026b,
+        0xa438, 0xd0bf, 0xa438, 0x8ff6, 0xa438, 0xd8bf, 0xa438, 0x8ff7,
+        0xa438, 0xd9bf, 0xa438, 0x8f00, 0xa438, 0x026b, 0xa438, 0xd0bf,
+        0xa438, 0x8ff4, 0xa438, 0xd8bf, 0xa438, 0x8ff5, 0xa438, 0xd9bf,
+        0xa438, 0x8e0d, 0xa438, 0x026b, 0xa438, 0xd0ae, 0xa438, 0xa766,
+        0xa438, 0xac5c, 0xa438, 0xbbac, 0xa438, 0x5c99, 0xa438, 0xac5c,
+        0xa438, 0xf0ac, 0xa438, 0x26f0, 0xa438, 0xac24, 0xa438, 0xf0ac,
+        0xa438, 0x22f0, 0xa438, 0xac20, 0xa438, 0xf0ac, 0xa438, 0x1eaf,
+        0xa438, 0x44f8, 0xa436, 0xb85e, 0xa438, 0x2344, 0xa436, 0xb860,
+        0xa438, 0x2254, 0xa436, 0xb862, 0xa438, 0x2DB5, 0xa436, 0xb864,
+        0xa438, 0x3D6C, 0xa436, 0xb886, 0xa438, 0x44ED, 0xa436, 0xb888,
+        0xa438, 0xffff, 0xa436, 0xb88a, 0xa438, 0xffff, 0xa436, 0xb88c,
+        0xa438, 0xffff, 0xa436, 0xb838, 0xa438, 0x001f, 0xb820, 0x0010,
+        0xa436, 0x87ad, 0xa438, 0xaf87, 0xa438, 0xc5af, 0xa438, 0x87e4,
+        0xa438, 0xaf8a, 0xa438, 0x3daf, 0xa438, 0x8a62, 0xa438, 0xaf8a,
+        0xa438, 0x62af, 0xa438, 0x8a62, 0xa438, 0xaf8a, 0xa438, 0x62af,
+        0xa438, 0x8a62, 0xa438, 0x2810, 0xa438, 0x0d01, 0xa438, 0xe484,
+        0xa438, 0xbf29, 0xa438, 0x100d, 0xa438, 0x11e5, 0xa438, 0x84c0,
+        0xa438, 0x2a10, 0xa438, 0x0d21, 0xa438, 0xe684, 0xa438, 0xc12b,
+        0xa438, 0x100d, 0xa438, 0x31e7, 0xa438, 0x84c2, 0xa438, 0xaf3f,
+        0xa438, 0x7cf8, 0xa438, 0xe080, 0xa438, 0x4cac, 0xa438, 0x222c,
+        0xa438, 0xe080, 0xa438, 0x40ad, 0xa438, 0x2232, 0xa438, 0xbf8a,
+        0xa438, 0x2502, 0xa438, 0x6752, 0xa438, 0xad29, 0xa438, 0x0502,
+        0xa438, 0x8827, 0xa438, 0xae0d, 0xa438, 0xad28, 0xa438, 0x0502,
+        0xa438, 0x8961, 0xa438, 0xae05, 0xa438, 0x0214, 0xa438, 0x04ae,
+        0xa438, 0x00e0, 0xa438, 0x8040, 0xa438, 0xac22, 0xa438, 0x1102,
+        0xa438, 0x13e1, 0xa438, 0xae0c, 0xa438, 0x0288, 0xa438, 0x7c02,
+        0xa438, 0x8a10, 0xa438, 0x0214, 0xa438, 0x2502, 0xa438, 0x1404,
+        0xa438, 0xfcaf, 0xa438, 0x13c6, 0xa438, 0xf8f8, 0xa438, 0xccf9,
+        0xa438, 0xfaef, 0xa438, 0x69fb, 0xa438, 0xe080, 0xa438, 0x18ad,
+        0xa438, 0x223b, 0xa438, 0xbf8a, 0xa438, 0x2b02, 0xa438, 0x6752,
+        0xa438, 0xad28, 0xa438, 0x32bf, 0xa438, 0x8a28, 0xa438, 0x026f,
+        0xa438, 0x17ee, 0xa438, 0x8ff3, 0xa438, 0x00bf, 0xa438, 0x6854,
+        0xa438, 0x0267, 0xa438, 0x52ad, 0xa438, 0x281f, 0xa438, 0xbf68,
+        0xa438, 0x5d02, 0xa438, 0x6752, 0xa438, 0xad28, 0xa438, 0x16e0,
+        0xa438, 0x8ff4, 0xa438, 0xe18f, 0xa438, 0xf502, 0xa438, 0x8891,
+        0xa438, 0xad50, 0xa438, 0x0abf, 0xa438, 0x8a28, 0xa438, 0x026f,
+        0xa438, 0x20ee, 0xa438, 0x8ff3, 0xa438, 0x0102, 0xa438, 0x1404,
+        0xa438, 0xffef, 0xa438, 0x96fe, 0xa438, 0xfdc4, 0xa438, 0xfcfc,
+        0xa438, 0x04f8, 0xa438, 0xf9ef, 0xa438, 0x59e0, 0xa438, 0x8018,
+        0xa438, 0xad22, 0xa438, 0x06bf, 0xa438, 0x8a28, 0xa438, 0x026f,
+        0xa438, 0x17ef, 0xa438, 0x95fd, 0xa438, 0xfc04, 0xa438, 0xf8f9,
+        0xa438, 0xf9ef, 0xa438, 0x59fa, 0xa438, 0xface, 0xa438, 0xe48f,
+        0xa438, 0xfee5, 0xa438, 0x8fff, 0xa438, 0xbf6e, 0xa438, 0x1b02,
+        0xa438, 0x6f20, 0xa438, 0xbf6e, 0xa438, 0x1802, 0xa438, 0x6f17,
+        0xa438, 0xd102, 0xa438, 0xbf6e, 0xa438, 0x1202, 0xa438, 0x6733,
+        0xa438, 0xbf6e, 0xa438, 0x1502, 0xa438, 0x6f17, 0xa438, 0xbe00,
+        0xa438, 0x00cc, 0xa438, 0xbf69, 0xa438, 0xcb02, 0xa438, 0x6733,
+        0xa438, 0xbf69, 0xa438, 0xce02, 0xa438, 0x6f17, 0xa438, 0xbf69,
+        0xa438, 0xce02, 0xa438, 0x6f20, 0xa438, 0xbf69, 0xa438, 0xd102,
+        0xa438, 0x6752, 0xa438, 0xad28, 0xa438, 0xf70c, 0xa438, 0x81bf,
+        0xa438, 0x8ff6, 0xa438, 0x1a98, 0xa438, 0xef59, 0xa438, 0xbf69,
+        0xa438, 0xd402, 0xa438, 0x6752, 0xa438, 0xef95, 0xa438, 0xdc19,
+        0xa438, 0xdd0d, 0xa438, 0x8118, 0xa438, 0xa800, 0xa438, 0x04c9,
+        0xa438, 0xbf69, 0xa438, 0xce02, 0xa438, 0x6f17, 0xa438, 0xe08f,
+        0xa438, 0xfce1, 0xa438, 0x8ffd, 0xa438, 0xef74, 0xa438, 0xe08f,
+        0xa438, 0xfae1, 0xa438, 0x8ffb, 0xa438, 0xef64, 0xa438, 0x026e,
+        0xa438, 0x57ad, 0xa438, 0x5008, 0xa438, 0xe08f, 0xa438, 0xfce1,
+        0xa438, 0x8ffd, 0xa438, 0xae06, 0xa438, 0xe08f, 0xa438, 0xfae1,
+        0xa438, 0x8ffb, 0xa438, 0xe28f, 0xa438, 0xf8e3, 0xa438, 0x8ff9,
+        0xa438, 0xef75, 0xa438, 0xe28f, 0xa438, 0xf6e3, 0xa438, 0x8ff7,
+        0xa438, 0xef65, 0xa438, 0x026e, 0xa438, 0x57ad, 0xa438, 0x5008,
+        0xa438, 0xe28f, 0xa438, 0xf8e3, 0xa438, 0x8ff9, 0xa438, 0xae06,
+        0xa438, 0xe28f, 0xa438, 0xf6e3, 0xa438, 0x8ff7, 0xa438, 0x1b45,
+        0xa438, 0xad27, 0xa438, 0x05d7, 0xa438, 0x0000, 0xa438, 0xae0d,
+        0xa438, 0xef74, 0xa438, 0xe08f, 0xa438, 0xfee1, 0xa438, 0x8fff,
+        0xa438, 0xef64, 0xa438, 0x026e, 0xa438, 0x57c6, 0xa438, 0xfefe,
+        0xa438, 0xef95, 0xa438, 0xfdfd, 0xa438, 0xfc04, 0xa438, 0xf8f9,
+        0xa438, 0xfaef, 0xa438, 0x69fb, 0xa438, 0xe080, 0xa438, 0x18ac,
+        0xa438, 0x2103, 0xa438, 0xaf8a, 0xa438, 0x06bf, 0xa438, 0x8a2b,
+        0xa438, 0xac21, 0xa438, 0x03af, 0xa438, 0x8a06, 0xa438, 0xbf8a,
+        0xa438, 0x2802, 0xa438, 0x6f17, 0xa438, 0xee8f, 0xa438, 0xee00,
+        0xa438, 0xee8f, 0xa438, 0xed00, 0xa438, 0xbf8a, 0xa438, 0x2e02,
+        0xa438, 0x6752, 0xa438, 0xad28, 0xa438, 0x03af, 0xa438, 0x8a06,
+        0xa438, 0xe28f, 0xa438, 0xefe3, 0xa438, 0x8ff0, 0xa438, 0xbf68,
+        0xa438, 0x5102, 0xa438, 0x6752, 0xa438, 0xac28, 0xa438, 0x11e2,
+        0xa438, 0x8ff1, 0xa438, 0xe38f, 0xa438, 0xf2bf, 0xa438, 0x6848,
+        0xa438, 0x0267, 0xa438, 0x52ac, 0xa438, 0x2802, 0xa438, 0xae53,
+        0xa438, 0xbf68, 0xa438, 0x5a02, 0xa438, 0x6752, 0xa438, 0xad28,
+        0xa438, 0x0aef, 0xa438, 0x4502, 0xa438, 0x8891, 0xa438, 0xac50,
+        0xa438, 0x38ae, 0xa438, 0x40bf, 0xa438, 0x8a31, 0xa438, 0x0267,
+        0xa438, 0x52ef, 0xa438, 0x31bf, 0xa438, 0x8a34, 0xa438, 0x0267,
+        0xa438, 0x520c, 0xa438, 0x311e, 0xa438, 0x31bf, 0xa438, 0x8a37,
+        0xa438, 0x0267, 0xa438, 0x520c, 0xa438, 0x311e, 0xa438, 0x31bf,
+        0xa438, 0x8a3a, 0xa438, 0x0267, 0xa438, 0x520c, 0xa438, 0x311e,
+        0xa438, 0x31e7, 0xa438, 0x8fee, 0xa438, 0xa30c, 0xa438, 0x02ae,
+        0xa438, 0x08a3, 0xa438, 0x0e02, 0xa438, 0xae03, 0xa438, 0xa30d,
+        0xa438, 0x0aee, 0xa438, 0x8fed, 0xa438, 0x01bf, 0xa438, 0x8a28,
+        0xa438, 0x026f, 0xa438, 0x2002, 0xa438, 0x1404, 0xa438, 0xffef,
+        0xa438, 0x96fe, 0xa438, 0xfdfc, 0xa438, 0x04f8, 0xa438, 0xfaef,
+        0xa438, 0x69e0, 0xa438, 0x8018, 0xa438, 0xad21, 0xa438, 0x06bf,
+        0xa438, 0x8a28, 0xa438, 0x026f, 0xa438, 0x17ef, 0xa438, 0x96fe,
+        0xa438, 0xfc04, 0xa438, 0xf8a4, 0xa438, 0xb677, 0xa438, 0xa4b6,
+        0xa438, 0x22a4, 0xa438, 0x4222, 0xa438, 0xa668, 0xa438, 0x00b2,
+        0xa438, 0x3e00, 0xa438, 0xb2be, 0xa438, 0x00b3, 0xa438, 0x3e00,
+        0xa438, 0xb3be, 0xa438, 0xd10f, 0xa438, 0xbf8a, 0xa438, 0x5c02,
+        0xa438, 0x6733, 0xa438, 0xbf8a, 0xa438, 0x5f02, 0xa438, 0x6733,
+        0xa438, 0xbf8a, 0xa438, 0x5c02, 0xa438, 0x6f17, 0xa438, 0xbf8a,
+        0xa438, 0x5f02, 0xa438, 0x6f17, 0xa438, 0x1f00, 0xa438, 0xaf3d,
+        0xa438, 0x0c30, 0xa438, 0xa85a, 0xa438, 0xfcad, 0xa438, 0x0e00,
+        0xa436, 0xb818, 0xa438, 0x3f31, 0xa436, 0xb81a, 0xa438, 0x13a4,
+        0xa436, 0xb81c, 0xa438, 0x3d0a, 0xa436, 0xb81e, 0xa438, 0xffff,
+        0xa436, 0xb850, 0xa438, 0xffff, 0xa436, 0xb852, 0xa438, 0xffff,
+        0xa436, 0xb878, 0xa438, 0xffff, 0xa436, 0xb884, 0xa438, 0xffff,
+        0xa436, 0xb832, 0xa438, 0x0007, 0xa436, 0x84cf, 0xa438, 0x0101,
+        0xa466, 0x0002, 0xa436, 0x86a7, 0xa438, 0x0000, 0xa436, 0x0000,
+        0xa438, 0x0000, 0xa436, 0xB82E, 0xa438, 0x0000, 0xa436, 0x8023,
+        0xa438, 0x0000, 0xa436, 0x801E, 0xa438, 0x0023, 0xb820, 0x0000,
+        0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8126a_1_2[] = {
+        0xB87C, 0x8a32, 0xB87E, 0x0400, 0xB87C, 0x8376, 0xB87E, 0x0300,
+        0xce00, 0x6CAF, 0xB87C, 0x8301, 0xB87E, 0x1133, 0xB87C, 0x8105,
+        0xB87E, 0xa000, 0xB87C, 0x8148, 0xB87E, 0xa000, 0xa436, 0x81d8,
+        0xa438, 0x5865, 0xacf8, 0xCCC0, 0xac90, 0x52B0, 0xad2C, 0x8000,
+        0xB87C, 0x83e6, 0xB87E, 0x4A0E, 0xB87C, 0x83d2, 0xB87E, 0x0A0E,
+        0xB87C, 0x80a0, 0xB87E, 0xB8B6, 0xB87C, 0x805e, 0xB87E, 0xB8B6,
+        0xB87C, 0x8057, 0xB87E, 0x305A, 0xB87C, 0x8099, 0xB87E, 0x305A,
+        0xB87C, 0x8052, 0xB87E, 0x3333, 0xB87C, 0x8094, 0xB87E, 0x3333,
+        0xB87C, 0x807F, 0xB87E, 0x7975, 0xB87C, 0x803D, 0xB87E, 0x7975,
+        0xB87C, 0x8036, 0xB87E, 0x305A, 0xB87C, 0x8078, 0xB87E, 0x305A,
+        0xB87C, 0x8031, 0xB87E, 0x3335, 0xB87C, 0x8073, 0xB87E, 0x3335,
+        0xa436, 0x81D8, 0xa438, 0x5865, 0xB87C, 0x867c, 0xB87E, 0x0617,
+        0xad94, 0x0092, 0xB87C, 0x89B1, 0xB87E, 0x5050, 0xB87C, 0x86E0,
+        0xB87E, 0x809A, 0xB87C, 0x86E2, 0xB87E, 0xB34D, 0xB87C, 0x8FD2,
+        0xB87E, 0x004B, 0xB87C, 0x8691, 0xB87E, 0x007D, 0xB87E, 0x00AF,
+        0xB87E, 0x00E1, 0xB87E, 0x00FF, 0xB87C, 0x867F, 0xB87E, 0x0201,
+        0xB87E, 0x0201, 0xB87E, 0x0201, 0xB87E, 0x0201, 0xB87E, 0x0201,
+        0xB87E, 0x0201, 0xB87C, 0x86DA, 0xB87E, 0xCDCD, 0xB87E, 0xE6CD,
+        0xB87E, 0xCDCD, 0xB87C, 0x8FE8, 0xB87E, 0x0368, 0xB87E, 0x033F,
+        0xB87E, 0x1046, 0xB87E, 0x147D, 0xB87E, 0x147D, 0xB87E, 0x147D,
+        0xB87E, 0x0368, 0xB87E, 0x033F, 0xB87E, 0x1046, 0xB87E, 0x147D,
+        0xB87E, 0x147D, 0xB87E, 0x147D, 0xa436, 0x80dd, 0xa438, 0xf0AB,
+        0xa436, 0x80df, 0xa438, 0xC009, 0xa436, 0x80e7, 0xa438, 0x401E,
+        0xa436, 0x80e1, 0xa438, 0x120A, 0xa436, 0x86f2, 0xa438, 0x5094,
+        0xa436, 0x8701, 0xa438, 0x5094, 0xa436, 0x80f1, 0xa438, 0x30CC,
+        0xa436, 0x80f3, 0xa438, 0x0001, 0xa436, 0x80f5, 0xa438, 0x330B,
+        0xa436, 0x80f8, 0xa438, 0xCB76, 0xa436, 0x8105, 0xa438, 0xf0D3,
+        0xa436, 0x8107, 0xa438, 0x0002, 0xa436, 0x8109, 0xa438, 0xff0B,
+        0xa436, 0x810c, 0xa438, 0xC86D, 0xB87C, 0x8a32, 0xB87E, 0x0400,
+        0xa6f8, 0x0000, 0xa6f8, 0x0000, 0xa436, 0x81bc, 0xa438, 0x1300,
+        0xa846, 0x2410, 0xa86A, 0x0801, 0xa85C, 0x9680, 0xa436, 0x841D,
+        0xa438, 0x4A28, 0xa436, 0x8016, 0xa438, 0xBE05, 0xBF9C, 0x004A,
+        0xBF96, 0x41FA, 0xBF9A, 0xDC81, 0xa436, 0x8018, 0xa438, 0x0700,
+        0xa436, 0x8ff4, 0xa438, 0x01AE, 0xa436, 0x8fef, 0xa438, 0x0172,
+        0xa438, 0x00dc, 0xc842, 0x0002, 0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8126a_1_3[] = {
+        0xb892, 0x0000, 0xB88E, 0xC236, 0xB890, 0x1A1C, 0xB88E, 0xC238,
+        0xB890, 0x1C1C, 0xB890, 0x1C1C, 0xB890, 0x2D2D, 0xB890, 0x2D2D,
+        0xB890, 0x2D2A, 0xB890, 0x2A2A, 0xB890, 0x2A2A, 0xB890, 0x2A19,
+        0xB88E, 0xC272, 0xB890, 0x8484, 0xB890, 0x8484, 0xB890, 0x84B4,
+        0xB890, 0xB4B4, 0xB890, 0xB4B4, 0xB890, 0xF8F8, 0xB890, 0xF8F8,
+        0xB890, 0xF8F8, 0xB88E, 0xC000, 0xB890, 0x0303, 0xB890, 0x0405,
+        0xB890, 0x0608, 0xB890, 0x0A0B, 0xB890, 0x0E11, 0xB890, 0x1519,
+        0xB890, 0x2028, 0xB890, 0x3503, 0xB890, 0x0304, 0xB890, 0x0405,
+        0xB890, 0x0606, 0xB890, 0x0708, 0xB890, 0x090A, 0xB890, 0x0B0D,
+        0xB890, 0x0F11, 0xB890, 0x1315, 0xB890, 0x181A, 0xB890, 0x2029,
+        0xB890, 0x2F36, 0xB890, 0x3D43, 0xB890, 0x0101, 0xB890, 0x0102,
+        0xB890, 0x0202, 0xB890, 0x0303, 0xB890, 0x0405, 0xB890, 0x0607,
+        0xB890, 0x090A, 0xB890, 0x0C0E, 0xB88E, 0xC038, 0xB890, 0x6AE1,
+        0xB890, 0x8E6B, 0xB890, 0xA767, 0xB890, 0x01EF, 0xB890, 0x5A63,
+        0xB890, 0x2B99, 0xB890, 0x7F5D, 0xB890, 0x361F, 0xB890, 0xA127,
+        0xB890, 0xB558, 0xB890, 0x11C3, 0xB890, 0x7D85, 0xB890, 0xBAC5,
+        0xB890, 0xE691, 0xB890, 0x8F79, 0xB890, 0x3164, 0xB890, 0x3293,
+        0xB890, 0xB80D, 0xB890, 0xE2B7, 0xB890, 0x0D62, 0xB890, 0x4F85,
+        0xB890, 0xC919, 0xB890, 0x78F3, 0xB890, 0x77FF, 0xB890, 0xBD9E,
+        0xB890, 0x69D6, 0xB890, 0x6DA4, 0xB890, 0x0CC5, 0xB88E, 0xC1D2,
+        0xB890, 0x2425, 0xB890, 0x2627, 0xB890, 0x2829, 0xB890, 0x2A2B,
+        0xB890, 0x2C2D, 0xB890, 0x2E2F, 0xB890, 0x3031, 0xB890, 0x3233,
+        0xB890, 0x2323, 0xB890, 0x2424, 0xB890, 0x2525, 0xB890, 0x2626,
+        0xB890, 0x2727, 0xB890, 0x2828, 0xB890, 0x2929, 0xB890, 0x2A2A,
+        0xB890, 0x2B2C, 0xB890, 0x2C2D, 0xB890, 0x2D2E, 0xB890, 0x2E2F,
+        0xB890, 0x2F30, 0xB890, 0x1A1B, 0xB890, 0x1D1E, 0xB890, 0x1F20,
+        0xB890, 0x2123, 0xB890, 0x2425, 0xB890, 0x2628, 0xB890, 0x292A,
+        0xB890, 0x2B2C, 0xB890, 0x2E12, 0xB88E, 0xC09A, 0xB890, 0xD3D3,
+        0xB890, 0xD3D3, 0xB890, 0xD3D3, 0xB890, 0xD3D3, 0xB890, 0xD3D3,
+        0xB890, 0xD3D3, 0xB890, 0xD3D3, 0xB890, 0xD3D3, 0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8126a_2_1[] = {
+        0xa436, 0x8023, 0xa438, 0x4700, 0xa436, 0xB82E, 0xa438, 0x0001,
+        0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x8025, 0xa438, 0x1800, 0xa438, 0x8033,
+        0xa438, 0x1800, 0xa438, 0x8037, 0xa438, 0x1800, 0xa438, 0x803c,
+        0xa438, 0x1800, 0xa438, 0x8044, 0xa438, 0x1800, 0xa438, 0x8054,
+        0xa438, 0x1800, 0xa438, 0x8059, 0xa438, 0xd504, 0xa438, 0xc9b5,
+        0xa438, 0xd500, 0xa438, 0xd707, 0xa438, 0x4070, 0xa438, 0x1800,
+        0xa438, 0x107a, 0xa438, 0xd504, 0xa438, 0xc994, 0xa438, 0xd500,
+        0xa438, 0xd707, 0xa438, 0x60d0, 0xa438, 0xd701, 0xa438, 0x252d,
+        0xa438, 0x8023, 0xa438, 0x1800, 0xa438, 0x1064, 0xa438, 0x1800,
+        0xa438, 0x107a, 0xa438, 0x1800, 0xa438, 0x1052, 0xa438, 0xd504,
+        0xa438, 0xc9d0, 0xa438, 0xd500, 0xa438, 0xd707, 0xa438, 0x60d0,
+        0xa438, 0xd701, 0xa438, 0x252d, 0xa438, 0x8031, 0xa438, 0x1800,
+        0xa438, 0x1171, 0xa438, 0x1800, 0xa438, 0x1187, 0xa438, 0x1800,
+        0xa438, 0x116a, 0xa438, 0xc0ff, 0xa438, 0xcaff, 0xa438, 0x1800,
+        0xa438, 0x00d6, 0xa438, 0xd504, 0xa438, 0xa001, 0xa438, 0xd704,
+        0xa438, 0x1800, 0xa438, 0x128b, 0xa438, 0xd707, 0xa438, 0x2005,
+        0xa438, 0x8042, 0xa438, 0xd75e, 0xa438, 0x1800, 0xa438, 0x137a,
+        0xa438, 0x1800, 0xa438, 0x13ed, 0xa438, 0x61d0, 0xa438, 0xd701,
+        0xa438, 0x60a5, 0xa438, 0xd504, 0xa438, 0xc9b2, 0xa438, 0xd500,
+        0xa438, 0xf004, 0xa438, 0xd504, 0xa438, 0xc9b1, 0xa438, 0xd500,
+        0xa438, 0xd707, 0xa438, 0x6070, 0xa438, 0x1800, 0xa438, 0x10a8,
+        0xa438, 0x1800, 0xa438, 0x10bd, 0xa438, 0xd500, 0xa438, 0xc492,
+        0xa438, 0xd501, 0xa438, 0x1800, 0xa438, 0x13c1, 0xa438, 0xa980,
+        0xa438, 0xd500, 0xa438, 0x1800, 0xa438, 0x143b, 0xa436, 0xA026,
+        0xa438, 0x143a, 0xa436, 0xA024, 0xa438, 0x13c0, 0xa436, 0xA022,
+        0xa438, 0x10bc, 0xa436, 0xA020, 0xa438, 0x1379, 0xa436, 0xA006,
+        0xa438, 0x128a, 0xa436, 0xA004, 0xa438, 0x00d5, 0xa436, 0xA002,
+        0xa438, 0x1182, 0xa436, 0xA000, 0xa438, 0x1075, 0xa436, 0xA008,
+        0xa438, 0xff00, 0xa436, 0xA016, 0xa438, 0x0010, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x8015, 0xa438, 0x1800, 0xa438, 0x801a,
+        0xa438, 0x1800, 0xa438, 0x801e, 0xa438, 0x1800, 0xa438, 0x8027,
+        0xa438, 0x1800, 0xa438, 0x8027, 0xa438, 0x1800, 0xa438, 0x8027,
+        0xa438, 0x1800, 0xa438, 0x8027, 0xa438, 0x0c0f, 0xa438, 0x0505,
+        0xa438, 0xba01, 0xa438, 0x1800, 0xa438, 0x015e, 0xa438, 0x0c0f,
+        0xa438, 0x0506, 0xa438, 0xba02, 0xa438, 0x1800, 0xa438, 0x017c,
+        0xa438, 0x9910, 0xa438, 0x9a03, 0xa438, 0x1800, 0xa438, 0x02d4,
+        0xa438, 0x8580, 0xa438, 0xc090, 0xa438, 0x9a03, 0xa438, 0x1000,
+        0xa438, 0x02c9, 0xa438, 0xd700, 0xa438, 0x5fa3, 0xa438, 0x1800,
+        0xa438, 0x0067, 0xa436, 0xA08E, 0xa438, 0xffff, 0xa436, 0xA08C,
+        0xa438, 0xffff, 0xa436, 0xA08A, 0xa438, 0xffff, 0xa436, 0xA088,
+        0xa438, 0xffff, 0xa436, 0xA086, 0xa438, 0x018c, 0xa436, 0xA084,
+        0xa438, 0x02d3, 0xa436, 0xA082, 0xa438, 0x017a, 0xa436, 0xA080,
+        0xa438, 0x015c, 0xa436, 0xA090, 0xa438, 0x000f, 0xa436, 0xA016,
+        0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x0000, 0xa436, 0xA014,
+        0xa438, 0x1800, 0xa438, 0x8010, 0xa438, 0x1800, 0xa438, 0x8023,
+        0xa438, 0x1800, 0xa438, 0x8313, 0xa438, 0x1800, 0xa438, 0x831a,
+        0xa438, 0x1800, 0xa438, 0x8489, 0xa438, 0x1800, 0xa438, 0x86b9,
+        0xa438, 0x1800, 0xa438, 0x86c1, 0xa438, 0x1800, 0xa438, 0x87ad,
+        0xa438, 0x1000, 0xa438, 0x124e, 0xa438, 0x9308, 0xa438, 0xb201,
+        0xa438, 0xb301, 0xa438, 0xd701, 0xa438, 0x5fe0, 0xa438, 0xd2ff,
+        0xa438, 0xb302, 0xa438, 0xd200, 0xa438, 0xb201, 0xa438, 0xb309,
+        0xa438, 0xd701, 0xa438, 0x5fe0, 0xa438, 0xd2ff, 0xa438, 0xb302,
+        0xa438, 0xd200, 0xa438, 0x1800, 0xa438, 0x0025, 0xa438, 0xd706,
+        0xa438, 0x6069, 0xa438, 0xd700, 0xa438, 0x6421, 0xa438, 0xd70c,
+        0xa438, 0x43ab, 0xa438, 0x800a, 0xa438, 0x8190, 0xa438, 0x8204,
+        0xa438, 0xa280, 0xa438, 0x8406, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa108, 0xa438, 0x9503, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x0c1f, 0xa438, 0x0f19, 0xa438, 0x9503, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd70c, 0xa438, 0x5fb3, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8f1f, 0xa438, 0x9503, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd70c, 0xa438, 0x7f33, 0xa438, 0x1000,
+        0xa438, 0x11bd, 0xa438, 0x1800, 0xa438, 0x81aa, 0xa438, 0x8710,
+        0xa438, 0xd701, 0xa438, 0x33b1, 0xa438, 0x8051, 0xa438, 0xd701,
+        0xa438, 0x60b5, 0xa438, 0xd706, 0xa438, 0x6069, 0xa438, 0x1800,
+        0xa438, 0x8056, 0xa438, 0xa00a, 0xa438, 0xa280, 0xa438, 0xa404,
+        0xa438, 0x1800, 0xa438, 0x80f3, 0xa438, 0xd173, 0xa438, 0xd04d,
+        0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0xd173, 0xa438, 0xd05d, 0xa438, 0xd10d, 0xa438, 0xd049,
+        0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0xd700, 0xa438, 0x64f5, 0xa438, 0xd700, 0xa438, 0x5ee7,
+        0xa438, 0xb920, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd71f,
+        0xa438, 0x7fb4, 0xa438, 0x9920, 0xa438, 0xcb3c, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd71f, 0xa438, 0x7d94, 0xa438, 0x6045,
+        0xa438, 0xfffa, 0xa438, 0xb820, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd71f, 0xa438, 0x7fa5, 0xa438, 0x9820, 0xa438, 0xcb3d,
+        0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x60b5,
+        0xa438, 0xd71f, 0xa438, 0x7bb4, 0xa438, 0x61b6, 0xa438, 0xfff8,
+        0xa438, 0xbb80, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd71f,
+        0xa438, 0x5fb4, 0xa438, 0x9b80, 0xa438, 0xd700, 0xa438, 0x60e7,
+        0xa438, 0xcb3f, 0xa438, 0x1800, 0xa438, 0x8094, 0xa438, 0xcb3e,
+        0xa438, 0x1800, 0xa438, 0x810f, 0xa438, 0x1800, 0xa438, 0x80f3,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xae04, 0xa438, 0x9503,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8e04, 0xa438, 0x9503, 0xa438, 0xd706, 0xa438, 0x65fe,
+        0xa438, 0x0c1f, 0xa438, 0x0d04, 0xa438, 0x8dc0, 0xa438, 0x1000,
+        0xa438, 0x11bd, 0xa438, 0xd70c, 0xa438, 0x414b, 0xa438, 0x0cc0,
+        0xa438, 0x0040, 0xa438, 0x0c03, 0xa438, 0x0102, 0xa438, 0x0ce0,
+        0xa438, 0x03e0, 0xa438, 0xccce, 0xa438, 0x1800, 0xa438, 0x80b7,
+        0xa438, 0x0cc0, 0xa438, 0x0040, 0xa438, 0x0c03, 0xa438, 0x0100,
+        0xa438, 0x0ce0, 0xa438, 0x0380, 0xa438, 0xcc9c, 0xa438, 0x8710,
+        0xa438, 0x1000, 0xa438, 0x1118, 0xa438, 0xa104, 0xa438, 0x1000,
+        0xa438, 0x112a, 0xa438, 0x8104, 0xa438, 0xa202, 0xa438, 0xa140,
+        0xa438, 0x1000, 0xa438, 0x112a, 0xa438, 0x8140, 0xa438, 0x1000,
+        0xa438, 0x1121, 0xa438, 0xaa0f, 0xa438, 0xa130, 0xa438, 0xaa2f,
+        0xa438, 0xa2d5, 0xa438, 0xa405, 0xa438, 0xa720, 0xa438, 0xa00a,
+        0xa438, 0x1800, 0xa438, 0x80f3, 0xa438, 0xd704, 0xa438, 0x3cf1,
+        0xa438, 0x80d5, 0xa438, 0x0c1f, 0xa438, 0x0d02, 0xa438, 0x1800,
+        0xa438, 0x80d7, 0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0x0cc0,
+        0xa438, 0x0d40, 0xa438, 0x1000, 0xa438, 0x11bd, 0xa438, 0x8710,
+        0xa438, 0x1000, 0xa438, 0x1118, 0xa438, 0xa108, 0xa438, 0x1000,
+        0xa438, 0x112a, 0xa438, 0x8108, 0xa438, 0xa203, 0xa438, 0x8a2f,
+        0xa438, 0xa130, 0xa438, 0x8204, 0xa438, 0xa140, 0xa438, 0x1000,
+        0xa438, 0x112a, 0xa438, 0x8140, 0xa438, 0x1000, 0xa438, 0x1121,
+        0xa438, 0xd17a, 0xa438, 0xd04b, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xa204, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fa7, 0xa438, 0xb920,
+        0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd71f, 0xa438, 0x7fb4,
+        0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd71f,
+        0xa438, 0x6125, 0xa438, 0x6054, 0xa438, 0xfffb, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fa7, 0xa438, 0x1800,
+        0xa438, 0x80f7, 0xa438, 0xb820, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd71f, 0xa438, 0x7fa5, 0xa438, 0x9820, 0xa438, 0x9b01,
+        0xa438, 0xd402, 0xa438, 0x1000, 0xa438, 0x110d, 0xa438, 0xd701,
+        0xa438, 0x33b1, 0xa438, 0x811c, 0xa438, 0xd701, 0xa438, 0x60b5,
+        0xa438, 0xd706, 0xa438, 0x6069, 0xa438, 0x1800, 0xa438, 0x811e,
+        0xa438, 0x1800, 0xa438, 0x8183, 0xa438, 0xd70c, 0xa438, 0x40ab,
+        0xa438, 0x800a, 0xa438, 0x8110, 0xa438, 0x8284, 0xa438, 0x8404,
+        0xa438, 0xa710, 0xa438, 0x8120, 0xa438, 0x8241, 0xa438, 0x1000,
+        0xa438, 0x1118, 0xa438, 0xa104, 0xa438, 0x1000, 0xa438, 0x112a,
+        0xa438, 0x8104, 0xa438, 0x1000, 0xa438, 0x1121, 0xa438, 0xaa2f,
+        0xa438, 0xd70c, 0xa438, 0x438b, 0xa438, 0xa284, 0xa438, 0xd078,
+        0xa438, 0x800a, 0xa438, 0x8110, 0xa438, 0xa284, 0xa438, 0x8404,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa108, 0xa438, 0x9503,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0c1f, 0xa438, 0x0f19,
+        0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd70c,
+        0xa438, 0x5fb3, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8f1f,
+        0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd70c,
+        0xa438, 0x7f33, 0xa438, 0x0c1f, 0xa438, 0x0d06, 0xa438, 0x8dc0,
+        0xa438, 0x1000, 0xa438, 0x11bd, 0xa438, 0x8110, 0xa438, 0xa284,
+        0xa438, 0xa404, 0xa438, 0xa00a, 0xa438, 0xd70c, 0xa438, 0x40a1,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xad10, 0xa438, 0x9503,
+        0xa438, 0xd70c, 0xa438, 0x414b, 0xa438, 0x0cc0, 0xa438, 0x0080,
+        0xa438, 0x0c03, 0xa438, 0x0102, 0xa438, 0x0ce0, 0xa438, 0x0340,
+        0xa438, 0xcc52, 0xa438, 0x1800, 0xa438, 0x816b, 0xa438, 0x80c0,
+        0xa438, 0x8103, 0xa438, 0x83e0, 0xa438, 0x8cff, 0xa438, 0xd193,
+        0xa438, 0xd047, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0x1000,
+        0xa438, 0x1193, 0xa438, 0xd700, 0xa438, 0x5f74, 0xa438, 0xa110,
+        0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0x1000, 0xa438, 0x1193,
+        0xa438, 0xd700, 0xa438, 0x5f6a, 0xa438, 0xa180, 0xa438, 0xd1f5,
+        0xa438, 0xd049, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0x1000,
+        0xa438, 0x1193, 0xa438, 0xd700, 0xa438, 0x5f74, 0xa438, 0x8710,
+        0xa438, 0xa00a, 0xa438, 0x8190, 0xa438, 0x8204, 0xa438, 0xa280,
+        0xa438, 0xa404, 0xa438, 0xbb80, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd71f, 0xa438, 0x5fb4, 0xa438, 0xb920, 0xa438, 0x9b80,
+        0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd71f, 0xa438, 0x7fb4,
+        0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xcb33,
+        0xa438, 0xd71f, 0xa438, 0x6105, 0xa438, 0x5f74, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fa7, 0xa438, 0x1800,
+        0xa438, 0x818e, 0xa438, 0xa710, 0xa438, 0xb820, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd71f, 0xa438, 0x7f65, 0xa438, 0x9820,
+        0xa438, 0x1800, 0xa438, 0x81f1, 0xa438, 0x0c1f, 0xa438, 0x0d04,
+        0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x11bd, 0xa438, 0xa00a,
+        0xa438, 0x8280, 0xa438, 0xa710, 0xa438, 0xd103, 0xa438, 0xd04c,
+        0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0x0c1f, 0xa438, 0x0d06, 0xa438, 0x8dc0, 0xa438, 0x1000,
+        0xa438, 0x11bd, 0xa438, 0x8710, 0xa438, 0xa190, 0xa438, 0xa204,
+        0xa438, 0x8280, 0xa438, 0xa404, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd700, 0xa438, 0x5fa7, 0xa438, 0xa00a, 0xa438, 0xa110,
+        0xa438, 0xa284, 0xa438, 0xa404, 0xa438, 0xcb33, 0xa438, 0xd71f,
+        0xa438, 0x5f54, 0xa438, 0xb920, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd71f, 0xa438, 0x7fb4, 0xa438, 0x9920, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd71f, 0xa438, 0x6145, 0xa438, 0x6074,
+        0xa438, 0x1800, 0xa438, 0x81d3, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd700, 0xa438, 0x5fa7, 0xa438, 0x1800, 0xa438, 0x81cd,
+        0xa438, 0xb820, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd71f,
+        0xa438, 0x7fa5, 0xa438, 0xa710, 0xa438, 0x9820, 0xa438, 0xbb20,
+        0xa438, 0x9308, 0xa438, 0xb210, 0xa438, 0xb301, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd701, 0xa438, 0x5fa4, 0xa438, 0xb302,
+        0xa438, 0x9210, 0xa438, 0xa00a, 0xa438, 0xa190, 0xa438, 0xa284,
+        0xa438, 0xa404, 0xa438, 0xcb34, 0xa438, 0xd701, 0xa438, 0x33b1,
+        0xa438, 0x823f, 0xa438, 0xd706, 0xa438, 0x60a9, 0xa438, 0xd1f5,
+        0xa438, 0xd049, 0xa438, 0x1800, 0xa438, 0x8201, 0xa438, 0xd13c,
+        0xa438, 0xd04a, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0x1000,
+        0xa438, 0x1193, 0xa438, 0xd700, 0xa438, 0x5f74, 0xa438, 0xd700,
+        0xa438, 0x5f2b, 0xa438, 0x0c1f, 0xa438, 0x0d03, 0xa438, 0x8dc0,
+        0xa438, 0x1000, 0xa438, 0x11bd, 0xa438, 0x8190, 0xa438, 0x8204,
+        0xa438, 0xa280, 0xa438, 0xa00a, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8304, 0xa438, 0x9503, 0xa438, 0xcb35, 0xa438, 0xd70c,
+        0xa438, 0x414b, 0xa438, 0x8280, 0xa438, 0x800a, 0xa438, 0xd411,
+        0xa438, 0x1000, 0xa438, 0x110d, 0xa438, 0x1000, 0xa438, 0x11bd,
+        0xa438, 0xa280, 0xa438, 0xa00a, 0xa438, 0xd40a, 0xa438, 0xcb36,
+        0xa438, 0x1000, 0xa438, 0x110d, 0xa438, 0xd706, 0xa438, 0x431b,
+        0xa438, 0x800a, 0xa438, 0x8180, 0xa438, 0x8280, 0xa438, 0x8404,
+        0xa438, 0xa004, 0xa438, 0x1000, 0xa438, 0x112a, 0xa438, 0x8004,
+        0xa438, 0xa001, 0xa438, 0x1000, 0xa438, 0x112a, 0xa438, 0x8001,
+        0xa438, 0x0c03, 0xa438, 0x0902, 0xa438, 0xa00a, 0xa438, 0xd14a,
+        0xa438, 0xd048, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0x1000,
+        0xa438, 0x1193, 0xa438, 0xd700, 0xa438, 0x5f74, 0xa438, 0x0c1f,
+        0xa438, 0x0d06, 0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x11bd,
+        0xa438, 0xd70c, 0xa438, 0x414b, 0xa438, 0x0cc0, 0xa438, 0x0080,
+        0xa438, 0x0c03, 0xa438, 0x0101, 0xa438, 0x0ce0, 0xa438, 0x03a0,
+        0xa438, 0xccb5, 0xa438, 0x1800, 0xa438, 0x8256, 0xa438, 0x0cc0,
+        0xa438, 0x0000, 0xa438, 0x0c03, 0xa438, 0x0101, 0xa438, 0x0ce0,
+        0xa438, 0x0320, 0xa438, 0xcc21, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x0c30, 0xa438, 0x0120, 0xa438, 0xa304, 0xa438, 0x9503,
+        0xa438, 0xd70c, 0xa438, 0x674b, 0xa438, 0xd704, 0xa438, 0x471a,
+        0xa438, 0xa301, 0xa438, 0x800a, 0xa438, 0xa110, 0xa438, 0x8180,
+        0xa438, 0xa204, 0xa438, 0x82a0, 0xa438, 0xa404, 0xa438, 0xaa40,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xaa01, 0xa438, 0x9503,
+        0xa438, 0xd178, 0xa438, 0xd049, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0x1000, 0xa438, 0x1193, 0xa438, 0xd700, 0xa438, 0x5f74,
+        0xa438, 0x8301, 0xa438, 0xa00a, 0xa438, 0x8110, 0xa438, 0xa180,
+        0xa438, 0xa284, 0xa438, 0x8220, 0xa438, 0xa404, 0xa438, 0xd178,
+        0xa438, 0xd048, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0x1000,
+        0xa438, 0x1193, 0xa438, 0xd700, 0xa438, 0x5f74, 0xa438, 0xcb3a,
+        0xa438, 0x8301, 0xa438, 0xa00a, 0xa438, 0xa190, 0xa438, 0xa280,
+        0xa438, 0x8224, 0xa438, 0xa404, 0xa438, 0xd700, 0xa438, 0x6041,
+        0xa438, 0xa402, 0xa438, 0xd178, 0xa438, 0xd049, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0x1000, 0xa438, 0x1193, 0xa438, 0xd700,
+        0xa438, 0x5f74, 0xa438, 0x1800, 0xa438, 0x82ab, 0xa438, 0xa00a,
+        0xa438, 0xa190, 0xa438, 0xa2a4, 0xa438, 0xa404, 0xa438, 0xd700,
+        0xa438, 0x6041, 0xa438, 0xa402, 0xa438, 0xcb37, 0xa438, 0xd706,
+        0xa438, 0x60a9, 0xa438, 0xd13d, 0xa438, 0xd04a, 0xa438, 0x1800,
+        0xa438, 0x82a7, 0xa438, 0xd13c, 0xa438, 0xd04b, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0x1000, 0xa438, 0x1193, 0xa438, 0xd700,
+        0xa438, 0x5f6b, 0xa438, 0x0c1f, 0xa438, 0x0d07, 0xa438, 0x8dc0,
+        0xa438, 0x1000, 0xa438, 0x11bd, 0xa438, 0xd40d, 0xa438, 0x1000,
+        0xa438, 0x110d, 0xa438, 0xa208, 0xa438, 0x8204, 0xa438, 0xaa40,
+        0xa438, 0xcb38, 0xa438, 0xd706, 0xa438, 0x6129, 0xa438, 0xd70c,
+        0xa438, 0x608b, 0xa438, 0xd17a, 0xa438, 0xd047, 0xa438, 0xf006,
+        0xa438, 0xd13d, 0xa438, 0xd04b, 0xa438, 0xf003, 0xa438, 0xd196,
+        0xa438, 0xd04b, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0x1000,
+        0xa438, 0x1193, 0xa438, 0xd700, 0xa438, 0x5f74, 0xa438, 0xd704,
+        0xa438, 0x35ac, 0xa438, 0x8311, 0xa438, 0x0cc0, 0xa438, 0x0000,
+        0xa438, 0x0c03, 0xa438, 0x0101, 0xa438, 0x0ce0, 0xa438, 0x0320,
+        0xa438, 0xcc21, 0xa438, 0x0c1f, 0xa438, 0x0d03, 0xa438, 0x8dc0,
+        0xa438, 0x1000, 0xa438, 0x11bd, 0xa438, 0x0cc0, 0xa438, 0x0000,
+        0xa438, 0x0c07, 0xa438, 0x0c07, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa280, 0xa438, 0x8780, 0xa438, 0x0c60, 0xa438, 0x0700,
+        0xa438, 0x9503, 0xa438, 0xd704, 0xa438, 0x409c, 0xa438, 0xd110,
+        0xa438, 0xd04d, 0xa438, 0xf003, 0xa438, 0xd110, 0xa438, 0xd04d,
+        0xa438, 0xcb4a, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa240,
+        0xa438, 0xa180, 0xa438, 0xa201, 0xa438, 0xa780, 0xa438, 0x9503,
+        0xa438, 0xd114, 0xa438, 0xd04a, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0xcb4b, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x1800,
+        0xa438, 0x0bc3, 0xa438, 0x1800, 0xa438, 0x0bc3, 0xa438, 0x1000,
+        0xa438, 0x110d, 0xa438, 0xd419, 0xa438, 0x1000, 0xa438, 0x110d,
+        0xa438, 0x1800, 0xa438, 0x01ae, 0xa438, 0x8110, 0xa438, 0xa180,
+        0xa438, 0x8280, 0xa438, 0xa404, 0xa438, 0xa00a, 0xa438, 0x8402,
+        0xa438, 0xcb42, 0xa438, 0xd706, 0xa438, 0x3de9, 0xa438, 0x837a,
+        0xa438, 0xd704, 0xa438, 0x35ac, 0xa438, 0x8380, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fab, 0xa438, 0x0c1f,
+        0xa438, 0x0d06, 0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x11bd,
+        0xa438, 0xd418, 0xa438, 0x1000, 0xa438, 0x110d, 0xa438, 0x0c1f,
+        0xa438, 0x0d03, 0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x11bd,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa780, 0xa438, 0xa20e,
+        0xa438, 0x9503, 0xa438, 0xd704, 0xa438, 0x409c, 0xa438, 0xd114,
+        0xa438, 0xd04d, 0xa438, 0xf003, 0xa438, 0xd114, 0xa438, 0xd04d,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa003, 0xa438, 0x9503,
+        0xa438, 0xcb4c, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0c60,
+        0xa438, 0x0720, 0xa438, 0xa220, 0xa438, 0x9503, 0xa438, 0xcb4d,
+        0xa438, 0xd704, 0xa438, 0x409c, 0xa438, 0xd128, 0xa438, 0xd04f,
+        0xa438, 0xf003, 0xa438, 0xd128, 0xa438, 0xd04f, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x0c60, 0xa438, 0x0740, 0xa438, 0xa210,
+        0xa438, 0x9503, 0xa438, 0xd704, 0xa438, 0x409c, 0xa438, 0xd114,
+        0xa438, 0xd04e, 0xa438, 0xf003, 0xa438, 0xd114, 0xa438, 0xd04e,
+        0xa438, 0xcb4e, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0x0c1f, 0xa438, 0x0d06, 0xa438, 0x8dc0,
+        0xa438, 0x1000, 0xa438, 0x11bd, 0xa438, 0x0cc0, 0xa438, 0x0000,
+        0xa438, 0x0c07, 0xa438, 0x0c01, 0xa438, 0xd704, 0xa438, 0x40b5,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa23c, 0xa438, 0x9503,
+        0xa438, 0xb920, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd71f,
+        0xa438, 0x7fb4, 0xa438, 0x8710, 0xa438, 0x9920, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd71f, 0xa438, 0x6105, 0xa438, 0x6054,
+        0xa438, 0xfffb, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd700,
+        0xa438, 0x5fa7, 0xa438, 0xffef, 0xa438, 0xa710, 0xa438, 0xb820,
+        0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd71f, 0xa438, 0x7fa5,
+        0xa438, 0x9820, 0xa438, 0xa00a, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa103, 0xa438, 0x9503, 0xa438, 0xbb20, 0xa438, 0xd706,
+        0xa438, 0x60dd, 0xa438, 0x0c1f, 0xa438, 0x0d07, 0xa438, 0x8dc0,
+        0xa438, 0x1000, 0xa438, 0x11bd, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x0c30, 0xa438, 0x0120, 0xa438, 0xa304, 0xa438, 0x9503,
+        0xa438, 0xa190, 0xa438, 0xa2a0, 0xa438, 0xa404, 0xa438, 0xa00a,
+        0xa438, 0xa604, 0xa438, 0xd700, 0xa438, 0x6041, 0xa438, 0xa402,
+        0xa438, 0xcb43, 0xa438, 0xd17a, 0xa438, 0xd048, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0x1000, 0xa438, 0x1193, 0xa438, 0xd700,
+        0xa438, 0x5f74, 0xa438, 0x609d, 0xa438, 0xd417, 0xa438, 0x1000,
+        0xa438, 0x110d, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0x1000,
+        0xa438, 0x1193, 0xa438, 0xd700, 0xa438, 0x5f7a, 0xa438, 0xd704,
+        0xa438, 0x5f36, 0xa438, 0xd706, 0xa438, 0x6089, 0xa438, 0xd40c,
+        0xa438, 0x1000, 0xa438, 0x110d, 0xa438, 0xaa40, 0xa438, 0xbb10,
+        0xa438, 0xcb50, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0x1000,
+        0xa438, 0x1193, 0xa438, 0xd71f, 0xa438, 0x5f75, 0xa438, 0x8190,
+        0xa438, 0x82a0, 0xa438, 0x8402, 0xa438, 0xa404, 0xa438, 0x800a,
+        0xa438, 0x8718, 0xa438, 0x9b10, 0xa438, 0x9b20, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd71f, 0xa438, 0x7fb5, 0xa438, 0xcb51,
+        0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd71f, 0xa438, 0x5f94,
+        0xa438, 0xd706, 0xa438, 0x6089, 0xa438, 0xd141, 0xa438, 0xd043,
+        0xa438, 0xf003, 0xa438, 0xd141, 0xa438, 0xd044, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xd700,
+        0xa438, 0x60e5, 0xa438, 0xd704, 0xa438, 0x60be, 0xa438, 0xd706,
+        0xa438, 0x29b1, 0xa438, 0x83fb, 0xa438, 0xf002, 0xa438, 0xa880,
+        0xa438, 0xa00a, 0xa438, 0xa190, 0xa438, 0x8220, 0xa438, 0xa280,
+        0xa438, 0xa404, 0xa438, 0xa620, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xc5aa, 0xa438, 0x9503, 0xa438, 0xd700, 0xa438, 0x6061,
+        0xa438, 0xa402, 0xa438, 0xa480, 0xa438, 0xcb52, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fba, 0xa438, 0xd704,
+        0xa438, 0x5f76, 0xa438, 0xb920, 0xa438, 0xcb53, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd71f, 0xa438, 0x7fb4, 0xa438, 0x9920,
+        0xa438, 0xa00a, 0xa438, 0xa190, 0xa438, 0xa280, 0xa438, 0x8220,
+        0xa438, 0xa404, 0xa438, 0xb580, 0xa438, 0xd700, 0xa438, 0x40a1,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa602, 0xa438, 0x9503,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa310, 0xa438, 0x9503,
+        0xa438, 0xcb60, 0xa438, 0xd1c8, 0xa438, 0xd045, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xaa10,
+        0xa438, 0xd70c, 0xa438, 0x2833, 0xa438, 0x8434, 0xa438, 0xf003,
+        0xa438, 0x1000, 0xa438, 0x1238, 0xa438, 0xd70c, 0xa438, 0x40a6,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa140, 0xa438, 0x9503,
+        0xa438, 0xd70c, 0xa438, 0x40a3, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xac20, 0xa438, 0x9503, 0xa438, 0xa90c, 0xa438, 0xaa80,
+        0xa438, 0x0c1f, 0xa438, 0x0d07, 0xa438, 0x8dc0, 0xa438, 0x1000,
+        0xa438, 0x11bd, 0xa438, 0xa00a, 0xa438, 0xa190, 0xa438, 0xa280,
+        0xa438, 0x8220, 0xa438, 0xa404, 0xa438, 0xb580, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xc500, 0xa438, 0x9503, 0xa438, 0x83e0,
+        0xa438, 0xd700, 0xa438, 0x40c1, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa602, 0xa438, 0x9503, 0xa438, 0x8e01, 0xa438, 0xd14a,
+        0xa438, 0xd058, 0xa438, 0xd70c, 0xa438, 0x4063, 0xa438, 0x1000,
+        0xa438, 0x11f2, 0xa438, 0xcb62, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd704, 0xa438, 0x2e70, 0xa438, 0x8479, 0xa438, 0xd71f,
+        0xa438, 0x626e, 0xa438, 0xd704, 0xa438, 0x3868, 0xa438, 0x847d,
+        0xa438, 0xd70c, 0xa438, 0x2f18, 0xa438, 0x8483, 0xa438, 0xd700,
+        0xa438, 0x5db5, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xc5aa,
+        0xa438, 0x9503, 0xa438, 0x0ce0, 0xa438, 0x0320, 0xa438, 0x1800,
+        0xa438, 0x0d6f, 0xa438, 0x1800, 0xa438, 0x0f15, 0xa438, 0x1800,
+        0xa438, 0x0dae, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xc5aa,
+        0xa438, 0x9503, 0xa438, 0x1800, 0xa438, 0x0fc9, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xc5aa, 0xa438, 0x9503, 0xa438, 0x1800,
+        0xa438, 0x0d84, 0xa438, 0x1000, 0xa438, 0x16e5, 0xa438, 0xd70c,
+        0xa438, 0x5fa4, 0xa438, 0xa706, 0xa438, 0xd70c, 0xa438, 0x408b,
+        0xa438, 0xa701, 0xa438, 0xa502, 0xa438, 0xa880, 0xa438, 0x8801,
+        0xa438, 0x8e01, 0xa438, 0xca50, 0xa438, 0x1000, 0xa438, 0x852e,
+        0xa438, 0xca51, 0xa438, 0xd70e, 0xa438, 0x2210, 0xa438, 0x852c,
+        0xa438, 0xd70c, 0xa438, 0x4084, 0xa438, 0xd705, 0xa438, 0x5efd,
+        0xa438, 0xf007, 0xa438, 0x1000, 0xa438, 0x16e9, 0xa438, 0xd70c,
+        0xa438, 0x5ca2, 0xa438, 0x1800, 0xa438, 0x15b2, 0xa438, 0xd70c,
+        0xa438, 0x605a, 0xa438, 0x9a10, 0xa438, 0x8e40, 0xa438, 0x8404,
+        0xa438, 0x1000, 0xa438, 0x174e, 0xa438, 0x8e80, 0xa438, 0xca62,
+        0xa438, 0xd705, 0xa438, 0x3084, 0xa438, 0x850e, 0xa438, 0xba10,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x1000, 0xa438, 0x8608,
+        0xa438, 0x0c03, 0xa438, 0x0100, 0xa438, 0xd702, 0xa438, 0x4638,
+        0xa438, 0xd1c4, 0xa438, 0xd044, 0xa438, 0x1000, 0xa438, 0x16e5,
+        0xa438, 0x1000, 0xa438, 0x170f, 0xa438, 0xd70c, 0xa438, 0x5f7c,
+        0xa438, 0x8108, 0xa438, 0x0c1f, 0xa438, 0x0907, 0xa438, 0x8940,
+        0xa438, 0x1000, 0xa438, 0x1702, 0xa438, 0xa0c4, 0xa438, 0x8610,
+        0xa438, 0x8030, 0xa438, 0x8706, 0xa438, 0x0c07, 0xa438, 0x0b06,
+        0xa438, 0x8410, 0xa438, 0xa980, 0xa438, 0xa702, 0xa438, 0xd1c4,
+        0xa438, 0xd045, 0xa438, 0x1000, 0xa438, 0x16e5, 0xa438, 0x1000,
+        0xa438, 0x170f, 0xa438, 0xd70c, 0xa438, 0x5f7c, 0xa438, 0x0c07,
+        0xa438, 0x0b06, 0xa438, 0xa030, 0xa438, 0xa610, 0xa438, 0xd700,
+        0xa438, 0x6041, 0xa438, 0xa501, 0xa438, 0xa108, 0xa438, 0xd1c4,
+        0xa438, 0xd045, 0xa438, 0xca63, 0xa438, 0x1000, 0xa438, 0x16e5,
+        0xa438, 0x1000, 0xa438, 0x170f, 0xa438, 0xd70c, 0xa438, 0x5f7c,
+        0xa438, 0xd702, 0xa438, 0x6078, 0xa438, 0x9920, 0xa438, 0xf003,
+        0xa438, 0xb920, 0xa438, 0xa880, 0xa438, 0x9a10, 0xa438, 0x1000,
+        0xa438, 0x16e5, 0xa438, 0x1000, 0xa438, 0x170f, 0xa438, 0xd71f,
+        0xa438, 0x5f73, 0xa438, 0xf011, 0xa438, 0xd70c, 0xa438, 0x409b,
+        0xa438, 0x9920, 0xa438, 0x9a10, 0xa438, 0xfff5, 0xa438, 0x80fe,
+        0xa438, 0x8610, 0xa438, 0x8501, 0xa438, 0x8980, 0xa438, 0x8702,
+        0xa438, 0xa410, 0xa438, 0xa940, 0xa438, 0x81c0, 0xa438, 0xae80,
+        0xa438, 0x1800, 0xa438, 0x84b3, 0xa438, 0x8804, 0xa438, 0xa704,
+        0xa438, 0x8788, 0xa438, 0xff80, 0xa438, 0xbb08, 0xa438, 0x0c1f,
+        0xa438, 0x0907, 0xa438, 0x8940, 0xa438, 0x1000, 0xa438, 0x1702,
+        0xa438, 0x8701, 0xa438, 0x8502, 0xa438, 0xa0f4, 0xa438, 0xa610,
+        0xa438, 0xd700, 0xa438, 0x6061, 0xa438, 0xa002, 0xa438, 0xa501,
+        0xa438, 0x8706, 0xa438, 0x8410, 0xa438, 0xa980, 0xa438, 0xca64,
+        0xa438, 0xd110, 0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x16e5,
+        0xa438, 0x1000, 0xa438, 0x170f, 0xa438, 0xd70c, 0xa438, 0x5f7c,
+        0xa438, 0x8804, 0xa438, 0xa706, 0xa438, 0x1800, 0xa438, 0x848d,
+        0xa438, 0x1800, 0xa438, 0x1384, 0xa438, 0xd705, 0xa438, 0x405f,
+        0xa438, 0xf036, 0xa438, 0xd705, 0xa438, 0x6234, 0xa438, 0xd70c,
+        0xa438, 0x41c6, 0xa438, 0xd70d, 0xa438, 0x419d, 0xa438, 0xd70d,
+        0xa438, 0x417e, 0xa438, 0xd704, 0xa438, 0x6127, 0xa438, 0x2951,
+        0xa438, 0x8543, 0xa438, 0xd70c, 0xa438, 0x4083, 0xa438, 0xd70c,
+        0xa438, 0x2e81, 0xa438, 0x8543, 0xa438, 0xf0c5, 0xa438, 0x80fe,
+        0xa438, 0x8610, 0xa438, 0x8501, 0xa438, 0x8704, 0xa438, 0x0c30,
+        0xa438, 0x0410, 0xa438, 0xa701, 0xa438, 0xac02, 0xa438, 0xa502,
+        0xa438, 0x8980, 0xa438, 0xca60, 0xa438, 0xa004, 0xa438, 0xd70c,
+        0xa438, 0x6065, 0xa438, 0x1800, 0xa438, 0x8554, 0xa438, 0x8004,
+        0xa438, 0xa804, 0xa438, 0x0c0f, 0xa438, 0x0602, 0xa438, 0x0c70,
+        0xa438, 0x0730, 0xa438, 0xa708, 0xa438, 0xd704, 0xa438, 0x609c,
+        0xa438, 0x0c1f, 0xa438, 0x0912, 0xa438, 0xf003, 0xa438, 0x0c1f,
+        0xa438, 0x090e, 0xa438, 0xa940, 0xa438, 0x1000, 0xa438, 0x1702,
+        0xa438, 0xa780, 0xa438, 0xf0a2, 0xa438, 0xd704, 0xa438, 0x63eb,
+        0xa438, 0xd705, 0xa438, 0x43b1, 0xa438, 0xd702, 0xa438, 0x339c,
+        0xa438, 0x8607, 0xa438, 0x8788, 0xa438, 0x8704, 0xa438, 0x0c1f,
+        0xa438, 0x0907, 0xa438, 0x8940, 0xa438, 0x1000, 0xa438, 0x1702,
+        0xa438, 0x8410, 0xa438, 0xa0f4, 0xa438, 0xa610, 0xa438, 0xd700,
+        0xa438, 0x6061, 0xa438, 0xa002, 0xa438, 0xa501, 0xa438, 0xa706,
+        0xa438, 0x8804, 0xa438, 0xa980, 0xa438, 0xd70c, 0xa438, 0x6085,
+        0xa438, 0x8701, 0xa438, 0x8502, 0xa438, 0x8c02, 0xa438, 0xa701,
+        0xa438, 0xa502, 0xa438, 0xf082, 0xa438, 0xd70c, 0xa438, 0x60c5,
+        0xa438, 0xd702, 0xa438, 0x6053, 0xa438, 0xf07d, 0xa438, 0x1800,
+        0xa438, 0x8604, 0xa438, 0xd70d, 0xa438, 0x4d1b, 0xa438, 0xba10,
+        0xa438, 0xae40, 0xa438, 0x0cfc, 0xa438, 0x03b4, 0xa438, 0x0cfc,
+        0xa438, 0x05b4, 0xa438, 0xd1c4, 0xa438, 0xd044, 0xa438, 0x1000,
+        0xa438, 0x16e5, 0xa438, 0x1000, 0xa438, 0x170f, 0xa438, 0xd70c,
+        0xa438, 0x5f7c, 0xa438, 0x8706, 0xa438, 0x8280, 0xa438, 0xace0,
+        0xa438, 0xa680, 0xa438, 0xa240, 0xa438, 0x1000, 0xa438, 0x16e5,
+        0xa438, 0x1000, 0xa438, 0x170f, 0xa438, 0xd702, 0xa438, 0x5f79,
+        0xa438, 0x8240, 0xa438, 0xd702, 0xa438, 0x6898, 0xa438, 0xd702,
+        0xa438, 0x4957, 0xa438, 0x1800, 0xa438, 0x85f6, 0xa438, 0xa1c0,
+        0xa438, 0x0c3f, 0xa438, 0x0220, 0xa438, 0x0cfc, 0xa438, 0x030c,
+        0xa438, 0x0cfc, 0xa438, 0x050c, 0xa438, 0x8108, 0xa438, 0x8640,
+        0xa438, 0xa120, 0xa438, 0xa640, 0xa438, 0x0c03, 0xa438, 0x0101,
+        0xa438, 0xa110, 0xa438, 0xd1c4, 0xa438, 0xd044, 0xa438, 0xca84,
+        0xa438, 0x1000, 0xa438, 0x16e5, 0xa438, 0x1000, 0xa438, 0x170f,
+        0xa438, 0xd70c, 0xa438, 0x5f7c, 0xa438, 0xd702, 0xa438, 0x60fc,
+        0xa438, 0x8210, 0xa438, 0x0ce0, 0xa438, 0x0320, 0xa438, 0x0ce0,
+        0xa438, 0x0520, 0xa438, 0xf002, 0xa438, 0xa210, 0xa438, 0xd1c4,
+        0xa438, 0xd043, 0xa438, 0x1000, 0xa438, 0x16e5, 0xa438, 0x1000,
+        0xa438, 0x170f, 0xa438, 0xd70c, 0xa438, 0x5f7c, 0xa438, 0x8233,
+        0xa438, 0x0cfc, 0xa438, 0x036c, 0xa438, 0x0cfc, 0xa438, 0x056c,
+        0xa438, 0xd1c4, 0xa438, 0xd044, 0xa438, 0xca85, 0xa438, 0x1000,
+        0xa438, 0x16e5, 0xa438, 0x1000, 0xa438, 0x170f, 0xa438, 0xd70c,
+        0xa438, 0x5f7c, 0xa438, 0xa680, 0xa438, 0xa240, 0xa438, 0x1000,
+        0xa438, 0x16e5, 0xa438, 0x1000, 0xa438, 0x170f, 0xa438, 0xd702,
+        0xa438, 0x5f79, 0xa438, 0x8240, 0xa438, 0x0cfc, 0xa438, 0x0390,
+        0xa438, 0x0cfc, 0xa438, 0x0590, 0xa438, 0xd702, 0xa438, 0x6058,
+        0xa438, 0xf002, 0xa438, 0xfec7, 0xa438, 0x81c0, 0xa438, 0x8880,
+        0xa438, 0x8706, 0xa438, 0xca61, 0xa438, 0xd1c4, 0xa438, 0xd054,
+        0xa438, 0x1000, 0xa438, 0x16e5, 0xa438, 0x1000, 0xa438, 0x170f,
+        0xa438, 0xd70c, 0xa438, 0x5f7d, 0xa438, 0xa706, 0xa438, 0xf004,
+        0xa438, 0x8788, 0xa438, 0xa404, 0xa438, 0x8702, 0xa438, 0x0800,
+        0xa438, 0x8443, 0xa438, 0x8303, 0xa438, 0x8280, 0xa438, 0x9920,
+        0xa438, 0x8ce0, 0xa438, 0x8004, 0xa438, 0xa1c0, 0xa438, 0xd70e,
+        0xa438, 0x404a, 0xa438, 0xa280, 0xa438, 0xd702, 0xa438, 0x3bd0,
+        0xa438, 0x8618, 0xa438, 0x0c3f, 0xa438, 0x0223, 0xa438, 0xf003,
+        0xa438, 0x0c3f, 0xa438, 0x0220, 0xa438, 0x0cfc, 0xa438, 0x0308,
+        0xa438, 0x0cfc, 0xa438, 0x0508, 0xa438, 0x8108, 0xa438, 0x8640,
+        0xa438, 0xa120, 0xa438, 0xa640, 0xa438, 0xd702, 0xa438, 0x6077,
+        0xa438, 0x8103, 0xa438, 0xf003, 0xa438, 0x0c03, 0xa438, 0x0101,
+        0xa438, 0xa110, 0xa438, 0xd702, 0xa438, 0x6077, 0xa438, 0xa108,
+        0xa438, 0xf006, 0xa438, 0xd704, 0xa438, 0x6077, 0xa438, 0x8108,
+        0xa438, 0xf002, 0xa438, 0xa108, 0xa438, 0xd193, 0xa438, 0xd045,
+        0xa438, 0xca82, 0xa438, 0x1000, 0xa438, 0x16e5, 0xa438, 0xd70e,
+        0xa438, 0x606a, 0xa438, 0x1000, 0xa438, 0x170f, 0xa438, 0xd70c,
+        0xa438, 0x5f3c, 0xa438, 0xd702, 0xa438, 0x60fc, 0xa438, 0x8210,
+        0xa438, 0x0ce0, 0xa438, 0x0320, 0xa438, 0x0ce0, 0xa438, 0x0520,
+        0xa438, 0xf002, 0xa438, 0xa210, 0xa438, 0xd1c4, 0xa438, 0xd043,
+        0xa438, 0x1000, 0xa438, 0x16e5, 0xa438, 0xd70e, 0xa438, 0x606a,
+        0xa438, 0x1000, 0xa438, 0x170f, 0xa438, 0xd70c, 0xa438, 0x5f3c,
+        0xa438, 0xd702, 0xa438, 0x3bd0, 0xa438, 0x8656, 0xa438, 0x0c3f,
+        0xa438, 0x020c, 0xa438, 0xf002, 0xa438, 0x823f, 0xa438, 0x0cfc,
+        0xa438, 0x034c, 0xa438, 0x0cfc, 0xa438, 0x054c, 0xa438, 0xd1c4,
+        0xa438, 0xd044, 0xa438, 0x1000, 0xa438, 0x16e5, 0xa438, 0xd70e,
+        0xa438, 0x606a, 0xa438, 0x1000, 0xa438, 0x170f, 0xa438, 0xd70c,
+        0xa438, 0x5f3c, 0xa438, 0x820c, 0xa438, 0xa360, 0xa438, 0xa560,
+        0xa438, 0xd1c4, 0xa438, 0xd043, 0xa438, 0xca83, 0xa438, 0x1000,
+        0xa438, 0x16e5, 0xa438, 0xd70e, 0xa438, 0x606a, 0xa438, 0x1000,
+        0xa438, 0x170f, 0xa438, 0xd70c, 0xa438, 0x5f3c, 0xa438, 0xd70e,
+        0xa438, 0x406a, 0xa438, 0x8680, 0xa438, 0xf002, 0xa438, 0xa680,
+        0xa438, 0xa240, 0xa438, 0x0c0f, 0xa438, 0x0604, 0xa438, 0x0c70,
+        0xa438, 0x0750, 0xa438, 0xa708, 0xa438, 0xd704, 0xa438, 0x609c,
+        0xa438, 0x0c1f, 0xa438, 0x0914, 0xa438, 0xf003, 0xa438, 0x0c1f,
+        0xa438, 0x0910, 0xa438, 0xa940, 0xa438, 0x1000, 0xa438, 0x1702,
+        0xa438, 0xa780, 0xa438, 0x1000, 0xa438, 0x16e5, 0xa438, 0xd70e,
+        0xa438, 0x606a, 0xa438, 0x1000, 0xa438, 0x170f, 0xa438, 0xd702,
+        0xa438, 0x399c, 0xa438, 0x8689, 0xa438, 0x8240, 0xa438, 0x8788,
+        0xa438, 0xd702, 0xa438, 0x63f8, 0xa438, 0xd705, 0xa438, 0x643c,
+        0xa438, 0xa402, 0xa438, 0xf012, 0xa438, 0x8402, 0xa438, 0xd705,
+        0xa438, 0x611b, 0xa438, 0xa401, 0xa438, 0xa302, 0xa438, 0xd702,
+        0xa438, 0x417d, 0xa438, 0xa440, 0xa438, 0xa280, 0xa438, 0xf008,
+        0xa438, 0x8401, 0xa438, 0x8302, 0xa438, 0xd70c, 0xa438, 0x6060,
+        0xa438, 0xa301, 0xa438, 0xf002, 0xa438, 0x8301, 0xa438, 0xd70c,
+        0xa438, 0x4080, 0xa438, 0xd70e, 0xa438, 0x604a, 0xa438, 0xff5f,
+        0xa438, 0xd705, 0xa438, 0x3cdd, 0xa438, 0x86b8, 0xa438, 0xff5b,
+        0xa438, 0x0cfc, 0xa438, 0x0390, 0xa438, 0x0cfc, 0xa438, 0x0590,
+        0xa438, 0x0800, 0xa438, 0x0c1f, 0xa438, 0x0d00, 0xa438, 0x8dc0,
+        0xa438, 0x1000, 0xa438, 0x11bd, 0xa438, 0xa504, 0xa438, 0x1800,
+        0xa438, 0x0fd3, 0xa438, 0xd70d, 0xa438, 0x407d, 0xa438, 0xa710,
+        0xa438, 0xf002, 0xa438, 0xa710, 0xa438, 0x9580, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xa304, 0xa438, 0x9503, 0xa438, 0x0c1f,
+        0xa438, 0x0d07, 0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x11bd,
+        0xa438, 0xcb81, 0xa438, 0xd70c, 0xa438, 0x4882, 0xa438, 0xd706,
+        0xa438, 0x407a, 0xa438, 0xd70c, 0xa438, 0x4807, 0xa438, 0xd706,
+        0xa438, 0x405a, 0xa438, 0x8910, 0xa438, 0xa210, 0xa438, 0xd704,
+        0xa438, 0x611c, 0xa438, 0x0cc0, 0xa438, 0x0080, 0xa438, 0x0c03,
+        0xa438, 0x0101, 0xa438, 0x0ce0, 0xa438, 0x03a0, 0xa438, 0xccb5,
+        0xa438, 0x0cc0, 0xa438, 0x0080, 0xa438, 0x0c03, 0xa438, 0x0102,
+        0xa438, 0x0ce0, 0xa438, 0x0340, 0xa438, 0xcc52, 0xa438, 0xd706,
+        0xa438, 0x42ba, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0c1f,
+        0xa438, 0x0f1c, 0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd70c, 0xa438, 0x5fb3, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8f1f, 0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd70c, 0xa438, 0x7f33, 0xa438, 0x8190, 0xa438, 0x8204,
+        0xa438, 0xf016, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0c1f,
+        0xa438, 0x0f1b, 0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd70c, 0xa438, 0x5fb3, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8f1f, 0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd70c, 0xa438, 0x7f33, 0xa438, 0xd70c, 0xa438, 0x6047,
+        0xa438, 0xf002, 0xa438, 0xf00c, 0xa438, 0xd403, 0xa438, 0xcb82,
+        0xa438, 0x1000, 0xa438, 0x110d, 0xa438, 0xd40a, 0xa438, 0x1000,
+        0xa438, 0x110d, 0xa438, 0xd70c, 0xa438, 0x4247, 0xa438, 0x1000,
+        0xa438, 0x1225, 0xa438, 0x8a40, 0xa438, 0x1000, 0xa438, 0x1118,
+        0xa438, 0xa104, 0xa438, 0x1000, 0xa438, 0x112a, 0xa438, 0x8104,
+        0xa438, 0x1000, 0xa438, 0x1121, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa704, 0xa438, 0x9503, 0xa438, 0xcb88, 0xa438, 0xf012,
+        0xa438, 0xa210, 0xa438, 0xa00a, 0xa438, 0xaa40, 0xa438, 0x1000,
+        0xa438, 0x1118, 0xa438, 0xa104, 0xa438, 0x1000, 0xa438, 0x112a,
+        0xa438, 0x8104, 0xa438, 0x1000, 0xa438, 0x1121, 0xa438, 0xa190,
+        0xa438, 0xa284, 0xa438, 0xa404, 0xa438, 0x8a10, 0xa438, 0x8a80,
+        0xa438, 0xcb84, 0xa438, 0xd13e, 0xa438, 0xd05a, 0xa438, 0xd13e,
+        0xa438, 0xd06b, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd700,
+        0xa438, 0x3559, 0xa438, 0x874b, 0xa438, 0xfffb, 0xa438, 0xd700,
+        0xa438, 0x604b, 0xa438, 0xcb8a, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd700, 0xa438, 0x3659, 0xa438, 0x8754, 0xa438, 0xfffb,
+        0xa438, 0xd700, 0xa438, 0x606b, 0xa438, 0xcb8b, 0xa438, 0x5eeb,
+        0xa438, 0xd700, 0xa438, 0x6041, 0xa438, 0xa402, 0xa438, 0xcb8c,
+        0xa438, 0xd706, 0xa438, 0x609a, 0xa438, 0xd1f5, 0xa438, 0xd048,
+        0xa438, 0xf003, 0xa438, 0xd160, 0xa438, 0xd04b, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xcb8d,
+        0xa438, 0x8710, 0xa438, 0xd71f, 0xa438, 0x5fd4, 0xa438, 0xb920,
+        0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd71f, 0xa438, 0x7fb4,
+        0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd71f,
+        0xa438, 0x6105, 0xa438, 0x6054, 0xa438, 0xfffb, 0xa438, 0x1000,
+        0xa438, 0x1175, 0xa438, 0xd700, 0xa438, 0x5fab, 0xa438, 0xfff0,
+        0xa438, 0xa710, 0xa438, 0xb820, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd71f, 0xa438, 0x7fa5, 0xa438, 0x9820, 0xa438, 0xd114,
+        0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd700,
+        0xa438, 0x5fba, 0xa438, 0xd704, 0xa438, 0x5f76, 0xa438, 0xd700,
+        0xa438, 0x5f34, 0xa438, 0xd700, 0xa438, 0x6081, 0xa438, 0xd706,
+        0xa438, 0x405a, 0xa438, 0xa480, 0xa438, 0xcb86, 0xa438, 0xd706,
+        0xa438, 0x609a, 0xa438, 0xd1c8, 0xa438, 0xd045, 0xa438, 0xf003,
+        0xa438, 0xd17a, 0xa438, 0xd04b, 0xa438, 0x1000, 0xa438, 0x1175,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x0cc0, 0xa438, 0x0000,
+        0xa438, 0x0c03, 0xa438, 0x0101, 0xa438, 0x0ce0, 0xa438, 0x0320,
+        0xa438, 0xcc29, 0xa438, 0xa208, 0xa438, 0x8204, 0xa438, 0xd114,
+        0xa438, 0xd040, 0xa438, 0xd700, 0xa438, 0x5ff4, 0xa438, 0x1800,
+        0xa438, 0x0bc3, 0xa438, 0xa00a, 0xa438, 0x9308, 0xa438, 0xb210,
+        0xa438, 0xb301, 0xa438, 0x1000, 0xa438, 0x1175, 0xa438, 0xd701,
+        0xa438, 0x5fa4, 0xa438, 0xb302, 0xa438, 0x9210, 0xa438, 0x800a,
+        0xa438, 0x1800, 0xa438, 0x0573, 0xa436, 0xA10E, 0xa438, 0x0572,
+        0xa436, 0xA10C, 0xa438, 0x0e47, 0xa436, 0xA10A, 0xa438, 0x0fd2,
+        0xa436, 0xA108, 0xa438, 0x1503, 0xa436, 0xA106, 0xa438, 0x0c0d,
+        0xa436, 0xA104, 0xa438, 0x01ac, 0xa436, 0xA102, 0xa438, 0x0956,
+        0xa436, 0xA100, 0xa438, 0x001c, 0xa436, 0xA110, 0xa438, 0x00ff,
+        0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x1ff8,
+        0xa436, 0xA014, 0xa438, 0x0000, 0xa438, 0x85f0, 0xa438, 0xa2a0,
+        0xa438, 0x8880, 0xa438, 0x0d00, 0xa438, 0xc500, 0xa438, 0x800a,
+        0xa438, 0xae01, 0xa436, 0xA164, 0xa438, 0x1013, 0xa436, 0xA166,
+        0xa438, 0x1014, 0xa436, 0xA168, 0xa438, 0x0F98, 0xa436, 0xA16A,
+        0xa438, 0x0DCA, 0xa436, 0xA16C, 0xa438, 0x109B, 0xa436, 0xA16E,
+        0xa438, 0x10A2, 0xa436, 0xA170, 0xa438, 0x0F33, 0xa436, 0xA172,
+        0xa438, 0x0F6E, 0xa436, 0xA162, 0xa438, 0x00ff, 0xa436, 0xb87c,
+        0xa438, 0x8a45, 0xa436, 0xb87e, 0xa438, 0xaf8a, 0xa438, 0x5daf,
+        0xa438, 0x8a63, 0xa438, 0xaf8a, 0xa438, 0x6caf, 0xa438, 0x8a78,
+        0xa438, 0xaf8a, 0xa438, 0x87af, 0xa438, 0x8a90, 0xa438, 0xaf8a,
+        0xa438, 0x96af, 0xa438, 0x8acf, 0xa438, 0x028a, 0xa438, 0xecaf,
+        0xa438, 0x211f, 0xa438, 0x0265, 0xa438, 0xcb02, 0xa438, 0x8fb4,
+        0xa438, 0xaf21, 0xa438, 0x6fa1, 0xa438, 0x1903, 0xa438, 0x028f,
+        0xa438, 0x3d02, 0xa438, 0x2261, 0xa438, 0xaf21, 0xa438, 0x2ead,
+        0xa438, 0x2109, 0xa438, 0xe08f, 0xa438, 0xffac, 0xa438, 0x2503,
+        0xa438, 0xaf4b, 0xa438, 0xeeaf, 0xa438, 0x4beb, 0xa438, 0xad35,
+        0xa438, 0x03af, 0xa438, 0x421b, 0xa438, 0xaf42, 0xa438, 0x5ce1,
+        0xa438, 0x8652, 0xa438, 0xaf49, 0xa438, 0xdcef, 0xa438, 0x31e1,
+        0xa438, 0x8ffd, 0xa438, 0xac28, 0xa438, 0x2ebf, 0xa438, 0x6dda,
+        0xa438, 0x0274, 0xa438, 0x95ad, 0xa438, 0x2825, 0xa438, 0xe28f,
+        0xa438, 0xe4ef, 0xa438, 0x131b, 0xa438, 0x12ac, 0xa438, 0x2f10,
+        0xa438, 0xef31, 0xa438, 0x1f44, 0xa438, 0xef13, 0xa438, 0xbf6c,
+        0xa438, 0xcf02, 0xa438, 0x7476, 0xa438, 0x1a12, 0xa438, 0xae08,
+        0xa438, 0xbf6c, 0xa438, 0xcf02, 0xa438, 0x744a, 0xa438, 0xef13,
+        0xa438, 0xaf08, 0xa438, 0x66af, 0xa438, 0x085c, 0xa438, 0xe18f,
+        0xa438, 0xe3ad, 0xa438, 0x2706, 0xa438, 0xe58f, 0xa438, 0xe9af,
+        0xa438, 0x4091, 0xa438, 0xe08f, 0xa438, 0xe1ac, 0xa438, 0x2002,
+        0xa438, 0xae03, 0xa438, 0xe18f, 0xa438, 0xe2e5, 0xa438, 0x8fe9,
+        0xa438, 0xaf3f, 0xa438, 0xe5f8, 0xa438, 0xe08f, 0xa438, 0xe7a0,
+        0xa438, 0x0005, 0xa438, 0x028b, 0xa438, 0x0dae, 0xa438, 0x13a0,
+        0xa438, 0x0105, 0xa438, 0x028b, 0xa438, 0x96ae, 0xa438, 0x0ba0,
+        0xa438, 0x0205, 0xa438, 0x028b, 0xa438, 0xc2ae, 0xa438, 0x0302,
+        0xa438, 0x8c18, 0xa438, 0xfc04, 0xa438, 0xf8fa, 0xa438, 0xef69,
+        0xa438, 0xfafb, 0xa438, 0xe080, 0xa438, 0x15ad, 0xa438, 0x2343,
+        0xa438, 0xe08f, 0xa438, 0xfdac, 0xa438, 0x203d, 0xa438, 0xe08f,
+        0xa438, 0xe9a0, 0xa438, 0x0002, 0xa438, 0xae35, 0xa438, 0xee8f,
+        0xa438, 0xe800, 0xa438, 0x028c, 0xa438, 0xc8bf, 0xa438, 0x8feb,
+        0xa438, 0xd819, 0xa438, 0xd9ef, 0xa438, 0x64bf, 0xa438, 0x8fef,
+        0xa438, 0xd819, 0xa438, 0xd9ef, 0xa438, 0x7402, 0xa438, 0x73a4,
+        0xa438, 0xad50, 0xa438, 0x18ee, 0xa438, 0x8fff, 0xa438, 0x0102,
+        0xa438, 0x8e1b, 0xa438, 0x0273, 0xa438, 0xd7ef, 0xa438, 0x47e5,
+        0xa438, 0x85a6, 0xa438, 0xe485, 0xa438, 0xa5ee, 0xa438, 0x8fe7,
+        0xa438, 0x01ae, 0xa438, 0x33bf, 0xa438, 0x8f87, 0xa438, 0x0274,
+        0xa438, 0x4abf, 0xa438, 0x8f8d, 0xa438, 0x0274, 0xa438, 0x4abf,
+        0xa438, 0x8f93, 0xa438, 0x0274, 0xa438, 0x4abf, 0xa438, 0x8f99,
+        0xa438, 0x0274, 0xa438, 0x4abf, 0xa438, 0x8f84, 0xa438, 0x0274,
+        0xa438, 0x53bf, 0xa438, 0x8f8a, 0xa438, 0x0274, 0xa438, 0x53bf,
+        0xa438, 0x8f90, 0xa438, 0x0274, 0xa438, 0x53bf, 0xa438, 0x8f96,
+        0xa438, 0x0274, 0xa438, 0x5302, 0xa438, 0x2261, 0xa438, 0xfffe,
+        0xa438, 0xef96, 0xa438, 0xfefc, 0xa438, 0x04f8, 0xa438, 0xfafb,
+        0xa438, 0xe085, 0xa438, 0xa5e1, 0xa438, 0x85a6, 0xa438, 0xef64,
+        0xa438, 0xd000, 0xa438, 0xe18f, 0xa438, 0xeaef, 0xa438, 0x7402,
+        0xa438, 0x73f2, 0xa438, 0xad50, 0xa438, 0x10e0, 0xa438, 0x8fe8,
+        0xa438, 0xac24, 0xa438, 0x06ee, 0xa438, 0x8fe7, 0xa438, 0x02ae,
+        0xa438, 0x04ee, 0xa438, 0x8fe7, 0xa438, 0x03ff, 0xa438, 0xfefc,
+        0xa438, 0x04f8, 0xa438, 0xf9fa, 0xa438, 0xef69, 0xa438, 0xfb02,
+        0xa438, 0x8cc8, 0xa438, 0xbf8f, 0xa438, 0xebd8, 0xa438, 0x19d9,
+        0xa438, 0xbf8f, 0xa438, 0xf3e2, 0xa438, 0x8fe8, 0xa438, 0xef32,
+        0xa438, 0x4b02, 0xa438, 0x1a93, 0xa438, 0xdc19, 0xa438, 0xdd12,
+        0xa438, 0xe68f, 0xa438, 0xe8e3, 0xa438, 0x8fe9, 0xa438, 0x1b23,
+        0xa438, 0xad37, 0xa438, 0x07e0, 0xa438, 0x8fff, 0xa438, 0x4802,
+        0xa438, 0xae09, 0xa438, 0xee8f, 0xa438, 0xe810, 0xa438, 0x1f00,
+        0xa438, 0xe48f, 0xa438, 0xfee4, 0xa438, 0x8fff, 0xa438, 0x028e,
+        0xa438, 0x1b02, 0xa438, 0x73d7, 0xa438, 0xef47, 0xa438, 0xe585,
+        0xa438, 0xa6e4, 0xa438, 0x85a5, 0xa438, 0xee8f, 0xa438, 0xe701,
+        0xa438, 0xffef, 0xa438, 0x96fe, 0xa438, 0xfdfc, 0xa438, 0x04f8,
+        0xa438, 0xf9fa, 0xa438, 0xef69, 0xa438, 0xfafb, 0xa438, 0x028c,
+        0xa438, 0xc8bf, 0xa438, 0x8feb, 0xa438, 0xd819, 0xa438, 0xd9ef,
+        0xa438, 0x64bf, 0xa438, 0x8fef, 0xa438, 0xd819, 0xa438, 0xd9ef,
+        0xa438, 0x7402, 0xa438, 0x73a4, 0xa438, 0xad50, 0xa438, 0x27bf,
+        0xa438, 0x8fed, 0xa438, 0xd819, 0xa438, 0xd9ef, 0xa438, 0x64bf,
+        0xa438, 0x8ff1, 0xa438, 0xd819, 0xa438, 0xd9ef, 0xa438, 0x7402,
+        0xa438, 0x73a4, 0xa438, 0xad50, 0xa438, 0x11e2, 0xa438, 0x8fe8,
+        0xa438, 0xe38f, 0xa438, 0xe9ef, 0xa438, 0x0258, 0xa438, 0x0f1b,
+        0xa438, 0x03ac, 0xa438, 0x2744, 0xa438, 0xae09, 0xa438, 0xe08f,
+        0xa438, 0xfee4, 0xa438, 0x8fff, 0xa438, 0x028e, 0xa438, 0x1b02,
+        0xa438, 0x2261, 0xa438, 0xee8f, 0xa438, 0xe700, 0xa438, 0xbf8f,
+        0xa438, 0x8702, 0xa438, 0x744a, 0xa438, 0xbf8f, 0xa438, 0x8d02,
+        0xa438, 0x744a, 0xa438, 0xbf8f, 0xa438, 0x9302, 0xa438, 0x744a,
+        0xa438, 0xbf8f, 0xa438, 0x9902, 0xa438, 0x744a, 0xa438, 0xbf8f,
+        0xa438, 0x8402, 0xa438, 0x7453, 0xa438, 0xbf8f, 0xa438, 0x8a02,
+        0xa438, 0x7453, 0xa438, 0xbf8f, 0xa438, 0x9002, 0xa438, 0x7453,
+        0xa438, 0xbf8f, 0xa438, 0x9602, 0xa438, 0x7453, 0xa438, 0xae1f,
+        0xa438, 0x12e6, 0xa438, 0x8fe8, 0xa438, 0xe08f, 0xa438, 0xffe4,
+        0xa438, 0x8ffe, 0xa438, 0x028d, 0xa438, 0x3e02, 0xa438, 0x8e1b,
+        0xa438, 0x0273, 0xa438, 0xd7ef, 0xa438, 0x47e5, 0xa438, 0x85a6,
+        0xa438, 0xe485, 0xa438, 0xa5ee, 0xa438, 0x8fe7, 0xa438, 0x01ff,
+        0xa438, 0xfeef, 0xa438, 0x96fe, 0xa438, 0xfdfc, 0xa438, 0x04f8,
+        0xa438, 0xf9fa, 0xa438, 0xef69, 0xa438, 0xfafb, 0xa438, 0x1f22,
+        0xa438, 0xee8f, 0xa438, 0xeb00, 0xa438, 0xee8f, 0xa438, 0xec00,
+        0xa438, 0xee8f, 0xa438, 0xed00, 0xa438, 0xee8f, 0xa438, 0xee00,
+        0xa438, 0x1f33, 0xa438, 0xee8f, 0xa438, 0xe500, 0xa438, 0xee8f,
+        0xa438, 0xe600, 0xa438, 0xbf53, 0xa438, 0x7d02, 0xa438, 0x7662,
+        0xa438, 0xef64, 0xa438, 0xbf8f, 0xa438, 0xe5d8, 0xa438, 0x19d9,
+        0xa438, 0xef74, 0xa438, 0x0273, 0xa438, 0xbfef, 0xa438, 0x47dd,
+        0xa438, 0x89dc, 0xa438, 0xd1ff, 0xa438, 0xb1fe, 0xa438, 0x13ad,
+        0xa438, 0x3be0, 0xa438, 0x0d73, 0xa438, 0xbf8f, 0xa438, 0xedd8,
+        0xa438, 0x19d9, 0xa438, 0xef64, 0xa438, 0xef47, 0xa438, 0x0273,
+        0xa438, 0xa4ad, 0xa438, 0x5003, 0xa438, 0xdd89, 0xa438, 0xdcef,
+        0xa438, 0x64bf, 0xa438, 0x8feb, 0xa438, 0xd819, 0xa438, 0xd91a,
+        0xa438, 0x46dd, 0xa438, 0x89dc, 0xa438, 0x12ad, 0xa438, 0x32b0,
+        0xa438, 0x0d42, 0xa438, 0xdc19, 0xa438, 0xddff, 0xa438, 0xfeef,
+        0xa438, 0x96fe, 0xa438, 0xfdfc, 0xa438, 0x04f8, 0xa438, 0xf9fa,
+        0xa438, 0xef69, 0xa438, 0xfafb, 0xa438, 0x1f22, 0xa438, 0xd6ff,
+        0xa438, 0xffef, 0xa438, 0x03bf, 0xa438, 0x8ff3, 0xa438, 0xef32,
+        0xa438, 0x4b02, 0xa438, 0x1a93, 0xa438, 0xef30, 0xa438, 0xd819,
+        0xa438, 0xd9ef, 0xa438, 0x7402, 0xa438, 0x73a4, 0xa438, 0xac50,
+        0xa438, 0x04ef, 0xa438, 0x32ef, 0xa438, 0x64e0, 0xa438, 0x8fe9,
+        0xa438, 0x12ef, 0xa438, 0x121b, 0xa438, 0x10ac, 0xa438, 0x2fd9,
+        0xa438, 0xef03, 0xa438, 0xbf8f, 0xa438, 0xf348, 0xa438, 0x021a,
+        0xa438, 0x90ec, 0xa438, 0xff19, 0xa438, 0xecff, 0xa438, 0xd001,
+        0xa438, 0xae03, 0xa438, 0x0c01, 0xa438, 0x83a3, 0xa438, 0x00fa,
+        0xa438, 0xe18f, 0xa438, 0xff1e, 0xa438, 0x10e5, 0xa438, 0x8fff,
+        0xa438, 0xfffe, 0xa438, 0xef96, 0xa438, 0xfefd, 0xa438, 0xfc04,
+        0xa438, 0x725a, 0xa438, 0x725d, 0xa438, 0x7260, 0xa438, 0x7263,
+        0xa438, 0x71fa, 0xa438, 0x71fd, 0xa438, 0x7200, 0xa438, 0x7203,
+        0xa438, 0x8f4b, 0xa438, 0x8f4e, 0xa438, 0x8f51, 0xa438, 0x8f54,
+        0xa438, 0x8f57, 0xa438, 0x8f5a, 0xa438, 0x8f5d, 0xa438, 0x8f60,
+        0xa438, 0x722a, 0xa438, 0x722d, 0xa438, 0x7230, 0xa438, 0x7233,
+        0xa438, 0x721e, 0xa438, 0x7221, 0xa438, 0x7224, 0xa438, 0x7227,
+        0xa438, 0x7212, 0xa438, 0x7215, 0xa438, 0x7218, 0xa438, 0x721b,
+        0xa438, 0x724e, 0xa438, 0x7251, 0xa438, 0x7254, 0xa438, 0x7257,
+        0xa438, 0x7242, 0xa438, 0x7245, 0xa438, 0x7248, 0xa438, 0x724b,
+        0xa438, 0x7236, 0xa438, 0x7239, 0xa438, 0x723c, 0xa438, 0x723f,
+        0xa438, 0x8f84, 0xa438, 0x8f8a, 0xa438, 0x8f90, 0xa438, 0x8f96,
+        0xa438, 0x8f9c, 0xa438, 0x8fa2, 0xa438, 0x8fa8, 0xa438, 0x8fae,
+        0xa438, 0x8f87, 0xa438, 0x8f8d, 0xa438, 0x8f93, 0xa438, 0x8f99,
+        0xa438, 0x8f9f, 0xa438, 0x8fa5, 0xa438, 0x8fab, 0xa438, 0x8fb1,
+        0xa438, 0x8f63, 0xa438, 0x8f66, 0xa438, 0x8f69, 0xa438, 0x8f6c,
+        0xa438, 0x8f6f, 0xa438, 0x8f72, 0xa438, 0x8f75, 0xa438, 0x8f78,
+        0xa438, 0x8f7b, 0xa438, 0xf8f9, 0xa438, 0xfaef, 0xa438, 0x69fa,
+        0xa438, 0xfbe2, 0xa438, 0x8fff, 0xa438, 0xad30, 0xa438, 0x06d1,
+        0xa438, 0x00d3, 0xa438, 0x00ae, 0xa438, 0x04d1, 0xa438, 0x01d3,
+        0xa438, 0x0fbf, 0xa438, 0x8d99, 0xa438, 0xd700, 0xa438, 0x0802,
+        0xa438, 0x7677, 0xa438, 0xef13, 0xa438, 0xbf8d, 0xa438, 0xa1d7,
+        0xa438, 0x0008, 0xa438, 0x0276, 0xa438, 0x77ad, 0xa438, 0x3106,
+        0xa438, 0xd100, 0xa438, 0xd300, 0xa438, 0xae04, 0xa438, 0xd101,
+        0xa438, 0xd30f, 0xa438, 0xbf8d, 0xa438, 0xa9d7, 0xa438, 0x0008,
+        0xa438, 0x0276, 0xa438, 0x77ef, 0xa438, 0x13bf, 0xa438, 0x8db1,
+        0xa438, 0xd700, 0xa438, 0x0802, 0xa438, 0x7677, 0xa438, 0xad32,
+        0xa438, 0x06d1, 0xa438, 0x00d3, 0xa438, 0x00ae, 0xa438, 0x04d1,
+        0xa438, 0x01d3, 0xa438, 0x03bf, 0xa438, 0x8db9, 0xa438, 0xd700,
+        0xa438, 0x1802, 0xa438, 0x7677, 0xa438, 0xef13, 0xa438, 0xbf8d,
+        0xa438, 0xd1d7, 0xa438, 0x0018, 0xa438, 0x0276, 0xa438, 0x77ad,
+        0xa438, 0x3304, 0xa438, 0xd101, 0xa438, 0xae02, 0xa438, 0xd100,
+        0xa438, 0xd300, 0xa438, 0xbf8d, 0xa438, 0xe9d7, 0xa438, 0x0010,
+        0xa438, 0x0276, 0xa438, 0x77ef, 0xa438, 0x13bf, 0xa438, 0x8df9,
+        0xa438, 0xd700, 0xa438, 0x1002, 0xa438, 0x7677, 0xa438, 0x1f33,
+        0xa438, 0xe38f, 0xa438, 0xfdac, 0xa438, 0x3803, 0xa438, 0xaf8f,
+        0xa438, 0x35ad, 0xa438, 0x3405, 0xa438, 0xe18f, 0xa438, 0xfbae,
+        0xa438, 0x02d1, 0xa438, 0x00bf, 0xa438, 0x8e09, 0xa438, 0xd700,
+        0xa438, 0x1202, 0xa438, 0x7677, 0xa438, 0xad35, 0xa438, 0x06d1,
+        0xa438, 0x01d3, 0xa438, 0x04ae, 0xa438, 0x04d1, 0xa438, 0x00d3,
+        0xa438, 0x00bf, 0xa438, 0x6f8a, 0xa438, 0x0274, 0xa438, 0x76bf,
+        0xa438, 0x6bd0, 0xa438, 0x0274, 0xa438, 0x951a, 0xa438, 0x13bf,
+        0xa438, 0x6bd0, 0xa438, 0x0274, 0xa438, 0x76bf, 0xa438, 0x6d2c,
+        0xa438, 0x0274, 0xa438, 0x95ac, 0xa438, 0x280b, 0xa438, 0xbf6d,
+        0xa438, 0x2f02, 0xa438, 0x7495, 0xa438, 0xac28, 0xa438, 0x02ae,
+        0xa438, 0x0bad, 0xa438, 0x3504, 0xa438, 0xd101, 0xa438, 0xae0d,
+        0xa438, 0xd10f, 0xa438, 0xae09, 0xa438, 0xad35, 0xa438, 0x04d1,
+        0xa438, 0x05ae, 0xa438, 0x02d1, 0xa438, 0x0fbf, 0xa438, 0x8f7e,
+        0xa438, 0x0274, 0xa438, 0x76e3, 0xa438, 0x8ffc, 0xa438, 0xac38,
+        0xa438, 0x05ad, 0xa438, 0x3618, 0xa438, 0xae08, 0xa438, 0xbf71,
+        0xa438, 0x9d02, 0xa438, 0x744a, 0xa438, 0xae0e, 0xa438, 0xd102,
+        0xa438, 0xbf8f, 0xa438, 0x8102, 0xa438, 0x7476, 0xa438, 0xbf71,
+        0xa438, 0x9d02, 0xa438, 0x7476, 0xa438, 0xfffe, 0xa438, 0xef96,
+        0xa438, 0xfefd, 0xa438, 0xfc04, 0xa438, 0xf91f, 0xa438, 0x33e3,
+        0xa438, 0x8ffd, 0xa438, 0xad38, 0xa438, 0x0302, 0xa438, 0x8e1b,
+        0xa438, 0xfd04, 0xa438, 0x55b0, 0xa438, 0x2055, 0xa438, 0xb0a0,
+        0xa438, 0x55b1, 0xa438, 0x2055, 0xa438, 0xb1a0, 0xa438, 0xfcb0,
+        0xa438, 0x22fc, 0xa438, 0xb0a2, 0xa438, 0xfcb1, 0xa438, 0x22fc,
+        0xa438, 0xb1a2, 0xa438, 0xfdad, 0xa438, 0xdaca, 0xa438, 0xadda,
+        0xa438, 0x97ad, 0xa438, 0xda64, 0xa438, 0xadda, 0xa438, 0x20ad,
+        0xa438, 0xdafd, 0xa438, 0xaddc, 0xa438, 0xcaad, 0xa438, 0xdc97,
+        0xa438, 0xaddc, 0xa438, 0x64ad, 0xa438, 0xdca7, 0xa438, 0xbf1e,
+        0xa438, 0x20bc, 0xa438, 0x3299, 0xa438, 0xadfe, 0xa438, 0x85ad,
+        0xa438, 0xfe44, 0xa438, 0xadfe, 0xa438, 0x30ad, 0xa438, 0xfeff,
+        0xa438, 0xae00, 0xa438, 0xebae, 0xa438, 0x00aa, 0xa438, 0xae00,
+        0xa438, 0x96ae, 0xa438, 0x00dd, 0xa438, 0xad94, 0xa438, 0xccad,
+        0xa438, 0x9499, 0xa438, 0xad94, 0xa438, 0x88ad, 0xa438, 0x94ff,
+        0xa438, 0xad94, 0xa438, 0xeead, 0xa438, 0x94bb, 0xa438, 0xad94,
+        0xa438, 0xaaad, 0xa438, 0x94f9, 0xa438, 0xe28f, 0xa438, 0xffee,
+        0xa438, 0x8fff, 0xa438, 0x00e3, 0xa438, 0x8ffd, 0xa438, 0xee8f,
+        0xa438, 0xfd01, 0xa438, 0xee8f, 0xa438, 0xfc01, 0xa438, 0x028e,
+        0xa438, 0x1be6, 0xa438, 0x8fff, 0xa438, 0xe78f, 0xa438, 0xfdee,
+        0xa438, 0x8ffc, 0xa438, 0x00ee, 0xa438, 0x8fe7, 0xa438, 0x00fd,
+        0xa438, 0x0400, 0xa436, 0xb85e, 0xa438, 0x211C, 0xa436, 0xb860,
+        0xa438, 0x216C, 0xa436, 0xb862, 0xa438, 0x212B, 0xa436, 0xb864,
+        0xa438, 0x4BE8, 0xa436, 0xb886, 0xa438, 0x4209, 0xa436, 0xb888,
+        0xa438, 0x49DA, 0xa436, 0xb88a, 0xa438, 0x085A, 0xa436, 0xb88c,
+        0xa438, 0x3FDF, 0xa436, 0xb838, 0xa438, 0x00ff, 0xb820, 0x0010,
+        0xa466, 0x0003, 0xa436, 0x8528, 0xa438, 0x0000, 0xa436, 0x85f8,
+        0xa438, 0xaf86, 0xa438, 0x10af, 0xa438, 0x8622, 0xa438, 0xaf86,
+        0xa438, 0x4aaf, 0xa438, 0x8658, 0xa438, 0xaf86, 0xa438, 0x64af,
+        0xa438, 0x8685, 0xa438, 0xaf86, 0xa438, 0xc4af, 0xa438, 0x86cf,
+        0xa438, 0xa104, 0xa438, 0x0ce0, 0xa438, 0x8394, 0xa438, 0xad20,
+        0xa438, 0x03af, 0xa438, 0x2b67, 0xa438, 0xaf2a, 0xa438, 0xf0af,
+        0xa438, 0x2b8d, 0xa438, 0xbf6b, 0xa438, 0x7202, 0xa438, 0x72dc,
+        0xa438, 0xa106, 0xa438, 0x19e1, 0xa438, 0x8164, 0xa438, 0xbf6d,
+        0xa438, 0x5b02, 0xa438, 0x72bd, 0xa438, 0x0d13, 0xa438, 0xbf6d,
+        0xa438, 0x5802, 0xa438, 0x72bd, 0xa438, 0x0d13, 0xa438, 0xbf6d,
+        0xa438, 0x6a02, 0xa438, 0x72bd, 0xa438, 0x0275, 0xa438, 0x12af,
+        0xa438, 0x380d, 0xa438, 0x0d55, 0xa438, 0x5d07, 0xa438, 0xffbf,
+        0xa438, 0x8b09, 0xa438, 0x0272, 0xa438, 0x91af, 0xa438, 0x3ee2,
+        0xa438, 0x023d, 0xa438, 0xffbf, 0xa438, 0x8b09, 0xa438, 0x0272,
+        0xa438, 0x9aaf, 0xa438, 0x41a6, 0xa438, 0x0223, 0xa438, 0x24f8,
+        0xa438, 0xfaef, 0xa438, 0x69bf, 0xa438, 0x6b9c, 0xa438, 0x0272,
+        0xa438, 0xdce0, 0xa438, 0x8f7a, 0xa438, 0x1f01, 0xa438, 0x9e06,
+        0xa438, 0xe58f, 0xa438, 0x7a02, 0xa438, 0x7550, 0xa438, 0xef96,
+        0xa438, 0xfefc, 0xa438, 0xaf06, 0xa438, 0x8702, 0xa438, 0x1cac,
+        0xa438, 0xf8f9, 0xa438, 0xfaef, 0xa438, 0x69fb, 0xa438, 0xd78f,
+        0xa438, 0x97ae, 0xa438, 0x00bf, 0xa438, 0x6d4f, 0xa438, 0x0272,
+        0xa438, 0x91d3, 0xa438, 0x00a3, 0xa438, 0x1202, 0xa438, 0xae1b,
+        0xa438, 0xbf6d, 0xa438, 0x52ef, 0xa438, 0x1302, 0xa438, 0x72bd,
+        0xa438, 0xef97, 0xa438, 0xd9bf, 0xa438, 0x6d55, 0xa438, 0x0272,
+        0xa438, 0xbd17, 0xa438, 0x13ae, 0xa438, 0xe6bf, 0xa438, 0x6d4f,
+        0xa438, 0x0272, 0xa438, 0x9aff, 0xa438, 0xef96, 0xa438, 0xfefd,
+        0xa438, 0xfcaf, 0xa438, 0x1c05, 0xa438, 0x0000, 0xa438, 0x021b,
+        0xa438, 0xf202, 0xa438, 0x8700, 0xa438, 0xaf1b, 0xa438, 0x73ad,
+        0xa438, 0x2003, 0xa438, 0x0206, 0xa438, 0x6ead, 0xa438, 0x2108,
+        0xa438, 0xe280, 0xa438, 0x51f7, 0xa438, 0x30e6, 0xa438, 0x8051,
+        0xa438, 0xe180, 0xa438, 0x421e, 0xa438, 0x10e5, 0xa438, 0x8042,
+        0xa438, 0xe0ff, 0xa438, 0xeee1, 0xa438, 0x8043, 0xa438, 0x1e10,
+        0xa438, 0xe580, 0xa438, 0x43e0, 0xa438, 0xffef, 0xa438, 0xad20,
+        0xa438, 0x04ee, 0xa438, 0x804f, 0xa438, 0x1eaf, 0xa438, 0x0661,
+        0xa438, 0xf8fa, 0xa438, 0xef69, 0xa438, 0xe080, 0xa438, 0x4fac,
+        0xa438, 0x2417, 0xa438, 0xe080, 0xa438, 0x44ad, 0xa438, 0x241a,
+        0xa438, 0x0287, 0xa438, 0x2fe0, 0xa438, 0x8044, 0xa438, 0xac24,
+        0xa438, 0x11bf, 0xa438, 0x8b0c, 0xa438, 0x0272, 0xa438, 0x9aae,
+        0xa438, 0x0902, 0xa438, 0x88c8, 0xa438, 0x028a, 0xa438, 0x9502,
+        0xa438, 0x8a8a, 0xa438, 0xef96, 0xa438, 0xfefc, 0xa438, 0x04f8,
+        0xa438, 0xe08f, 0xa438, 0x96a0, 0xa438, 0x0005, 0xa438, 0x0288,
+        0xa438, 0x6cae, 0xa438, 0x38a0, 0xa438, 0x0105, 0xa438, 0x0287,
+        0xa438, 0x75ae, 0xa438, 0x30a0, 0xa438, 0x0205, 0xa438, 0x0287,
+        0xa438, 0xb3ae, 0xa438, 0x28a0, 0xa438, 0x0305, 0xa438, 0x0287,
+        0xa438, 0xc9ae, 0xa438, 0x20a0, 0xa438, 0x0405, 0xa438, 0x0287,
+        0xa438, 0xd6ae, 0xa438, 0x18a0, 0xa438, 0x0505, 0xa438, 0x0288,
+        0xa438, 0x1aae, 0xa438, 0x10a0, 0xa438, 0x0605, 0xa438, 0x0288,
+        0xa438, 0x27ae, 0xa438, 0x08a0, 0xa438, 0x0705, 0xa438, 0x0288,
+        0xa438, 0x48ae, 0xa438, 0x00fc, 0xa438, 0x04f8, 0xa438, 0xfaef,
+        0xa438, 0x69e0, 0xa438, 0x8018, 0xa438, 0xad25, 0xa438, 0x2c02,
+        0xa438, 0x8a67, 0xa438, 0xe184, 0xa438, 0x5de5, 0xa438, 0x8f92,
+        0xa438, 0xe58f, 0xa438, 0x93e5, 0xa438, 0x8f94, 0xa438, 0xe58f,
+        0xa438, 0x9502, 0xa438, 0x88e6, 0xa438, 0xe184, 0xa438, 0xf759,
+        0xa438, 0x0fe5, 0xa438, 0x8f7b, 0xa438, 0xe58f, 0xa438, 0x7ce5,
+        0xa438, 0x8f7d, 0xa438, 0xe58f, 0xa438, 0x7eee, 0xa438, 0x8f96,
+        0xa438, 0x02ae, 0xa438, 0x0302, 0xa438, 0x8a8a, 0xa438, 0xef96,
+        0xa438, 0xfefc, 0xa438, 0x04f9, 0xa438, 0x0289, 0xa438, 0x19ac,
+        0xa438, 0x3009, 0xa438, 0xee8f, 0xa438, 0x9603, 0xa438, 0x0288,
+        0xa438, 0x8eae, 0xa438, 0x04ee, 0xa438, 0x8f96, 0xa438, 0x04fd,
+        0xa438, 0x04fb, 0xa438, 0x0288, 0xa438, 0x55ad, 0xa438, 0x5004,
+        0xa438, 0xee8f, 0xa438, 0x9602, 0xa438, 0xff04, 0xa438, 0xf902,
+        0xa438, 0x8943, 0xa438, 0xe28f, 0xa438, 0x920c, 0xa438, 0x245a,
+        0xa438, 0xf0e3, 0xa438, 0x84f7, 0xa438, 0x5bf0, 0xa438, 0x1b23,
+        0xa438, 0x9e0f, 0xa438, 0x028a, 0xa438, 0x52ee, 0xa438, 0x8f96,
+        0xa438, 0x0502, 0xa438, 0x888e, 0xa438, 0x0287, 0xa438, 0xffae,
+        0xa438, 0x04ee, 0xa438, 0x8f96, 0xa438, 0x06fd, 0xa438, 0x04f8,
+        0xa438, 0xf9fa, 0xa438, 0xef69, 0xa438, 0xfa1f, 0xa438, 0x44d2,
+        0xa438, 0x04bf, 0xa438, 0x8f7f, 0xa438, 0xdc19, 0xa438, 0xdd19,
+        0xa438, 0x829f, 0xa438, 0xf9fe, 0xa438, 0xef96, 0xa438, 0xfefd,
+        0xa438, 0xfc04, 0xa438, 0xfb02, 0xa438, 0x8855, 0xa438, 0xad50,
+        0xa438, 0x04ee, 0xa438, 0x8f96, 0xa438, 0x04ff, 0xa438, 0x04f8,
+        0xa438, 0xf9fa, 0xa438, 0xef69, 0xa438, 0x0289, 0xa438, 0x19ac,
+        0xa438, 0x3009, 0xa438, 0xee8f, 0xa438, 0x9607, 0xa438, 0x0288,
+        0xa438, 0x8eae, 0xa438, 0x0702, 0xa438, 0x8a8a, 0xa438, 0xee8f,
+        0xa438, 0x9601, 0xa438, 0xef96, 0xa438, 0xfefd, 0xa438, 0xfc04,
+        0xa438, 0xfb02, 0xa438, 0x8855, 0xa438, 0xad50, 0xa438, 0x04ee,
+        0xa438, 0x8f96, 0xa438, 0x06ff, 0xa438, 0x04f8, 0xa438, 0xfae0,
+        0xa438, 0x8457, 0xa438, 0xe184, 0xa438, 0x58ef, 0xa438, 0x64e1,
+        0xa438, 0x8f90, 0xa438, 0xd000, 0xa438, 0xef74, 0xa438, 0x0271,
+        0xa438, 0xfffe, 0xa438, 0xfc04, 0xa438, 0xf8fa, 0xa438, 0xef69,
+        0xa438, 0xee8f, 0xa438, 0x9601, 0xa438, 0xee8f, 0xa438, 0x9004,
+        0xa438, 0xee8f, 0xa438, 0x8f40, 0xa438, 0xbf8b, 0xa438, 0x0f02,
+        0xa438, 0x72dc, 0xa438, 0xe584, 0xa438, 0x5dee, 0xa438, 0x8f91,
+        0xa438, 0x77ef, 0xa438, 0x96fe, 0xa438, 0xfc04, 0xa438, 0xf8fa,
+        0xa438, 0xfbef, 0xa438, 0x69e1, 0xa438, 0x8f92, 0xa438, 0xbf8b,
+        0xa438, 0x0f02, 0xa438, 0x72bd, 0xa438, 0xe18f, 0xa438, 0x93bf,
+        0xa438, 0x8b12, 0xa438, 0x0272, 0xa438, 0xbde1, 0xa438, 0x8f94,
+        0xa438, 0xbf8b, 0xa438, 0x1502, 0xa438, 0x72bd, 0xa438, 0xe18f,
+        0xa438, 0x95bf, 0xa438, 0x8b18, 0xa438, 0x0272, 0xa438, 0xbd02,
+        0xa438, 0x71e4, 0xa438, 0xef47, 0xa438, 0xe484, 0xa438, 0x57e5,
+        0xa438, 0x8458, 0xa438, 0xef96, 0xa438, 0xfffe, 0xa438, 0xfc04,
+        0xa438, 0xf8e0, 0xa438, 0x8018, 0xa438, 0xad25, 0xa438, 0x15ee,
+        0xa438, 0x8f96, 0xa438, 0x00d0, 0xa438, 0x08e4, 0xa438, 0x8f92,
+        0xa438, 0xe48f, 0xa438, 0x93e4, 0xa438, 0x8f94, 0xa438, 0xe48f,
+        0xa438, 0x9502, 0xa438, 0x888e, 0xa438, 0xfc04, 0xa438, 0xf9e2,
+        0xa438, 0x845d, 0xa438, 0xe38f, 0xa438, 0x910d, 0xa438, 0x345b,
+        0xa438, 0x0f1a, 0xa438, 0x32ac, 0xa438, 0x3c09, 0xa438, 0x0c34,
+        0xa438, 0x5bf0, 0xa438, 0xe784, 0xa438, 0xf7ae, 0xa438, 0x04ee,
+        0xa438, 0x84f7, 0xa438, 0xf0e3, 0xa438, 0x8f91, 0xa438, 0x5b0f,
+        0xa438, 0x1b23, 0xa438, 0xac37, 0xa438, 0x0ae3, 0xa438, 0x84f7,
+        0xa438, 0x1e32, 0xa438, 0xe784, 0xa438, 0xf7ae, 0xa438, 0x00fd,
+        0xa438, 0x04f8, 0xa438, 0xfaef, 0xa438, 0x69fa, 0xa438, 0xfbd2,
+        0xa438, 0x01d3, 0xa438, 0x04d6, 0xa438, 0x8f92, 0xa438, 0xd78f,
+        0xa438, 0x7bef, 0xa438, 0x97d9, 0xa438, 0xef96, 0xa438, 0xd81b,
+        0xa438, 0x109e, 0xa438, 0x0480, 0xa438, 0xdcd2, 0xa438, 0x0016,
+        0xa438, 0x1783, 0xa438, 0x9fed, 0xa438, 0xfffe, 0xa438, 0xef96,
+        0xa438, 0xfefc, 0xa438, 0x04f8, 0xa438, 0xf9fa, 0xa438, 0xfbef,
+        0xa438, 0x79fb, 0xa438, 0xcffb, 0xa438, 0xd200, 0xa438, 0xbe00,
+        0xa438, 0x00ef, 0xa438, 0x1229, 0xa438, 0x40d0, 0xa438, 0x041c,
+        0xa438, 0x081a, 0xa438, 0x10bf, 0xa438, 0x8b27, 0xa438, 0x0272,
+        0xa438, 0xbd02, 0xa438, 0x89ee, 0xa438, 0xbf8f, 0xa438, 0x7fef,
+        0xa438, 0x1249, 0xa438, 0x021a, 0xa438, 0x91d8, 0xa438, 0x19d9,
+        0xa438, 0xef74, 0xa438, 0x0271, 0xa438, 0xccef, 0xa438, 0x47dd,
+        0xa438, 0x89dc, 0xa438, 0x18a8, 0xa438, 0x0002, 0xa438, 0xd202,
+        0xa438, 0x8990, 0xa438, 0x12a2, 0xa438, 0x04c8, 0xa438, 0xffc7,
+        0xa438, 0xffef, 0xa438, 0x97ff, 0xa438, 0xfefd, 0xa438, 0xfc04,
+        0xa438, 0xf8f9, 0xa438, 0xfafb, 0xa438, 0xef79, 0xa438, 0xfbbf,
+        0xa438, 0x8f7f, 0xa438, 0xef12, 0xa438, 0x4902, 0xa438, 0x1a91,
+        0xa438, 0xd819, 0xa438, 0xd9ef, 0xa438, 0x64bf, 0xa438, 0x8f87,
+        0xa438, 0xef12, 0xa438, 0x4902, 0xa438, 0x1a91, 0xa438, 0xd819,
+        0xa438, 0xd9ef, 0xa438, 0x7489, 0xa438, 0x0271, 0xa438, 0xb1ad,
+        0xa438, 0x502c, 0xa438, 0xef46, 0xa438, 0xdc19, 0xa438, 0xdda2,
+        0xa438, 0x0006, 0xa438, 0xbf8b, 0xa438, 0x0f02, 0xa438, 0x72dc,
+        0xa438, 0xa201, 0xa438, 0x06bf, 0xa438, 0x8b12, 0xa438, 0x0272,
+        0xa438, 0xdca2, 0xa438, 0x0206, 0xa438, 0xbf8b, 0xa438, 0x1502,
+        0xa438, 0x72dc, 0xa438, 0xbf8b, 0xa438, 0x1802, 0xa438, 0x72dc,
+        0xa438, 0xbf8f, 0xa438, 0x7b1a, 0xa438, 0x92dd, 0xa438, 0xffef,
+        0xa438, 0x97ff, 0xa438, 0xfefd, 0xa438, 0xfc04, 0xa438, 0xf9f8,
+        0xa438, 0xfbef, 0xa438, 0x79fb, 0xa438, 0x028a, 0xa438, 0xa0bf,
+        0xa438, 0x8b1b, 0xa438, 0x0272, 0xa438, 0x9a16, 0xa438, 0xbf8b,
+        0xa438, 0x1e02, 0xa438, 0x72dc, 0xa438, 0xac28, 0xa438, 0x02ae,
+        0xa438, 0xf4d6, 0xa438, 0x0000, 0xa438, 0xbf8b, 0xa438, 0x1b02,
+        0xa438, 0x7291, 0xa438, 0xae03, 0xa438, 0x028a, 0xa438, 0x8ad2,
+        0xa438, 0x00d7, 0xa438, 0x0000, 0xa438, 0xe18f, 0xa438, 0x8f1b,
+        0xa438, 0x12a1, 0xa438, 0x0004, 0xa438, 0xef67, 0xa438, 0xae1d,
+        0xa438, 0xef12, 0xa438, 0xbf8b, 0xa438, 0x2102, 0xa438, 0x72bd,
+        0xa438, 0x12bf, 0xa438, 0x8b24, 0xa438, 0x0272, 0xa438, 0xdcef,
+        0xa438, 0x64ad, 0xa438, 0x4f04, 0xa438, 0x7eff, 0xa438, 0xff16,
+        0xa438, 0x0271, 0xa438, 0xccae, 0xa438, 0xd7bf, 0xa438, 0x8b2d,
+        0xa438, 0x0272, 0xa438, 0x91ff, 0xa438, 0xef97, 0xa438, 0xfffc,
+        0xa438, 0xfd04, 0xa438, 0xf8fa, 0xa438, 0xef69, 0xa438, 0xd104,
+        0xa438, 0xbf8f, 0xa438, 0x92d8, 0xa438, 0x10dc, 0xa438, 0x1981,
+        0xa438, 0x9ff9, 0xa438, 0xef96, 0xa438, 0xfefc, 0xa438, 0x04f8,
+        0xa438, 0xfbfa, 0xa438, 0xef69, 0xa438, 0xbf8f, 0xa438, 0x87d0,
+        0xa438, 0x08d1, 0xa438, 0xff02, 0xa438, 0x8a7c, 0xa438, 0xef96,
+        0xa438, 0xfeff, 0xa438, 0xfc04, 0xa438, 0xf8fa, 0xa438, 0xef69,
+        0xa438, 0xdd19, 0xa438, 0x809f, 0xa438, 0xfbef, 0xa438, 0x96fe,
+        0xa438, 0xfc04, 0xa438, 0xf8e0, 0xa438, 0x8044, 0xa438, 0xf624,
+        0xa438, 0xe480, 0xa438, 0x44fc, 0xa438, 0x04f8, 0xa438, 0xe080,
+        0xa438, 0x4ff6, 0xa438, 0x24e4, 0xa438, 0x804f, 0xa438, 0xfc04,
+        0xa438, 0xf8fa, 0xa438, 0xfbef, 0xa438, 0x79fb, 0xa438, 0xbf8b,
+        0xa438, 0x2a02, 0xa438, 0x7291, 0xa438, 0xbf8b, 0xa438, 0x3302,
+        0xa438, 0x7291, 0xa438, 0xd68b, 0xa438, 0x2dd7, 0xa438, 0x8b30,
+        0xa438, 0x0116, 0xa438, 0xad50, 0xa438, 0x0cbf, 0xa438, 0x8b2a,
+        0xa438, 0x0272, 0xa438, 0x9abf, 0xa438, 0x8b33, 0xa438, 0x0272,
+        0xa438, 0x9aff, 0xa438, 0xef97, 0xa438, 0xfffe, 0xa438, 0xfc04,
+        0xa438, 0xf8f9, 0xa438, 0xfaef, 0xa438, 0x49f8, 0xa438, 0xccf8,
+        0xa438, 0xef96, 0xa438, 0x0272, 0xa438, 0x9a1f, 0xa438, 0x22c7,
+        0xa438, 0xbd02, 0xa438, 0x72dc, 0xa438, 0xac28, 0xa438, 0x16ac,
+        0xa438, 0x3008, 0xa438, 0x0271, 0xa438, 0xe4ef, 0xa438, 0x6712,
+        0xa438, 0xaeee, 0xa438, 0xd700, 0xa438, 0x0202, 0xa438, 0x71ff,
+        0xa438, 0xac50, 0xa438, 0x05ae, 0xa438, 0xe3d7, 0xa438, 0x0000,
+        0xa438, 0xfcc4, 0xa438, 0xfcef, 0xa438, 0x94fe, 0xa438, 0xfdfc,
+        0xa438, 0x04cc, 0xa438, 0xc010, 0xa438, 0x44ac, 0xa438, 0x0030,
+        0xa438, 0xbce0, 0xa438, 0x74bc, 0xa438, 0xe0b8, 0xa438, 0xbce0,
+        0xa438, 0xfcbc, 0xa438, 0xe011, 0xa438, 0xacb4, 0xa438, 0xddac,
+        0xa438, 0xb6fa, 0xa438, 0xacb4, 0xa438, 0xf0ac, 0xa438, 0xba92,
+        0xa438, 0xacb4, 0xa438, 0xffac, 0xa438, 0x5600, 0xa438, 0xacb4,
+        0xa438, 0xccac, 0xa438, 0xb6ff, 0xa438, 0xb034, 0xa436, 0xb818,
+        0xa438, 0x2ae4, 0xa436, 0xb81a, 0xa438, 0x380A, 0xa436, 0xb81c,
+        0xa438, 0x3EDD, 0xa436, 0xb81e, 0xa438, 0x41A3, 0xa436, 0xb850,
+        0xa438, 0x0684, 0xa436, 0xb852, 0xa438, 0x1C02, 0xa436, 0xb878,
+        0xa438, 0x1B70, 0xa436, 0xb884, 0xa438, 0x0633, 0xa436, 0xb832,
+        0xa438, 0x00ff, 0xa436, 0xacfc, 0xa438, 0x0100, 0xa436, 0xacfe,
+        0xa438, 0x8000, 0xa436, 0xad00, 0xa438, 0x27ff, 0xa436, 0xad02,
+        0xa438, 0x3c67, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x000f, 0xa436, 0xad00,
+        0xa438, 0x47ff, 0xa436, 0xad02, 0xa438, 0x3e67, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x000f, 0xa436, 0xad00, 0xa438, 0x67ff, 0xa436, 0xad02,
+        0xa438, 0x3067, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x000f, 0xa436, 0xad00,
+        0xa438, 0x87ff, 0xa436, 0xad02, 0xa438, 0x3267, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x000f, 0xa436, 0xad00, 0xa438, 0xa7ff, 0xa436, 0xad02,
+        0xa438, 0x3467, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x000f, 0xa436, 0xad00,
+        0xa438, 0xcfff, 0xa436, 0xad02, 0xa438, 0x3667, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x000f, 0xa436, 0xad00, 0xa438, 0xefff, 0xa436, 0xad02,
+        0xa438, 0x3867, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x000f, 0xa436, 0xad00,
+        0xa438, 0x0fff, 0xa436, 0xad02, 0xa438, 0x3a67, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x000f, 0xa436, 0xad00, 0xa438, 0x2fff, 0xa436, 0xad02,
+        0xa438, 0x3ce7, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x4fff, 0xa436, 0xad02, 0xa438, 0x3ee7, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x6fff, 0xa436, 0xad02,
+        0xa438, 0x30e7, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x8fff, 0xa436, 0xad02, 0xa438, 0x32e7, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xafff, 0xa436, 0xad02,
+        0xa438, 0x34e7, 0xa436, 0xad04, 0xa438, 0x1008, 0xa436, 0xad06,
+        0xa438, 0xfff4, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0x36ff, 0xa436, 0xad04,
+        0xa438, 0x1048, 0xa436, 0xad06, 0xa438, 0xfff5, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0x38ff, 0xa436, 0xad04, 0xa438, 0x1088, 0xa436, 0xad06,
+        0xa438, 0xfff6, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0x3aff, 0xa436, 0xad04,
+        0xa438, 0x10c8, 0xa436, 0xad06, 0xa438, 0xf417, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xffff, 0xa436, 0xad04, 0xa438, 0x1109, 0xa436, 0xad06,
+        0xa438, 0xf434, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x0207, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0x1149, 0xa436, 0xad06, 0xa438, 0x0455, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x2227, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0x1189, 0xa436, 0xad06,
+        0xa438, 0x1476, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x4247, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0x11c9, 0xa436, 0xad06, 0xa438, 0x2517, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x6267, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0x1209, 0xa436, 0xad06,
+        0xa438, 0x3534, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x0007, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0x1249, 0xa436, 0xad06, 0xa438, 0x0555, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x2027, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0x1289, 0xa436, 0xad06,
+        0xa438, 0x1576, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x4047, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0x12c9, 0xa436, 0xad06, 0xa438, 0x2517, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x6067, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0x1309, 0xa436, 0xad06,
+        0xa438, 0x3534, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x8087, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0x1349, 0xa436, 0xad06, 0xa438, 0x0555, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xa0a7, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0x1389, 0xa436, 0xad06,
+        0xa438, 0x1576, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0xc0c7, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0x13c9, 0xa436, 0xad06, 0xa438, 0x2517, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xe0e7, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0x140b, 0xa436, 0xad06,
+        0xa438, 0x3534, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x0107, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0x144b, 0xa436, 0xad06, 0xa438, 0x0555, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x2127, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0x148b, 0xa436, 0xad06,
+        0xa438, 0x1576, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x4147, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0x14cb, 0xa436, 0xad06, 0xa438, 0x2417, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x6167, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0x5109, 0xa436, 0xad06,
+        0xa438, 0x3434, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x8287, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0x5149, 0xa436, 0xad06, 0xa438, 0x0455, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xa2a7, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0x5189, 0xa436, 0xad06,
+        0xa438, 0x1476, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0xc2c7, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0x51c9, 0xa436, 0xad06, 0xa438, 0x2417, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xe2e7, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0x5009, 0xa436, 0xad06,
+        0xa438, 0x3434, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x0a0f, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0x5049, 0xa436, 0xad06, 0xa438, 0x0455, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x2a2f, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0x5089, 0xa436, 0xad06,
+        0xa438, 0x1476, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x4a4f, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0x50c9, 0xa436, 0xad06, 0xa438, 0x2517, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x6a6f, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0x5209, 0xa436, 0xad06,
+        0xa438, 0x3534, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x080f, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0x5249, 0xa436, 0xad06, 0xa438, 0x0555, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x282f, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0x5289, 0xa436, 0xad06,
+        0xa438, 0x1576, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x484f, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0x52c9, 0xa436, 0xad06, 0xa438, 0x2517, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x686f, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0x5309, 0xa436, 0xad06,
+        0xa438, 0x3534, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x888f, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0x5349, 0xa436, 0xad06, 0xa438, 0x0555, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xa8af, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0x5389, 0xa436, 0xad06,
+        0xa438, 0x1576, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0xc8cf, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0x53c9, 0xa436, 0xad06, 0xa438, 0x2517, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xe8ef, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0x550b, 0xa436, 0xad06,
+        0xa438, 0x3534, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x090f, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0x554b, 0xa436, 0xad06, 0xa438, 0x0555, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x292f, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0x558b, 0xa436, 0xad06,
+        0xa438, 0x1576, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x494f, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0x55cb, 0xa436, 0xad06, 0xa438, 0x2417, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x696f, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0x9209, 0xa436, 0xad06,
+        0xa438, 0x3434, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x8a8f, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0x9249, 0xa436, 0xad06, 0xa438, 0x0455, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xaaaf, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0x9289, 0xa436, 0xad06,
+        0xa438, 0x1476, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0xcacf, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0x92c9, 0xa436, 0xad06, 0xa438, 0x2417, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xeaef, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0x9009, 0xa436, 0xad06,
+        0xa438, 0x3434, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x1217, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0x9049, 0xa436, 0xad06, 0xa438, 0x0455, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x3237, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0x9089, 0xa436, 0xad06,
+        0xa438, 0x1476, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x5257, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0x90c9, 0xa436, 0xad06, 0xa438, 0x2517, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x7277, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0x9109, 0xa436, 0xad06,
+        0xa438, 0x3534, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x1017, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0x9149, 0xa436, 0xad06, 0xa438, 0x0555, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x3037, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0x9189, 0xa436, 0xad06,
+        0xa438, 0x1576, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x5057, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0x91c9, 0xa436, 0xad06, 0xa438, 0x2517, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x7077, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0x9309, 0xa436, 0xad06,
+        0xa438, 0x3534, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x9097, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0x9349, 0xa436, 0xad06, 0xa438, 0x0555, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xb0b7, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0x9389, 0xa436, 0xad06,
+        0xa438, 0x1576, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0xd0d7, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0x93c9, 0xa436, 0xad06, 0xa438, 0x2517, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xf0f7, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0x960b, 0xa436, 0xad06,
+        0xa438, 0x3534, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x1117, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0x964b, 0xa436, 0xad06, 0xa438, 0x0555, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x3137, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0x968b, 0xa436, 0xad06,
+        0xa438, 0x1576, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x5157, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0x96cb, 0xa436, 0xad06, 0xa438, 0x2417, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x7177, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0xd309, 0xa436, 0xad06,
+        0xa438, 0x3434, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x9297, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0xd349, 0xa436, 0xad06, 0xa438, 0x0455, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xb2b7, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0xd389, 0xa436, 0xad06,
+        0xa438, 0x1476, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0xd2d7, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0xd3c9, 0xa436, 0xad06, 0xa438, 0x2417, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xf2f7, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0xd009, 0xa436, 0xad06,
+        0xa438, 0x3434, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x1a1f, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0xd049, 0xa436, 0xad06, 0xa438, 0x0455, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x3a3f, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0xd089, 0xa436, 0xad06,
+        0xa438, 0x1476, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x5a5f, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0xd0c9, 0xa436, 0xad06, 0xa438, 0x2517, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x7a7f, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0xd109, 0xa436, 0xad06,
+        0xa438, 0x3534, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x181f, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0xd149, 0xa436, 0xad06, 0xa438, 0x0555, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x383f, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0xd189, 0xa436, 0xad06,
+        0xa438, 0x1576, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x585f, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0xd1c9, 0xa436, 0xad06, 0xa438, 0x2517, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x787f, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0xd209, 0xa436, 0xad06,
+        0xa438, 0x3534, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x989f, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0xd249, 0xa436, 0xad06, 0xa438, 0x0555, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xb8bf, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0xd289, 0xa436, 0xad06,
+        0xa438, 0x1576, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0xd8df, 0xa436, 0xad02, 0xa438, 0xffe0, 0xa436, 0xad04,
+        0xa438, 0xd2c9, 0xa436, 0xad06, 0xa438, 0x2517, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xf8ff, 0xa436, 0xad02,
+        0xa438, 0xffe0, 0xa436, 0xad04, 0xa438, 0xd70b, 0xa436, 0xad06,
+        0xa438, 0x3534, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x191f, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0xd74b, 0xa436, 0xad06, 0xa438, 0x0555, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x393f, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0xd78b, 0xa436, 0xad06,
+        0xa438, 0x1576, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x595f, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0xd7cb, 0xa436, 0xad06, 0xa438, 0x2417, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0x797f, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0x000d, 0xa436, 0xad06,
+        0xa438, 0x3434, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x9a9f, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0x004d, 0xa436, 0xad06, 0xa438, 0x0455, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xbabf, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0x008d, 0xa436, 0xad06,
+        0xa438, 0x1476, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0xdadf, 0xa436, 0xad02, 0xa438, 0xffe2, 0xa436, 0xad04,
+        0xa438, 0x00cd, 0xa436, 0xad06, 0xa438, 0x2c17, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xfaf8, 0xa436, 0xad02,
+        0xa438, 0xffe2, 0xa436, 0xad04, 0xa438, 0x400d, 0xa436, 0xad06,
+        0xa438, 0x3c34, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x8187, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0x404d, 0xa436, 0xad06, 0xa438, 0x0c55, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xa1a7, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0x408d, 0xa436, 0xad06,
+        0xa438, 0x1c76, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0xc1c7, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0x40cd, 0xa436, 0xad06, 0xa438, 0x2c97, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xe1e7, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0x800d, 0xa436, 0xad06,
+        0xa438, 0x3cb4, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x898f, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0x804d, 0xa436, 0xad06, 0xa438, 0x0cd5, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xa9af, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0x808d, 0xa436, 0xad06,
+        0xa438, 0x1cf6, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0xc9cf, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0x80cd, 0xa436, 0xad06, 0xa438, 0x2d17, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xe9ef, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0xc00d, 0xa436, 0xad06,
+        0xa438, 0x3d34, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x9197, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0xc04d, 0xa436, 0xad06, 0xa438, 0x0d55, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xb1b7, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0xc08d, 0xa436, 0xad06,
+        0xa438, 0x1d76, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0xd1d7, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0xc0cd, 0xa436, 0xad06, 0xa438, 0x2d97, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xf1f7, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0x3dbf, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0x999f, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0x0ddf, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xb9bf, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0x1dff, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0xd9df, 0xa436, 0xad02, 0xa438, 0xffe1, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0x2fff, 0xa436, 0xad08,
+        0xa438, 0x0002, 0xa436, 0xad00, 0xa438, 0xf9ff, 0xa436, 0xad02,
+        0xa438, 0xffe1, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0x3fff, 0xa436, 0xad08, 0xa438, 0x0002, 0xa436, 0xad00,
+        0xa438, 0xd7ff, 0xa436, 0xad02, 0xa438, 0xffe7, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xf7ff, 0xa436, 0xad02,
+        0xa438, 0xffe7, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x17ff, 0xa436, 0xad02, 0xa438, 0xffe7, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x37ff, 0xa436, 0xad02,
+        0xa438, 0x3d67, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x57ff, 0xa436, 0xad02, 0xa438, 0x3f67, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x77ff, 0xa436, 0xad02,
+        0xa438, 0x3167, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x97ff, 0xa436, 0xad02, 0xa438, 0x3367, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xb7ff, 0xa436, 0xad02,
+        0xa438, 0x3567, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xdfff, 0xa436, 0xad02, 0xa438, 0x3767, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0x3967, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x1fff, 0xa436, 0xad02, 0xa438, 0x3b67, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x3fff, 0xa436, 0xad02,
+        0xa438, 0x3de7, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x5fff, 0xa436, 0xad02, 0xa438, 0x3fe7, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x7fff, 0xa436, 0xad02,
+        0xa438, 0x31e7, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x9fff, 0xa436, 0xad02, 0xa438, 0x33e7, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xbfff, 0xa436, 0xad02,
+        0xa438, 0x35e7, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x07ff, 0xa436, 0xad02, 0xa438, 0x37e6, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x27ff, 0xa436, 0xad02,
+        0xa438, 0x39e6, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x47ff, 0xa436, 0xad02, 0xa438, 0x3be6, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x67ff, 0xa436, 0xad02,
+        0xa438, 0x2066, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x07ff, 0xa436, 0xad02, 0xa438, 0x2264, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x27ff, 0xa436, 0xad02,
+        0xa438, 0x2464, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x47ff, 0xa436, 0xad02, 0xa438, 0x2664, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x67ff, 0xa436, 0xad02,
+        0xa438, 0x0064, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x87ff, 0xa436, 0xad02, 0xa438, 0x0264, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xa7ff, 0xa436, 0xad02,
+        0xa438, 0x0464, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xc7ff, 0xa436, 0xad02, 0xa438, 0x0664, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xe7ff, 0xa436, 0xad02,
+        0xa438, 0x0864, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x07ff, 0xa436, 0xad02, 0xa438, 0x0a65, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x27ff, 0xa436, 0xad02,
+        0xa438, 0x0c65, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x47ff, 0xa436, 0xad02, 0xa438, 0x0e65, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x67ff, 0xa436, 0xad02,
+        0xa438, 0x1065, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x87ff, 0xa436, 0xad02, 0xa438, 0x1266, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xa7ff, 0xa436, 0xad02,
+        0xa438, 0x1466, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xc7ff, 0xa436, 0xad02, 0xa438, 0x1666, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xe7ff, 0xa436, 0xad02,
+        0xa438, 0x2866, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x0fff, 0xa436, 0xad02, 0xa438, 0x2a66, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x2fff, 0xa436, 0xad02,
+        0xa438, 0x2c66, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x4fff, 0xa436, 0xad02, 0xa438, 0x2e66, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x6fff, 0xa436, 0xad02,
+        0xa438, 0x20e6, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x0fff, 0xa436, 0xad02, 0xa438, 0x22e4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x2fff, 0xa436, 0xad02,
+        0xa438, 0x24e4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x4fff, 0xa436, 0xad02, 0xa438, 0x26e4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x6fff, 0xa436, 0xad02,
+        0xa438, 0x00e4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x8fff, 0xa436, 0xad02, 0xa438, 0x02e4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xafff, 0xa436, 0xad02,
+        0xa438, 0x04e4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xcfff, 0xa436, 0xad02, 0xa438, 0x06e4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xefff, 0xa436, 0xad02,
+        0xa438, 0x08e4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x0fff, 0xa436, 0xad02, 0xa438, 0x0ae5, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x2fff, 0xa436, 0xad02,
+        0xa438, 0x0ce5, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x4fff, 0xa436, 0xad02, 0xa438, 0x0ee5, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x6fff, 0xa436, 0xad02,
+        0xa438, 0x10e5, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x8fff, 0xa436, 0xad02, 0xa438, 0x12e6, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xafff, 0xa436, 0xad02,
+        0xa438, 0x14e6, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xcfff, 0xa436, 0xad02, 0xa438, 0x16e6, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xefff, 0xa436, 0xad02,
+        0xa438, 0x28e6, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x17ff, 0xa436, 0xad02, 0xa438, 0x2ae6, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x37ff, 0xa436, 0xad02,
+        0xa438, 0x2ce6, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x57ff, 0xa436, 0xad02, 0xa438, 0x2ee6, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x77ff, 0xa436, 0xad02,
+        0xa438, 0x2166, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x17ff, 0xa436, 0xad02, 0xa438, 0x2364, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x37ff, 0xa436, 0xad02,
+        0xa438, 0x2564, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x57ff, 0xa436, 0xad02, 0xa438, 0x2764, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x77ff, 0xa436, 0xad02,
+        0xa438, 0x0164, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x97ff, 0xa436, 0xad02, 0xa438, 0x0364, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xb7ff, 0xa436, 0xad02,
+        0xa438, 0x0564, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xd7ff, 0xa436, 0xad02, 0xa438, 0x0764, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xf7ff, 0xa436, 0xad02,
+        0xa438, 0x0964, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x17ff, 0xa436, 0xad02, 0xa438, 0x0b65, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x37ff, 0xa436, 0xad02,
+        0xa438, 0x0d65, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x57ff, 0xa436, 0xad02, 0xa438, 0x0f65, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x77ff, 0xa436, 0xad02,
+        0xa438, 0x1165, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x97ff, 0xa436, 0xad02, 0xa438, 0x1366, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xb7ff, 0xa436, 0xad02,
+        0xa438, 0x1566, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xd7ff, 0xa436, 0xad02, 0xa438, 0x1766, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xf7ff, 0xa436, 0xad02,
+        0xa438, 0x2966, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x1fff, 0xa436, 0xad02, 0xa438, 0x2b66, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x3fff, 0xa436, 0xad02,
+        0xa438, 0x2d66, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x5fff, 0xa436, 0xad02, 0xa438, 0x2f66, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x7fff, 0xa436, 0xad02,
+        0xa438, 0x21e6, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x1fff, 0xa436, 0xad02, 0xa438, 0x23e4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x3fff, 0xa436, 0xad02,
+        0xa438, 0x25e4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x5fff, 0xa436, 0xad02, 0xa438, 0x27e4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x7fff, 0xa436, 0xad02,
+        0xa438, 0x01e4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x9fff, 0xa436, 0xad02, 0xa438, 0x03e4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xbfff, 0xa436, 0xad02,
+        0xa438, 0x05e4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xdfff, 0xa436, 0xad02, 0xa438, 0x07e4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0x09e4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x1fff, 0xa436, 0xad02, 0xa438, 0x0be5, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x3fff, 0xa436, 0xad02,
+        0xa438, 0x0de5, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x5fff, 0xa436, 0xad02, 0xa438, 0x0fe5, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x7fff, 0xa436, 0xad02,
+        0xa438, 0x11e5, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x9fff, 0xa436, 0xad02, 0xa438, 0x13e6, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xbfff, 0xa436, 0xad02,
+        0xa438, 0x15e6, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xdfff, 0xa436, 0xad02, 0xa438, 0x17e6, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0x29e6, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x87ff, 0xa436, 0xad02, 0xa438, 0x2be5, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xa7ff, 0xa436, 0xad02,
+        0xa438, 0x2de5, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xc7ff, 0xa436, 0xad02, 0xa438, 0x2fe5, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xe7ff, 0xa436, 0xad02,
+        0xa438, 0x1865, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x8fff, 0xa436, 0xad02, 0xa438, 0x1a65, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xafff, 0xa436, 0xad02,
+        0xa438, 0x1c65, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xcfff, 0xa436, 0xad02, 0xa438, 0x1e65, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xefff, 0xa436, 0xad02,
+        0xa438, 0x18e5, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x97ff, 0xa436, 0xad02, 0xa438, 0x1ae5, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xb7ff, 0xa436, 0xad02,
+        0xa438, 0x1ce5, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xd7ff, 0xa436, 0xad02, 0xa438, 0x1ee5, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xf7ff, 0xa436, 0xad02,
+        0xa438, 0x1965, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x9fff, 0xa436, 0xad02, 0xa438, 0x1b65, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xbfff, 0xa436, 0xad02,
+        0xa438, 0x1d65, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xdfff, 0xa436, 0xad02, 0xa438, 0x1f65, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0x19e5, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x07ff, 0xa436, 0xad02, 0xa438, 0x1b9c, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x27ff, 0xa436, 0xad02,
+        0xa438, 0x1d9c, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x0fff, 0xa436, 0xad02, 0xa438, 0x1f9c, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x2fff, 0xa436, 0xad02,
+        0xa438, 0x589c, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x17ff, 0xa436, 0xad02, 0xa438, 0x5c9c, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x37ff, 0xa436, 0xad02,
+        0xa438, 0x599c, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x1fff, 0xa436, 0xad02, 0xa438, 0x5d9c, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x3fff, 0xa436, 0xad02,
+        0xa438, 0x5a9c, 0xa436, 0xad04, 0xa438, 0x100e, 0xa436, 0xad06,
+        0xa438, 0xfff6, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0x5eff, 0xa436, 0xad04,
+        0xa438, 0x104e, 0xa436, 0xad06, 0xa438, 0xfff7, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0x5bff, 0xa436, 0xad04, 0xa438, 0x110e, 0xa436, 0xad06,
+        0xa438, 0xfff6, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0x5fff, 0xa436, 0xad04,
+        0xa438, 0x114e, 0xa436, 0xad06, 0xa438, 0xf817, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xffff, 0xa436, 0xad04, 0xa438, 0x120f, 0xa436, 0xad06,
+        0xa438, 0xf836, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xc3c7, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0x124f, 0xa436, 0xad06, 0xa438, 0x0997, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0xe3e7, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0x130f, 0xa436, 0xad06,
+        0xa438, 0x19b6, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0x0307, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0x134f, 0xa436, 0xad06, 0xa438, 0x4917, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0x2327, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0x510f, 0xa436, 0xad06,
+        0xa438, 0x5936, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0x4347, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0x514f, 0xa436, 0xad06, 0xa438, 0x0997, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0x6367, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0x500f, 0xa436, 0xad06,
+        0xa438, 0x19b6, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0x8387, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0x504f, 0xa436, 0xad06, 0xa438, 0x4817, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0xa3a7, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0x520f, 0xa436, 0xad06,
+        0xa438, 0x5836, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0xcbcf, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0x524f, 0xa436, 0xad06, 0xa438, 0x0997, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0xebef, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0x530f, 0xa436, 0xad06,
+        0xa438, 0x19b6, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0x0b0f, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0x534f, 0xa436, 0xad06, 0xa438, 0x4917, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0x2b2f, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0x920f, 0xa436, 0xad06,
+        0xa438, 0x5936, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0x4b4f, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0x924f, 0xa436, 0xad06, 0xa438, 0x0997, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0x6b6f, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0x900f, 0xa436, 0xad06,
+        0xa438, 0x19b6, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0x8b8f, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0x904f, 0xa436, 0xad06, 0xa438, 0x4817, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0xabaf, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0x910f, 0xa436, 0xad06,
+        0xa438, 0x5836, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0xd3d7, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0x914f, 0xa436, 0xad06, 0xa438, 0x0997, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0xf3f7, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0x930f, 0xa436, 0xad06,
+        0xa438, 0x19b6, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0x1317, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0x934f, 0xa436, 0xad06, 0xa438, 0x4917, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0x3337, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0xd30f, 0xa436, 0xad06,
+        0xa438, 0x5936, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0x5357, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0xd34f, 0xa436, 0xad06, 0xa438, 0x0997, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0x7377, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0xd00f, 0xa436, 0xad06,
+        0xa438, 0x19b6, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0x9397, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0xd04f, 0xa436, 0xad06, 0xa438, 0x4817, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0xb3b7, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0xd10f, 0xa436, 0xad06,
+        0xa438, 0x5836, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0xdbdf, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0xd14f, 0xa436, 0xad06, 0xa438, 0x0997, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0xfbff, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0xd20f, 0xa436, 0xad06,
+        0xa438, 0x19b6, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0x1b1f, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0xd24f, 0xa436, 0xad06, 0xa438, 0x4917, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0x3b3f, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0x593f, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0x5b5f, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0x099f, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0x7b7f, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0x19bf, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0x9b9f, 0xa436, 0xad02, 0xa438, 0xffe3, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0x4fff, 0xa436, 0xad08,
+        0xa438, 0x0004, 0xa436, 0xad00, 0xa438, 0xbbbf, 0xa436, 0xad02,
+        0xa438, 0xffe3, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0x5fff, 0xa436, 0xad08, 0xa438, 0x0004, 0xa436, 0xad00,
+        0xa438, 0x07ff, 0xa436, 0xad02, 0xa438, 0xffa4, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x27ff, 0xa436, 0xad02,
+        0xa438, 0xffa4, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x47ff, 0xa436, 0xad02, 0xa438, 0xffa4, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x67ff, 0xa436, 0xad02,
+        0xa438, 0x58a4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x0fff, 0xa436, 0xad02, 0xa438, 0x5ca4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x2fff, 0xa436, 0xad02,
+        0xa438, 0x50a4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x4fff, 0xa436, 0xad02, 0xa438, 0x54a4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x6fff, 0xa436, 0xad02,
+        0xa438, 0x59a4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x17ff, 0xa436, 0xad02, 0xa438, 0x5da4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x37ff, 0xa436, 0xad02,
+        0xa438, 0x51a4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x57ff, 0xa436, 0xad02, 0xa438, 0x55a4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x77ff, 0xa436, 0xad02,
+        0xa438, 0x5aa4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x1fff, 0xa436, 0xad02, 0xa438, 0x5ea4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x3fff, 0xa436, 0xad02,
+        0xa438, 0x52a4, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0x5fff, 0xa436, 0xad02, 0xa438, 0x56a4, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0x7fff, 0xa436, 0xad02,
+        0xa438, 0x5ba4, 0xa436, 0xad04, 0xa438, 0x2a06, 0xa436, 0xad06,
+        0xa438, 0xfff6, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0x5fff, 0xa436, 0xad04,
+        0xa438, 0x2b06, 0xa436, 0xad06, 0xa438, 0xfff7, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0x53ff, 0xa436, 0xad04, 0xa438, 0x2a06, 0xa436, 0xad06,
+        0xa438, 0xfff4, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0x57ff, 0xa436, 0xad04,
+        0xa438, 0x2b06, 0xa436, 0xad06, 0xa438, 0xf615, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xffff, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0xf63f, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xffff, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0x069f, 0xa436, 0xad08,
+        0xa438, 0x0003, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xffff, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0x16bf, 0xa436, 0xad08, 0xa438, 0x0003, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xffff, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0x4fff, 0xa436, 0xad08,
+        0xa438, 0x0003, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xd0ff, 0xa436, 0xad04, 0xa438, 0x6a46, 0xa436, 0xad06,
+        0xa438, 0x5ff6, 0xa436, 0xad08, 0xa438, 0x0003, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xd4ff, 0xa436, 0xad04,
+        0xa438, 0x6b46, 0xa436, 0xad06, 0xa438, 0xfff7, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xd8ff, 0xa436, 0xad04, 0xa438, 0x6a46, 0xa436, 0xad06,
+        0xa438, 0xfff4, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xdcff, 0xa436, 0xad04,
+        0xa438, 0x6b46, 0xa436, 0xad06, 0xa438, 0xf615, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xffff, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0xf63f, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xffff, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0x069f, 0xa436, 0xad08,
+        0xa438, 0x0003, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xffff, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0x16bf, 0xa436, 0xad08, 0xa438, 0x0003, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xffff, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0x4fff, 0xa436, 0xad08,
+        0xa438, 0x0003, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xd1ff, 0xa436, 0xad04, 0xa438, 0xaa86, 0xa436, 0xad06,
+        0xa438, 0x5ff6, 0xa436, 0xad08, 0xa438, 0x0003, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xd5ff, 0xa436, 0xad04,
+        0xa438, 0xab86, 0xa436, 0xad06, 0xa438, 0xfff7, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xd9ff, 0xa436, 0xad04, 0xa438, 0xaa86, 0xa436, 0xad06,
+        0xa438, 0xfff4, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xddff, 0xa436, 0xad04,
+        0xa438, 0xab86, 0xa436, 0xad06, 0xa438, 0xf615, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xffff, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0xf63f, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xffff, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0x069f, 0xa436, 0xad08,
+        0xa438, 0x0003, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xffff, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0x16bf, 0xa436, 0xad08, 0xa438, 0x0003, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xffff, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0x4fff, 0xa436, 0xad08,
+        0xa438, 0x0003, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xd2ff, 0xa436, 0xad04, 0xa438, 0xeac6, 0xa436, 0xad06,
+        0xa438, 0x5ff6, 0xa436, 0xad08, 0xa438, 0x0003, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xd6ff, 0xa436, 0xad04,
+        0xa438, 0xebc6, 0xa436, 0xad06, 0xa438, 0xfff7, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xdaff, 0xa436, 0xad04, 0xa438, 0xeac6, 0xa436, 0xad06,
+        0xa438, 0xfff4, 0xa436, 0xad08, 0xa438, 0x0007, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xdeff, 0xa436, 0xad04,
+        0xa438, 0xebc6, 0xa436, 0xad06, 0xa438, 0xf615, 0xa436, 0xad08,
+        0xa438, 0x0007, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xffff, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0xf63f, 0xa436, 0xad08, 0xa438, 0x0017, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xffff, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0x069f, 0xa436, 0xad08,
+        0xa438, 0x0013, 0xa436, 0xad00, 0xa438, 0xffff, 0xa436, 0xad02,
+        0xa438, 0xffff, 0xa436, 0xad04, 0xa438, 0xffff, 0xa436, 0xad06,
+        0xa438, 0x16bf, 0xa436, 0xad08, 0xa438, 0x0013, 0xa436, 0xad00,
+        0xa438, 0xffff, 0xa436, 0xad02, 0xa438, 0xffff, 0xa436, 0xad04,
+        0xa438, 0xffff, 0xa436, 0xad06, 0xa438, 0x4fff, 0xa436, 0xad08,
+        0xa438, 0x0013, 0xa436, 0xad00, 0xa438, 0xfffa, 0xa436, 0xad02,
+        0xa438, 0xd3ff, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0x5fff, 0xa436, 0xad08, 0xa438, 0x0013, 0xa436, 0xad00,
+        0xa438, 0xc7ff, 0xa436, 0xad02, 0xa438, 0xd7e7, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0017, 0xa436, 0xad00, 0xa438, 0xe7ff, 0xa436, 0xad02,
+        0xa438, 0xdbe7, 0xa436, 0xad04, 0xa438, 0xfffe, 0xa436, 0xad06,
+        0xa438, 0xffff, 0xa436, 0xad08, 0xa438, 0x0017, 0xa436, 0xad00,
+        0xa438, 0x07ff, 0xa436, 0xad02, 0xa438, 0xdfe7, 0xa436, 0xad04,
+        0xa438, 0xfffe, 0xa436, 0xad06, 0xa438, 0xffff, 0xa436, 0xad08,
+        0xa438, 0x0017, 0xa436, 0xacfc, 0xa438, 0x0000, 0xa436, 0xaccc,
+        0xa438, 0x2000, 0xa436, 0xacce, 0xa438, 0x6000, 0xa436, 0xaccc,
+        0xa438, 0x2001, 0xa436, 0xacce, 0xa438, 0x6008, 0xa436, 0xaccc,
+        0xa438, 0x2002, 0xa436, 0xacce, 0xa438, 0x6010, 0xa436, 0xaccc,
+        0xa438, 0x2003, 0xa436, 0xacce, 0xa438, 0x6020, 0xa436, 0xaccc,
+        0xa438, 0x2004, 0xa436, 0xacce, 0xa438, 0x6060, 0xa436, 0xaccc,
+        0xa438, 0x2005, 0xa436, 0xacce, 0xa438, 0x60a0, 0xa436, 0xaccc,
+        0xa438, 0x2006, 0xa436, 0xacce, 0xa438, 0x60e0, 0xa436, 0xaccc,
+        0xa438, 0x2007, 0xa436, 0xacce, 0xa438, 0x6128, 0xa436, 0xaccc,
+        0xa438, 0x2008, 0xa436, 0xacce, 0xa438, 0x6178, 0xa436, 0xaccc,
+        0xa438, 0x2009, 0xa436, 0xacce, 0xa438, 0x61a8, 0xa436, 0xaccc,
+        0xa438, 0x200a, 0xa436, 0xacce, 0xa438, 0x61f0, 0xa436, 0xaccc,
+        0xa438, 0x200b, 0xa436, 0xacce, 0xa438, 0x6248, 0xa436, 0xaccc,
+        0xa438, 0x200c, 0xa436, 0xacce, 0xa438, 0x6258, 0xa436, 0xaccc,
+        0xa438, 0x200d, 0xa436, 0xacce, 0xa438, 0x6268, 0xa436, 0xaccc,
+        0xa438, 0x200e, 0xa436, 0xacce, 0xa438, 0x6270, 0xa436, 0xaccc,
+        0xa438, 0x200f, 0xa436, 0xacce, 0xa438, 0x6274, 0xa436, 0xaccc,
+        0xa438, 0x2010, 0xa436, 0xacce, 0xa438, 0x627c, 0xa436, 0xaccc,
+        0xa438, 0x2011, 0xa436, 0xacce, 0xa438, 0x6284, 0xa436, 0xaccc,
+        0xa438, 0x2012, 0xa436, 0xacce, 0xa438, 0x6294, 0xa436, 0xaccc,
+        0xa438, 0x2013, 0xa436, 0xacce, 0xa438, 0x629c, 0xa436, 0xaccc,
+        0xa438, 0x2014, 0xa436, 0xacce, 0xa438, 0x62ac, 0xa436, 0xaccc,
+        0xa438, 0x2015, 0xa436, 0xacce, 0xa438, 0x62bc, 0xa436, 0xaccc,
+        0xa438, 0x2016, 0xa436, 0xacce, 0xa438, 0x62c4, 0xa436, 0xaccc,
+        0xa438, 0x2017, 0xa436, 0xacce, 0xa438, 0x7000, 0xa436, 0xaccc,
+        0xa438, 0x2018, 0xa436, 0xacce, 0xa438, 0x6000, 0xa436, 0xaccc,
+        0xa438, 0x2019, 0xa436, 0xacce, 0xa438, 0x6000, 0xa436, 0xaccc,
+        0xa438, 0x201a, 0xa436, 0xacce, 0xa438, 0x6000, 0xa436, 0xaccc,
+        0xa438, 0x201b, 0xa436, 0xacce, 0xa438, 0x6000, 0xa436, 0xaccc,
+        0xa438, 0x201c, 0xa436, 0xacce, 0xa438, 0x6000, 0xa436, 0xaccc,
+        0xa438, 0x201d, 0xa436, 0xacce, 0xa438, 0x6000, 0xa436, 0xaccc,
+        0xa438, 0x201e, 0xa436, 0xacce, 0xa438, 0x6000, 0xa436, 0xaccc,
+        0xa438, 0x201f, 0xa436, 0xacce, 0xa438, 0x6000, 0xa436, 0xacce,
+        0xa438, 0x0000, 0xa436, 0x0000, 0xa438, 0x0000, 0xb82e, 0x0000,
+        0xa436, 0x8023, 0xa438, 0x0000, 0xa436, 0x801E, 0xa438, 0x0027,
+        0xB820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8126a_2_3[] = {
+        0xb892, 0x0000, 0xb88e, 0xC15C, 0xb890, 0x0303, 0xb890, 0x0506,
+        0xb890, 0x0807, 0xb890, 0x090B, 0xb890, 0x0E12, 0xb890, 0x1617,
+        0xb890, 0x1C24, 0xb890, 0x2B37, 0xb890, 0x0203, 0xb890, 0x0304,
+        0xb890, 0x0504, 0xb890, 0x0506, 0xb890, 0x0708, 0xb890, 0x090A,
+        0xb890, 0x0B0E, 0xb890, 0x1013, 0xb890, 0x1519, 0xb890, 0x1D22,
+        0xb890, 0x282E, 0xb890, 0x363E, 0xb890, 0x474B, 0xb88e, 0xC196,
+        0xb890, 0x3F5E, 0xb890, 0xF834, 0xb890, 0x6C01, 0xb890, 0xA67F,
+        0xb890, 0xA06C, 0xb890, 0x043B, 0xb890, 0x6190, 0xb890, 0x88DB,
+        0xb890, 0x9ECD, 0xb890, 0x4DBC, 0xb890, 0x6E0E, 0xb890, 0x9F2D,
+        0xb890, 0x2C18, 0xb890, 0x5E8C, 0xb890, 0x5BFE, 0xb890, 0x183C,
+        0xb890, 0x23C9, 0xb890, 0x3E84, 0xb890, 0x3C20, 0xb890, 0xCC56,
+        0xb890, 0x3480, 0xb890, 0x0040, 0xb88e, 0xC00F, 0xb890, 0x3502,
+        0xb890, 0x0203, 0xb890, 0x0303, 0xb890, 0x0404, 0xb890, 0x0506,
+        0xb890, 0x0607, 0xb890, 0x080A, 0xb890, 0x0B0D, 0xb890, 0x0E10,
+        0xb890, 0x1114, 0xb890, 0x171B, 0xb890, 0x1F22, 0xb890, 0x2832,
+        0xb890, 0x0101, 0xb890, 0x0101, 0xb890, 0x0202, 0xb890, 0x0303,
+        0xb890, 0x0404, 0xb890, 0x0506, 0xb890, 0x0709, 0xb890, 0x0A0D,
+        0xb88e, 0xC047, 0xb890, 0x365F, 0xb890, 0xBE10, 0xb890, 0x84E4,
+        0xb890, 0x60E9, 0xb890, 0xA86A, 0xb890, 0xF1E3, 0xb890, 0xF73F,
+        0xb890, 0x5C02, 0xb890, 0x9547, 0xb890, 0xC30C, 0xb890, 0xB064,
+        0xb890, 0x079A, 0xb890, 0x1E23, 0xb890, 0x1B5D, 0xb890, 0x92E7,
+        0xb890, 0x4BAF, 0xb890, 0x2386, 0xb890, 0x01B6, 0xb890, 0x6F82,
+        0xb890, 0xDC1C, 0xb890, 0x8C92, 0xb88e, 0xC110, 0xb890, 0x0C7F,
+        0xb890, 0x1014, 0xb890, 0x231D, 0xb890, 0x2023, 0xb890, 0x2628,
+        0xb890, 0x2A2D, 0xb890, 0x2D2C, 0xb890, 0x2C2E, 0xb890, 0x320D,
+        0xb88e, 0xC186, 0xb890, 0x0306, 0xb890, 0x0804, 0xb890, 0x0406,
+        0xb890, 0x0707, 0xb890, 0x0709, 0xb890, 0x0B0F, 0xb890, 0x161D,
+        0xb890, 0x202A, 0xb890, 0x3F5E, 0xb88e, 0xC1C1, 0xb890, 0x0040,
+        0xb890, 0x5920, 0xb890, 0x88CD, 0xb890, 0x1CA1, 0xb890, 0x3D20,
+        0xb890, 0x3AE4, 0xb890, 0x6A43, 0xb890, 0x30AF, 0xb890, 0xDD16,
+        0xb88e, 0xC283, 0xb890, 0x1611, 0xb890, 0x161C, 0xb890, 0x2127,
+        0xb890, 0x2C32, 0xb890, 0x373D, 0xb890, 0x4247, 0xb890, 0x4D52,
+        0xb890, 0x585A, 0xb890, 0x0004, 0xb890, 0x080C, 0xb890, 0x1014,
+        0xb890, 0x181B, 0xb890, 0x1F23, 0xb890, 0x272B, 0xb890, 0x2F33,
+        0xb890, 0x363A, 0xb890, 0x3E42, 0xb890, 0x464A, 0xb890, 0x4D51,
+        0xb890, 0x5559, 0xb890, 0x5D65, 0xb890, 0xE769, 0xb890, 0xEB56,
+        0xb890, 0xC04B, 0xb890, 0xD502, 0xb890, 0x2FB1, 0xb890, 0x33B5,
+        0xb890, 0x37F8, 0xb890, 0xBB98, 0xb890, 0x7450, 0xb890, 0x4C48,
+        0xb890, 0x12DC, 0xb890, 0xDCDC, 0xb890, 0x934A, 0xb890, 0x3E33,
+        0xb890, 0xE496, 0xb890, 0x724E, 0xb890, 0x2B07, 0xb890, 0xE4C0,
+        0xb890, 0x9C79, 0xb890, 0x5512, 0xb88e, 0xC212, 0xb890, 0x2020,
+        0xb890, 0x2020, 0xb890, 0x2020, 0xb890, 0x2020, 0xb890, 0x2020,
+        0xb890, 0x2019, 0xb88e, 0xC24D, 0xb890, 0x8400, 0xb890, 0x0000,
+        0xb890, 0x0000, 0xb890, 0x0000, 0xb890, 0x0000, 0xb890, 0x0000,
+        0xb88e, 0xC2D3, 0xb890, 0x5524, 0xb890, 0x2526, 0xb890, 0x2728,
+        0xb88e, 0xC2E3, 0xb890, 0x3323, 0xb890, 0x2324, 0xb890, 0x2425,
+        0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8126a_3_1[] = {
+        0xa436, 0x8023, 0xa438, 0x4701, 0xa436, 0xB82E, 0xa438, 0x0001,
+        0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x801a, 0xa438, 0x1800, 0xa438, 0x802a,
+        0xa438, 0x1800, 0xa438, 0x8032, 0xa438, 0x1800, 0xa438, 0x803a,
+        0xa438, 0x1800, 0xa438, 0x803e, 0xa438, 0x1800, 0xa438, 0x8044,
+        0xa438, 0x1800, 0xa438, 0x804b, 0xa438, 0xd504, 0xa438, 0xc9b5,
+        0xa438, 0xd500, 0xa438, 0xd707, 0xa438, 0x4070, 0xa438, 0x1800,
+        0xa438, 0x1082, 0xa438, 0xd504, 0xa438, 0x1800, 0xa438, 0x107a,
+        0xa438, 0x61d0, 0xa438, 0xd701, 0xa438, 0x60a5, 0xa438, 0xd504,
+        0xa438, 0xc9b2, 0xa438, 0xd500, 0xa438, 0xf004, 0xa438, 0xd504,
+        0xa438, 0xc9b1, 0xa438, 0xd500, 0xa438, 0xd707, 0xa438, 0x6070,
+        0xa438, 0x1800, 0xa438, 0x10b0, 0xa438, 0x1800, 0xa438, 0x10c5,
+        0xa438, 0xd707, 0xa438, 0x2005, 0xa438, 0x8030, 0xa438, 0xd75e,
+        0xa438, 0x1800, 0xa438, 0x138c, 0xa438, 0x1800, 0xa438, 0x13ff,
+        0xa438, 0xc504, 0xa438, 0xce20, 0xa438, 0xcf01, 0xa438, 0xd70a,
+        0xa438, 0x4005, 0xa438, 0xcf02, 0xa438, 0x1800, 0xa438, 0x1b99,
+        0xa438, 0xa980, 0xa438, 0xd500, 0xa438, 0x1800, 0xa438, 0x144d,
+        0xa438, 0x907f, 0xa438, 0x91a3, 0xa438, 0x9306, 0xa438, 0xb118,
+        0xa438, 0x1800, 0xa438, 0x2147, 0xa438, 0x907f, 0xa438, 0x9209,
+        0xa438, 0x91a3, 0xa438, 0x9306, 0xa438, 0xb118, 0xa438, 0x1800,
+        0xa438, 0x203c, 0xa438, 0xd707, 0xa438, 0x4121, 0xa438, 0xd706,
+        0xa438, 0x40fc, 0xa438, 0xd70a, 0xa438, 0x40b5, 0xa438, 0xd028,
+        0xa438, 0xd1c1, 0xa438, 0x1800, 0xa438, 0x8057, 0xa438, 0xd07b,
+        0xa438, 0xd1c5, 0xa438, 0xd503, 0xa438, 0xa108, 0xa438, 0xd505,
+        0xa438, 0x8103, 0xa438, 0xd504, 0xa438, 0xa002, 0xa438, 0xa302,
+        0xa438, 0xd707, 0xa438, 0x4061, 0xa438, 0xd503, 0xa438, 0x8b01,
+        0xa438, 0xd500, 0xa438, 0xc48a, 0xa438, 0xd503, 0xa438, 0xcc09,
+        0xa438, 0xcd58, 0xa438, 0xaf01, 0xa438, 0xd500, 0xa438, 0xbe10,
+        0xa438, 0x1000, 0xa438, 0x1739, 0xa438, 0xd719, 0xa438, 0x606c,
+        0xa438, 0xd704, 0xa438, 0x645c, 0xa438, 0xd75e, 0xa438, 0x604d,
+        0xa438, 0xfff8, 0xa438, 0x9e10, 0xa438, 0x1000, 0xa438, 0x1739,
+        0xa438, 0xd719, 0xa438, 0x606c, 0xa438, 0xd704, 0xa438, 0x631c,
+        0xa438, 0xd75e, 0xa438, 0x404d, 0xa438, 0xfff8, 0xa438, 0xd504,
+        0xa438, 0xaa18, 0xa438, 0xa001, 0xa438, 0xa1e0, 0xa438, 0xd500,
+        0xa438, 0x1000, 0xa438, 0x1739, 0xa438, 0xd719, 0xa438, 0x7fac,
+        0xa438, 0xd504, 0xa438, 0xa001, 0xa438, 0xd500, 0xa438, 0x1000,
+        0xa438, 0x1739, 0xa438, 0xd704, 0xa438, 0x5f5c, 0xa438, 0xd719,
+        0xa438, 0x3aaf, 0xa438, 0x8091, 0xa438, 0xf016, 0xa438, 0xd707,
+        0xa438, 0x6121, 0xa438, 0x1000, 0xa438, 0x16d8, 0xa438, 0xd503,
+        0xa438, 0xcd59, 0xa438, 0xaf01, 0xa438, 0xd500, 0xa438, 0x1800,
+        0xa438, 0x0ddc, 0xa438, 0xd503, 0xa438, 0x8040, 0xa438, 0xd500,
+        0xa438, 0x1000, 0xa438, 0x16d8, 0xa438, 0xd503, 0xa438, 0xcd5a,
+        0xa438, 0xaf01, 0xa438, 0xd500, 0xa438, 0x1800, 0xa438, 0x0dbf,
+        0xa438, 0xd504, 0xa438, 0xa008, 0xa438, 0xa204, 0xa438, 0xd500,
+        0xa438, 0x1000, 0xa438, 0x1739, 0xa438, 0xd701, 0xa438, 0x5fa0,
+        0xa438, 0xd503, 0xa438, 0xa082, 0xa438, 0xd500, 0xa438, 0xd71e,
+        0xa438, 0x4097, 0xa438, 0xd078, 0xa438, 0xd1aa, 0xa438, 0xf003,
+        0xa438, 0xd078, 0xa438, 0xd1aa, 0xa438, 0xd707, 0xa438, 0x40c1,
+        0xa438, 0xd706, 0xa438, 0x409c, 0xa438, 0xd70a, 0xa438, 0x4055,
+        0xa438, 0xf010, 0xa438, 0xd706, 0xa438, 0x6065, 0xa438, 0xcc89,
+        0xa438, 0xf002, 0xa438, 0xcc8b, 0xa438, 0x1000, 0xa438, 0x0b7b,
+        0xa438, 0xd705, 0xa438, 0x2ad0, 0xa438, 0x80ca, 0xa438, 0xf003,
+        0xa438, 0x1000, 0xa438, 0x0b81, 0xa438, 0x1000, 0xa438, 0x0b87,
+        0xa438, 0x1000, 0xa438, 0x0c53, 0xa438, 0x1800, 0xa438, 0x12d7,
+        0xa436, 0xA026, 0xa438, 0x125d, 0xa436, 0xA024, 0xa438, 0x2033,
+        0xa436, 0xA022, 0xa438, 0x213f, 0xa436, 0xA020, 0xa438, 0x144c,
+        0xa436, 0xA006, 0xa438, 0x1b98, 0xa436, 0xA004, 0xa438, 0x138b,
+        0xa436, 0xA002, 0xa438, 0x10c4, 0xa436, 0xA000, 0xa438, 0x1079,
+        0xa436, 0xA008, 0xa438, 0xff00, 0xa436, 0xA016, 0xa438, 0x0000,
+        0xa436, 0xA012, 0xa438, 0x0ff8, 0xa436, 0xA014, 0xa438, 0xd04d,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa436, 0xA152,
+        0xa438, 0x12dc, 0xa436, 0xA154, 0xa438, 0x3fff, 0xa436, 0xA156,
+        0xa438, 0x3fff, 0xa436, 0xA158, 0xa438, 0x3fff, 0xa436, 0xA15A,
+        0xa438, 0x3fff, 0xa436, 0xA15C, 0xa438, 0x3fff, 0xa436, 0xA15E,
+        0xa438, 0x3fff, 0xa436, 0xA160, 0xa438, 0x3fff, 0xa436, 0xA150,
+        0xa438, 0x0001, 0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x801a, 0xa438, 0x1800, 0xa438, 0x8022,
+        0xa438, 0x1800, 0xa438, 0x8233, 0xa438, 0x1800, 0xa438, 0x8332,
+        0xa438, 0x1800, 0xa438, 0x855f, 0xa438, 0x1800, 0xa438, 0x8619,
+        0xa438, 0x1800, 0xa438, 0x86af, 0xa438, 0xd706, 0xa438, 0x60a9,
+        0xa438, 0xd700, 0xa438, 0x60a1, 0xa438, 0x1800, 0xa438, 0x0962,
+        0xa438, 0x1800, 0xa438, 0x0962, 0xa438, 0x1800, 0xa438, 0x0982,
+        0xa438, 0x800a, 0xa438, 0x0c1f, 0xa438, 0x0d00, 0xa438, 0x8dc0,
+        0xa438, 0x1000, 0xa438, 0x12b5, 0xa438, 0x1800, 0xa438, 0x0f99,
+        0xa438, 0xd702, 0xa438, 0x6201, 0xa438, 0xd702, 0xa438, 0x40a0,
+        0xa438, 0xd70d, 0xa438, 0x419d, 0xa438, 0x1800, 0xa438, 0x802c,
+        0xa438, 0xd701, 0xa438, 0x611a, 0xa438, 0x8710, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8280, 0xa438, 0x8780, 0xa438, 0x9503,
+        0xa438, 0xf002, 0xa438, 0xa710, 0xa438, 0x9580, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xa304, 0xa438, 0x9503, 0xa438, 0x0c1f,
+        0xa438, 0x0d07, 0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x12b5,
+        0xa438, 0xcb81, 0xa438, 0xd70c, 0xa438, 0x48e2, 0xa438, 0xd706,
+        0xa438, 0x407a, 0xa438, 0xd70c, 0xa438, 0x4867, 0xa438, 0xd706,
+        0xa438, 0x405a, 0xa438, 0x8910, 0xa438, 0xa210, 0xa438, 0xd704,
+        0xa438, 0x611c, 0xa438, 0x0cc0, 0xa438, 0x0080, 0xa438, 0x0c03,
+        0xa438, 0x0101, 0xa438, 0x0ce0, 0xa438, 0x03a0, 0xa438, 0xccb5,
+        0xa438, 0x0cc0, 0xa438, 0x0080, 0xa438, 0x0c03, 0xa438, 0x0102,
+        0xa438, 0x0ce0, 0xa438, 0x0340, 0xa438, 0xcc52, 0xa438, 0xd706,
+        0xa438, 0x42da, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0c1f,
+        0xa438, 0x0f1c, 0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x126b,
+        0xa438, 0xd70c, 0xa438, 0x5fb3, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8f1f, 0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x126b,
+        0xa438, 0xd70c, 0xa438, 0x7f33, 0xa438, 0x8190, 0xa438, 0x8204,
+        0xa438, 0x1800, 0xa438, 0x8087, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x0c1f, 0xa438, 0x0f1b, 0xa438, 0x9503, 0xa438, 0x1000,
+        0xa438, 0x126b, 0xa438, 0xd70c, 0xa438, 0x5fb3, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8f1f, 0xa438, 0x9503, 0xa438, 0x1000,
+        0xa438, 0x126b, 0xa438, 0xd70c, 0xa438, 0x7f33, 0xa438, 0xd70c,
+        0xa438, 0x6067, 0xa438, 0x1800, 0xa438, 0x8087, 0xa438, 0x1800,
+        0xa438, 0x8092, 0xa438, 0xd403, 0xa438, 0x1000, 0xa438, 0x1203,
+        0xa438, 0xcb82, 0xa438, 0xd40a, 0xa438, 0x1000, 0xa438, 0x1203,
+        0xa438, 0xd70c, 0xa438, 0x4267, 0xa438, 0x1000, 0xa438, 0x131d,
+        0xa438, 0x8a40, 0xa438, 0x1000, 0xa438, 0x120e, 0xa438, 0xa104,
+        0xa438, 0x1000, 0xa438, 0x1220, 0xa438, 0x8104, 0xa438, 0x1000,
+        0xa438, 0x1217, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa704,
+        0xa438, 0x9503, 0xa438, 0xcb88, 0xa438, 0x1800, 0xa438, 0x81b7,
+        0xa438, 0xd702, 0xa438, 0x6161, 0xa438, 0xd702, 0xa438, 0x40a0,
+        0xa438, 0xd70d, 0xa438, 0x40fd, 0xa438, 0x1800, 0xa438, 0x80b0,
+        0xa438, 0xd701, 0xa438, 0x607a, 0xa438, 0x1800, 0xa438, 0x80b0,
+        0xa438, 0x1800, 0xa438, 0x81a6, 0xa438, 0xa210, 0xa438, 0x8a10,
+        0xa438, 0xd706, 0xa438, 0x643e, 0xa438, 0x0c1f, 0xa438, 0x0d04,
+        0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x12b5, 0xa438, 0x0cc0,
+        0xa438, 0x0040, 0xa438, 0x0c03, 0xa438, 0x0102, 0xa438, 0x0ce0,
+        0xa438, 0x03e0, 0xa438, 0xccce, 0xa438, 0xa00a, 0xa438, 0xa280,
+        0xa438, 0xd110, 0xa438, 0xd04c, 0xa438, 0xcba0, 0xa438, 0x1000,
+        0xa438, 0x126b, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x8710,
+        0xa438, 0xaa0f, 0xa438, 0xa130, 0xa438, 0xaa2f, 0xa438, 0xa2d5,
+        0xa438, 0xa405, 0xa438, 0xa720, 0xa438, 0xa00a, 0xa438, 0xcba1,
+        0xa438, 0x1800, 0xa438, 0x80fa, 0xa438, 0xd704, 0xa438, 0x3cf1,
+        0xa438, 0x80db, 0xa438, 0x0c1f, 0xa438, 0x0d02, 0xa438, 0x1800,
+        0xa438, 0x80dd, 0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0x0cc0,
+        0xa438, 0x0d40, 0xa438, 0x1000, 0xa438, 0x12b5, 0xa438, 0x8710,
+        0xa438, 0x1000, 0xa438, 0x120e, 0xa438, 0xa108, 0xa438, 0x1000,
+        0xa438, 0x1220, 0xa438, 0x8108, 0xa438, 0xa203, 0xa438, 0x8a2f,
+        0xa438, 0xa130, 0xa438, 0x8204, 0xa438, 0xa140, 0xa438, 0x1000,
+        0xa438, 0x1220, 0xa438, 0x8140, 0xa438, 0x1000, 0xa438, 0x1217,
+        0xa438, 0xcba2, 0xa438, 0xd17a, 0xa438, 0xd04b, 0xa438, 0x1000,
+        0xa438, 0x126b, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xa204,
+        0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd700, 0xa438, 0x5fa7,
+        0xa438, 0xb920, 0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd71f,
+        0xa438, 0x7fb4, 0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x126b,
+        0xa438, 0xd71f, 0xa438, 0x6145, 0xa438, 0x6074, 0xa438, 0x1800,
+        0xa438, 0x8104, 0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd700,
+        0xa438, 0x5fa7, 0xa438, 0x1800, 0xa438, 0x80fe, 0xa438, 0xb820,
+        0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd71f, 0xa438, 0x7fa5,
+        0xa438, 0x9820, 0xa438, 0x9b01, 0xa438, 0xd402, 0xa438, 0x1000,
+        0xa438, 0x1203, 0xa438, 0xd701, 0xa438, 0x33b1, 0xa438, 0x8124,
+        0xa438, 0xd701, 0xa438, 0x60b5, 0xa438, 0xd706, 0xa438, 0x6069,
+        0xa438, 0x1800, 0xa438, 0x8126, 0xa438, 0x1800, 0xa438, 0x8196,
+        0xa438, 0xd70c, 0xa438, 0x40ab, 0xa438, 0x800a, 0xa438, 0x8110,
+        0xa438, 0x8284, 0xa438, 0x8404, 0xa438, 0xa710, 0xa438, 0x8120,
+        0xa438, 0x8241, 0xa438, 0x1000, 0xa438, 0x120e, 0xa438, 0xa104,
+        0xa438, 0x1000, 0xa438, 0x1220, 0xa438, 0x8104, 0xa438, 0x1000,
+        0xa438, 0x1217, 0xa438, 0xaa2f, 0xa438, 0xcba3, 0xa438, 0xd70c,
+        0xa438, 0x438b, 0xa438, 0xa284, 0xa438, 0xd078, 0xa438, 0x800a,
+        0xa438, 0x8110, 0xa438, 0xa284, 0xa438, 0x8404, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xa108, 0xa438, 0x9503, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x0c1f, 0xa438, 0x0f19, 0xa438, 0x9503,
+        0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd70c, 0xa438, 0x5fb3,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8f1f, 0xa438, 0x9503,
+        0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd70c, 0xa438, 0x7f33,
+        0xa438, 0x0c1f, 0xa438, 0x0d07, 0xa438, 0x8dc0, 0xa438, 0x1000,
+        0xa438, 0x12b5, 0xa438, 0x8110, 0xa438, 0xa284, 0xa438, 0xa404,
+        0xa438, 0xa00a, 0xa438, 0xcba4, 0xa438, 0xd70c, 0xa438, 0x40a1,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xad10, 0xa438, 0x9503,
+        0xa438, 0xd70c, 0xa438, 0x414b, 0xa438, 0x0cc0, 0xa438, 0x0080,
+        0xa438, 0x0c03, 0xa438, 0x0102, 0xa438, 0x0ce0, 0xa438, 0x0340,
+        0xa438, 0xcc52, 0xa438, 0x1800, 0xa438, 0x8175, 0xa438, 0x80c0,
+        0xa438, 0x8103, 0xa438, 0x83e0, 0xa438, 0x8cff, 0xa438, 0x60ba,
+        0xa438, 0xd110, 0xa438, 0xd041, 0xa438, 0x1800, 0xa438, 0x817c,
+        0xa438, 0xd193, 0xa438, 0xd047, 0xa438, 0x1000, 0xa438, 0x126b,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xa110, 0xa438, 0xcba5,
+        0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd700, 0xa438, 0x5faa,
+        0xa438, 0xa180, 0xa438, 0xd700, 0xa438, 0x6041, 0xa438, 0xa402,
+        0xa438, 0xcba6, 0xa438, 0x60ba, 0xa438, 0xd1f5, 0xa438, 0xd045,
+        0xa438, 0x1800, 0xa438, 0x8192, 0xa438, 0xd1f5, 0xa438, 0xd049,
+        0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0x8710, 0xa438, 0xa00a, 0xa438, 0xa190, 0xa438, 0xa204,
+        0xa438, 0xa280, 0xa438, 0xa404, 0xa438, 0xcba7, 0xa438, 0xbb80,
+        0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd71f, 0xa438, 0x5fb4,
+        0xa438, 0xb920, 0xa438, 0x9b80, 0xa438, 0x1800, 0xa438, 0x81e5,
+        0xa438, 0xa210, 0xa438, 0xa00a, 0xa438, 0xaa40, 0xa438, 0x1000,
+        0xa438, 0x120e, 0xa438, 0xa104, 0xa438, 0x1000, 0xa438, 0x1220,
+        0xa438, 0x8104, 0xa438, 0x1000, 0xa438, 0x1217, 0xa438, 0xa190,
+        0xa438, 0xa284, 0xa438, 0xa404, 0xa438, 0x8a10, 0xa438, 0x8a80,
+        0xa438, 0xcb84, 0xa438, 0xd13e, 0xa438, 0xd05a, 0xa438, 0xd13e,
+        0xa438, 0xd06b, 0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd700,
+        0xa438, 0x3559, 0xa438, 0x81c2, 0xa438, 0x1800, 0xa438, 0x81bb,
+        0xa438, 0xd700, 0xa438, 0x604b, 0xa438, 0xcb8a, 0xa438, 0x1000,
+        0xa438, 0x126b, 0xa438, 0xd700, 0xa438, 0x3659, 0xa438, 0x81cc,
+        0xa438, 0x1800, 0xa438, 0x81c5, 0xa438, 0xd700, 0xa438, 0x606b,
+        0xa438, 0xcb8b, 0xa438, 0x5ecb, 0xa438, 0xd700, 0xa438, 0x6041,
+        0xa438, 0xa402, 0xa438, 0xcb8c, 0xa438, 0xd706, 0xa438, 0x60ba,
+        0xa438, 0xd179, 0xa438, 0xd049, 0xa438, 0x1800, 0xa438, 0x81dc,
+        0xa438, 0xd160, 0xa438, 0xd04b, 0xa438, 0x1000, 0xa438, 0x126b,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xcb8d, 0xa438, 0x8710,
+        0xa438, 0xd71f, 0xa438, 0x5fd4, 0xa438, 0xb920, 0xa438, 0x1000,
+        0xa438, 0x126b, 0xa438, 0xd71f, 0xa438, 0x7fb4, 0xa438, 0x9920,
+        0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd71f, 0xa438, 0x6145,
+        0xa438, 0x6074, 0xa438, 0x1800, 0xa438, 0x81ea, 0xa438, 0x1000,
+        0xa438, 0x126b, 0xa438, 0xd700, 0xa438, 0x5fab, 0xa438, 0x1800,
+        0xa438, 0x81e4, 0xa438, 0xa710, 0xa438, 0xb820, 0xa438, 0x1000,
+        0xa438, 0x126b, 0xa438, 0xd71f, 0xa438, 0x7fa5, 0xa438, 0x9820,
+        0xa438, 0xd114, 0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x126b,
+        0xa438, 0xd700, 0xa438, 0x5fba, 0xa438, 0xd704, 0xa438, 0x5f76,
+        0xa438, 0xd700, 0xa438, 0x5f34, 0xa438, 0xd700, 0xa438, 0x6081,
+        0xa438, 0xd706, 0xa438, 0x405a, 0xa438, 0xa480, 0xa438, 0xcb86,
+        0xa438, 0xd706, 0xa438, 0x60fa, 0xa438, 0xd700, 0xa438, 0x60e1,
+        0xa438, 0xd1c8, 0xa438, 0xd045, 0xa438, 0x1800, 0xa438, 0x8218,
+        0xa438, 0xd17a, 0xa438, 0xd04b, 0xa438, 0x1000, 0xa438, 0x126b,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x0cc0, 0xa438, 0x0000,
+        0xa438, 0x0c03, 0xa438, 0x0101, 0xa438, 0x0ce0, 0xa438, 0x0320,
+        0xa438, 0xcc29, 0xa438, 0xa208, 0xa438, 0x8204, 0xa438, 0xd704,
+        0xa438, 0x40f5, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa280,
+        0xa438, 0x8780, 0xa438, 0x9503, 0xa438, 0x8e04, 0xa438, 0xd114,
+        0xa438, 0xd040, 0xa438, 0xd700, 0xa438, 0x5ff4, 0xa438, 0x1800,
+        0xa438, 0x0c3e, 0xa438, 0xd706, 0xa438, 0x609d, 0xa438, 0xd417,
+        0xa438, 0x1000, 0xa438, 0x1203, 0xa438, 0x1000, 0xa438, 0x126b,
+        0xa438, 0x1000, 0xa438, 0x1289, 0xa438, 0xd700, 0xa438, 0x5f7a,
+        0xa438, 0xd704, 0xa438, 0x5f36, 0xa438, 0xd706, 0xa438, 0x6089,
+        0xa438, 0xd40c, 0xa438, 0x1000, 0xa438, 0x1203, 0xa438, 0xaa40,
+        0xa438, 0xbb10, 0xa438, 0xcb50, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa310, 0xa438, 0x9503, 0xa438, 0xcb5f, 0xa438, 0x1000,
+        0xa438, 0x126b, 0xa438, 0x1000, 0xa438, 0x1289, 0xa438, 0xd71f,
+        0xa438, 0x5f75, 0xa438, 0x8190, 0xa438, 0x82a0, 0xa438, 0x8402,
+        0xa438, 0xa404, 0xa438, 0x800a, 0xa438, 0x8718, 0xa438, 0x9b10,
+        0xa438, 0x9b20, 0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd71f,
+        0xa438, 0x7fb5, 0xa438, 0xcb51, 0xa438, 0x1000, 0xa438, 0x126b,
+        0xa438, 0xd71f, 0xa438, 0x5f94, 0xa438, 0xd706, 0xa438, 0x61a9,
+        0xa438, 0xd702, 0xa438, 0x40a1, 0xa438, 0xd706, 0xa438, 0x4079,
+        0xa438, 0xd706, 0xa438, 0x609d, 0xa438, 0xd141, 0xa438, 0xd043,
+        0xa438, 0xf006, 0xa438, 0xd101, 0xa438, 0xd040, 0xa438, 0xf003,
+        0xa438, 0xd141, 0xa438, 0xd044, 0xa438, 0x1000, 0xa438, 0x126b,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xd700, 0xa438, 0x60e5,
+        0xa438, 0xd704, 0xa438, 0x60be, 0xa438, 0xd706, 0xa438, 0x29b1,
+        0xa438, 0x8280, 0xa438, 0xf002, 0xa438, 0xa880, 0xa438, 0xa00a,
+        0xa438, 0xa190, 0xa438, 0x8220, 0xa438, 0xa280, 0xa438, 0xa404,
+        0xa438, 0xa620, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xc5aa,
+        0xa438, 0x9503, 0xa438, 0xd700, 0xa438, 0x6061, 0xa438, 0xa402,
+        0xa438, 0xa480, 0xa438, 0xcb52, 0xa438, 0x1000, 0xa438, 0x126b,
+        0xa438, 0xd700, 0xa438, 0x5fba, 0xa438, 0xd704, 0xa438, 0x5f76,
+        0xa438, 0xb920, 0xa438, 0xcb53, 0xa438, 0x1000, 0xa438, 0x126b,
+        0xa438, 0xd71f, 0xa438, 0x7fb4, 0xa438, 0x9920, 0xa438, 0xa00a,
+        0xa438, 0xa190, 0xa438, 0xa280, 0xa438, 0x8220, 0xa438, 0xa404,
+        0xa438, 0xb580, 0xa438, 0xd700, 0xa438, 0x40a1, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xa602, 0xa438, 0x9503, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xa310, 0xa438, 0x9503, 0xa438, 0xcb60,
+        0xa438, 0xd101, 0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x126b,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xaa10, 0xa438, 0xd70c,
+        0xa438, 0x2833, 0xa438, 0x82b9, 0xa438, 0xf003, 0xa438, 0x1000,
+        0xa438, 0x1330, 0xa438, 0xd70c, 0xa438, 0x40a6, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xa140, 0xa438, 0x9503, 0xa438, 0xd70c,
+        0xa438, 0x40a3, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xac20,
+        0xa438, 0x9503, 0xa438, 0xa90c, 0xa438, 0xaa80, 0xa438, 0x0c1f,
+        0xa438, 0x0d07, 0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x12b5,
+        0xa438, 0xa00a, 0xa438, 0xa190, 0xa438, 0xa280, 0xa438, 0x8220,
+        0xa438, 0xa404, 0xa438, 0xb580, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xc500, 0xa438, 0x9503, 0xa438, 0x83e0, 0xa438, 0x8e01,
+        0xa438, 0xd700, 0xa438, 0x40a1, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa602, 0xa438, 0x9503, 0xa438, 0xd14a, 0xa438, 0xd058,
+        0xa438, 0x1000, 0xa438, 0x12d7, 0xa438, 0xd70c, 0xa438, 0x4063,
+        0xa438, 0x1000, 0xa438, 0x12ea, 0xa438, 0xcb6f, 0xa438, 0x1000,
+        0xa438, 0x126b, 0xa438, 0xd704, 0xa438, 0x2e70, 0xa438, 0x8327,
+        0xa438, 0xd71f, 0xa438, 0x676e, 0xa438, 0xd704, 0xa438, 0x3868,
+        0xa438, 0x8302, 0xa438, 0xd706, 0xa438, 0x61c2, 0xa438, 0xd70c,
+        0xa438, 0x2f18, 0xa438, 0x8308, 0xa438, 0xd700, 0xa438, 0x5d35,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xc5aa, 0xa438, 0x9503,
+        0xa438, 0x0ce0, 0xa438, 0x0320, 0xa438, 0x1800, 0xa438, 0x830e,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xc5aa, 0xa438, 0x9503,
+        0xa438, 0x1800, 0xa438, 0x832e, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xc5aa, 0xa438, 0x9503, 0xa438, 0x1800, 0xa438, 0x8330,
+        0xa438, 0x1000, 0xa438, 0x12d7, 0xa438, 0xae02, 0xa438, 0xd70c,
+        0xa438, 0x4063, 0xa438, 0x1000, 0xa438, 0x12ea, 0xa438, 0xcb61,
+        0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd704, 0xa438, 0x2e70,
+        0xa438, 0x8327, 0xa438, 0xd704, 0xa438, 0x3868, 0xa438, 0x832e,
+        0xa438, 0xd706, 0xa438, 0x61e2, 0xa438, 0xd71f, 0xa438, 0x612e,
+        0xa438, 0xd70c, 0xa438, 0x2f18, 0xa438, 0x8330, 0xa438, 0x1800,
+        0xa438, 0x830e, 0xa438, 0x8e02, 0xa438, 0x1800, 0xa438, 0x0f99,
+        0xa438, 0xae04, 0xa438, 0x8310, 0xa438, 0x1800, 0xa438, 0x0e31,
+        0xa438, 0x1800, 0xa438, 0x85ac, 0xa438, 0x1800, 0xa438, 0x0e07,
+        0xa438, 0x1000, 0xa438, 0x17be, 0xa438, 0xd70c, 0xa438, 0x5fa4,
+        0xa438, 0xa706, 0xa438, 0xd70c, 0xa438, 0x404b, 0xa438, 0xa880,
+        0xa438, 0x8801, 0xa438, 0x8e01, 0xa438, 0xca50, 0xa438, 0x1000,
+        0xa438, 0x83d5, 0xa438, 0xca51, 0xa438, 0xd70e, 0xa438, 0x2210,
+        0xa438, 0x83d3, 0xa438, 0xd70c, 0xa438, 0x4084, 0xa438, 0xd705,
+        0xa438, 0x5efd, 0xa438, 0xf007, 0xa438, 0x1000, 0xa438, 0x17c2,
+        0xa438, 0xd70c, 0xa438, 0x5ce2, 0xa438, 0x1800, 0xa438, 0x1692,
+        0xa438, 0xd70c, 0xa438, 0x605a, 0xa438, 0x9a10, 0xa438, 0x8e40,
+        0xa438, 0x8404, 0xa438, 0x1000, 0xa438, 0x1827, 0xa438, 0x8e80,
+        0xa438, 0xca62, 0xa438, 0xd705, 0xa438, 0x3084, 0xa438, 0x83b5,
+        0xa438, 0xba10, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x1000,
+        0xa438, 0x84ae, 0xa438, 0x0c03, 0xa438, 0x0100, 0xa438, 0xd702,
+        0xa438, 0x4638, 0xa438, 0xd1c4, 0xa438, 0xd044, 0xa438, 0x1000,
+        0xa438, 0x17be, 0xa438, 0x1000, 0xa438, 0x17e8, 0xa438, 0xd70c,
+        0xa438, 0x5f7c, 0xa438, 0x8108, 0xa438, 0x0c1f, 0xa438, 0x0907,
+        0xa438, 0x8940, 0xa438, 0x1000, 0xa438, 0x17db, 0xa438, 0xa0c4,
+        0xa438, 0x8610, 0xa438, 0x8030, 0xa438, 0x8706, 0xa438, 0x0c07,
+        0xa438, 0x0b06, 0xa438, 0x8410, 0xa438, 0xa980, 0xa438, 0xa702,
+        0xa438, 0xd1c4, 0xa438, 0xd045, 0xa438, 0x1000, 0xa438, 0x17be,
+        0xa438, 0x1000, 0xa438, 0x17e8, 0xa438, 0xd70c, 0xa438, 0x5f7c,
+        0xa438, 0x0c07, 0xa438, 0x0b06, 0xa438, 0xa030, 0xa438, 0xa610,
+        0xa438, 0xd700, 0xa438, 0x6041, 0xa438, 0xa501, 0xa438, 0xa108,
+        0xa438, 0xd1c4, 0xa438, 0xd045, 0xa438, 0xca63, 0xa438, 0x1000,
+        0xa438, 0x17be, 0xa438, 0x1000, 0xa438, 0x17e8, 0xa438, 0xd70c,
+        0xa438, 0x5f7c, 0xa438, 0xd702, 0xa438, 0x6078, 0xa438, 0x9920,
+        0xa438, 0xf003, 0xa438, 0xb920, 0xa438, 0xa880, 0xa438, 0x9a10,
+        0xa438, 0x1000, 0xa438, 0x17be, 0xa438, 0x1000, 0xa438, 0x17e8,
+        0xa438, 0xd71f, 0xa438, 0x5f73, 0xa438, 0xf011, 0xa438, 0xd70c,
+        0xa438, 0x409b, 0xa438, 0x9920, 0xa438, 0x9a10, 0xa438, 0xfff5,
+        0xa438, 0x80fe, 0xa438, 0x8610, 0xa438, 0x8501, 0xa438, 0x8980,
+        0xa438, 0x8702, 0xa438, 0xa410, 0xa438, 0xa940, 0xa438, 0x81c0,
+        0xa438, 0xae80, 0xa438, 0x1800, 0xa438, 0x835a, 0xa438, 0x8804,
+        0xa438, 0xa704, 0xa438, 0x8788, 0xa438, 0xff82, 0xa438, 0xbb08,
+        0xa438, 0x0c1f, 0xa438, 0x0907, 0xa438, 0x8940, 0xa438, 0x1000,
+        0xa438, 0x17db, 0xa438, 0x8701, 0xa438, 0x8502, 0xa438, 0xa0f4,
+        0xa438, 0xa610, 0xa438, 0xd700, 0xa438, 0x6061, 0xa438, 0xa002,
+        0xa438, 0xa501, 0xa438, 0x8706, 0xa438, 0x8410, 0xa438, 0xa980,
+        0xa438, 0xca64, 0xa438, 0xd110, 0xa438, 0xd040, 0xa438, 0x1000,
+        0xa438, 0x17be, 0xa438, 0x1000, 0xa438, 0x17e8, 0xa438, 0xd70c,
+        0xa438, 0x5f7c, 0xa438, 0x8804, 0xa438, 0xa706, 0xa438, 0x1800,
+        0xa438, 0x8336, 0xa438, 0x1800, 0xa438, 0x147c, 0xa438, 0xd705,
+        0xa438, 0x405f, 0xa438, 0xf037, 0xa438, 0xd701, 0xa438, 0x4259,
+        0xa438, 0xd705, 0xa438, 0x6234, 0xa438, 0xd70c, 0xa438, 0x41c6,
+        0xa438, 0xd70d, 0xa438, 0x419d, 0xa438, 0xd70d, 0xa438, 0x417e,
+        0xa438, 0xd704, 0xa438, 0x6127, 0xa438, 0x2951, 0xa438, 0x83ec,
+        0xa438, 0xd70c, 0xa438, 0x4083, 0xa438, 0xd70c, 0xa438, 0x2e81,
+        0xa438, 0x83ec, 0xa438, 0xf0c2, 0xa438, 0x80fe, 0xa438, 0x8610,
+        0xa438, 0x8501, 0xa438, 0x8704, 0xa438, 0x0c30, 0xa438, 0x0410,
+        0xa438, 0xac02, 0xa438, 0xa502, 0xa438, 0x8980, 0xa438, 0xca60,
+        0xa438, 0xa004, 0xa438, 0xd70c, 0xa438, 0x6065, 0xa438, 0x1800,
+        0xa438, 0x83fc, 0xa438, 0x8004, 0xa438, 0xa804, 0xa438, 0x0c0f,
+        0xa438, 0x0602, 0xa438, 0x0c70, 0xa438, 0x0730, 0xa438, 0xa708,
+        0xa438, 0xd704, 0xa438, 0x609c, 0xa438, 0x0c1f, 0xa438, 0x0912,
+        0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x090e, 0xa438, 0xa940,
+        0xa438, 0x1000, 0xa438, 0x17db, 0xa438, 0xa780, 0xa438, 0xf0a0,
+        0xa438, 0xd704, 0xa438, 0x63ab, 0xa438, 0xd705, 0xa438, 0x4371,
+        0xa438, 0xd702, 0xa438, 0x339c, 0xa438, 0x84ad, 0xa438, 0x8788,
+        0xa438, 0x8704, 0xa438, 0x0c1f, 0xa438, 0x0907, 0xa438, 0x8940,
+        0xa438, 0x1000, 0xa438, 0x17db, 0xa438, 0x8410, 0xa438, 0xa0f4,
+        0xa438, 0xa610, 0xa438, 0xd700, 0xa438, 0x6061, 0xa438, 0xa002,
+        0xa438, 0xa501, 0xa438, 0xa706, 0xa438, 0x8804, 0xa438, 0xa980,
+        0xa438, 0xd70c, 0xa438, 0x6085, 0xa438, 0x8701, 0xa438, 0x8502,
+        0xa438, 0x8c02, 0xa438, 0xf082, 0xa438, 0xd70c, 0xa438, 0x60c5,
+        0xa438, 0xd702, 0xa438, 0x6053, 0xa438, 0xf07d, 0xa438, 0x1800,
+        0xa438, 0x84aa, 0xa438, 0xd70d, 0xa438, 0x4d1b, 0xa438, 0xba10,
+        0xa438, 0xae40, 0xa438, 0x0cfc, 0xa438, 0x03b4, 0xa438, 0x0cfc,
+        0xa438, 0x05b4, 0xa438, 0xd1c4, 0xa438, 0xd044, 0xa438, 0x1000,
+        0xa438, 0x17be, 0xa438, 0x1000, 0xa438, 0x17e8, 0xa438, 0xd70c,
+        0xa438, 0x5f7c, 0xa438, 0x8706, 0xa438, 0x8280, 0xa438, 0xace0,
+        0xa438, 0xa680, 0xa438, 0xa240, 0xa438, 0x1000, 0xa438, 0x17be,
+        0xa438, 0x1000, 0xa438, 0x17e8, 0xa438, 0xd702, 0xa438, 0x5f79,
+        0xa438, 0x8240, 0xa438, 0xd702, 0xa438, 0x6898, 0xa438, 0xd702,
+        0xa438, 0x4957, 0xa438, 0x1800, 0xa438, 0x849c, 0xa438, 0xa1c0,
+        0xa438, 0x0c3f, 0xa438, 0x0220, 0xa438, 0x0cfc, 0xa438, 0x030c,
+        0xa438, 0x0cfc, 0xa438, 0x050c, 0xa438, 0x8108, 0xa438, 0x8640,
+        0xa438, 0xa120, 0xa438, 0xa640, 0xa438, 0x0c03, 0xa438, 0x0101,
+        0xa438, 0xa110, 0xa438, 0xd1c4, 0xa438, 0xd044, 0xa438, 0xca84,
+        0xa438, 0x1000, 0xa438, 0x17be, 0xa438, 0x1000, 0xa438, 0x17e8,
+        0xa438, 0xd70c, 0xa438, 0x5f7c, 0xa438, 0xd702, 0xa438, 0x60fc,
+        0xa438, 0x8210, 0xa438, 0x0ce0, 0xa438, 0x0320, 0xa438, 0x0ce0,
+        0xa438, 0x0520, 0xa438, 0xf002, 0xa438, 0xa210, 0xa438, 0xd1c4,
+        0xa438, 0xd043, 0xa438, 0x1000, 0xa438, 0x17be, 0xa438, 0x1000,
+        0xa438, 0x17e8, 0xa438, 0xd70c, 0xa438, 0x5f7c, 0xa438, 0x8233,
+        0xa438, 0x0cfc, 0xa438, 0x036c, 0xa438, 0x0cfc, 0xa438, 0x056c,
+        0xa438, 0xd1c4, 0xa438, 0xd044, 0xa438, 0xca85, 0xa438, 0x1000,
+        0xa438, 0x17be, 0xa438, 0x1000, 0xa438, 0x17e8, 0xa438, 0xd70c,
+        0xa438, 0x5f7c, 0xa438, 0xa680, 0xa438, 0xa240, 0xa438, 0x1000,
+        0xa438, 0x17be, 0xa438, 0x1000, 0xa438, 0x17e8, 0xa438, 0xd702,
+        0xa438, 0x5f79, 0xa438, 0x8240, 0xa438, 0x0cfc, 0xa438, 0x0390,
+        0xa438, 0x0cfc, 0xa438, 0x0590, 0xa438, 0xd702, 0xa438, 0x6058,
+        0xa438, 0xf002, 0xa438, 0xfec8, 0xa438, 0x81c0, 0xa438, 0x8880,
+        0xa438, 0x8706, 0xa438, 0xca61, 0xa438, 0xd1c4, 0xa438, 0xd054,
+        0xa438, 0x1000, 0xa438, 0x17be, 0xa438, 0x1000, 0xa438, 0x17e8,
+        0xa438, 0xd70c, 0xa438, 0x5f7d, 0xa438, 0xa706, 0xa438, 0xf004,
+        0xa438, 0x8788, 0xa438, 0xa404, 0xa438, 0x8702, 0xa438, 0x0800,
+        0xa438, 0x8443, 0xa438, 0x8303, 0xa438, 0x8280, 0xa438, 0x9920,
+        0xa438, 0x8ce0, 0xa438, 0x8004, 0xa438, 0xa1c0, 0xa438, 0xd70e,
+        0xa438, 0x404a, 0xa438, 0xa280, 0xa438, 0xd702, 0xa438, 0x3bd0,
+        0xa438, 0x84be, 0xa438, 0x0c3f, 0xa438, 0x0223, 0xa438, 0xf003,
+        0xa438, 0x0c3f, 0xa438, 0x0220, 0xa438, 0x0cfc, 0xa438, 0x0308,
+        0xa438, 0x0cfc, 0xa438, 0x0508, 0xa438, 0x8108, 0xa438, 0x8640,
+        0xa438, 0xa120, 0xa438, 0xa640, 0xa438, 0xd702, 0xa438, 0x6077,
+        0xa438, 0x8103, 0xa438, 0xf003, 0xa438, 0x0c03, 0xa438, 0x0101,
+        0xa438, 0xa110, 0xa438, 0xd702, 0xa438, 0x6077, 0xa438, 0xa108,
+        0xa438, 0xf006, 0xa438, 0xd704, 0xa438, 0x6077, 0xa438, 0x8108,
+        0xa438, 0xf002, 0xa438, 0xa108, 0xa438, 0xd193, 0xa438, 0xd045,
+        0xa438, 0xca82, 0xa438, 0x1000, 0xa438, 0x17be, 0xa438, 0xd70e,
+        0xa438, 0x606a, 0xa438, 0x1000, 0xa438, 0x17e8, 0xa438, 0xd70c,
+        0xa438, 0x5f3c, 0xa438, 0xd702, 0xa438, 0x60fc, 0xa438, 0x8210,
+        0xa438, 0x0ce0, 0xa438, 0x0320, 0xa438, 0x0ce0, 0xa438, 0x0520,
+        0xa438, 0xf002, 0xa438, 0xa210, 0xa438, 0xd1c4, 0xa438, 0xd043,
+        0xa438, 0x1000, 0xa438, 0x17be, 0xa438, 0xd70e, 0xa438, 0x606a,
+        0xa438, 0x1000, 0xa438, 0x17e8, 0xa438, 0xd70c, 0xa438, 0x5f3c,
+        0xa438, 0xd702, 0xa438, 0x3bd0, 0xa438, 0x84fc, 0xa438, 0x0c3f,
+        0xa438, 0x020c, 0xa438, 0xf002, 0xa438, 0x823f, 0xa438, 0x0cfc,
+        0xa438, 0x034c, 0xa438, 0x0cfc, 0xa438, 0x054c, 0xa438, 0xd1c4,
+        0xa438, 0xd044, 0xa438, 0x1000, 0xa438, 0x17be, 0xa438, 0xd70e,
+        0xa438, 0x606a, 0xa438, 0x1000, 0xa438, 0x17e8, 0xa438, 0xd70c,
+        0xa438, 0x5f3c, 0xa438, 0x820c, 0xa438, 0xa360, 0xa438, 0xa560,
+        0xa438, 0xd1c4, 0xa438, 0xd043, 0xa438, 0xca83, 0xa438, 0x1000,
+        0xa438, 0x17be, 0xa438, 0xd70e, 0xa438, 0x606a, 0xa438, 0x1000,
+        0xa438, 0x17e8, 0xa438, 0xd70c, 0xa438, 0x5f3c, 0xa438, 0xd70e,
+        0xa438, 0x406a, 0xa438, 0x8680, 0xa438, 0xf002, 0xa438, 0xa680,
+        0xa438, 0xa240, 0xa438, 0x0c0f, 0xa438, 0x0604, 0xa438, 0x0c70,
+        0xa438, 0x0750, 0xa438, 0xa708, 0xa438, 0xd704, 0xa438, 0x609c,
+        0xa438, 0x0c1f, 0xa438, 0x0914, 0xa438, 0xf003, 0xa438, 0x0c1f,
+        0xa438, 0x0910, 0xa438, 0xa940, 0xa438, 0x1000, 0xa438, 0x17db,
+        0xa438, 0xa780, 0xa438, 0x1000, 0xa438, 0x17be, 0xa438, 0xd70e,
+        0xa438, 0x606a, 0xa438, 0x1000, 0xa438, 0x17e8, 0xa438, 0xd702,
+        0xa438, 0x399c, 0xa438, 0x852f, 0xa438, 0x8240, 0xa438, 0x8788,
+        0xa438, 0xd702, 0xa438, 0x63f8, 0xa438, 0xd705, 0xa438, 0x643c,
+        0xa438, 0xa402, 0xa438, 0xf012, 0xa438, 0x8402, 0xa438, 0xd705,
+        0xa438, 0x611b, 0xa438, 0xa401, 0xa438, 0xa302, 0xa438, 0xd702,
+        0xa438, 0x417d, 0xa438, 0xa440, 0xa438, 0xa280, 0xa438, 0xf008,
+        0xa438, 0x8401, 0xa438, 0x8302, 0xa438, 0xd70c, 0xa438, 0x6060,
+        0xa438, 0xa301, 0xa438, 0xf002, 0xa438, 0x8301, 0xa438, 0xd70c,
+        0xa438, 0x4080, 0xa438, 0xd70e, 0xa438, 0x604a, 0xa438, 0xff5f,
+        0xa438, 0xd705, 0xa438, 0x3cdd, 0xa438, 0x855e, 0xa438, 0xff5b,
+        0xa438, 0x0cfc, 0xa438, 0x0390, 0xa438, 0x0cfc, 0xa438, 0x0590,
+        0xa438, 0x0800, 0xa438, 0xd704, 0xa438, 0x60f9, 0xa438, 0xd704,
+        0xa438, 0x6958, 0xa438, 0xd706, 0xa438, 0x6902, 0xa438, 0x1800,
+        0xa438, 0x1001, 0xa438, 0xa220, 0xa438, 0xa404, 0xa438, 0xd704,
+        0xa438, 0x4054, 0xa438, 0xa740, 0xa438, 0xa504, 0xa438, 0xd704,
+        0xa438, 0x40b5, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa003,
+        0xa438, 0x9503, 0xa438, 0x8190, 0xa438, 0xcb91, 0xa438, 0x1000,
+        0xa438, 0x10af, 0xa438, 0xd704, 0xa438, 0x7fb9, 0xa438, 0x8220,
+        0xa438, 0x8404, 0xa438, 0xa280, 0xa438, 0xa110, 0xa438, 0xd706,
+        0xa438, 0x4041, 0xa438, 0xa180, 0xa438, 0x1000, 0xa438, 0x130c,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x850f, 0xa438, 0x9503,
+        0xa438, 0x0c1f, 0xa438, 0x0d08, 0xa438, 0x0cc0, 0xa438, 0x0d80,
+        0xa438, 0x1000, 0xa438, 0x12b5, 0xa438, 0x1000, 0xa438, 0x10af,
+        0xa438, 0xd704, 0xa438, 0x615f, 0xa438, 0xd70c, 0xa438, 0x6103,
+        0xa438, 0x8504, 0xa438, 0xd704, 0xa438, 0x40b5, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8003, 0xa438, 0x9503, 0xa438, 0xcb92,
+        0xa438, 0x1000, 0xa438, 0x10af, 0xa438, 0xd706, 0xa438, 0x7fa3,
+        0xa438, 0x8280, 0xa438, 0x8190, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x0c0f, 0xa438, 0x050a, 0xa438, 0x9503, 0xa438, 0x0c1f,
+        0xa438, 0x0d00, 0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x12b5,
+        0xa438, 0x1800, 0xa438, 0x1001, 0xa438, 0x0c1f, 0xa438, 0x0d00,
+        0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x12b5, 0xa438, 0x800a,
+        0xa438, 0xd705, 0xa438, 0x40b9, 0xa438, 0xd70c, 0xa438, 0x6063,
+        0xa438, 0xa020, 0xa438, 0xf003, 0xa438, 0xd705, 0xa438, 0x8020,
+        0xa438, 0xa504, 0xa438, 0xd704, 0xa438, 0x40b5, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xa003, 0xa438, 0x9503, 0xa438, 0xd704,
+        0xa438, 0x4054, 0xa438, 0xa740, 0xa438, 0x8190, 0xa438, 0xcb93,
+        0xa438, 0xd700, 0xa438, 0x6063, 0xa438, 0xd704, 0xa438, 0x609c,
+        0xa438, 0xd14b, 0xa438, 0xd040, 0xa438, 0xf003, 0xa438, 0xd120,
+        0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x10af, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0xa008, 0xa438, 0xd706, 0xa438, 0x4040,
+        0xa438, 0xa002, 0xa438, 0xd705, 0xa438, 0x4079, 0xa438, 0x1000,
+        0xa438, 0x1313, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x85f0,
+        0xa438, 0x9503, 0xa438, 0xd705, 0xa438, 0x40d9, 0xa438, 0xd70c,
+        0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d09, 0xa438, 0xf003,
+        0xa438, 0x0c1f, 0xa438, 0x0d0a, 0xa438, 0x0cc0, 0xa438, 0x0d80,
+        0xa438, 0x1000, 0xa438, 0x12b5, 0xa438, 0x1000, 0xa438, 0x10af,
+        0xa438, 0x8020, 0xa438, 0xd705, 0xa438, 0x4199, 0xa438, 0xd704,
+        0xa438, 0x615f, 0xa438, 0xd70c, 0xa438, 0x6103, 0xa438, 0x8504,
+        0xa438, 0xd704, 0xa438, 0x40b5, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8003, 0xa438, 0x9503, 0xa438, 0xcb94, 0xa438, 0x1000,
+        0xa438, 0x10af, 0xa438, 0xd706, 0xa438, 0x7fa2, 0xa438, 0x800a,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x85f0, 0xa438, 0x9503,
+        0xa438, 0xd705, 0xa438, 0x40b9, 0xa438, 0x0c1f, 0xa438, 0x0d00,
+        0xa438, 0x8dc0, 0xa438, 0xf005, 0xa438, 0x0c1f, 0xa438, 0x0d07,
+        0xa438, 0x8dc0, 0xa438, 0xa190, 0xa438, 0x1000, 0xa438, 0x12b5,
+        0xa438, 0xd705, 0xa438, 0x39cc, 0xa438, 0x8617, 0xa438, 0x1800,
+        0xa438, 0x1001, 0xa438, 0x1800, 0xa438, 0x82c7, 0xa438, 0xcb13,
+        0xa438, 0xd706, 0xa438, 0x6089, 0xa438, 0xd1b8, 0xa438, 0xd04a,
+        0xa438, 0xf003, 0xa438, 0xd11c, 0xa438, 0xd04b, 0xa438, 0x1000,
+        0xa438, 0x126b, 0xa438, 0xd701, 0xa438, 0x67d5, 0xa438, 0xd700,
+        0xa438, 0x5f74, 0xa438, 0xd70c, 0xa438, 0x610c, 0xa438, 0x1000,
+        0xa438, 0x126b, 0xa438, 0xd700, 0xa438, 0x6846, 0xa438, 0xd706,
+        0xa438, 0x647b, 0xa438, 0xfffa, 0xa438, 0x1000, 0xa438, 0x1330,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0c1f, 0xa438, 0x0f16,
+        0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd70c,
+        0xa438, 0x5fb3, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8f1f,
+        0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd70c,
+        0xa438, 0x7f33, 0xa438, 0x1000, 0xa438, 0x12b5, 0xa438, 0x0c07,
+        0xa438, 0x0c02, 0xa438, 0x0cc0, 0xa438, 0x0080, 0xa438, 0xd14a,
+        0xa438, 0xd048, 0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0x1800, 0xa438, 0x8629, 0xa438, 0x800a,
+        0xa438, 0x1000, 0xa438, 0x120e, 0xa438, 0xa004, 0xa438, 0x1000,
+        0xa438, 0x1220, 0xa438, 0x8004, 0xa438, 0xa001, 0xa438, 0x1000,
+        0xa438, 0x1220, 0xa438, 0x8001, 0xa438, 0x1000, 0xa438, 0x1217,
+        0xa438, 0x0c03, 0xa438, 0x0902, 0xa438, 0x1800, 0xa438, 0x04ed,
+        0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd71f, 0xa438, 0x5fab,
+        0xa438, 0xba08, 0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd71f,
+        0xa438, 0x7f8b, 0xa438, 0x9a08, 0xa438, 0x1800, 0xa438, 0x0581,
+        0xa438, 0x800a, 0xa438, 0xd702, 0xa438, 0x6555, 0xa438, 0x1000,
+        0xa438, 0x120e, 0xa438, 0xa004, 0xa438, 0x1000, 0xa438, 0x1220,
+        0xa438, 0x8004, 0xa438, 0xa001, 0xa438, 0x1000, 0xa438, 0x1220,
+        0xa438, 0x8001, 0xa438, 0x1000, 0xa438, 0x1217, 0xa438, 0xa00a,
+        0xa438, 0xa780, 0xa438, 0xcb14, 0xa438, 0xd1b8, 0xa438, 0xd04a,
+        0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0x6286, 0xa438, 0xd706, 0xa438, 0x5f5b, 0xa438, 0x800a,
+        0xa438, 0x1000, 0xa438, 0x120e, 0xa438, 0xa004, 0xa438, 0x1000,
+        0xa438, 0x1220, 0xa438, 0x8004, 0xa438, 0xa001, 0xa438, 0x1000,
+        0xa438, 0x1220, 0xa438, 0x8001, 0xa438, 0x1000, 0xa438, 0x1217,
+        0xa438, 0x0c03, 0xa438, 0x0902, 0xa438, 0x1800, 0xa438, 0x8671,
+        0xa438, 0xa00a, 0xa438, 0x9308, 0xa438, 0xb210, 0xa438, 0xb301,
+        0xa438, 0x1000, 0xa438, 0x126b, 0xa438, 0xd701, 0xa438, 0x5fa4,
+        0xa438, 0xb302, 0xa438, 0x9210, 0xa438, 0xd409, 0xa438, 0x1000,
+        0xa438, 0x1203, 0xa438, 0xd103, 0xa438, 0xd04c, 0xa438, 0x1000,
+        0xa438, 0x126b, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x1800,
+        0xa438, 0x0581, 0xa438, 0xd70c, 0xa438, 0x60b3, 0xa438, 0x1800,
+        0xa438, 0x86b3, 0xa438, 0x1800, 0xa438, 0x001a, 0xa438, 0x1800,
+        0xa438, 0x12cb, 0xa436, 0xA10E, 0xa438, 0x12cf, 0xa436, 0xA10C,
+        0xa438, 0x04f8, 0xa436, 0xA10A, 0xa438, 0x1003, 0xa436, 0xA108,
+        0xa438, 0x15fb, 0xa436, 0xA106, 0xa438, 0x0d2b, 0xa436, 0xA104,
+        0xa438, 0x0ecb, 0xa436, 0xA102, 0xa438, 0x1119, 0xa436, 0xA100,
+        0xa438, 0x0960, 0xa436, 0xA110, 0xa438, 0x00ff, 0xa436, 0xA016,
+        0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x1ff8, 0xa436, 0xA014,
+        0xa438, 0xa704, 0xa438, 0x82c7, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa436, 0xA164, 0xa438, 0x119F, 0xa436, 0xA166, 0xa438, 0x11A1,
+        0xa436, 0xA168, 0xa438, 0x3fff, 0xa436, 0xA16A, 0xa438, 0x3fff,
+        0xa436, 0xA16C, 0xa438, 0x3fff, 0xa436, 0xA16E, 0xa438, 0x3fff,
+        0xa436, 0xA170, 0xa438, 0x3fff, 0xa436, 0xA172, 0xa438, 0x3fff,
+        0xa436, 0xA162, 0xa438, 0x0003, 0xa436, 0xb87c, 0xa438, 0x8a63,
+        0xa436, 0xb87e, 0xa438, 0xaf8a, 0xa438, 0x7baf, 0xa438, 0x8ab6,
+        0xa438, 0xaf8a, 0xa438, 0xd6af, 0xa438, 0x8ae4, 0xa438, 0xaf8a,
+        0xa438, 0xf2af, 0xa438, 0x8b01, 0xa438, 0xaf8b, 0xa438, 0x0aaf,
+        0xa438, 0x8b10, 0xa438, 0xad35, 0xa438, 0x27bf, 0xa438, 0x7308,
+        0xa438, 0x027b, 0xa438, 0x07ac, 0xa438, 0x280d, 0xa438, 0xbf73,
+        0xa438, 0x0b02, 0xa438, 0x7b07, 0xa438, 0xac28, 0xa438, 0x04d0,
+        0xa438, 0x05ae, 0xa438, 0x02d0, 0xa438, 0x01d1, 0xa438, 0x01d3,
+        0xa438, 0x04ee, 0xa438, 0x8640, 0xa438, 0x00ee, 0xa438, 0x8641,
+        0xa438, 0x00af, 0xa438, 0x6aa6, 0xa438, 0xd100, 0xa438, 0xd300,
+        0xa438, 0xee86, 0xa438, 0x4001, 0xa438, 0xee86, 0xa438, 0x4124,
+        0xa438, 0xd00f, 0xa438, 0xaf6a, 0xa438, 0xa6bf, 0xa438, 0x739e,
+        0xa438, 0x027b, 0xa438, 0x07ad, 0xa438, 0x280b, 0xa438, 0xe18f,
+        0xa438, 0xfdad, 0xa438, 0x2805, 0xa438, 0xe08f, 0xa438, 0xfeae,
+        0xa438, 0x03e0, 0xa438, 0x8fff, 0xa438, 0xe489, 0xa438, 0xe7e0,
+        0xa438, 0x89e7, 0xa438, 0xaf67, 0xa438, 0x9fa0, 0xa438, 0x9402,
+        0xa438, 0xae03, 0xa438, 0xa0b5, 0xa438, 0x03af, 0xa438, 0x0d89,
+        0xa438, 0xaf0d, 0xa438, 0xafa0, 0xa438, 0x9402, 0xa438, 0xae03,
+        0xa438, 0xa0b5, 0xa438, 0x03af, 0xa438, 0x0c64, 0xa438, 0xaf0c,
+        0xa438, 0xcce0, 0xa438, 0x86a5, 0xa438, 0xad25, 0xa438, 0x0602,
+        0xa438, 0x6ba4, 0xa438, 0x0265, 0xa438, 0x4faf, 0xa438, 0x6e9a,
+        0xa438, 0xac24, 0xa438, 0x03af, 0xa438, 0x6bb4, 0xa438, 0xaf6b,
+        0xa438, 0xb602, 0xa438, 0x7ae8, 0xa438, 0xaf6c, 0xa438, 0xa100,
+        0xa436, 0xb85e, 0xa438, 0x6A7F, 0xa436, 0xb860, 0xa438, 0x679C,
+        0xa436, 0xb862, 0xa438, 0x0d86, 0xa436, 0xb864, 0xa438, 0x0c61,
+        0xa436, 0xb886, 0xa438, 0x6E7C, 0xa436, 0xb888, 0xa438, 0x6BAE,
+        0xa436, 0xb88a, 0xa438, 0x6C9B, 0xa436, 0xb88c, 0xa438, 0xffff,
+        0xa436, 0xb838, 0xa438, 0x007f, 0xb820, 0x0010, 0xa436, 0x8629,
+        0xa438, 0xaf86, 0xa438, 0x41af, 0xa438, 0x8644, 0xa438, 0xaf88,
+        0xa438, 0x0caf, 0xa438, 0x8813, 0xa438, 0xaf88, 0xa438, 0x4baf,
+        0xa438, 0x884b, 0xa438, 0xaf88, 0xa438, 0x4baf, 0xa438, 0x884b,
+        0xa438, 0xaf1d, 0xa438, 0x8a02, 0xa438, 0x864d, 0xa438, 0x0210,
+        0xa438, 0x64af, 0xa438, 0x1063, 0xa438, 0xf8fa, 0xa438, 0xef69,
+        0xa438, 0xe080, 0xa438, 0x4cac, 0xa438, 0x2517, 0xa438, 0xe080,
+        0xa438, 0x40ad, 0xa438, 0x251a, 0xa438, 0x0286, 0xa438, 0x7ce0,
+        0xa438, 0x8040, 0xa438, 0xac25, 0xa438, 0x11bf, 0xa438, 0x87f4,
+        0xa438, 0x0277, 0xa438, 0xf6ae, 0xa438, 0x0902, 0xa438, 0x87b3,
+        0xa438, 0x0287, 0xa438, 0xe902, 0xa438, 0x87de, 0xa438, 0xef96,
+        0xa438, 0xfefc, 0xa438, 0x04f8, 0xa438, 0xe080, 0xa438, 0x18ad,
+        0xa438, 0x2611, 0xa438, 0xe08f, 0xa438, 0x9cac, 0xa438, 0x2005,
+        0xa438, 0x0286, 0xa438, 0x99ae, 0xa438, 0x0302, 0xa438, 0x8707,
+        0xa438, 0x0287, 0xa438, 0x5002, 0xa438, 0x87de, 0xa438, 0xfc04,
+        0xa438, 0xf8f9, 0xa438, 0xef79, 0xa438, 0xfbbf, 0xa438, 0x87f7,
+        0xa438, 0x0278, 0xa438, 0x385c, 0xa438, 0x2000, 0xa438, 0x0d4d,
+        0xa438, 0xa101, 0xa438, 0x51bf, 0xa438, 0x87f7, 0xa438, 0x0278,
+        0xa438, 0x385c, 0xa438, 0x07ff, 0xa438, 0xe38f, 0xa438, 0x9d1b,
+        0xa438, 0x319f, 0xa438, 0x410d, 0xa438, 0x48e3, 0xa438, 0x8f9e,
+        0xa438, 0x1b31, 0xa438, 0x9f38, 0xa438, 0xbf87, 0xa438, 0xfa02,
+        0xa438, 0x7838, 0xa438, 0x5c07, 0xa438, 0xffe3, 0xa438, 0x8f9f,
+        0xa438, 0x1b31, 0xa438, 0x9f28, 0xa438, 0x0d48, 0xa438, 0xe38f,
+        0xa438, 0xa01b, 0xa438, 0x319f, 0xa438, 0x1fbf, 0xa438, 0x87fd,
+        0xa438, 0x0278, 0xa438, 0x385c, 0xa438, 0x07ff, 0xa438, 0xe38f,
+        0xa438, 0xa11b, 0xa438, 0x319f, 0xa438, 0x0f0d, 0xa438, 0x48e3,
+        0xa438, 0x8fa2, 0xa438, 0x1b31, 0xa438, 0x9f06, 0xa438, 0xee8f,
+        0xa438, 0x9c01, 0xa438, 0xae04, 0xa438, 0xee8f, 0xa438, 0x9c00,
+        0xa438, 0xffef, 0xa438, 0x97fd, 0xa438, 0xfc04, 0xa438, 0xf8f9,
+        0xa438, 0xef79, 0xa438, 0xfbbf, 0xa438, 0x87f7, 0xa438, 0x0278,
+        0xa438, 0x385c, 0xa438, 0x2000, 0xa438, 0x0d4d, 0xa438, 0xa100,
+        0xa438, 0x20bf, 0xa438, 0x87f7, 0xa438, 0x0278, 0xa438, 0x385c,
+        0xa438, 0x0600, 0xa438, 0x0d49, 0xa438, 0xe38f, 0xa438, 0xa31b,
+        0xa438, 0x319f, 0xa438, 0x0ebf, 0xa438, 0x8800, 0xa438, 0x0277,
+        0xa438, 0xf6bf, 0xa438, 0x8806, 0xa438, 0x0277, 0xa438, 0xf6ae,
+        0xa438, 0x0cbf, 0xa438, 0x8800, 0xa438, 0x0277, 0xa438, 0xedbf,
+        0xa438, 0x8806, 0xa438, 0x0277, 0xa438, 0xedee, 0xa438, 0x8f9c,
+        0xa438, 0x00ff, 0xa438, 0xef97, 0xa438, 0xfdfc, 0xa438, 0x04f8,
+        0xa438, 0xf9ef, 0xa438, 0x79fb, 0xa438, 0xbf87, 0xa438, 0xf702,
+        0xa438, 0x7838, 0xa438, 0x5c20, 0xa438, 0x000d, 0xa438, 0x4da1,
+        0xa438, 0x014a, 0xa438, 0xbf87, 0xa438, 0xf702, 0xa438, 0x7838,
+        0xa438, 0x5c07, 0xa438, 0xffe3, 0xa438, 0x8fa4, 0xa438, 0x1b31,
+        0xa438, 0x9f3a, 0xa438, 0x0d48, 0xa438, 0xe38f, 0xa438, 0xa51b,
+        0xa438, 0x319f, 0xa438, 0x31bf, 0xa438, 0x87fa, 0xa438, 0x0278,
+        0xa438, 0x38e3, 0xa438, 0x8fa6, 0xa438, 0x1b31, 0xa438, 0x9f24,
+        0xa438, 0x0d48, 0xa438, 0xe38f, 0xa438, 0xa71b, 0xa438, 0x319f,
+        0xa438, 0x1bbf, 0xa438, 0x87fd, 0xa438, 0x0278, 0xa438, 0x38e3,
+        0xa438, 0x8fa8, 0xa438, 0x1b31, 0xa438, 0x9f0e, 0xa438, 0xbf88,
+        0xa438, 0x0302, 0xa438, 0x77f6, 0xa438, 0xbf88, 0xa438, 0x0902,
+        0xa438, 0x77f6, 0xa438, 0xae00, 0xa438, 0xffef, 0xa438, 0x97fd,
+        0xa438, 0xfc04, 0xa438, 0xf8ef, 0xa438, 0x79fb, 0xa438, 0xe080,
+        0xa438, 0x18ad, 0xa438, 0x261c, 0xa438, 0xee8f, 0xa438, 0x9c00,
+        0xa438, 0xbf88, 0xa438, 0x0002, 0xa438, 0x77ed, 0xa438, 0xbf88,
+        0xa438, 0x0602, 0xa438, 0x77ed, 0xa438, 0xbf88, 0xa438, 0x0302,
+        0xa438, 0x77ed, 0xa438, 0xbf88, 0xa438, 0x0902, 0xa438, 0x77ed,
+        0xa438, 0xffef, 0xa438, 0x97fc, 0xa438, 0x04f8, 0xa438, 0xe080,
+        0xa438, 0x40f6, 0xa438, 0x25e4, 0xa438, 0x8040, 0xa438, 0xfc04,
+        0xa438, 0xf8e0, 0xa438, 0x804c, 0xa438, 0xf625, 0xa438, 0xe480,
+        0xa438, 0x4cfc, 0xa438, 0x0455, 0xa438, 0xa4ba, 0xa438, 0xf0a6,
+        0xa438, 0x4af0, 0xa438, 0xa64c, 0xa438, 0xf0a6, 0xa438, 0x4e66,
+        0xa438, 0xa4b6, 0xa438, 0x55a4, 0xa438, 0xb600, 0xa438, 0xac56,
+        0xa438, 0x11ac, 0xa438, 0x56ee, 0xa438, 0x804c, 0xa438, 0x3aaf,
+        0xa438, 0x0627, 0xa438, 0xbf88, 0xa438, 0x4802, 0xa438, 0x77ed,
+        0xa438, 0xd203, 0xa438, 0xe083, 0xa438, 0x8a0d, 0xa438, 0x01f6,
+        0xa438, 0x271b, 0xa438, 0x03aa, 0xa438, 0x0182, 0xa438, 0xe083,
+        0xa438, 0x890d, 0xa438, 0x01f6, 0xa438, 0x271b, 0xa438, 0x03aa,
+        0xa438, 0x0182, 0xa438, 0xe083, 0xa438, 0x880d, 0xa438, 0x01f6,
+        0xa438, 0x271b, 0xa438, 0x03aa, 0xa438, 0x0782, 0xa438, 0xbf88,
+        0xa438, 0x4802, 0xa438, 0x77f6, 0xa438, 0xaf16, 0xa438, 0x1500,
+        0xa438, 0xa86a, 0xa436, 0xb818, 0xa438, 0x1D84, 0xa436, 0xb81a,
+        0xa438, 0x1060, 0xa436, 0xb81c, 0xa438, 0x0623, 0xa436, 0xb81e,
+        0xa438, 0x15ef, 0xa436, 0xb850, 0xa438, 0xffff, 0xa436, 0xb852,
+        0xa438, 0xffff, 0xa436, 0xb878, 0xa438, 0xffff, 0xa436, 0xb884,
+        0xa438, 0xffff, 0xa436, 0xb832, 0xa438, 0x000f, 0xa436, 0x0000,
+        0xa438, 0x0000, 0xB82E, 0x0000, 0xa436, 0x8023, 0xa438, 0x0000,
+        0xB820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static void
+rtl8126_real_set_phy_mcu_8126a_1_1(struct net_device *dev)
+{
+        rtl8126_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8126a_1_1,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8126a_1_1));
+}
+
+static void
+rtl8126_real_set_phy_mcu_8126a_1_2(struct net_device *dev)
+{
+        rtl8126_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8126a_1_2,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8126a_1_2));
+}
+
+static void
+rtl8126_real_set_phy_mcu_8126a_1_3(struct net_device *dev)
+{
+        rtl8126_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8126a_1_3,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8126a_1_3));
+}
+
+static void
+rtl8126_set_phy_mcu_8126a_1(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        rtl8126_set_phy_mcu_patch_request(tp);
+
+        rtl8126_real_set_phy_mcu_8126a_1_1(dev);
+
+        rtl8126_clear_phy_mcu_patch_request(tp);
+
+        rtl8126_set_phy_mcu_patch_request(tp);
+
+        rtl8126_real_set_phy_mcu_8126a_1_2(dev);
+
+        rtl8126_clear_phy_mcu_patch_request(tp);
+
+        rtl8126_set_phy_mcu_patch_request(tp);
+
+        rtl8126_real_set_phy_mcu_8126a_1_3(dev);
+
+        rtl8126_clear_phy_mcu_patch_request(tp);
+}
+
+static void
+rtl8126_real_set_phy_mcu_8126a_2_1(struct net_device *dev)
+{
+        rtl8126_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8126a_2_1,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8126a_2_1));
+}
+
+static void
+rtl8126_real_set_phy_mcu_8126a_2_3(struct net_device *dev)
+{
+        rtl8126_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8126a_2_3,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8126a_2_3));
+}
+
+static void
+rtl8126_set_phy_mcu_8126a_2(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        rtl8126_set_phy_mcu_patch_request(tp);
+
+        rtl8126_real_set_phy_mcu_8126a_2_1(dev);
+
+        rtl8126_clear_phy_mcu_patch_request(tp);
+
+        rtl8126_set_phy_mcu_patch_request(tp);
+
+        rtl8126_real_set_phy_mcu_8126a_2_3(dev);
+
+        rtl8126_clear_phy_mcu_patch_request(tp);
+}
+
+static void
+rtl8126_real_set_phy_mcu_8126a_3_1(struct net_device *dev)
+{
+        rtl8126_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8126a_3_1,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8126a_3_1));
+}
+
+static void
+rtl8126_set_phy_mcu_8126a_3(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        rtl8126_set_phy_mcu_patch_request(tp);
+
+        rtl8126_real_set_phy_mcu_8126a_3_1(dev);
+
+        rtl8126_clear_phy_mcu_patch_request(tp);
+}
+
+static void
+rtl8126_init_hw_phy_mcu(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u8 require_disable_phy_disable_mode = FALSE;
+
+        if (tp->NotWrRamCodeToMicroP == TRUE)
+                return;
+
+        if (rtl8126_check_hw_phy_mcu_code_ver(dev))
+                return;
+
+        if (HW_SUPPORT_CHECK_PHY_DISABLE_MODE(tp) && rtl8126_is_in_phy_disable_mode(dev))
+                require_disable_phy_disable_mode = TRUE;
+
+        if (require_disable_phy_disable_mode)
+                rtl8126_disable_phy_disable_mode(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_1:
+                rtl8126_set_phy_mcu_8126a_1(dev);
+                break;
+        case CFG_METHOD_2:
+                rtl8126_set_phy_mcu_8126a_2(dev);
+                break;
+        case CFG_METHOD_3:
+                rtl8126_set_phy_mcu_8126a_3(dev);
+                break;
+        }
+
+        if (require_disable_phy_disable_mode)
+                rtl8126_enable_phy_disable_mode(dev);
+
+        rtl8126_write_hw_phy_mcu_code_ver(dev);
+
+        rtl8126_mdio_write(tp,0x1F, 0x0000);
+
+        tp->HwHasWrRamCodeToMicroP = TRUE;
+}
+#endif
+
+static void
+rtl8126_enable_phy_aldps(struct rtl8126_private *tp)
+{
+        //enable aldps
+        //GPHY OCP 0xA430 bit[2] = 0x1 (en_aldps)
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xA430, BIT_2);
+}
+
+static void
+rtl8126_hw_phy_config_8126a_1(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xA442, BIT_11);
+
+
+        if (aspm && HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                rtl8126_enable_phy_aldps(tp);
+}
+
+static void
+rtl8126_hw_phy_config_8126a_2(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xA442, BIT_11);
+
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80BF);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0xED00);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80CD);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x1000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80D1);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0xC800);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80D4);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0xC800);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80E1);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x10CC);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x80E5);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x4F0C);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8387);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x4700);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA80C,
+                                              BIT_7 | BIT_6,
+                                              BIT_7);
+
+
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xAC90, BIT_4);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xAD2C, BIT_15);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8321);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x1100);
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xACF8, (BIT_3 | BIT_2));
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8183);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x5900);
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xAD94, BIT_5);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA654, BIT_11);
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xB648, BIT_14);
+
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x839E);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x2F00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x83F2);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0800);
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xADA0, BIT_1);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80F3);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x9900);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8126);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0xC100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x893A);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x8080);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8647);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0xE600);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x862C);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x1200);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x864A);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0xE600);
+
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80A0);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0xBCBC);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x805E);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0xBCBC);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8056);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x3077);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8058);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x5A00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8098);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x3077);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x809A);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x5A00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8052);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x3733);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8094);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x3733);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x807F);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x7C75);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x803D);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x7C75);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8036);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x3000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8078);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x3000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8031);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x3300);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8073);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x3300);
+
+
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAE06,
+                                              0xFC00,
+                                              0x7C00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x89D1);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0004);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FBD);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x0A00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FBE);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0D09);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x89CD);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0F0F);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x89CF);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0F0F);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x83A4);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x6600);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x83A6);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x6601);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x83C0);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x6600);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x83C2);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x6601);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8414);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x6600);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8416);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x6601);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x83F8);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x6600);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x83FA);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x6601);
+
+
+        rtl8126_set_phy_mcu_patch_request(tp);
+
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBD96,
+                                              0x1F00,
+                                              0x1000);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBF1C,
+                                              0x0007,
+                                              0x0007);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xBFBE, BIT_15);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBF40,
+                                              0x0380,
+                                              0x0280);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBF90,
+                                              BIT_7,
+                                              (BIT_6 | BIT_5));
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xBF90,
+                                              BIT_4,
+                                              BIT_3 | BIT_2);
+
+        rtl8126_clear_phy_mcu_patch_request(tp);
+
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x843B);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x2000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x843D);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x2000);
+
+
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xB516, 0x7F);
+
+
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xBF80, (BIT_5 | BIT_4));
+
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8188);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0044);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00A8);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00D6);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00EC);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00F6);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00FC);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00FE);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00FE);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00BC);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0058);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x002A);
+
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8015);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0800);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FFD);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FFF);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x7F00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FFB);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FE9);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0002);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FEF);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x00A5);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FF1);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0106);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FE1);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0102);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FE3);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0400);
+
+
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xA654, BIT_11);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0XA65A, (BIT_1 | BIT_0));
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xAC3A, 0x5851);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0XAC3C,
+                                              BIT_15 | BIT_14 | BIT_12,
+                                              BIT_13);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAC42,
+                                              BIT_9,
+                                              BIT_8 | BIT_7 | BIT_6);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xAC3E, BIT_15 | BIT_14 | BIT_13);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xAC42, BIT_5 | BIT_4 | BIT_3);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAC42,
+                                              BIT_1,
+                                              BIT_2 | BIT_0);
+
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xAC1A, 0x00DB);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xADE4, 0x01B5);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xAD9C, BIT_11 | BIT_10);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x814B);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x1100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x814D);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x1100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x814F);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0B00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8142);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8144);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8150);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8118);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0700);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x811A);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0700);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x811C);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0500);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x810F);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8111);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x811D);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xAC36, BIT_12);
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xAD1C, BIT_8);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xADE8,
+                                              0xFFC0,
+                                              0x1400);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x864B);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x9D00);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8F97);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x003F);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3F02);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x023C);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3B0A);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1C00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+
+
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xAD9C, BIT_5);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8122);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0C00);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x82C8);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03ED);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03FF);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0009);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03FE);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x000B);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0021);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03F7);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03B8);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03E0);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0049);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0049);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03E0);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03B8);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03F7);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0021);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x000B);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03FE);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0009);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03FF);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03ED);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80EF);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0C00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x82A0);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x000E);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03FE);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03ED);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0006);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x001A);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03F1);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03D8);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0023);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0054);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0322);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x00DD);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03AB);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03DC);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0027);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x000E);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03E5);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03F9);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0012);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0001);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03F1);
+
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8018);
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xA438, BIT_13);
+
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FE4);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0000);
+
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB54C,
+                                              0xFFC0,
+                                              0x3700);
+
+
+        if (aspm && HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                rtl8126_enable_phy_aldps(tp);
+}
+
+static void
+rtl8126_hw_phy_config_8126a_3(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xA442, BIT_11);
+
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8183);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x5900);
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xA654, BIT_11);
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xB648, BIT_14);
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xAD2C, BIT_15);
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xAD94, BIT_5);
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xADA0, BIT_1);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xAE06,
+                                              BIT_15 | BIT_14 | BIT_13 | BIT_12 | BIT_11 | BIT_10,
+                                              BIT_14 | BIT_13 | BIT_12 | BIT_11 | BIT_10);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8647);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0xE600);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8036);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x3000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8078);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x3000);
+
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x89E9);
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xB87E, 0xFF00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FFD);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FFE);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0200);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FFF);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0400);
+
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8018);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x7700);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8F9C);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0005);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x00ED);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0502);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0B00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0xD401);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FA8);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xA438,
+                                              0xFF00,
+                                              0x2900);
+
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x814B);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x1100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x814D);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x1100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x814F);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0B00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8142);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8144);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8150);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8118);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0700);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x811A);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0700);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x811C);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0500);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x810F);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8111);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x811D);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0100);
+
+
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xAD1C, BIT_8);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xADE8,
+                                              BIT_15 | BIT_14 | BIT_13 | BIT_12 | BIT_11 | BIT_10 | BIT_9 | BIT_8 | BIT_7 | BIT_6,
+                                              BIT_12 | BIT_10);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x864B);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x9D00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x862C);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x1200);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA436, 0x8566);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x003F);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3F02);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x023C);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x3B0A);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x1C00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+
+
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xAD9C, BIT_5);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8122);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0C00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x82C8);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03ED);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03FF);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0009);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03FE);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x000B);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0021);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03F7);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03B8);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03E0);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0049);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0049);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03E0);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03B8);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03F7);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0021);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x000B);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03FE);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0009);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03FF);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03ED);
+
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80EF);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x0C00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x82A0);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x000E);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03FE);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03ED);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0006);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x001A);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03F1);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03D8);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0023);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0054);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0322);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x00DD);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03AB);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03DC);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0027);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x000E);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03E5);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03F9);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0012);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0001);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87E, 0x03F1);
+
+
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xA430, BIT_1 | BIT_0);
+
+
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB54C,
+                                              0xFFC0,
+                                              0x3700);
+
+
+        rtl8126_set_eth_phy_ocp_bit(tp, 0xB648, BIT_6);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8082);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x5D00);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x807C);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x5000);
+        rtl8126_mdio_direct_write_phy_ocp(tp, 0xB87C, 0x809D);
+        rtl8126_clear_and_set_eth_phy_ocp_bit(tp,
+                                              0xB87E,
+                                              0xFF00,
+                                              0x5000);
+
+
+        if (aspm && HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp))
+                rtl8126_enable_phy_aldps(tp);
+}
+
+static void
+rtl8126_hw_phy_config(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        unsigned long flags;
+
+        if (tp->resume_not_chg_speed)
+                return;
+
+        tp->phy_reset_enable(dev);
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+#ifndef ENABLE_USE_FIRMWARE_FILE
+        if (!tp->rtl_fw)
+                rtl8126_init_hw_phy_mcu(dev);
+#endif
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_1:
+                rtl8126_hw_phy_config_8126a_1(dev);
+                break;
+        case CFG_METHOD_2:
+                rtl8126_hw_phy_config_8126a_2(dev);
+                break;
+        case CFG_METHOD_3:
+                rtl8126_hw_phy_config_8126a_3(dev);
+                break;
+        }
+
+        //legacy force mode(Chap 22)
+        rtl8126_clear_eth_phy_ocp_bit(tp, 0xA5B4, BIT_15);
+
+#ifdef ENABLE_FIBER_SUPPORT
+        if (HW_FIBER_MODE_ENABLED(tp))
+                rtl8126_hw_fiber_phy_config(tp);
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        rtl8126_mdio_write(tp, 0x1F, 0x0000);
+
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                if (tp->eee.eee_enabled)
+                        rtl8126_enable_eee(tp);
+                else
+                        rtl8126_disable_eee(tp);
+        }
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+}
+
+static void
+rtl8126_up(struct net_device *dev)
+{
+        rtl8126_hw_init(dev);
+        rtl8126_hw_reset(dev);
+        rtl8126_powerup_pll(dev);
+        rtl8126_hw_ephy_config(dev);
+        rtl8126_hw_phy_config(dev);
+        rtl8126_hw_config(dev);
+}
+
+/*
+static inline void rtl8126_delete_esd_timer(struct net_device *dev, struct timer_list *timer)
+{
+        del_timer_sync(timer);
+}
+
+static inline void rtl8126_request_esd_timer(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        struct timer_list *timer = &tp->esd_timer;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+        setup_timer(timer, rtl8126_esd_timer, (unsigned long)dev);
+#else
+        timer_setup(timer, rtl8126_esd_timer, 0);
+#endif
+        mod_timer(timer, jiffies + RTL8126_ESD_TIMEOUT);
+}
+*/
+
+/*
+static inline void rtl8126_delete_link_timer(struct net_device *dev, struct timer_list *timer)
+{
+        del_timer_sync(timer);
+}
+
+static inline void rtl8126_request_link_timer(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        struct timer_list *timer = &tp->link_timer;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+        setup_timer(timer, rtl8126_link_timer, (unsigned long)dev);
+#else
+        timer_setup(timer, rtl8126_link_timer, 0);
+#endif
+        mod_timer(timer, jiffies + RTL8126_LINK_TIMEOUT);
+}
+*/
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+static void
+rtl8126_netpoll(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i;
+        for (i = 0; i < tp->irq_nvecs; i++) {
+                struct r8126_irq *irq = &tp->irq_tbl[i];
+                struct r8126_napi *r8126napi = &tp->r8126napi[i];
+
+                disable_irq(irq->vector);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+                irq->handler(irq->vector, r8126napi);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+                irq->handler(irq->vector, r8126napi, NULL);
+#else
+                irq->handler(irq->vector, r8126napi);
+#endif
+
+                enable_irq(irq->vector);
+        }
+}
+#endif //CONFIG_NET_POLL_CONTROLLER
+
+static void
+rtl8126_setup_interrupt_mask(struct rtl8126_private *tp)
+{
+        int i;
+
+        if (tp->HwCurrIsrVer == 5) {
+                tp->intr_mask = ISRIMR_V5_LINKCHG | ISRIMR_V5_TOK_Q0;
+                if (tp->num_tx_rings > 1)
+                        tp->intr_mask |= ISRIMR_V5_TOK_Q1;
+                for (i = 0; i < tp->num_rx_rings; i++)
+                        tp->intr_mask |= ISRIMR_V5_ROK_Q0 << i;
+        } else if (tp->HwCurrIsrVer == 4) {
+                tp->intr_mask = ISRIMR_V4_LINKCHG;
+                for (i = 0; i < tp->num_rx_rings; i++)
+                        tp->intr_mask |= ISRIMR_V4_ROK_Q0 << i;
+        } else if (tp->HwCurrIsrVer == 3) {
+                tp->intr_mask = ISRIMR_V2_LINKCHG;
+                for (i = 0; i < max(tp->num_tx_rings, tp->num_rx_rings); i++)
+                        tp->intr_mask |= ISRIMR_V2_ROK_Q0 << i;
+        } else if (tp->HwCurrIsrVer == 2) {
+                tp->intr_mask = ISRIMR_V2_LINKCHG | ISRIMR_TOK_Q0;
+                if (tp->num_tx_rings > 1)
+                        tp->intr_mask |= ISRIMR_TOK_Q1;
+
+                for (i = 0; i < tp->num_rx_rings; i++)
+                        tp->intr_mask |= ISRIMR_V2_ROK_Q0 << i;
+        } else {
+                tp->intr_mask = LinkChg | RxDescUnavail | TxOK | RxOK | SWInt;
+                tp->timer_intr_mask = LinkChg | PCSTimeout;
+        }
+}
+
+static void
+rtl8126_setup_mqs_reg(struct rtl8126_private *tp)
+{
+        u16 hw_clo_ptr0_reg, sw_tail_ptr0_reg;
+        u16 reg_len;
+        int i;
+
+        //tx
+        tp->tx_ring[0].tdsar_reg = TxDescStartAddrLow;
+        for (i = 1; i < tp->HwSuppNumTxQueues; i++)
+                tp->tx_ring[i].tdsar_reg = (u16)(TNPDS_Q1_LOW_8125 + (i - 1) * 8);
+
+        switch (tp->HwSuppTxNoCloseVer) {
+        case 4:
+        case 5:
+                hw_clo_ptr0_reg = HW_CLO_PTR0_8126;
+                sw_tail_ptr0_reg = SW_TAIL_PTR0_8126;
+                reg_len = 4;
+                break;
+        case 6:
+                hw_clo_ptr0_reg = HW_CLO_PTR0_8125BP;
+                sw_tail_ptr0_reg = SW_TAIL_PTR0_8125BP;
+                reg_len = 8;
+                break;
+        default:
+                hw_clo_ptr0_reg = HW_CLO_PTR0_8125;
+                sw_tail_ptr0_reg = SW_TAIL_PTR0_8125;
+                reg_len = 4;
+                break;
+        }
+
+        for (i = 0; i < tp->HwSuppNumTxQueues; i++) {
+                tp->tx_ring[i].hw_clo_ptr_reg = (u16)(hw_clo_ptr0_reg + i * reg_len);
+                tp->tx_ring[i].sw_tail_ptr_reg = (u16)(sw_tail_ptr0_reg + i * reg_len);
+        }
+
+        //rx
+        tp->rx_ring[0].rdsar_reg = RxDescAddrLow;
+        for (i = 1; i < tp->HwSuppNumRxQueues; i++)
+                tp->rx_ring[i].rdsar_reg = (u16)(RDSAR_Q1_LOW_8125 + (i - 1) * 8);
+
+        tp->isr_reg[0] = ISR0_8125;
+        for (i = 1; i < tp->hw_supp_irq_nvecs; i++)
+                tp->isr_reg[i] = (u16)(ISR1_8125 + (i - 1) * 4);
+
+        tp->imr_reg[0] = IMR0_8125;
+        for (i = 1; i < tp->hw_supp_irq_nvecs; i++)
+                tp->imr_reg[i] = (u16)(IMR1_8125 + (i - 1) * 4);
+}
+
+static void
+rtl8126_init_software_variable(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        struct pci_dev *pdev = tp->pci_dev;
+
+#ifdef ENABLE_LIB_SUPPORT
+        tp->ring_lib_enabled = 1;
+#endif
+        tp->HwPkgDet = rtl8126_mac_ocp_read(tp, 0xDC00);
+        tp->HwPkgDet = (tp->HwPkgDet >> 3) & 0x07;
+
+        tp->HwSuppNowIsOobVer = 1;
+
+        tp->HwPcieSNOffset = 0x174;
+
+#ifdef ENABLE_REALWOW_SUPPORT
+        rtl8126_get_realwow_hw_version(dev);
+#endif //ENABLE_REALWOW_SUPPORT
+
+        if (aspm) {
+                tp->org_pci_offset_99 = rtl8126_csi_fun0_read_byte(tp, 0x99);
+                tp->org_pci_offset_99 &= ~(BIT_5|BIT_6);
+
+                tp->org_pci_offset_180 = rtl8126_csi_fun0_read_byte(tp, 0x22c);
+        }
+
+        pci_read_config_byte(pdev, 0x80, &tp->org_pci_offset_80);
+        pci_read_config_byte(pdev, 0x81, &tp->org_pci_offset_81);
+
+        tp->use_timer_interrupt = TRUE;
+
+        tp->HwSuppMaxPhyLinkSpeed = 5000;
+
+        if (timer_count == 0 || tp->mcfg == CFG_METHOD_DEFAULT)
+                tp->use_timer_interrupt = FALSE;
+
+        tp->ShortPacketSwChecksum = TRUE;
+        tp->UseSwPaddingShortPkt = TRUE;
+
+#ifdef ENABLE_FIBER_SUPPORT
+        rtl8126_check_fiber_mode_support(tp);
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        tp->HwSuppMagicPktVer = WAKEUP_MAGIC_PACKET_V3;
+
+        tp->HwSuppLinkChgWakeUpVer = 3;
+
+        tp->HwSuppD0SpeedUpVer = 1;
+
+        tp->HwSuppCheckPhyDisableModeVer = 3;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_1:
+                tp->HwSuppTxNoCloseVer = 4;
+                break;
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+                tp->HwSuppTxNoCloseVer = 5;
+                break;
+        }
+
+        switch (tp->HwSuppTxNoCloseVer) {
+        case 5:
+        case 6:
+                tp->MaxTxDescPtrMask = MAX_TX_NO_CLOSE_DESC_PTR_MASK_V4;
+                break;
+        case 4:
+                tp->MaxTxDescPtrMask = MAX_TX_NO_CLOSE_DESC_PTR_MASK_V3;
+                break;
+        case 3:
+                tp->MaxTxDescPtrMask = MAX_TX_NO_CLOSE_DESC_PTR_MASK_V2;
+                break;
+        default:
+                tx_no_close_enable = 0;
+                break;
+        }
+
+        if (tp->HwSuppTxNoCloseVer > 0 && tx_no_close_enable == 1)
+                tp->EnableTxNoClose = TRUE;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_1:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_1;
+                break;
+        case CFG_METHOD_2:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_2;
+                break;
+        case CFG_METHOD_3:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_3;
+                break;
+        }
+
+        if (tp->HwIcVerUnknown) {
+                tp->NotWrRamCodeToMicroP = TRUE;
+                tp->NotWrMcuPatchCode = TRUE;
+        }
+
+        tp->HwSuppMacMcuVer = 2;
+
+        tp->MacMcuPageSize = RTL8126_MAC_MCU_PAGE_SIZE;
+
+        tp->HwSuppNumTxQueues = 2;
+        tp->HwSuppNumRxQueues = 4;
+
+        //init interrupt
+        switch (tp->mcfg) {
+        case CFG_METHOD_1:
+                tp->HwSuppIsrVer = 2;
+                break;
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+                tp->HwSuppIsrVer = 3;
+                break;
+        default:
+                tp->HwSuppIsrVer = 1;
+                break;
+        }
+
+        tp->HwCurrIsrVer = tp->HwSuppIsrVer;
+        if (tp->HwCurrIsrVer > 1) {
+                if (!(tp->features & RTL_FEATURE_MSIX) ||
+                    tp->irq_nvecs < tp->min_irq_nvecs)
+                        tp->HwCurrIsrVer = 1;
+        }
+
+        tp->num_tx_rings = 1;
+#ifdef ENABLE_MULTIPLE_TX_QUEUE
+#ifndef ENABLE_LIB_SUPPORT
+        tp->num_tx_rings = tp->HwSuppNumTxQueues;
+#endif
+#endif
+        if (tp->HwCurrIsrVer < 2 ||
+            (tp->HwCurrIsrVer == 2 && tp->irq_nvecs < 19))
+                tp->num_tx_rings = 1;
+
+        //RSS
+        tp->HwSuppRssVer = 5;
+        tp->HwSuppIndirTblEntries = 128;
+
+        tp->num_rx_rings = 1;
+#ifdef ENABLE_RSS_SUPPORT
+#ifdef ENABLE_LIB_SUPPORT
+        if (tp->HwSuppRssVer > 0)
+                tp->EnableRss = 1;
+#else
+        if (tp->HwSuppRssVer > 0 && tp->HwCurrIsrVer > 1) {
+                u8 rss_queue_num = netif_get_num_default_rss_queues();
+                tp->num_rx_rings = (tp->HwSuppNumRxQueues > rss_queue_num)?
+                                   rss_queue_num : tp->HwSuppNumRxQueues;
+
+                if (!(tp->num_rx_rings >= 2 && tp->irq_nvecs >= tp->num_rx_rings))
+                        tp->num_rx_rings = 1;
+
+                if (tp->num_rx_rings >= 2)
+                        tp->EnableRss = 1;
+        }
+#endif
+#endif
+
+        //interrupt mask
+        rtl8126_setup_interrupt_mask(tp);
+
+        rtl8126_setup_mqs_reg(tp);
+
+        rtl8126_set_ring_size(tp, NUM_RX_DESC, NUM_TX_DESC);
+
+        tp->HwSuppPtpVer = 2;
+#ifdef ENABLE_PTP_SUPPORT
+        if (tp->HwSuppPtpVer > 0)
+                tp->EnablePtp = 1;
+#endif
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_1:
+                tp->HwSuppIntMitiVer = 4;
+                break;
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+                tp->HwSuppIntMitiVer = 5;
+                break;
+        }
+
+        tp->HwSuppTcamVer = 2;
+
+        tp->TcamNotValidReg = TCAM_NOTVALID_ADDR_V2;
+        tp->TcamValidReg = TCAM_VALID_ADDR_V2;
+        tp->TcamMaAddrcOffset = TCAM_MAC_ADDR_V2;
+        tp->TcamVlanTagOffset = TCAM_VLAN_TAG_V2;
+
+        tp->HwSuppExtendTallyCounterVer = 1;
+
+        timer_count_v2 = (timer_count / 0x100);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_1:
+                tp->HwSuppRxDescType = RX_DESC_RING_TYPE_3;
+                break;
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+                tp->HwSuppRxDescType = RX_DESC_RING_TYPE_4;
+                break;
+        default:
+                tp->HwSuppRxDescType = RX_DESC_RING_TYPE_1;
+                break;
+        }
+
+        tp->InitRxDescType = RX_DESC_RING_TYPE_1;
+        tp->RxDescLength = RX_DESC_LEN_TYPE_1;
+        switch (tp->HwSuppRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                if (tp->EnableRss) {
+                        tp->InitRxDescType = RX_DESC_RING_TYPE_3;
+                        tp->RxDescLength = RX_DESC_LEN_TYPE_3;
+                }
+                break;
+        case RX_DESC_RING_TYPE_4:
+                if (tp->EnableRss) {
+                        tp->InitRxDescType = RX_DESC_RING_TYPE_4;
+                        tp->RxDescLength = RX_DESC_LEN_TYPE_4;
+                }
+                break;
+        }
+
+        tp->rtl8126_rx_config = rtl_chip_info[tp->chipset].RCR_Cfg;
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                tp->rtl8126_rx_config |= EnableRxDescV3;
+        else if (tp->InitRxDescType == RX_DESC_RING_TYPE_4)
+                tp->rtl8126_rx_config &= ~EnableRxDescV4_1;
+
+        tp->NicCustLedValue = RTL_R16(tp, CustomLED);
+
+        tp->wol_opts = rtl8126_get_hw_wol(tp);
+        tp->wol_enabled = (tp->wol_opts) ? WOL_ENABLED : WOL_DISABLED;
+
+        rtl8126_set_link_option(tp, autoneg_mode, speed_mode, duplex_mode,
+                                rtl8126_fc_full);
+
+        tp->max_jumbo_frame_size = rtl_chip_info[tp->chipset].jumbo_frame_sz;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+        /* MTU range: 60 - hw-specific max */
+        dev->min_mtu = ETH_MIN_MTU;
+        dev->max_mtu = tp->max_jumbo_frame_size;
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+
+        if (tp->mcfg != CFG_METHOD_DEFAULT) {
+                struct ethtool_keee *eee = &tp->eee;
+
+                eee->eee_enabled = eee_enable;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,9,0)
+                eee->supported  = SUPPORTED_100baseT_Full |
+                                  SUPPORTED_1000baseT_Full |
+                                  SUPPORTED_2500baseX_Full;
+                eee->advertised = mmd_eee_adv_to_ethtool_adv_t(MDIO_EEE_1000T | MDIO_EEE_100TX);
+                eee->advertised |= SUPPORTED_2500baseX_Full;
+#else
+                linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, eee->supported);
+                linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, eee->supported);
+                linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, eee->supported);
+                linkmode_set_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT, eee->supported);
+                linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, eee->advertised);
+                linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, eee->advertised);
+                linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, eee->advertised);
+                linkmode_set_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT, eee->advertised);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(6,9,0) */
+                eee->tx_lpi_enabled = eee_enable;
+                eee->tx_lpi_timer = dev->mtu + ETH_HLEN + 0x20;
+        }
+
+#ifdef ENABLE_RSS_SUPPORT
+        if (tp->EnableRss)
+                rtl8126_init_rss(tp);
+#endif
+}
+
+static void
+rtl8126_release_board(struct pci_dev *pdev,
+                      struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+
+        rtl8126_rar_set(tp, tp->org_mac_addr);
+        tp->wol_enabled = WOL_DISABLED;
+
+        rtl8126_phy_power_down(dev);
+
+        iounmap(ioaddr);
+        pci_release_regions(pdev);
+        pci_clear_mwi(pdev);
+        pci_disable_device(pdev);
+        free_netdev(dev);
+}
+
+static void
+rtl8126_hw_address_set(struct net_device *dev, u8 mac_addr[MAC_ADDR_LEN])
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+        eth_hw_addr_set(dev, mac_addr);
+#else
+        memcpy(dev->dev_addr, mac_addr, MAC_ADDR_LEN);
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+}
+
+static int
+rtl8126_get_mac_address(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i;
+        u8 mac_addr[MAC_ADDR_LEN];
+
+        for (i = 0; i < MAC_ADDR_LEN; i++)
+                mac_addr[i] = RTL_R8(tp, MAC0 + i);
+
+        *(u32*)&mac_addr[0] = RTL_R32(tp, BACKUP_ADDR0_8125);
+        *(u16*)&mac_addr[4] = RTL_R16(tp, BACKUP_ADDR1_8125);
+
+        if (!is_valid_ether_addr(mac_addr)) {
+                netif_err(tp, probe, dev, "Invalid ether addr %pM\n",
+                          mac_addr);
+                eth_random_addr(mac_addr);
+                dev->addr_assign_type = NET_ADDR_RANDOM;
+                netif_info(tp, probe, dev, "Random ether addr %pM\n",
+                           mac_addr);
+                tp->random_mac = 1;
+        }
+
+        rtl8126_hw_address_set(dev, mac_addr);
+        rtl8126_rar_set(tp, mac_addr);
+
+        /* keep the original MAC address */
+        memcpy(tp->org_mac_addr, dev->dev_addr, MAC_ADDR_LEN);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+        memcpy(dev->perm_addr, dev->dev_addr, MAC_ADDR_LEN);
+#endif
+        return 0;
+}
+
+/**
+ * rtl8126_set_mac_address - Change the Ethernet Address of the NIC
+ * @dev: network interface device structure
+ * @p:   pointer to an address structure
+ *
+ * Return 0 on success, negative on failure
+ **/
+static int
+rtl8126_set_mac_address(struct net_device *dev,
+                        void *p)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        struct sockaddr *addr = p;
+
+        if (!is_valid_ether_addr(addr->sa_data))
+                return -EADDRNOTAVAIL;
+
+        rtl8126_hw_address_set(dev, addr->sa_data);
+
+        rtl8126_rar_set(tp, dev->dev_addr);
+
+        return 0;
+}
+
+/******************************************************************************
+ * rtl8126_rar_set - Puts an ethernet address into a receive address register.
+ *
+ * tp - The private data structure for driver
+ * addr - Address to put into receive address register
+ *****************************************************************************/
+void
+rtl8126_rar_set(struct rtl8126_private *tp,
+                const u8 *addr)
+{
+        uint32_t rar_low = 0;
+        uint32_t rar_high = 0;
+
+        rar_low = ((uint32_t) addr[0] |
+                   ((uint32_t) addr[1] << 8) |
+                   ((uint32_t) addr[2] << 16) |
+                   ((uint32_t) addr[3] << 24));
+
+        rar_high = ((uint32_t) addr[4] |
+                    ((uint32_t) addr[5] << 8));
+
+        rtl8126_enable_cfg9346_write(tp);
+        RTL_W32(tp, MAC0, rar_low);
+        RTL_W32(tp, MAC4, rar_high);
+
+        rtl8126_disable_cfg9346_write(tp);
+}
+
+#ifdef ETHTOOL_OPS_COMPAT
+static int ethtool_get_settings(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_cmd cmd = { ETHTOOL_GSET };
+        int err;
+
+        if (!ethtool_ops->get_settings)
+                return -EOPNOTSUPP;
+
+        err = ethtool_ops->get_settings(dev, &cmd);
+        if (err < 0)
+                return err;
+
+        if (copy_to_user(useraddr, &cmd, sizeof(cmd)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_settings(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_cmd cmd;
+
+        if (!ethtool_ops->set_settings)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&cmd, useraddr, sizeof(cmd)))
+                return -EFAULT;
+
+        return ethtool_ops->set_settings(dev, &cmd);
+}
+
+static int ethtool_get_drvinfo(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_drvinfo info;
+        struct ethtool_ops *ops = ethtool_ops;
+
+        if (!ops->get_drvinfo)
+                return -EOPNOTSUPP;
+
+        memset(&info, 0, sizeof(info));
+        info.cmd = ETHTOOL_GDRVINFO;
+        ops->get_drvinfo(dev, &info);
+
+        if (ops->self_test_count)
+                info.testinfo_len = ops->self_test_count(dev);
+        if (ops->get_stats_count)
+                info.n_stats = ops->get_stats_count(dev);
+        if (ops->get_regs_len)
+                info.regdump_len = ops->get_regs_len(dev);
+        if (ops->get_eeprom_len)
+                info.eedump_len = ops->get_eeprom_len(dev);
+
+        if (copy_to_user(useraddr, &info, sizeof(info)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_get_regs(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_regs regs;
+        struct ethtool_ops *ops = ethtool_ops;
+        void *regbuf;
+        int reglen, ret;
+
+        if (!ops->get_regs || !ops->get_regs_len)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&regs, useraddr, sizeof(regs)))
+                return -EFAULT;
+
+        reglen = ops->get_regs_len(dev);
+        if (regs.len > reglen)
+                regs.len = reglen;
+
+        regbuf = kmalloc(reglen, GFP_USER);
+        if (!regbuf)
+                return -ENOMEM;
+
+        ops->get_regs(dev, &regs, regbuf);
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &regs, sizeof(regs)))
+                goto out;
+        useraddr += offsetof(struct ethtool_regs, data);
+        if (copy_to_user(useraddr, regbuf, reglen))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(regbuf);
+        return ret;
+}
+
+static int ethtool_get_wol(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_wolinfo wol = { ETHTOOL_GWOL };
+
+        if (!ethtool_ops->get_wol)
+                return -EOPNOTSUPP;
+
+        ethtool_ops->get_wol(dev, &wol);
+
+        if (copy_to_user(useraddr, &wol, sizeof(wol)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_wol(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_wolinfo wol;
+
+        if (!ethtool_ops->set_wol)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&wol, useraddr, sizeof(wol)))
+                return -EFAULT;
+
+        return ethtool_ops->set_wol(dev, &wol);
+}
+
+static int ethtool_get_msglevel(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GMSGLVL };
+
+        if (!ethtool_ops->get_msglevel)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_msglevel(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_msglevel(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_msglevel)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        ethtool_ops->set_msglevel(dev, edata.data);
+        return 0;
+}
+
+static int ethtool_nway_reset(struct net_device *dev)
+{
+        if (!ethtool_ops->nway_reset)
+                return -EOPNOTSUPP;
+
+        return ethtool_ops->nway_reset(dev);
+}
+
+static int ethtool_get_link(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GLINK };
+
+        if (!ethtool_ops->get_link)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_link(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_get_eeprom(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_eeprom eeprom;
+        struct ethtool_ops *ops = ethtool_ops;
+        u8 *data;
+        int ret;
+
+        if (!ops->get_eeprom || !ops->get_eeprom_len)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&eeprom, useraddr, sizeof(eeprom)))
+                return -EFAULT;
+
+        /* Check for wrap and zero */
+        if (eeprom.offset + eeprom.len <= eeprom.offset)
+                return -EINVAL;
+
+        /* Check for exceeding total eeprom len */
+        if (eeprom.offset + eeprom.len > ops->get_eeprom_len(dev))
+                return -EINVAL;
+
+        data = kmalloc(eeprom.len, GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ret = -EFAULT;
+        if (copy_from_user(data, useraddr + sizeof(eeprom), eeprom.len))
+                goto out;
+
+        ret = ops->get_eeprom(dev, &eeprom, data);
+        if (ret)
+                goto out;
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &eeprom, sizeof(eeprom)))
+                goto out;
+        if (copy_to_user(useraddr + sizeof(eeprom), data, eeprom.len))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_set_eeprom(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_eeprom eeprom;
+        struct ethtool_ops *ops = ethtool_ops;
+        u8 *data;
+        int ret;
+
+        if (!ops->set_eeprom || !ops->get_eeprom_len)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&eeprom, useraddr, sizeof(eeprom)))
+                return -EFAULT;
+
+        /* Check for wrap and zero */
+        if (eeprom.offset + eeprom.len <= eeprom.offset)
+                return -EINVAL;
+
+        /* Check for exceeding total eeprom len */
+        if (eeprom.offset + eeprom.len > ops->get_eeprom_len(dev))
+                return -EINVAL;
+
+        data = kmalloc(eeprom.len, GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ret = -EFAULT;
+        if (copy_from_user(data, useraddr + sizeof(eeprom), eeprom.len))
+                goto out;
+
+        ret = ops->set_eeprom(dev, &eeprom, data);
+        if (ret)
+                goto out;
+
+        if (copy_to_user(useraddr + sizeof(eeprom), data, eeprom.len))
+                ret = -EFAULT;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_get_coalesce(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_coalesce coalesce = { ETHTOOL_GCOALESCE };
+
+        if (!ethtool_ops->get_coalesce)
+                return -EOPNOTSUPP;
+
+        ethtool_ops->get_coalesce(dev, &coalesce);
+
+        if (copy_to_user(useraddr, &coalesce, sizeof(coalesce)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_coalesce(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_coalesce coalesce;
+
+        if (!ethtool_ops->get_coalesce)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&coalesce, useraddr, sizeof(coalesce)))
+                return -EFAULT;
+
+        return ethtool_ops->set_coalesce(dev, &coalesce);
+}
+
+static int ethtool_get_ringparam(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_ringparam ringparam = { ETHTOOL_GRINGPARAM };
+
+        if (!ethtool_ops->get_ringparam)
+                return -EOPNOTSUPP;
+
+        ethtool_ops->get_ringparam(dev, &ringparam);
+
+        if (copy_to_user(useraddr, &ringparam, sizeof(ringparam)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_ringparam(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_ringparam ringparam;
+
+        if (!ethtool_ops->get_ringparam)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&ringparam, useraddr, sizeof(ringparam)))
+                return -EFAULT;
+
+        return ethtool_ops->set_ringparam(dev, &ringparam);
+}
+
+static int ethtool_get_pauseparam(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_pauseparam pauseparam = { ETHTOOL_GPAUSEPARAM };
+
+        if (!ethtool_ops->get_pauseparam)
+                return -EOPNOTSUPP;
+
+        ethtool_ops->get_pauseparam(dev, &pauseparam);
+
+        if (copy_to_user(useraddr, &pauseparam, sizeof(pauseparam)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_pauseparam(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_pauseparam pauseparam;
+
+        if (!ethtool_ops->get_pauseparam)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&pauseparam, useraddr, sizeof(pauseparam)))
+                return -EFAULT;
+
+        return ethtool_ops->set_pauseparam(dev, &pauseparam);
+}
+
+static int ethtool_get_rx_csum(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GRXCSUM };
+
+        if (!ethtool_ops->get_rx_csum)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_rx_csum(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_rx_csum(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_rx_csum)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        ethtool_ops->set_rx_csum(dev, edata.data);
+        return 0;
+}
+
+static int ethtool_get_tx_csum(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GTXCSUM };
+
+        if (!ethtool_ops->get_tx_csum)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_tx_csum(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_tx_csum(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_tx_csum)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        return ethtool_ops->set_tx_csum(dev, edata.data);
+}
+
+static int ethtool_get_sg(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GSG };
+
+        if (!ethtool_ops->get_sg)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_sg(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_sg(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_sg)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        return ethtool_ops->set_sg(dev, edata.data);
+}
+
+static int ethtool_get_tso(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GTSO };
+
+        if (!ethtool_ops->get_tso)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_tso(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_tso(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_tso)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        return ethtool_ops->set_tso(dev, edata.data);
+}
+
+static int ethtool_self_test(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_test test;
+        struct ethtool_ops *ops = ethtool_ops;
+        u64 *data;
+        int ret;
+
+        if (!ops->self_test || !ops->self_test_count)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&test, useraddr, sizeof(test)))
+                return -EFAULT;
+
+        test.len = ops->self_test_count(dev);
+        data = kmalloc(test.len * sizeof(u64), GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ops->self_test(dev, &test, data);
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &test, sizeof(test)))
+                goto out;
+        useraddr += sizeof(test);
+        if (copy_to_user(useraddr, data, test.len * sizeof(u64)))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_get_strings(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_gstrings gstrings;
+        struct ethtool_ops *ops = ethtool_ops;
+        u8 *data;
+        int ret;
+
+        if (!ops->get_strings)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&gstrings, useraddr, sizeof(gstrings)))
+                return -EFAULT;
+
+        switch (gstrings.string_set) {
+        case ETH_SS_TEST:
+                if (!ops->self_test_count)
+                        return -EOPNOTSUPP;
+                gstrings.len = ops->self_test_count(dev);
+                break;
+        case ETH_SS_STATS:
+                if (!ops->get_stats_count)
+                        return -EOPNOTSUPP;
+                gstrings.len = ops->get_stats_count(dev);
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        data = kmalloc(gstrings.len * ETH_GSTRING_LEN, GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ops->get_strings(dev, gstrings.string_set, data);
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &gstrings, sizeof(gstrings)))
+                goto out;
+        useraddr += sizeof(gstrings);
+        if (copy_to_user(useraddr, data, gstrings.len * ETH_GSTRING_LEN))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_phys_id(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_value id;
+
+        if (!ethtool_ops->phys_id)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&id, useraddr, sizeof(id)))
+                return -EFAULT;
+
+        return ethtool_ops->phys_id(dev, id.data);
+}
+
+static int ethtool_get_stats(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_stats stats;
+        struct ethtool_ops *ops = ethtool_ops;
+        u64 *data;
+        int ret;
+
+        if (!ops->get_ethtool_stats || !ops->get_stats_count)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&stats, useraddr, sizeof(stats)))
+                return -EFAULT;
+
+        stats.n_stats = ops->get_stats_count(dev);
+        data = kmalloc(stats.n_stats * sizeof(u64), GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ops->get_ethtool_stats(dev, &stats, data);
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &stats, sizeof(stats)))
+                goto out;
+        useraddr += sizeof(stats);
+        if (copy_to_user(useraddr, data, stats.n_stats * sizeof(u64)))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_ioctl(struct ifreq *ifr)
+{
+        struct net_device *dev = __dev_get_by_name(ifr->ifr_name);
+        void *useraddr = (void *) ifr->ifr_data;
+        u32 ethcmd;
+
+        /*
+         * XXX: This can be pushed down into the ethtool_* handlers that
+         * need it.  Keep existing behaviour for the moment.
+         */
+        if (!capable(CAP_NET_ADMIN))
+                return -EPERM;
+
+        if (!dev || !netif_device_present(dev))
+                return -ENODEV;
+
+        if (copy_from_user(&ethcmd, useraddr, sizeof (ethcmd)))
+                return -EFAULT;
+
+        switch (ethcmd) {
+        case ETHTOOL_GSET:
+                return ethtool_get_settings(dev, useraddr);
+        case ETHTOOL_SSET:
+                return ethtool_set_settings(dev, useraddr);
+        case ETHTOOL_GDRVINFO:
+                return ethtool_get_drvinfo(dev, useraddr);
+        case ETHTOOL_GREGS:
+                return ethtool_get_regs(dev, useraddr);
+        case ETHTOOL_GWOL:
+                return ethtool_get_wol(dev, useraddr);
+        case ETHTOOL_SWOL:
+                return ethtool_set_wol(dev, useraddr);
+        case ETHTOOL_GMSGLVL:
+                return ethtool_get_msglevel(dev, useraddr);
+        case ETHTOOL_SMSGLVL:
+                return ethtool_set_msglevel(dev, useraddr);
+        case ETHTOOL_NWAY_RST:
+                return ethtool_nway_reset(dev);
+        case ETHTOOL_GLINK:
+                return ethtool_get_link(dev, useraddr);
+        case ETHTOOL_GEEPROM:
+                return ethtool_get_eeprom(dev, useraddr);
+        case ETHTOOL_SEEPROM:
+                return ethtool_set_eeprom(dev, useraddr);
+        case ETHTOOL_GCOALESCE:
+                return ethtool_get_coalesce(dev, useraddr);
+        case ETHTOOL_SCOALESCE:
+                return ethtool_set_coalesce(dev, useraddr);
+        case ETHTOOL_GRINGPARAM:
+                return ethtool_get_ringparam(dev, useraddr);
+        case ETHTOOL_SRINGPARAM:
+                return ethtool_set_ringparam(dev, useraddr);
+        case ETHTOOL_GPAUSEPARAM:
+                return ethtool_get_pauseparam(dev, useraddr);
+        case ETHTOOL_SPAUSEPARAM:
+                return ethtool_set_pauseparam(dev, useraddr);
+        case ETHTOOL_GRXCSUM:
+                return ethtool_get_rx_csum(dev, useraddr);
+        case ETHTOOL_SRXCSUM:
+                return ethtool_set_rx_csum(dev, useraddr);
+        case ETHTOOL_GTXCSUM:
+                return ethtool_get_tx_csum(dev, useraddr);
+        case ETHTOOL_STXCSUM:
+                return ethtool_set_tx_csum(dev, useraddr);
+        case ETHTOOL_GSG:
+                return ethtool_get_sg(dev, useraddr);
+        case ETHTOOL_SSG:
+                return ethtool_set_sg(dev, useraddr);
+        case ETHTOOL_GTSO:
+                return ethtool_get_tso(dev, useraddr);
+        case ETHTOOL_STSO:
+                return ethtool_set_tso(dev, useraddr);
+        case ETHTOOL_TEST:
+                return ethtool_self_test(dev, useraddr);
+        case ETHTOOL_GSTRINGS:
+                return ethtool_get_strings(dev, useraddr);
+        case ETHTOOL_PHYS_ID:
+                return ethtool_phys_id(dev, useraddr);
+        case ETHTOOL_GSTATS:
+                return ethtool_get_stats(dev, useraddr);
+        default:
+                return -EOPNOTSUPP;
+        }
+
+        return -EOPNOTSUPP;
+}
+#endif //ETHTOOL_OPS_COMPAT
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0)
+static int rtl8126_siocdevprivate(struct net_device *dev, struct ifreq *ifr,
+                                  void __user *data, int cmd)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int ret = 0;
+
+        switch (cmd) {
+#ifdef ENABLE_REALWOW_SUPPORT
+        case SIOCDEVPRIVATE_RTLREALWOW:
+                if (!netif_running(dev)) {
+                        ret = -ENODEV;
+                        break;
+                }
+
+                ret = rtl8126_realwow_ioctl(dev, ifr);
+                break;
+#endif
+
+        case SIOCRTLTOOL:
+                if (!capable(CAP_NET_ADMIN)) {
+                        ret = -EPERM;
+                        break;
+                }
+
+                ret = rtl8126_tool_ioctl(tp, ifr);
+                break;
+
+        default:
+                ret = -EOPNOTSUPP;
+        }
+
+        return ret;
+}
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0)
+
+static int
+rtl8126_do_ioctl(struct net_device *dev,
+                 struct ifreq *ifr,
+                 int cmd)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        struct mii_ioctl_data *data = if_mii(ifr);
+        int ret = 0;
+
+        switch (cmd) {
+        case SIOCGMIIPHY:
+                data->phy_id = 32; /* Internal PHY */
+                break;
+
+        case SIOCGMIIREG:
+                rtl8126_mdio_write(tp, 0x1F, 0x0000);
+                data->val_out = rtl8126_mdio_read(tp, data->reg_num);
+                break;
+
+        case SIOCSMIIREG:
+                if (!capable(CAP_NET_ADMIN))
+                        return -EPERM;
+                rtl8126_mdio_write(tp, 0x1F, 0x0000);
+                rtl8126_mdio_write(tp, data->reg_num, data->val_in);
+                break;
+
+#ifdef ETHTOOL_OPS_COMPAT
+        case SIOCETHTOOL:
+                ret = ethtool_ioctl(ifr);
+                break;
+#endif
+
+#ifdef ENABLE_PTP_SUPPORT
+        case SIOCSHWTSTAMP:
+        case SIOCGHWTSTAMP:
+                if (tp->EnablePtp)
+                        ret = rtl8126_ptp_ioctl(dev, ifr, cmd);
+                else
+                        ret = -EOPNOTSUPP;
+                break;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+#ifdef ENABLE_REALWOW_SUPPORT
+        case SIOCDEVPRIVATE_RTLREALWOW:
+                if (!netif_running(dev)) {
+                        ret = -ENODEV;
+                        break;
+                }
+
+                if (!capable(CAP_NET_ADMIN)) {
+                        ret = -EPERM;
+                        break;
+                }
+
+                ret = rtl8126_realwow_ioctl(dev, ifr);
+                break;
+#endif
+
+        case SIOCRTLTOOL:
+                if (!capable(CAP_NET_ADMIN)) {
+                        ret = -EPERM;
+                        break;
+                }
+
+                ret = rtl8126_tool_ioctl(tp, ifr);
+                break;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+
+        default:
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        return ret;
+}
+
+static void
+rtl8126_phy_power_up(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        unsigned long flags;
+
+        if (rtl8126_is_in_phy_disable_mode(dev))
+                return;
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        rtl8126_mdio_write(tp, 0x1F, 0x0000);
+        rtl8126_mdio_write(tp, MII_BMCR, BMCR_ANENABLE);
+
+        //wait ups resume (phy state 3)
+        rtl8126_wait_phy_ups_resume(dev, 3);
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+}
+
+static void
+rtl8126_phy_power_down(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        unsigned long flags;
+
+#ifdef ENABLE_FIBER_SUPPORT
+        if (HW_FIBER_MODE_ENABLED(tp))
+                return;
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+        rtl8126_mdio_write(tp, 0x1F, 0x0000);
+        rtl8126_mdio_write(tp, MII_BMCR, BMCR_ANENABLE | BMCR_PDOWN);
+        r8126_spin_unlock(&tp->phy_lock, flags);
+}
+
+static int __devinit
+rtl8126_init_board(struct pci_dev *pdev,
+                   struct net_device **dev_out,
+                   void __iomem **ioaddr_out)
+{
+        void __iomem *ioaddr;
+        struct net_device *dev;
+        struct rtl8126_private *tp;
+        int rc = -ENOMEM, i, pm_cap;
+
+        assert(ioaddr_out != NULL);
+
+        /* dev zeroed in alloc_etherdev */
+        dev = alloc_etherdev_mq(sizeof (*tp), R8126_MAX_QUEUES);
+        if (dev == NULL) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_drv(&debug))
+                        dev_err(&pdev->dev, "unable to alloc new ethernet\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                goto err_out;
+        }
+
+        SET_MODULE_OWNER(dev);
+        SET_NETDEV_DEV(dev, &pdev->dev);
+        tp = netdev_priv(dev);
+        tp->dev = dev;
+        tp->pci_dev = pdev;
+        tp->msg_enable = netif_msg_init(debug.msg_enable, R8126_MSG_DEFAULT);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        if (!aspm)
+                pci_disable_link_state(pdev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |
+                                       PCIE_LINK_STATE_CLKPM);
+#endif
+
+        /* enable device (incl. PCI PM wakeup and hotplug setup) */
+        rc = pci_enable_device(pdev);
+        if (rc < 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "enable failure\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                goto err_out_free_dev;
+        }
+
+        if (pci_set_mwi(pdev) < 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_drv(&debug))
+                        dev_info(&pdev->dev, "Mem-Wr-Inval unavailable.\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        }
+
+        /* save power state before pci_enable_device overwrites it */
+        pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM);
+        if (pm_cap) {
+                u16 pwr_command;
+
+                pci_read_config_word(pdev, pm_cap + PCI_PM_CTRL, &pwr_command);
+        } else {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "PowerManagement capability not found.\n");
+#else
+                printk("PowerManagement capability not found.\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+
+        }
+
+        /* make sure PCI base addr 1 is MMIO */
+        if (!(pci_resource_flags(pdev, 2) & IORESOURCE_MEM)) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "region #1 not an MMIO resource, aborting\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                rc = -ENODEV;
+                goto err_out_mwi;
+        }
+        /* check for weird/broken PCI region reporting */
+        if (pci_resource_len(pdev, 2) < R8126_REGS_SIZE) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "Invalid PCI region size(s), aborting\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                rc = -ENODEV;
+                goto err_out_mwi;
+        }
+
+        rc = pci_request_regions(pdev, MODULENAME);
+        if (rc < 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "could not request regions.\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                goto err_out_mwi;
+        }
+
+        if ((sizeof(dma_addr_t) > 4) &&
+            use_dac &&
+            !dma_set_mask(&pdev->dev, DMA_BIT_MASK(64)) &&
+            !dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64))) {
+                dev->features |= NETIF_F_HIGHDMA;
+        } else {
+                rc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
+                if (rc < 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                        if (netif_msg_probe(tp))
+                                dev_err(&pdev->dev, "DMA configuration failed.\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                        goto err_out_free_res;
+                }
+        }
+
+        /* ioremap MMIO region */
+        ioaddr = ioremap(pci_resource_start(pdev, 2), pci_resource_len(pdev, 2));
+        if (ioaddr == NULL) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "cannot remap MMIO, aborting\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                rc = -EIO;
+                goto err_out_free_res;
+        }
+
+        tp->mmio_addr = ioaddr;
+
+        /* Identify chip attached to board */
+        rtl8126_get_mac_version(tp);
+
+        rtl8126_print_mac_version(tp);
+
+        for (i = ARRAY_SIZE(rtl_chip_info) - 1; i >= 0; i--) {
+                if (tp->mcfg == rtl_chip_info[i].mcfg)
+                        break;
+        }
+
+        if (i < 0) {
+                /* Unknown chip: assume array element #0, original RTL-8125 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_printk(KERN_DEBUG, &pdev->dev, "unknown chip version, assuming %s\n", rtl_chip_info[0].name);
+#else
+                printk("Realtek unknown chip version, assuming %s\n", rtl_chip_info[0].name);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+                i++;
+        }
+
+        tp->chipset = i;
+
+        *ioaddr_out = ioaddr;
+        *dev_out = dev;
+out:
+        return rc;
+
+err_out_free_res:
+        pci_release_regions(pdev);
+err_out_mwi:
+        pci_clear_mwi(pdev);
+        pci_disable_device(pdev);
+err_out_free_dev:
+        free_netdev(dev);
+err_out:
+        *ioaddr_out = NULL;
+        *dev_out = NULL;
+        goto out;
+}
+
+static void
+rtl8126_esd_checker(struct rtl8126_private *tp)
+{
+        struct net_device *dev = tp->dev;
+        struct pci_dev *pdev = tp->pci_dev;
+        u8 cmd;
+        u16 io_base_l;
+        u16 mem_base_l;
+        u16 mem_base_h;
+        u8 ilr;
+        u16 resv_0x1c_h;
+        u16 resv_0x1c_l;
+        u16 resv_0x20_l;
+        u16 resv_0x20_h;
+        u16 resv_0x24_l;
+        u16 resv_0x24_h;
+        u16 resv_0x2c_h;
+        u16 resv_0x2c_l;
+        u32 pci_sn_l;
+        u32 pci_sn_h;
+
+        if (unlikely(tp->rtk_enable_diag))
+                goto exit;
+
+        tp->esd_flag = 0;
+
+        pci_read_config_byte(pdev, PCI_COMMAND, &cmd);
+        if (cmd != tp->pci_cfg_space.cmd) {
+                printk(KERN_ERR "%s: cmd = 0x%02x, should be 0x%02x \n.", dev->name, cmd, tp->pci_cfg_space.cmd);
+                pci_write_config_byte(pdev, PCI_COMMAND, tp->pci_cfg_space.cmd);
+                tp->esd_flag |= BIT_0;
+
+                pci_read_config_byte(pdev, PCI_COMMAND, &cmd);
+                if (cmd == 0xff) {
+                        printk(KERN_ERR "%s: pci link is down \n.", dev->name);
+                        goto exit;
+                }
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_0, &io_base_l);
+        if (io_base_l != tp->pci_cfg_space.io_base_l) {
+                printk(KERN_ERR "%s: io_base_l = 0x%04x, should be 0x%04x \n.", dev->name, io_base_l, tp->pci_cfg_space.io_base_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_0, tp->pci_cfg_space.io_base_l);
+                tp->esd_flag |= BIT_1;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_2, &mem_base_l);
+        if (mem_base_l != tp->pci_cfg_space.mem_base_l) {
+                printk(KERN_ERR "%s: mem_base_l = 0x%04x, should be 0x%04x \n.", dev->name, mem_base_l, tp->pci_cfg_space.mem_base_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_2, tp->pci_cfg_space.mem_base_l);
+                tp->esd_flag |= BIT_2;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_2 + 2, &mem_base_h);
+        if (mem_base_h!= tp->pci_cfg_space.mem_base_h) {
+                printk(KERN_ERR "%s: mem_base_h = 0x%04x, should be 0x%04x \n.", dev->name, mem_base_h, tp->pci_cfg_space.mem_base_h);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_2 + 2, tp->pci_cfg_space.mem_base_h);
+                tp->esd_flag |= BIT_3;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_3, &resv_0x1c_l);
+        if (resv_0x1c_l != tp->pci_cfg_space.resv_0x1c_l) {
+                printk(KERN_ERR "%s: resv_0x1c_l = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x1c_l, tp->pci_cfg_space.resv_0x1c_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_3, tp->pci_cfg_space.resv_0x1c_l);
+                tp->esd_flag |= BIT_4;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_3 + 2, &resv_0x1c_h);
+        if (resv_0x1c_h != tp->pci_cfg_space.resv_0x1c_h) {
+                printk(KERN_ERR "%s: resv_0x1c_h = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x1c_h, tp->pci_cfg_space.resv_0x1c_h);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_3 + 2, tp->pci_cfg_space.resv_0x1c_h);
+                tp->esd_flag |= BIT_5;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_4, &resv_0x20_l);
+        if (resv_0x20_l != tp->pci_cfg_space.resv_0x20_l) {
+                printk(KERN_ERR "%s: resv_0x20_l = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x20_l, tp->pci_cfg_space.resv_0x20_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_4, tp->pci_cfg_space.resv_0x20_l);
+                tp->esd_flag |= BIT_6;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_4 + 2, &resv_0x20_h);
+        if (resv_0x20_h != tp->pci_cfg_space.resv_0x20_h) {
+                printk(KERN_ERR "%s: resv_0x20_h = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x20_h, tp->pci_cfg_space.resv_0x20_h);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_4 + 2, tp->pci_cfg_space.resv_0x20_h);
+                tp->esd_flag |= BIT_7;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_5, &resv_0x24_l);
+        if (resv_0x24_l != tp->pci_cfg_space.resv_0x24_l) {
+                printk(KERN_ERR "%s: resv_0x24_l = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x24_l, tp->pci_cfg_space.resv_0x24_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_5, tp->pci_cfg_space.resv_0x24_l);
+                tp->esd_flag |= BIT_8;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_5 + 2, &resv_0x24_h);
+        if (resv_0x24_h != tp->pci_cfg_space.resv_0x24_h) {
+                printk(KERN_ERR "%s: resv_0x24_h = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x24_h, tp->pci_cfg_space.resv_0x24_h);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_5 + 2, tp->pci_cfg_space.resv_0x24_h);
+                tp->esd_flag |= BIT_9;
+        }
+
+        pci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &ilr);
+        if (ilr != tp->pci_cfg_space.ilr) {
+                printk(KERN_ERR "%s: ilr = 0x%02x, should be 0x%02x \n.", dev->name, ilr, tp->pci_cfg_space.ilr);
+                pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, tp->pci_cfg_space.ilr);
+                tp->esd_flag |= BIT_10;
+        }
+
+        pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &resv_0x2c_l);
+        if (resv_0x2c_l != tp->pci_cfg_space.resv_0x2c_l) {
+                printk(KERN_ERR "%s: resv_0x2c_l = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x2c_l, tp->pci_cfg_space.resv_0x2c_l);
+                pci_write_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, tp->pci_cfg_space.resv_0x2c_l);
+                tp->esd_flag |= BIT_11;
+        }
+
+        pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID + 2, &resv_0x2c_h);
+        if (resv_0x2c_h != tp->pci_cfg_space.resv_0x2c_h) {
+                printk(KERN_ERR "%s: resv_0x2c_h = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x2c_h, tp->pci_cfg_space.resv_0x2c_h);
+                pci_write_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID + 2, tp->pci_cfg_space.resv_0x2c_h);
+                tp->esd_flag |= BIT_12;
+        }
+
+        if (tp->HwPcieSNOffset > 0) {
+                pci_sn_l = rtl8126_csi_read(tp, tp->HwPcieSNOffset);
+                if (pci_sn_l != tp->pci_cfg_space.pci_sn_l) {
+                        printk(KERN_ERR "%s: pci_sn_l = 0x%08x, should be 0x%08x \n.", dev->name, pci_sn_l, tp->pci_cfg_space.pci_sn_l);
+                        rtl8126_csi_write(tp, tp->HwPcieSNOffset, tp->pci_cfg_space.pci_sn_l);
+                        tp->esd_flag |= BIT_13;
+                }
+
+                pci_sn_h = rtl8126_csi_read(tp, tp->HwPcieSNOffset + 4);
+                if (pci_sn_h != tp->pci_cfg_space.pci_sn_h) {
+                        printk(KERN_ERR "%s: pci_sn_h = 0x%08x, should be 0x%08x \n.", dev->name, pci_sn_h, tp->pci_cfg_space.pci_sn_h);
+                        rtl8126_csi_write(tp, tp->HwPcieSNOffset + 4, tp->pci_cfg_space.pci_sn_h);
+                        tp->esd_flag |= BIT_14;
+                }
+        }
+
+        if (tp->esd_flag != 0) {
+                printk(KERN_ERR "%s: esd_flag = 0x%04x\n.\n", dev->name, tp->esd_flag);
+                netif_carrier_off(dev);
+                netif_tx_disable(dev);
+                rtl8126_hw_reset(dev);
+                rtl8126_tx_clear(tp);
+                rtl8126_rx_clear(tp);
+                rtl8126_init_ring(dev);
+                rtl8126_up(dev);
+                rtl8126_enable_hw_linkchg_interrupt(tp);
+                rtl8126_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+                tp->esd_flag = 0;
+        }
+exit:
+        return;
+}
+/*
+static void
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+rtl8126_esd_timer(unsigned long __opaque)
+#else
+rtl8126_esd_timer(struct timer_list *t)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+        struct net_device *dev = (struct net_device *)__opaque;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        struct timer_list *timer = &tp->esd_timer;
+#else
+        struct rtl8126_private *tp = from_timer(tp, t, esd_timer);
+        //struct net_device *dev = tp->dev;
+        struct timer_list *timer = t;
+#endif
+        rtl8126_esd_checker(tp);
+
+        mod_timer(timer, jiffies + timeout);
+}
+*/
+
+/*
+static void
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+rtl8126_link_timer(unsigned long __opaque)
+#else
+rtl8126_link_timer(struct timer_list *t)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+        struct net_device *dev = (struct net_device *)__opaque;
+        struct rtl8126_private *tp = netdev_priv(dev);
+        struct timer_list *timer = &tp->link_timer;
+#else
+        struct rtl8126_private *tp = from_timer(tp, t, link_timer);
+        struct net_device *dev = tp->dev;
+        struct timer_list *timer = t;
+#endif
+        rtl8126_check_link_status(dev);
+
+        mod_timer(timer, jiffies + RTL8126_LINK_TIMEOUT);
+}
+*/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
+static int pci_enable_msix_range(struct pci_dev *dev, struct msix_entry *entries,
+                                 int minvec, int maxvec)
+{
+        int nvec = maxvec;
+        int rc;
+
+        if (maxvec < minvec)
+                return -ERANGE;
+
+        do {
+                rc = pci_enable_msix(dev, entries, nvec);
+                if (rc < 0) {
+                        return rc;
+                } else if (rc > 0) {
+                        if (rc < minvec)
+                                return -ENOSPC;
+                        nvec = rc;
+                }
+        } while (rc);
+
+        return nvec;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0) */
+
+static int rtl8126_enable_msix(struct rtl8126_private *tp)
+{
+        int i, nvecs = 0;
+        struct msix_entry msix_ent[R8126_MAX_MSIX_VEC];
+        //struct net_device *dev = tp->dev;
+        //const int len = sizeof(tp->irq_tbl[0].name);
+
+        for (i = 0; i < R8126_MAX_MSIX_VEC; i++) {
+                msix_ent[i].entry = i;
+                msix_ent[i].vector = 0;
+        }
+
+        nvecs = pci_enable_msix_range(tp->pci_dev, msix_ent,
+                                      tp->min_irq_nvecs, tp->max_irq_nvecs);
+        if (nvecs < 0)
+                goto out;
+
+        for (i = 0; i < nvecs; i++) {
+                struct r8126_irq *irq = &tp->irq_tbl[i];
+                irq->vector = msix_ent[i].vector;
+                //snprintf(irq->name, len, "%s-%d", dev->name, i);
+                //irq->handler = rtl8126_interrupt_msix;
+        }
+
+out:
+        return nvecs;
+}
+
+/* Cfg9346_Unlock assumed. */
+static int rtl8126_try_msi(struct rtl8126_private *tp)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+        unsigned int hw_supp_irq_nvecs;
+        unsigned msi = 0;
+        int nvecs = 1;
+
+        hw_supp_irq_nvecs = R8126_MAX_MSIX_VEC_8125B;
+        tp->hw_supp_irq_nvecs = clamp_val(hw_supp_irq_nvecs, 1,
+                                          R8126_MAX_MSIX_VEC);
+
+        tp->max_irq_nvecs = tp->hw_supp_irq_nvecs;
+        tp->min_irq_nvecs = R8126_MIN_MSIX_VEC_8125B;
+#ifdef DISABLE_MULTI_MSIX_VECTOR
+        tp->max_irq_nvecs = 1;
+#endif
+
+#if defined(RTL_USE_NEW_INTR_API)
+        if ((nvecs = pci_alloc_irq_vectors(pdev, tp->min_irq_nvecs, tp->max_irq_nvecs, PCI_IRQ_MSIX)) > 0)
+                msi |= RTL_FEATURE_MSIX;
+        else if ((nvecs = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES)) > 0 &&
+                 pci_dev_msi_enabled(pdev))
+                msi |= RTL_FEATURE_MSI;
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+        if ((nvecs = rtl8126_enable_msix(tp)) > 0)
+                msi |= RTL_FEATURE_MSIX;
+        else if (!pci_enable_msi(pdev))
+                msi |= RTL_FEATURE_MSI;
+#endif
+        if (!(msi & (RTL_FEATURE_MSI | RTL_FEATURE_MSIX)))
+                dev_info(&pdev->dev, "no MSI/MSI-X. Back to INTx.\n");
+
+        if (!(msi & RTL_FEATURE_MSIX) || nvecs < 1)
+                nvecs = 1;
+
+        tp->irq_nvecs = nvecs;
+
+        tp->features |= msi;
+
+        return nvecs;
+}
+
+static void rtl8126_disable_msi(struct pci_dev *pdev, struct rtl8126_private *tp)
+{
+#if defined(RTL_USE_NEW_INTR_API)
+        if (tp->features & (RTL_FEATURE_MSI | RTL_FEATURE_MSIX))
+                pci_free_irq_vectors(pdev);
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+        if (tp->features & (RTL_FEATURE_MSIX))
+                pci_disable_msix(pdev);
+        else if (tp->features & (RTL_FEATURE_MSI))
+                pci_disable_msi(pdev);
+#endif
+        tp->features &= ~(RTL_FEATURE_MSI | RTL_FEATURE_MSIX);
+}
+
+static int rtl8126_get_irq(struct pci_dev *pdev)
+{
+#if defined(RTL_USE_NEW_INTR_API)
+        return pci_irq_vector(pdev, 0);
+#else
+        return pdev->irq;
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+static void
+rtl8126_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        struct rtl8126_counters *counters = tp->tally_vaddr;
+        dma_addr_t paddr = tp->tally_paddr;
+
+        if (!counters)
+                return;
+
+        netdev_stats_to_stats64(stats, &dev->stats);
+        dev_fetch_sw_netstats(stats, dev->tstats);
+
+        /*
+         * Fetch additional counter values missing in stats collected by driver
+         * from tally counters.
+         */
+        rtl8126_dump_tally_counter(tp, paddr);
+
+        stats->tx_errors = le64_to_cpu(counters->tx_errors);
+        stats->collisions = le32_to_cpu(counters->tx_multi_collision);
+        stats->tx_aborted_errors = le16_to_cpu(counters->tx_aborted);
+        stats->rx_missed_errors = le16_to_cpu(counters->rx_missed);
+}
+#else
+/**
+ *  rtl8126_get_stats - Get rtl8126 read/write statistics
+ *  @dev: The Ethernet Device to get statistics for
+ *
+ *  Get TX/RX statistics for rtl8126
+ */
+static struct
+net_device_stats *rtl8126_get_stats(struct net_device *dev)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+        struct rtl8126_private *tp = netdev_priv(dev);
+#endif
+        return &RTLDEV->stats;
+}
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+static const struct net_device_ops rtl8126_netdev_ops = {
+        .ndo_open       = rtl8126_open,
+        .ndo_stop       = rtl8126_close,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+        .ndo_get_stats64    = rtl8126_get_stats64,
+#else
+        .ndo_get_stats      = rtl8126_get_stats,
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+        .ndo_start_xmit     = rtl8126_start_xmit,
+        .ndo_tx_timeout     = rtl8126_tx_timeout,
+        .ndo_change_mtu     = rtl8126_change_mtu,
+        .ndo_set_mac_address    = rtl8126_set_mac_address,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+        .ndo_do_ioctl       = rtl8126_do_ioctl,
+#else
+        .ndo_siocdevprivate = rtl8126_siocdevprivate,
+        .ndo_eth_ioctl      = rtl8126_do_ioctl,
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0)
+        .ndo_set_multicast_list = rtl8126_set_rx_mode,
+#else
+        .ndo_set_rx_mode    = rtl8126_set_rx_mode,
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+#ifdef CONFIG_R8126_VLAN
+        .ndo_vlan_rx_register   = rtl8126_vlan_rx_register,
+#endif
+#else
+        .ndo_fix_features   = rtl8126_fix_features,
+        .ndo_set_features   = rtl8126_set_features,
+#endif
+#ifdef CONFIG_NET_POLL_CONTROLLER
+        .ndo_poll_controller    = rtl8126_netpoll,
+#endif
+};
+#endif
+
+
+#ifdef  CONFIG_R8126_NAPI
+
+static int rtl8126_poll(napi_ptr napi, napi_budget budget)
+{
+        struct r8126_napi *r8126napi = RTL_GET_PRIV(napi, struct r8126_napi);
+        struct rtl8126_private *tp = r8126napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        unsigned int work_done = 0;
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++)
+                rtl8126_tx_interrupt(&tp->tx_ring[i], budget);
+
+        for (i = 0; i < tp->num_rx_rings; i++)
+                work_done += rtl8126_rx_interrupt(dev, tp, &tp->rx_ring[i], budget);
+
+        work_done = min(work_done, work_to_do);
+
+        RTL_NAPI_QUOTA_UPDATE(dev, work_done, budget);
+
+        if (work_done < work_to_do) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+                if (RTL_NETIF_RX_COMPLETE(dev, napi, work_done) == FALSE)
+                        return RTL_NAPI_RETURN_VALUE;
+#else
+                RTL_NETIF_RX_COMPLETE(dev, napi, work_done);
+#endif
+                /*
+                 * 20040426: the barrier is not strictly required but the
+                 * behavior of the irq handler could be less predictable
+                 * without it. Btw, the lack of flush for the posted pci
+                 * write is safe - FR
+                 */
+                smp_wmb();
+
+                rtl8126_switch_to_timer_interrupt(tp);
+        }
+
+        return RTL_NAPI_RETURN_VALUE;
+}
+
+static int rtl8126_poll_msix_ring(napi_ptr napi, napi_budget budget)
+{
+        struct r8126_napi *r8126napi = RTL_GET_PRIV(napi, struct r8126_napi);
+        struct rtl8126_private *tp = r8126napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        unsigned int work_done = 0;
+        const int message_id = r8126napi->index;
+
+        if (message_id < tp->num_tx_rings)
+                rtl8126_tx_interrupt_with_vector(tp, message_id, budget);
+
+        if (message_id < tp->num_rx_rings)
+                work_done += rtl8126_rx_interrupt(dev, tp, &tp->rx_ring[message_id], budget);
+
+        RTL_NAPI_QUOTA_UPDATE(dev, work_done, budget);
+
+        if (work_done < work_to_do) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+                if (RTL_NETIF_RX_COMPLETE(dev, napi, work_done) == FALSE)
+                        return RTL_NAPI_RETURN_VALUE;
+#else
+                RTL_NETIF_RX_COMPLETE(dev, napi, work_done);
+#endif
+                /*
+                 * 20040426: the barrier is not strictly required but the
+                 * behavior of the irq handler could be less predictable
+                 * without it. Btw, the lack of flush for the posted pci
+                 * write is safe - FR
+                 */
+                smp_wmb();
+
+                rtl8126_enable_hw_interrupt_v2(tp, message_id);
+        }
+
+        return RTL_NAPI_RETURN_VALUE;
+}
+
+static int rtl8126_poll_msix_tx(napi_ptr napi, napi_budget budget)
+{
+        struct r8126_napi *r8126napi = RTL_GET_PRIV(napi, struct r8126_napi);
+        struct rtl8126_private *tp = r8126napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        unsigned int work_done = 0;
+        const int message_id = r8126napi->index;
+
+        //suppress unused variable
+        (void)(dev);
+
+        rtl8126_tx_interrupt_with_vector(tp, message_id, budget);
+
+        RTL_NAPI_QUOTA_UPDATE(dev, work_done, budget);
+
+        if (work_done < work_to_do) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+                if (RTL_NETIF_RX_COMPLETE(dev, napi, work_done) == FALSE)
+                        return RTL_NAPI_RETURN_VALUE;
+#else
+                RTL_NETIF_RX_COMPLETE(dev, napi, work_done);
+#endif
+                /*
+                 * 20040426: the barrier is not strictly required but the
+                 * behavior of the irq handler could be less predictable
+                 * without it. Btw, the lack of flush for the posted pci
+                 * write is safe - FR
+                 */
+                smp_wmb();
+
+                rtl8126_enable_hw_interrupt_v2(tp, message_id);
+        }
+
+        return RTL_NAPI_RETURN_VALUE;
+}
+
+static int rtl8126_poll_msix_other(napi_ptr napi, napi_budget budget)
+{
+        struct r8126_napi *r8126napi = RTL_GET_PRIV(napi, struct r8126_napi);
+        struct rtl8126_private *tp = r8126napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        const int message_id = r8126napi->index;
+
+        //suppress unused variable
+        (void)(dev);
+        (void)(work_to_do);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+        RTL_NETIF_RX_COMPLETE(dev, napi, work_to_do);
+#else
+        RTL_NETIF_RX_COMPLETE(dev, napi, work_to_do);
+#endif
+
+        rtl8126_enable_hw_interrupt_v2(tp, message_id);
+
+        return 1;
+}
+
+static int rtl8126_poll_msix_rx(napi_ptr napi, napi_budget budget)
+{
+        struct r8126_napi *r8126napi = RTL_GET_PRIV(napi, struct r8126_napi);
+        struct rtl8126_private *tp = r8126napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        unsigned int work_done = 0;
+        const int message_id = r8126napi->index;
+
+        if (message_id < tp->num_rx_rings)
+                work_done += rtl8126_rx_interrupt(dev, tp, &tp->rx_ring[message_id], budget);
+
+        RTL_NAPI_QUOTA_UPDATE(dev, work_done, budget);
+
+        if (work_done < work_to_do) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+                if (RTL_NETIF_RX_COMPLETE(dev, napi, work_done) == FALSE)
+                        return RTL_NAPI_RETURN_VALUE;
+#else
+                RTL_NETIF_RX_COMPLETE(dev, napi, work_done);
+#endif
+                /*
+                 * 20040426: the barrier is not strictly required but the
+                 * behavior of the irq handler could be less predictable
+                 * without it. Btw, the lack of flush for the posted pci
+                 * write is safe - FR
+                 */
+                smp_wmb();
+
+                rtl8126_enable_hw_interrupt_v2(tp, message_id);
+        }
+
+        return RTL_NAPI_RETURN_VALUE;
+}
+
+void rtl8126_enable_napi(struct rtl8126_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        int i;
+
+        for (i = 0; i < tp->irq_nvecs; i++)
+                RTL_NAPI_ENABLE(tp->dev, &tp->r8126napi[i].napi);
+#endif
+}
+
+static void rtl8126_disable_napi(struct rtl8126_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        int i;
+
+        for (i = 0; i < tp->irq_nvecs; i++)
+                RTL_NAPI_DISABLE(tp->dev, &tp->r8126napi[i].napi);
+#endif
+}
+
+static void rtl8126_del_napi(struct rtl8126_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        int i;
+
+        for (i = 0; i < tp->irq_nvecs; i++)
+                RTL_NAPI_DEL((&tp->r8126napi[i]));
+#endif
+}
+#endif //CONFIG_R8126_NAPI
+
+static void rtl8126_init_napi(struct rtl8126_private *tp)
+{
+        int i;
+
+        for (i=0; i<tp->irq_nvecs; i++) {
+                struct r8126_napi *r8126napi = &tp->r8126napi[i];
+#ifdef CONFIG_R8126_NAPI
+                int (*poll)(struct napi_struct *, int);
+
+                poll = rtl8126_poll;
+                if (tp->features & RTL_FEATURE_MSIX) {
+                        switch (tp->HwCurrIsrVer) {
+                        case 5:
+                                if (i < R8126_MAX_RX_QUEUES_VEC_V3)
+                                        poll = rtl8126_poll_msix_rx;
+                                else if (i == 16 || i == 17)
+                                        poll = rtl8126_poll_msix_tx;
+                                else
+                                        poll = rtl8126_poll_msix_other;
+                                break;
+                        case 2:
+                                if (i < R8126_MAX_RX_QUEUES_VEC_V3)
+                                        poll = rtl8126_poll_msix_rx;
+                                else if (i == 16 || i == 18)
+                                        poll = rtl8126_poll_msix_tx;
+                                else
+                                        poll = rtl8126_poll_msix_other;
+                                break;
+                        case 3:
+                        case 4:
+                                if (i < R8126_MAX_RX_QUEUES_VEC_V3)
+                                        poll = rtl8126_poll_msix_ring;
+                                else
+                                        poll = rtl8126_poll_msix_other;
+                                break;
+                        }
+                }
+
+                RTL_NAPI_CONFIG(tp->dev, r8126napi, poll, R8126_NAPI_WEIGHT);
+#endif
+
+                r8126napi->priv = tp;
+                r8126napi->index = i;
+        }
+}
+
+static int
+rtl8126_set_real_num_queue(struct rtl8126_private *tp)
+{
+        int retval = 0;
+
+        retval = netif_set_real_num_tx_queues(tp->dev, tp->num_tx_rings);
+        if (retval < 0)
+                goto exit;
+
+        retval = netif_set_real_num_rx_queues(tp->dev, tp->num_rx_rings);
+        if (retval < 0)
+                goto exit;
+
+exit:
+        return retval;
+}
+
+static int __devinit
+rtl8126_init_one(struct pci_dev *pdev,
+                 const struct pci_device_id *ent)
+{
+        struct net_device *dev = NULL;
+        struct rtl8126_private *tp;
+        void __iomem *ioaddr = NULL;
+        static int board_idx = -1;
+
+        int rc;
+
+        assert(pdev != NULL);
+        assert(ent != NULL);
+
+        board_idx++;
+
+        if (netif_msg_drv(&debug))
+                printk(KERN_INFO "%s Ethernet controller driver %s loaded\n",
+                       MODULENAME, RTL8126_VERSION);
+
+        rc = rtl8126_init_board(pdev, &dev, &ioaddr);
+        if (rc)
+                goto out;
+
+        tp = netdev_priv(dev);
+        assert(ioaddr != NULL);
+
+        spin_lock_init(&tp->phy_lock);
+
+        tp->set_speed = rtl8126_set_speed_xmii;
+        tp->get_settings = rtl8126_gset_xmii;
+        tp->phy_reset_enable = rtl8126_xmii_reset_enable;
+        tp->phy_reset_pending = rtl8126_xmii_reset_pending;
+        tp->link_ok = rtl8126_xmii_link_ok;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+        dev->tstats = devm_netdev_alloc_pcpu_stats(&pdev->dev,
+                        struct pcpu_sw_netstats);
+        if (!dev->tstats)
+                goto err_out_1;
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+
+        rc = rtl8126_try_msi(tp);
+        if (rc < 0) {
+                dev_err(&pdev->dev, "Can't allocate interrupt\n");
+                goto err_out_1;
+        }
+
+        rtl8126_init_software_variable(dev);
+
+        RTL_NET_DEVICE_OPS(rtl8126_netdev_ops);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+        SET_ETHTOOL_OPS(dev, &rtl8126_ethtool_ops);
+#endif
+
+        dev->watchdog_timeo = RTL8126_TX_TIMEOUT;
+        dev->irq = rtl8126_get_irq(pdev);
+        dev->base_addr = (unsigned long) ioaddr;
+
+        rtl8126_init_napi(tp);
+
+#ifdef CONFIG_R8126_VLAN
+        if (tp->mcfg != CFG_METHOD_DEFAULT) {
+                dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+                dev->vlan_rx_kill_vid = rtl8126_vlan_rx_kill_vid;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+        }
+#endif
+
+        /* There has been a number of reports that using SG/TSO results in
+         * tx timeouts. However for a lot of people SG/TSO works fine.
+         * Therefore disable both features by default, but allow users to
+         * enable them. Use at own risk!
+         */
+        tp->cp_cmd |= RTL_R16(tp, CPlusCmd);
+        if (tp->mcfg != CFG_METHOD_DEFAULT) {
+                dev->features |= NETIF_F_IP_CSUM;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+                tp->cp_cmd |= RxChkSum;
+#else
+                dev->features |= NETIF_F_RXCSUM;
+                dev->features |= NETIF_F_SG | NETIF_F_TSO;
+                dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
+                                   NETIF_F_RXCSUM | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
+                dev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
+                                     NETIF_F_HIGHDMA;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
+                dev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
+                dev->hw_features |= NETIF_F_RXALL;
+                dev->hw_features |= NETIF_F_RXFCS;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+                dev->hw_features |= NETIF_F_IPV6_CSUM | NETIF_F_TSO6;
+                dev->features |= NETIF_F_IPV6_CSUM;
+                dev->features |= NETIF_F_TSO6;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,19,0)
+                netif_set_tso_max_size(dev, LSO_64K);
+                netif_set_tso_max_segs(dev, NIC_MAX_PHYS_BUF_COUNT_LSO2);
+#else //LINUX_VERSION_CODE >= KERNEL_VERSION(5,19,0)
+                netif_set_gso_max_size(dev, LSO_64K);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
+                dev->gso_max_segs = NIC_MAX_PHYS_BUF_COUNT_LSO2;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+                dev->gso_min_segs = NIC_MIN_PHYS_BUF_COUNT;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,19,0)
+
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+#ifdef ENABLE_RSS_SUPPORT
+                if (tp->EnableRss) {
+                        dev->hw_features |= NETIF_F_RXHASH;
+                        dev->features |= NETIF_F_RXHASH;
+                }
+#endif
+        }
+
+        netdev_sw_irq_coalesce_default_on(dev);
+
+#ifdef ENABLE_LIB_SUPPORT
+        BLOCKING_INIT_NOTIFIER_HEAD(&tp->lib_nh);
+#endif
+        rtl8126_init_all_schedule_work(tp);
+
+        rc = rtl8126_set_real_num_queue(tp);
+        if (rc < 0)
+                goto err_out;
+
+        rtl8126_exit_oob(dev);
+
+        rtl8126_powerup_pll(dev);
+
+        rtl8126_hw_init(dev);
+
+        rtl8126_hw_reset(dev);
+
+        /* Get production from EEPROM */
+        rtl8126_eeprom_type(tp);
+
+        if (tp->eeprom_type == EEPROM_TYPE_93C46 || tp->eeprom_type == EEPROM_TYPE_93C56)
+                rtl8126_set_eeprom_sel_low(tp);
+
+        rtl8126_get_mac_address(dev);
+
+        tp->fw_name = rtl_chip_fw_infos[tp->mcfg].fw_name;
+
+        tp->tally_vaddr = dma_alloc_coherent(&pdev->dev, sizeof(*tp->tally_vaddr),
+                                             &tp->tally_paddr, GFP_KERNEL);
+        if (!tp->tally_vaddr) {
+                rc = -ENOMEM;
+                goto err_out;
+        }
+
+        rtl8126_tally_counter_clear(tp);
+
+        pci_set_drvdata(pdev, dev);
+
+        rc = register_netdev(dev);
+        if (rc)
+                goto err_out;
+
+        printk(KERN_INFO "%s: This product is covered by one or more of the following patents: US6,570,884, US6,115,776, and US6,327,625.\n", MODULENAME);
+
+        rtl8126_disable_rxdvgate(dev);
+
+        device_set_wakeup_enable(&pdev->dev, tp->wol_enabled);
+
+        netif_carrier_off(dev);
+
+#ifdef ENABLE_R8126_SYSFS
+        rtl8126_sysfs_init(dev);
+#endif /* ENABLE_R8126_SYSFS */
+
+        printk("%s", GPL_CLAIM);
+
+out:
+        return rc;
+
+err_out:
+        if (tp->tally_vaddr != NULL) {
+                dma_free_coherent(&pdev->dev, sizeof(*tp->tally_vaddr), tp->tally_vaddr,
+                                  tp->tally_paddr);
+
+                tp->tally_vaddr = NULL;
+        }
+#ifdef  CONFIG_R8126_NAPI
+        rtl8126_del_napi(tp);
+#endif
+        rtl8126_disable_msi(pdev, tp);
+
+err_out_1:
+        rtl8126_release_board(pdev, dev);
+
+        goto out;
+}
+
+static void __devexit
+rtl8126_remove_one(struct pci_dev *pdev)
+{
+        struct net_device *dev = pci_get_drvdata(pdev);
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        assert(dev != NULL);
+        assert(tp != NULL);
+
+        set_bit(R8126_FLAG_DOWN, tp->task_flags);
+
+        rtl8126_cancel_all_schedule_work(tp);
+
+        rtl8126_disable_pci_offset_180(tp);
+
+#ifdef ENABLE_R8126_SYSFS
+        rtl8126_sysfs_remove(dev);
+#endif //ENABLE_R8126_SYSFS
+
+        unregister_netdev(dev);
+#ifdef  CONFIG_R8126_NAPI
+        rtl8126_del_napi(tp);
+#endif
+        rtl8126_disable_msi(pdev, tp);
+#ifdef ENABLE_R8126_PROCFS
+        rtl8126_proc_remove(dev);
+#endif
+        if (tp->tally_vaddr != NULL) {
+                dma_free_coherent(&pdev->dev, sizeof(*tp->tally_vaddr), tp->tally_vaddr, tp->tally_paddr);
+                tp->tally_vaddr = NULL;
+        }
+
+        rtl8126_release_board(pdev, dev);
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+        rtl8126_release_firmware(tp);
+#endif
+
+        pci_set_drvdata(pdev, NULL);
+}
+
+#ifdef ENABLE_PAGE_REUSE
+static inline unsigned int rtl8126_rx_page_order(unsigned rx_buf_sz, unsigned page_size)
+{
+        unsigned truesize = SKB_DATA_ALIGN(sizeof(struct skb_shared_info)) +
+                            SKB_DATA_ALIGN(rx_buf_sz + R8126_RX_ALIGN);
+
+        return get_order(truesize * 2);
+}
+#endif //ENABLE_PAGE_REUSE
+
+static void
+rtl8126_set_rxbufsize(struct rtl8126_private *tp,
+                      struct net_device *dev)
+{
+        unsigned int mtu = dev->mtu;
+
+        tp->rms = (mtu > ETH_DATA_LEN) ?
+                  mtu + ETH_HLEN + RT_VALN_HLEN + ETH_FCS_LEN:
+                  RX_BUF_SIZE;
+        tp->rx_buf_sz = tp->rms;
+#ifdef ENABLE_RX_PACKET_FRAGMENT
+        tp->rx_buf_sz =  SKB_DATA_ALIGN(RX_BUF_SIZE);
+#endif //ENABLE_RX_PACKET_FRAGMENT
+#ifdef ENABLE_PAGE_REUSE
+        tp->rx_buf_page_order = rtl8126_rx_page_order(tp->rx_buf_sz, PAGE_SIZE);
+        tp->rx_buf_page_size = rtl8126_rx_page_size(tp->rx_buf_page_order);
+#endif //ENABLE_PAGE_REUSE
+}
+
+static void
+rtl8126_set_rms(struct rtl8126_private *tp, u16 rms)
+{
+        RTL_W16(tp, RxMaxSize, rms | AcceppVlanPhys);
+}
+
+static void rtl8126_free_irq(struct rtl8126_private *tp)
+{
+        int i;
+
+        for (i=0; i<tp->irq_nvecs; i++) {
+                struct r8126_irq *irq = &tp->irq_tbl[i];
+                struct r8126_napi *r8126napi = &tp->r8126napi[i];
+
+                if (irq->requested) {
+                        irq->requested = 0;
+#if defined(RTL_USE_NEW_INTR_API)
+                        pci_free_irq(tp->pci_dev, i, r8126napi);
+#else
+                        free_irq(irq->vector, r8126napi);
+#endif
+                }
+        }
+}
+
+static int rtl8126_alloc_irq(struct rtl8126_private *tp)
+{
+        struct net_device *dev = tp->dev;
+        int rc = 0;
+        struct r8126_irq *irq;
+        struct r8126_napi *r8126napi;
+        int i = 0;
+        const int len = sizeof(tp->irq_tbl[0].name);
+
+#if defined(RTL_USE_NEW_INTR_API)
+        for (i=0; i<tp->irq_nvecs; i++) {
+                irq = &tp->irq_tbl[i];
+                if (tp->features & RTL_FEATURE_MSIX &&
+                    tp->HwCurrIsrVer > 1)
+                        irq->handler = rtl8126_interrupt_msix;
+                else
+                        irq->handler = rtl8126_interrupt;
+
+                r8126napi = &tp->r8126napi[i];
+                snprintf(irq->name, len, "%s-%d", dev->name, i);
+                rc = pci_request_irq(tp->pci_dev, i, irq->handler, NULL, r8126napi,
+                                     irq->name);
+                if (rc)
+                        break;
+
+                irq->vector = pci_irq_vector(tp->pci_dev, i);
+                irq->requested = 1;
+        }
+#else
+        unsigned long irq_flags = 0;
+#ifdef ENABLE_LIB_SUPPORT
+        irq_flags |= IRQF_NO_SUSPEND;
+#endif
+        if (tp->features & RTL_FEATURE_MSIX &&
+            tp->HwCurrIsrVer > 1) {
+                for (i=0; i<tp->irq_nvecs; i++) {
+                        irq = &tp->irq_tbl[i];
+                        irq->handler = rtl8126_interrupt_msix;
+                        r8126napi = &tp->r8126napi[i];
+                        snprintf(irq->name, len, "%s-%d", dev->name, i);
+                        rc = request_irq(irq->vector, irq->handler, irq_flags, irq->name, r8126napi);
+
+                        if (rc)
+                                break;
+
+                        irq->requested = 1;
+                }
+        } else {
+                irq = &tp->irq_tbl[0];
+                irq->handler = rtl8126_interrupt;
+                r8126napi = &tp->r8126napi[0];
+                snprintf(irq->name, len, "%s-0", dev->name);
+                if (!(tp->features & RTL_FEATURE_MSIX))
+                        irq->vector = dev->irq;
+                irq_flags |= (tp->features & (RTL_FEATURE_MSI | RTL_FEATURE_MSIX)) ? 0 : SA_SHIRQ;
+                rc = request_irq(irq->vector, irq->handler, irq_flags, irq->name, r8126napi);
+
+                if (rc == 0)
+                        irq->requested = 1;
+        }
+#endif
+        if (rc)
+                rtl8126_free_irq(tp);
+
+        return rc;
+}
+
+static int rtl8126_alloc_tx_desc(struct rtl8126_private *tp)
+{
+        struct rtl8126_tx_ring *ring;
+        struct pci_dev *pdev = tp->pci_dev;
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                ring = &tp->tx_ring[i];
+                ring->TxDescAllocSize = (ring->num_tx_desc + 1) * sizeof(struct TxDesc);
+                ring->TxDescArray = dma_alloc_coherent(&pdev->dev,
+                                                       ring->TxDescAllocSize,
+                                                       &ring->TxPhyAddr,
+                                                       GFP_KERNEL);
+
+                if (!ring->TxDescArray)
+                        return -1;
+        }
+
+        return 0;
+}
+
+static int rtl8126_alloc_rx_desc(struct rtl8126_private *tp)
+{
+        struct rtl8126_rx_ring *ring;
+        struct pci_dev *pdev = tp->pci_dev;
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                ring = &tp->rx_ring[i];
+                ring->RxDescAllocSize = (ring->num_rx_desc + 1) * tp->RxDescLength;
+                ring->RxDescArray = dma_alloc_coherent(&pdev->dev,
+                                                       ring->RxDescAllocSize,
+                                                       &ring->RxPhyAddr,
+                                                       GFP_KERNEL);
+
+                if (!ring->RxDescArray)
+                        return -1;
+        }
+
+        return 0;
+}
+
+static void rtl8126_free_tx_desc(struct rtl8126_private *tp)
+{
+        struct rtl8126_tx_ring *ring;
+        struct pci_dev *pdev = tp->pci_dev;
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                ring = &tp->tx_ring[i];
+                if (ring->TxDescArray) {
+                        dma_free_coherent(&pdev->dev,
+                                          ring->TxDescAllocSize,
+                                          ring->TxDescArray,
+                                          ring->TxPhyAddr);
+                        ring->TxDescArray = NULL;
+                }
+        }
+}
+
+static void rtl8126_free_rx_desc(struct rtl8126_private *tp)
+{
+        struct rtl8126_rx_ring *ring;
+        struct pci_dev *pdev = tp->pci_dev;
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                ring = &tp->rx_ring[i];
+                if (ring->RxDescArray) {
+                        dma_free_coherent(&pdev->dev,
+                                          ring->RxDescAllocSize,
+                                          ring->RxDescArray,
+                                          ring->RxPhyAddr);
+                        ring->RxDescArray = NULL;
+                }
+        }
+}
+
+static void rtl8126_free_alloc_resources(struct rtl8126_private *tp)
+{
+        rtl8126_free_rx_desc(tp);
+
+        rtl8126_free_tx_desc(tp);
+}
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+static void rtl8126_request_firmware(struct rtl8126_private *tp)
+{
+        struct rtl8126_fw *rtl_fw;
+
+        /* firmware loaded already or no firmware available */
+        if (tp->rtl_fw || !tp->fw_name)
+                return;
+
+        rtl_fw = kzalloc(sizeof(*rtl_fw), GFP_KERNEL);
+        if (!rtl_fw)
+                return;
+
+        rtl_fw->phy_write = rtl8126_mdio_write;
+        rtl_fw->phy_read = rtl8126_mdio_read;
+        rtl_fw->mac_mcu_write = mac_mcu_write;
+        rtl_fw->mac_mcu_read = mac_mcu_read;
+        rtl_fw->fw_name = tp->fw_name;
+        rtl_fw->dev = tp_to_dev(tp);
+
+        if (rtl8126_fw_request_firmware(rtl_fw))
+                kfree(rtl_fw);
+        else
+                tp->rtl_fw = rtl_fw;
+}
+#endif
+
+int rtl8126_open(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int retval;
+
+        retval = -ENOMEM;
+
+#ifdef ENABLE_R8126_PROCFS
+        rtl8126_proc_init(dev);
+#endif
+        rtl8126_set_rxbufsize(tp, dev);
+        /*
+         * Rx and Tx descriptors needs 256 bytes alignment.
+         * pci_alloc_consistent provides more.
+         */
+        if (rtl8126_alloc_tx_desc(tp) < 0 || rtl8126_alloc_rx_desc(tp) < 0)
+                goto err_free_all_allocated_mem;
+
+        retval = rtl8126_init_ring(dev);
+        if (retval < 0)
+                goto err_free_all_allocated_mem;
+
+        retval = rtl8126_alloc_irq(tp);
+        if (retval < 0)
+                goto err_free_all_allocated_mem;
+
+        if (netif_msg_probe(tp)) {
+                printk(KERN_INFO "%s: 0x%lx, "
+                       "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x, "
+                       "IRQ %d\n",
+                       dev->name,
+                       dev->base_addr,
+                       dev->dev_addr[0], dev->dev_addr[1],
+                       dev->dev_addr[2], dev->dev_addr[3],
+                       dev->dev_addr[4], dev->dev_addr[5], dev->irq);
+        }
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+        rtl8126_request_firmware(tp);
+#endif
+        pci_set_master(tp->pci_dev);
+
+#ifdef  CONFIG_R8126_NAPI
+        rtl8126_enable_napi(tp);
+#endif
+
+        rtl8126_exit_oob(dev);
+
+        rtl8126_up(dev);
+
+#ifdef ENABLE_PTP_SUPPORT
+        if (tp->EnablePtp)
+                rtl8126_ptp_init(tp);
+#endif
+        clear_bit(R8126_FLAG_DOWN, tp->task_flags);
+
+        if (tp->resume_not_chg_speed)
+                _rtl8126_check_link_status(dev, R8126_LINK_STATE_UNKNOWN);
+        else
+                rtl8126_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+
+        if (tp->esd_flag == 0) {
+                //rtl8126_request_esd_timer(dev);
+
+                rtl8126_schedule_esd_work(tp);
+        }
+
+        //rtl8126_request_link_timer(dev);
+#ifdef ENABLE_FIBER_SUPPORT
+        if (HW_FIBER_MODE_ENABLED(tp))
+                rtl8126_schedule_link_work(tp);
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        rtl8126_enable_hw_linkchg_interrupt(tp);
+out:
+
+        return retval;
+
+err_free_all_allocated_mem:
+        rtl8126_free_alloc_resources(tp);
+
+        goto out;
+}
+
+static void
+_rtl8126_set_l1_l0s_entry_latency(struct rtl8126_private *tp, u8 setting)
+{
+        u32 csi_tmp;
+        u32 temp;
+
+        temp = setting & 0x3f;
+        temp <<= 24;
+        /*set PCI configuration space offset 0x70F to setting*/
+        /*When the register offset of PCI configuration space larger than 0xff, use CSI to access it.*/
+
+        csi_tmp = rtl8126_csi_read(tp, 0x70c) & 0xc0ffffff;
+        rtl8126_csi_write(tp, 0x70c, csi_tmp | temp);
+}
+
+static void
+rtl8126_set_l1_l0s_entry_latency(struct rtl8126_private *tp)
+{
+        _rtl8126_set_l1_l0s_entry_latency(tp, 0x27);
+}
+
+static void
+_rtl8126_set_mrrs(struct rtl8126_private *tp, u8 setting)
+{
+        //Set PCI configuration space offset 0x79 to setting
+
+        struct pci_dev *pdev = tp->pci_dev;
+        u8 device_control;
+
+        pci_read_config_byte(pdev, 0x79, &device_control);
+        device_control &= ~0x70;
+        device_control |= setting;
+        pci_write_config_byte(pdev, 0x79, device_control);
+}
+
+static void
+rtl8126_set_mrrs(struct rtl8126_private *tp)
+{
+        if (hwoptimize & HW_PATCH_SOC_LAN)
+                return;
+
+        _rtl8126_set_mrrs(tp, 0x40);
+}
+
+static void
+rtl8126_disable_l1_timeout(struct rtl8126_private *tp)
+{
+        rtl8126_csi_write(tp, 0x890, rtl8126_csi_read(tp, 0x890) & ~BIT(0));
+}
+
+void
+rtl8126_hw_set_rx_packet_filter(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        u32 mc_filter[2];   /* Multicast hash filter */
+        int rx_mode;
+        u32 tmp = 0;
+
+        if (dev->flags & IFF_PROMISC) {
+                /* Unconditionally log net taps. */
+                if (netif_msg_link(tp))
+                        printk(KERN_NOTICE "%s: Promiscuous mode enabled.\n",
+                               dev->name);
+
+                rx_mode =
+                        AcceptBroadcast | AcceptMulticast | AcceptMyPhys |
+                        AcceptAllPhys;
+                mc_filter[1] = mc_filter[0] = 0xffffffff;
+        } else if (dev->flags & IFF_ALLMULTI) {
+                /* accept all multicasts. */
+                rx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;
+                mc_filter[1] = mc_filter[0] = 0xffffffff;
+        } else {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+                struct dev_mc_list *mclist;
+                unsigned int i;
+
+                rx_mode = AcceptBroadcast | AcceptMyPhys;
+                mc_filter[1] = mc_filter[0] = 0;
+                for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
+                     i++, mclist = mclist->next) {
+                        int bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+                        mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+                        rx_mode |= AcceptMulticast;
+                }
+#else
+                struct netdev_hw_addr *ha;
+
+                rx_mode = AcceptBroadcast | AcceptMyPhys;
+                mc_filter[1] = mc_filter[0] = 0;
+                netdev_for_each_mc_addr(ha, dev) {
+                        int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
+                        mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+                        rx_mode |= AcceptMulticast;
+                }
+#endif
+        }
+
+        if (dev->features & NETIF_F_RXALL)
+                rx_mode |= (AcceptErr | AcceptRunt);
+
+        tmp = mc_filter[0];
+        mc_filter[0] = swab32(mc_filter[1]);
+        mc_filter[1] = swab32(tmp);
+
+        tmp = tp->rtl8126_rx_config | rx_mode | (RTL_R32(tp, RxConfig) & rtl_chip_info[tp->chipset].RxConfigMask);
+
+        RTL_W32(tp, RxConfig, tmp);
+        RTL_W32(tp, MAR0 + 0, mc_filter[0]);
+        RTL_W32(tp, MAR0 + 4, mc_filter[1]);
+}
+
+static void
+rtl8126_set_rx_mode(struct net_device *dev)
+{
+        rtl8126_hw_set_rx_packet_filter(dev);
+}
+
+void
+rtl8126_set_rx_q_num(struct rtl8126_private *tp,
+                     unsigned int num_rx_queues)
+{
+        u16 q_ctrl;
+        u16 rx_q_num;
+
+        rx_q_num = (u16)ilog2(num_rx_queues);
+        rx_q_num &= (BIT_0 | BIT_1 | BIT_2);
+        rx_q_num <<= 2;
+        q_ctrl = RTL_R16(tp, Q_NUM_CTRL_8125);
+        q_ctrl &= ~(BIT_2 | BIT_3 | BIT_4);
+        q_ctrl |= rx_q_num;
+        RTL_W16(tp, Q_NUM_CTRL_8125, q_ctrl);
+}
+
+void
+rtl8126_set_tx_q_num(struct rtl8126_private *tp,
+                     unsigned int num_tx_queues)
+{
+        u16 mac_ocp_data;
+
+        mac_ocp_data = rtl8126_mac_ocp_read(tp, 0xE63E);
+        mac_ocp_data &= ~(BIT_11 | BIT_10);
+        mac_ocp_data |= ((ilog2(num_tx_queues) & 0x03) << 10);
+        rtl8126_mac_ocp_write(tp, 0xE63E, mac_ocp_data);
+}
+
+void
+rtl8126_enable_mcu(struct rtl8126_private *tp, bool enable)
+{
+        if (FALSE == HW_SUPPORT_MAC_MCU(tp))
+                return;
+
+        if (enable)
+                rtl8126_set_mac_ocp_bit(tp, 0xC0B4, BIT_0);
+        else
+                rtl8126_clear_mac_ocp_bit(tp, 0xC0B4, BIT_0);
+}
+
+static void
+rtl8126_clear_tcam_entries(struct rtl8126_private *tp)
+{
+        if (FALSE == HW_SUPPORT_TCAM(tp))
+                return;
+
+        rtl8126_set_mac_ocp_bit(tp, 0xEB54, BIT_0);
+        udelay(1);
+        rtl8126_clear_mac_ocp_bit(tp, 0xEB54, BIT_0);
+}
+
+static u8
+rtl8126_get_l1off_cap_bits(struct rtl8126_private *tp)
+{
+        u8 l1offCapBits = 0;
+
+        l1offCapBits = (BIT_0 | BIT_1);
+        l1offCapBits |= (BIT_2 | BIT_3);
+
+        return l1offCapBits;
+}
+
+void
+rtl8126_hw_config(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        struct pci_dev *pdev = tp->pci_dev;
+        u16 mac_ocp_data;
+
+        rtl8126_disable_rx_packet_filter(tp);
+
+        rtl8126_hw_reset(dev);
+
+        rtl8126_enable_cfg9346_write(tp);
+        rtl8126_enable_force_clkreq(tp, 0);
+        rtl8126_enable_aspm_clkreq_lock(tp, 0);
+
+        rtl8126_set_eee_lpi_timer(tp);
+
+        //keep magic packet only
+        mac_ocp_data = rtl8126_mac_ocp_read(tp, 0xC0B6);
+        mac_ocp_data &= BIT_0;
+        rtl8126_mac_ocp_write(tp, 0xC0B6, mac_ocp_data);
+
+        rtl8126_tally_counter_addr_fill(tp);
+
+        rtl8126_enable_extend_tally_couter(tp);
+
+        rtl8126_desc_addr_fill(tp);
+
+        /* Set DMA burst size and Interframe Gap Time */
+        RTL_W32(tp, TxConfig, (TX_DMA_BURST_unlimited << TxDMAShift) |
+                (InterFrameGap << TxInterFrameGapShift));
+
+        if (tp->EnableTxNoClose)
+                RTL_W32(tp, TxConfig, (RTL_R32(tp, TxConfig) | BIT_6));
+
+        if (enable_double_vlan)
+                rtl8126_enable_double_vlan(tp);
+        else
+                rtl8126_disable_double_vlan(tp);
+
+        rtl8126_set_l1_l0s_entry_latency(tp);
+
+        rtl8126_set_mrrs(tp);
+
+        rtl8126_disable_l1_timeout(tp);
+
+#ifdef ENABLE_RSS_SUPPORT
+        rtl8126_config_rss(tp);
+#else
+        RTL_W32(tp, RSS_CTRL_8125, 0x00);
+#endif
+        rtl8126_set_rx_q_num(tp, rtl8126_tot_rx_rings(tp));
+
+        RTL_W8(tp, Config1, RTL_R8(tp, Config1) & ~0x10);
+
+        rtl8126_mac_ocp_write(tp, 0xC140, 0xFFFF);
+        rtl8126_mac_ocp_write(tp, 0xC142, 0xFFFF);
+
+        //new tx desc format
+        mac_ocp_data = rtl8126_mac_ocp_read(tp, 0xEB58);
+        if (tp->mcfg == CFG_METHOD_2 || tp->mcfg == CFG_METHOD_3)
+                mac_ocp_data &= ~(BIT_0 | BIT_1);
+        mac_ocp_data |= (BIT_0);
+        rtl8126_mac_ocp_write(tp, 0xEB58, mac_ocp_data);
+
+        if (tp->HwSuppRxDescType == RX_DESC_RING_TYPE_4) {
+                if (tp->InitRxDescType == RX_DESC_RING_TYPE_4)
+                        RTL_W8(tp, 0xd8, RTL_R8(tp, 0xd8) |
+                               EnableRxDescV4_0);
+                else
+                        RTL_W8(tp, 0xd8, RTL_R8(tp, 0xd8) &
+                               ~EnableRxDescV4_0);
+        }
+
+        mac_ocp_data = rtl8126_mac_ocp_read(tp, 0xE614);
+        mac_ocp_data &= ~(BIT_10 | BIT_9 | BIT_8);
+        if (tp->EnableTxNoClose)
+                mac_ocp_data |= (4 << 8);
+        else
+                mac_ocp_data |= (3 << 8);
+        rtl8126_mac_ocp_write(tp, 0xE614, mac_ocp_data);
+
+        rtl8126_set_tx_q_num(tp, rtl8126_tot_tx_rings(tp));
+
+        mac_ocp_data = rtl8126_mac_ocp_read(tp, 0xE63E);
+        mac_ocp_data &= ~(BIT_5 | BIT_4);
+        mac_ocp_data |= ((0x02 & 0x03) << 4);
+        rtl8126_mac_ocp_write(tp, 0xE63E, mac_ocp_data);
+
+        rtl8126_enable_mcu(tp, 0);
+        rtl8126_enable_mcu(tp, 1);
+
+        mac_ocp_data = rtl8126_mac_ocp_read(tp, 0xC0B4);
+        mac_ocp_data |= (BIT_3 | BIT_2);
+        rtl8126_mac_ocp_write(tp, 0xC0B4, mac_ocp_data);
+
+        mac_ocp_data = rtl8126_mac_ocp_read(tp, 0xEB6A);
+        mac_ocp_data &= ~(BIT_7 | BIT_6 | BIT_5 | BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0);
+        mac_ocp_data |= (BIT_5 | BIT_4 | BIT_1 | BIT_0);
+        rtl8126_mac_ocp_write(tp, 0xEB6A, mac_ocp_data);
+
+        mac_ocp_data = rtl8126_mac_ocp_read(tp, 0xEB50);
+        mac_ocp_data &= ~(BIT_9 | BIT_8 | BIT_7 | BIT_6 | BIT_5);
+        mac_ocp_data |= (BIT_6);
+        rtl8126_mac_ocp_write(tp, 0xEB50, mac_ocp_data);
+
+        mac_ocp_data = rtl8126_mac_ocp_read(tp, 0xE056);
+        mac_ocp_data &= ~(BIT_7 | BIT_6 | BIT_5 | BIT_4);
+        //mac_ocp_data |= (BIT_4 | BIT_5);
+        rtl8126_mac_ocp_write(tp, 0xE056, mac_ocp_data);
+
+        RTL_W8(tp, TDFNR, 0x10);
+
+        mac_ocp_data = rtl8126_mac_ocp_read(tp, 0xE040);
+        mac_ocp_data &= ~(BIT_12);
+        rtl8126_mac_ocp_write(tp, 0xE040, mac_ocp_data);
+
+        mac_ocp_data = rtl8126_mac_ocp_read(tp, 0xEA1C);
+        mac_ocp_data &= ~(BIT_1 | BIT_0);
+        mac_ocp_data |= (BIT_0);
+        rtl8126_mac_ocp_write(tp, 0xEA1C, mac_ocp_data);
+
+        rtl8126_mac_ocp_write(tp, 0xE0C0, 0x4000);
+
+        rtl8126_set_mac_ocp_bit(tp, 0xE052, (BIT_6 | BIT_5));
+        rtl8126_clear_mac_ocp_bit(tp, 0xE052, BIT_3 | BIT_7);
+
+        mac_ocp_data = rtl8126_mac_ocp_read(tp, 0xD430);
+        mac_ocp_data &= ~(BIT_11 | BIT_10 | BIT_9 | BIT_8 | BIT_7 | BIT_6 | BIT_5 | BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0);
+        mac_ocp_data |= 0x45F;
+        rtl8126_mac_ocp_write(tp, 0xD430, mac_ocp_data);
+
+        //rtl8126_mac_ocp_write(tp, 0xE0C0, 0x4F87);
+        RTL_W8(tp, 0xD0, RTL_R8(tp, 0xD0) | BIT_6 | BIT_7);
+
+        rtl8126_disable_eee_plus(tp);
+
+        mac_ocp_data = rtl8126_mac_ocp_read(tp, 0xEA1C);
+        mac_ocp_data &= ~(BIT_2);
+        if (tp->mcfg == CFG_METHOD_2 || tp->mcfg == CFG_METHOD_3)
+                mac_ocp_data &= ~(BIT_9 | BIT_8);
+        rtl8126_mac_ocp_write(tp, 0xEA1C, mac_ocp_data);
+
+        rtl8126_clear_tcam_entries(tp);
+
+        RTL_W16(tp, 0x1880, RTL_R16(tp, 0x1880) & ~(BIT_4 | BIT_5));
+
+        /* csum offload command for RTL8125 */
+        tp->tx_tcp_csum_cmd = TxTCPCS_C;
+        tp->tx_udp_csum_cmd = TxUDPCS_C;
+        tp->tx_ip_csum_cmd = TxIPCS_C;
+        tp->tx_ipv6_csum_cmd = TxIPV6F_C;
+
+        /* config interrupt type for RTL8125B */
+        if (tp->HwSuppIsrVer > 1)
+                rtl8126_hw_set_interrupt_type(tp, tp->HwCurrIsrVer);
+
+        //other hw parameters
+        rtl8126_hw_clear_timer_int(dev);
+
+        rtl8126_hw_clear_int_miti(dev);
+
+        if (tp->use_timer_interrupt &&
+            (tp->HwCurrIsrVer > 1) &&
+            (tp->HwSuppIntMitiVer > 3) &&
+            (tp->features & RTL_FEATURE_MSIX)) {
+                int i;
+                for (i = 0; i < tp->irq_nvecs; i++)
+                        rtl8126_hw_set_timer_int(tp, i, timer_count_v2);
+        }
+
+        rtl8126_enable_exit_l1_mask(tp);
+
+        rtl8126_mac_ocp_write(tp, 0xE098, 0xC302);
+
+        if (aspm && (tp->org_pci_offset_99 & (BIT_2 | BIT_5 | BIT_6)))
+                rtl8126_init_pci_offset_99(tp);
+        else
+                rtl8126_disable_pci_offset_99(tp);
+
+        if (aspm && (tp->org_pci_offset_180 & rtl8126_get_l1off_cap_bits(tp)))
+                rtl8126_init_pci_offset_180(tp);
+        else
+                rtl8126_disable_pci_offset_180(tp);
+
+        tp->cp_cmd &= ~(EnableBist | Macdbgo_oe | Force_halfdup |
+                        Force_rxflow_en | Force_txflow_en | Cxpl_dbg_sel |
+                        ASF | Macdbgo_sel);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        RTL_W16(tp, CPlusCmd, tp->cp_cmd);
+#else
+        rtl8126_hw_set_features(dev, dev->features);
+#endif
+        rtl8126_set_rms(tp, tp->rms);
+
+        rtl8126_disable_rxdvgate(dev);
+
+        if (!tp->pci_cfg_is_read) {
+                pci_read_config_byte(pdev, PCI_COMMAND, &tp->pci_cfg_space.cmd);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_0, &tp->pci_cfg_space.io_base_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_0 + 2, &tp->pci_cfg_space.io_base_h);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_2, &tp->pci_cfg_space.mem_base_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_2 + 2, &tp->pci_cfg_space.mem_base_h);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_3, &tp->pci_cfg_space.resv_0x1c_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_3 + 2, &tp->pci_cfg_space.resv_0x1c_h);
+                pci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &tp->pci_cfg_space.ilr);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_4, &tp->pci_cfg_space.resv_0x20_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_4 + 2, &tp->pci_cfg_space.resv_0x20_h);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_5, &tp->pci_cfg_space.resv_0x24_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_5 + 2, &tp->pci_cfg_space.resv_0x24_h);
+                pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &tp->pci_cfg_space.resv_0x2c_l);
+                pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID + 2, &tp->pci_cfg_space.resv_0x2c_h);
+                if (tp->HwPcieSNOffset > 0) {
+                        tp->pci_cfg_space.pci_sn_l = rtl8126_csi_read(tp, tp->HwPcieSNOffset);
+                        tp->pci_cfg_space.pci_sn_h = rtl8126_csi_read(tp, tp->HwPcieSNOffset + 4);
+                }
+
+                tp->pci_cfg_is_read = 1;
+        }
+
+        /* Set Rx packet filter */
+        rtl8126_hw_set_rx_packet_filter(dev);
+
+        rtl8126_enable_aspm_clkreq_lock(tp, aspm ? 1 : 0);
+
+        rtl8126_disable_cfg9346_write(tp);
+
+        udelay(10);
+}
+
+void
+rtl8126_hw_start(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+#ifdef ENABLE_LIB_SUPPORT
+        rtl8126_init_lib_ring(tp);
+#endif
+
+        RTL_W8(tp, ChipCmd, CmdTxEnb | CmdRxEnb);
+
+        rtl8126_enable_hw_interrupt(tp);
+
+        rtl8126_lib_reset_complete(tp);
+}
+
+static int
+rtl8126_change_mtu(struct net_device *dev,
+                   int new_mtu)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int ret = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+        if (new_mtu < ETH_MIN_MTU)
+                return -EINVAL;
+        else if (new_mtu > tp->max_jumbo_frame_size)
+                new_mtu = tp->max_jumbo_frame_size;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+
+        dev->mtu = new_mtu;
+
+        tp->eee.tx_lpi_timer = dev->mtu + ETH_HLEN + 0x20;
+
+        if (!netif_running(dev))
+                goto out;
+
+        rtl8126_down(dev);
+
+        rtl8126_set_rxbufsize(tp, dev);
+
+        ret = rtl8126_init_ring(dev);
+
+        if (ret < 0)
+                goto err_out;
+
+#ifdef CONFIG_R8126_NAPI
+        rtl8126_enable_napi(tp);
+#endif//CONFIG_R8126_NAPI
+
+        if (tp->link_ok(dev))
+                rtl8126_link_on_patch(dev);
+        else
+                rtl8126_link_down_patch(dev);
+
+        //mod_timer(&tp->esd_timer, jiffies + RTL8126_ESD_TIMEOUT);
+        //mod_timer(&tp->link_timer, jiffies + RTL8126_LINK_TIMEOUT);
+out:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+        netdev_update_features(dev);
+#endif
+
+err_out:
+        return ret;
+}
+
+static inline void
+rtl8126_set_desc_dma_addr(struct rtl8126_private *tp,
+                          struct RxDesc *desc,
+                          dma_addr_t mapping)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                ((struct RxDescV3 *)desc)->addr = cpu_to_le64(mapping);
+                break;
+        case RX_DESC_RING_TYPE_4:
+                ((struct RxDescV4 *)desc)->addr = cpu_to_le64(mapping);
+                break;
+        default:
+                desc->addr = cpu_to_le64(mapping);
+                break;
+        }
+}
+
+static inline void
+rtl8126_mark_to_asic_v1(struct RxDesc *desc,
+                        u32 rx_buf_sz)
+{
+        u32 eor = le32_to_cpu(desc->opts1) & RingEnd;
+
+        WRITE_ONCE(desc->opts1, cpu_to_le32(DescOwn | eor | rx_buf_sz));
+}
+
+static inline void
+rtl8126_mark_to_asic_v3(struct RxDescV3 *descv3,
+                        u32 rx_buf_sz)
+{
+        u32 eor = le32_to_cpu(descv3->RxDescNormalDDWord4.opts1) & RingEnd;
+
+        WRITE_ONCE(descv3->RxDescNormalDDWord4.opts1, cpu_to_le32(DescOwn | eor | rx_buf_sz));
+}
+
+static inline void
+rtl8126_mark_to_asic_v4(struct RxDescV4 *descv4,
+                        u32 rx_buf_sz)
+{
+        u32 eor = le32_to_cpu(descv4->RxDescNormalDDWord2.opts1) & RingEnd;
+
+        WRITE_ONCE(descv4->RxDescNormalDDWord2.opts1, cpu_to_le32(DescOwn | eor | rx_buf_sz));
+}
+
+void
+rtl8126_mark_to_asic(struct rtl8126_private *tp,
+                     struct RxDesc *desc,
+                     u32 rx_buf_sz)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                rtl8126_mark_to_asic_v3((struct RxDescV3 *)desc, rx_buf_sz);
+                break;
+        case RX_DESC_RING_TYPE_4:
+                rtl8126_mark_to_asic_v4((struct RxDescV4 *)desc, rx_buf_sz);
+                break;
+        default:
+                rtl8126_mark_to_asic_v1(desc, rx_buf_sz);
+                break;
+        }
+}
+
+static inline void
+rtl8126_map_to_asic(struct rtl8126_private *tp,
+                    struct rtl8126_rx_ring *ring,
+                    struct RxDesc *desc,
+                    dma_addr_t mapping,
+                    u32 rx_buf_sz,
+                    const u32 cur_rx)
+{
+        ring->RxDescPhyAddr[cur_rx] = mapping;
+        rtl8126_set_desc_dma_addr(tp, desc, mapping);
+        wmb();
+        rtl8126_mark_to_asic(tp, desc, rx_buf_sz);
+}
+
+#ifdef ENABLE_PAGE_REUSE
+
+static int
+rtl8126_alloc_rx_page(struct rtl8126_private *tp, struct rtl8126_rx_ring *ring,
+                      struct rtl8126_rx_buffer *rxb)
+{
+        struct page *page;
+        dma_addr_t dma;
+        unsigned int order = tp->rx_buf_page_order;
+
+        //get free page
+        page = dev_alloc_pages(order);
+
+        if (unlikely(!page))
+                return -ENOMEM;
+
+        dma = dma_map_page_attrs(&tp->pci_dev->dev, page, 0,
+                                 tp->rx_buf_page_size,
+                                 DMA_FROM_DEVICE,
+                                 (DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING));
+
+        if (unlikely(dma_mapping_error(&tp->pci_dev->dev, dma))) {
+                __free_pages(page, order);
+                return -ENOMEM;
+        }
+
+        rxb->page = page;
+        rxb->data = page_address(page);
+        rxb->page_offset = ring->rx_offset;
+        rxb->dma = dma;
+
+        //after page alloc, page refcount already = 1
+
+        return 0;
+}
+
+static void
+rtl8126_free_rx_page(struct rtl8126_private *tp, struct rtl8126_rx_buffer *rxb)
+{
+        if (!rxb->page)
+                return;
+
+        dma_unmap_page_attrs(&tp->pci_dev->dev, rxb->dma,
+                             tp->rx_buf_page_size,
+                             DMA_FROM_DEVICE,
+                             (DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING));
+        __free_pages(rxb->page, tp->rx_buf_page_order);
+        rxb->page = NULL;
+}
+
+static void
+_rtl8126_rx_clear(struct rtl8126_private *tp, struct rtl8126_rx_ring *ring)
+{
+        int i;
+        struct rtl8126_rx_buffer *rxb;
+
+        for (i = 0; i < ring->num_rx_desc; i++) {
+                rxb = &ring->rx_buffer[i];
+                if (rxb->skb) {
+                        dev_kfree_skb(rxb->skb);
+                        rxb->skb = NULL;
+                }
+                rtl8126_free_rx_page(tp, rxb);
+        }
+}
+
+static u32
+rtl8126_rx_fill(struct rtl8126_private *tp,
+                struct rtl8126_rx_ring *ring,
+                struct net_device *dev,
+                u32 start,
+                u32 end,
+                u8 in_intr)
+{
+        u32 cur;
+        struct rtl8126_rx_buffer *rxb;
+
+        for (cur = start; end - cur > 0; cur++) {
+                int ret, i = cur % ring->num_rx_desc;
+
+                rxb = &ring->rx_buffer[i];
+                if (rxb->page)
+                        continue;
+
+                ret = rtl8126_alloc_rx_page(tp, ring, rxb);
+                if (ret)
+                        break;
+
+                dma_sync_single_range_for_device(tp_to_dev(tp),
+                                                 rxb->dma,
+                                                 rxb->page_offset,
+                                                 tp->rx_buf_sz,
+                                                 DMA_FROM_DEVICE);
+
+                rtl8126_map_to_asic(tp, ring,
+                                    rtl8126_get_rxdesc(tp, ring->RxDescArray, i),
+                                    rxb->dma + rxb->page_offset,
+                                    tp->rx_buf_sz, i);
+        }
+        return cur - start;
+}
+
+#else //ENABLE_PAGE_REUSE
+
+static void
+rtl8126_free_rx_skb(struct rtl8126_private *tp,
+                    struct rtl8126_rx_ring *ring,
+                    struct sk_buff **sk_buff,
+                    struct RxDesc *desc,
+                    const u32 cur_rx)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+
+        dma_unmap_single(&pdev->dev, ring->RxDescPhyAddr[cur_rx], tp->rx_buf_sz,
+                         DMA_FROM_DEVICE);
+        dev_kfree_skb(*sk_buff);
+        *sk_buff = NULL;
+        rtl8126_make_unusable_by_asic(tp, desc);
+}
+
+static int
+rtl8126_alloc_rx_skb(struct rtl8126_private *tp,
+                     struct rtl8126_rx_ring *ring,
+                     struct sk_buff **sk_buff,
+                     struct RxDesc *desc,
+                     int rx_buf_sz,
+                     const u32 cur_rx,
+                     u8 in_intr)
+{
+        struct sk_buff *skb;
+        dma_addr_t mapping;
+        int ret = 0;
+
+        if (in_intr)
+                skb = RTL_ALLOC_SKB_INTR(&tp->r8126napi[ring->index].napi, rx_buf_sz + R8126_RX_ALIGN);
+        else
+                skb = dev_alloc_skb(rx_buf_sz + R8126_RX_ALIGN);
+
+        if (unlikely(!skb))
+                goto err_out;
+
+        if (!in_intr || !R8126_USE_NAPI_ALLOC_SKB)
+                skb_reserve(skb, R8126_RX_ALIGN);
+
+        mapping = dma_map_single(tp_to_dev(tp), skb->data, rx_buf_sz,
+                                 DMA_FROM_DEVICE);
+        if (unlikely(dma_mapping_error(tp_to_dev(tp), mapping))) {
+                if (unlikely(net_ratelimit()))
+                        netif_err(tp, drv, tp->dev, "Failed to map RX DMA!\n");
+                goto err_out;
+        }
+
+        *sk_buff = skb;
+        rtl8126_map_to_asic(tp, ring, desc, mapping, rx_buf_sz, cur_rx);
+out:
+        return ret;
+
+err_out:
+        if (skb)
+                dev_kfree_skb(skb);
+        ret = -ENOMEM;
+        rtl8126_make_unusable_by_asic(tp, desc);
+        goto out;
+}
+
+static void
+_rtl8126_rx_clear(struct rtl8126_private *tp, struct rtl8126_rx_ring *ring)
+{
+        int i;
+
+        for (i = 0; i < ring->num_rx_desc; i++) {
+                if (ring->Rx_skbuff[i]) {
+                        rtl8126_free_rx_skb(tp,
+                                            ring,
+                                            ring->Rx_skbuff + i,
+                                            rtl8126_get_rxdesc(tp, ring->RxDescArray, i),
+                                            i);
+                        ring->Rx_skbuff[i] = NULL;
+                }
+        }
+}
+
+static u32
+rtl8126_rx_fill(struct rtl8126_private *tp,
+                struct rtl8126_rx_ring *ring,
+                struct net_device *dev,
+                u32 start,
+                u32 end,
+                u8 in_intr)
+{
+        u32 cur;
+
+        for (cur = start; end - cur > 0; cur++) {
+                int ret, i = cur % ring->num_rx_desc;
+
+                if (ring->Rx_skbuff[i])
+                        continue;
+
+                ret = rtl8126_alloc_rx_skb(tp,
+                                           ring,
+                                           ring->Rx_skbuff + i,
+                                           rtl8126_get_rxdesc(tp, ring->RxDescArray, i),
+                                           tp->rx_buf_sz,
+                                           i,
+                                           in_intr);
+                if (ret < 0)
+                        break;
+        }
+        return cur - start;
+}
+
+#endif //ENABLE_PAGE_REUSE
+
+void
+rtl8126_rx_clear(struct rtl8126_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8126_rx_ring *ring = &tp->rx_ring[i];
+
+                _rtl8126_rx_clear(tp, ring);
+        }
+}
+
+static void
+rtl8126_mark_as_last_descriptor_v1(struct RxDesc *desc)
+{
+        desc->opts1 |= cpu_to_le32(RingEnd);
+}
+
+static void
+rtl8126_mark_as_last_descriptor_v3(struct RxDescV3 *descv3)
+{
+        descv3->RxDescNormalDDWord4.opts1 |= cpu_to_le32(RingEnd);
+}
+
+static void
+rtl8126_mark_as_last_descriptor_v4(struct RxDescV4 *descv4)
+{
+        descv4->RxDescNormalDDWord2.opts1 |= cpu_to_le32(RingEnd);
+}
+
+void
+rtl8126_mark_as_last_descriptor(struct rtl8126_private *tp,
+                                struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                rtl8126_mark_as_last_descriptor_v3((struct RxDescV3 *)desc);
+                break;
+        case RX_DESC_RING_TYPE_4:
+                rtl8126_mark_as_last_descriptor_v4((struct RxDescV4 *)desc);
+                break;
+        default:
+                rtl8126_mark_as_last_descriptor_v1(desc);
+                break;
+        }
+}
+
+static void
+rtl8126_desc_addr_fill(struct rtl8126_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8126_tx_ring *ring = &tp->tx_ring[i];
+                RTL_W32(tp, ring->tdsar_reg, ((u64)ring->TxPhyAddr & DMA_BIT_MASK(32)));
+                RTL_W32(tp, ring->tdsar_reg + 4, ((u64)ring->TxPhyAddr >> 32));
+        }
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8126_rx_ring *ring = &tp->rx_ring[i];
+                RTL_W32(tp, ring->rdsar_reg, ((u64)ring->RxPhyAddr & DMA_BIT_MASK(32)));
+                RTL_W32(tp, ring->rdsar_reg + 4, ((u64)ring->RxPhyAddr >> 32));
+        }
+}
+
+static void
+rtl8126_tx_desc_init(struct rtl8126_private *tp)
+{
+        int i = 0;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8126_tx_ring *ring = &tp->tx_ring[i];
+                memset(ring->TxDescArray, 0x0, ring->TxDescAllocSize);
+
+                ring->TxDescArray[ring->num_tx_desc - 1].opts1 = cpu_to_le32(RingEnd);
+        }
+}
+
+static void
+rtl8126_rx_desc_init(struct rtl8126_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8126_rx_ring *ring = &tp->rx_ring[i];
+                memset(ring->RxDescArray, 0x0, ring->RxDescAllocSize);
+        }
+}
+
+int
+rtl8126_init_ring(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        int i;
+
+        rtl8126_init_ring_indexes(tp);
+
+        rtl8126_tx_desc_init(tp);
+        rtl8126_rx_desc_init(tp);
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8126_tx_ring *ring = &tp->tx_ring[i];
+                memset(ring->tx_skb, 0x0, sizeof(ring->tx_skb));
+        }
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8126_rx_ring *ring = &tp->rx_ring[i];
+#ifdef ENABLE_PAGE_REUSE
+                ring->rx_offset = R8126_RX_ALIGN;
+#else
+                memset(ring->Rx_skbuff, 0x0, sizeof(ring->Rx_skbuff));
+#endif //ENABLE_PAGE_REUSE
+                if (rtl8126_rx_fill(tp, ring, dev, 0, ring->num_rx_desc, 0) != ring->num_rx_desc)
+                        goto err_out;
+
+                rtl8126_mark_as_last_descriptor(tp, rtl8126_get_rxdesc(tp, ring->RxDescArray, ring->num_rx_desc - 1));
+        }
+
+        return 0;
+
+err_out:
+        rtl8126_rx_clear(tp);
+        return -ENOMEM;
+}
+
+static void
+rtl8126_unmap_tx_skb(struct pci_dev *pdev,
+                     struct ring_info *tx_skb,
+                     struct TxDesc *desc)
+{
+        unsigned int len = tx_skb->len;
+
+        dma_unmap_single(&pdev->dev, le64_to_cpu(desc->addr), len, DMA_TO_DEVICE);
+
+        desc->opts1 = cpu_to_le32(RTK_MAGIC_DEBUG_VALUE);
+        desc->opts2 = 0x00;
+        desc->addr = RTL8126_MAGIC_NUMBER;
+        tx_skb->len = 0;
+}
+
+static void
+rtl8126_tx_clear_range(struct rtl8126_private *tp,
+                       struct rtl8126_tx_ring *ring,
+                       u32 start,
+                       unsigned int n)
+{
+        unsigned int i;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+        struct net_device *dev = tp->dev;
+#endif
+
+        for (i = 0; i < n; i++) {
+                unsigned int entry = (start + i) % ring->num_tx_desc;
+                struct ring_info *tx_skb = ring->tx_skb + entry;
+                unsigned int len = tx_skb->len;
+
+                if (len) {
+                        struct sk_buff *skb = tx_skb->skb;
+
+                        rtl8126_unmap_tx_skb(tp->pci_dev, tx_skb,
+                                             ring->TxDescArray + entry);
+                        if (skb) {
+                                RTLDEV->stats.tx_dropped++;
+                                dev_kfree_skb_any(skb);
+                                tx_skb->skb = NULL;
+                        }
+                }
+        }
+}
+
+void
+rtl8126_tx_clear(struct rtl8126_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8126_tx_ring *ring = &tp->tx_ring[i];
+                rtl8126_tx_clear_range(tp, ring, ring->dirty_tx, ring->num_tx_desc);
+                ring->cur_tx = ring->dirty_tx = 0;
+        }
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8126_schedule_reset_work(struct rtl8126_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        set_bit(R8126_FLAG_TASK_RESET_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->reset_task, 4);
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+}
+
+static void rtl8126_schedule_esd_work(struct rtl8126_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        set_bit(R8126_FLAG_TASK_ESD_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->esd_task, RTL8126_ESD_TIMEOUT);
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+}
+
+static void rtl8126_schedule_linkchg_work(struct rtl8126_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        set_bit(R8126_FLAG_TASK_LINKCHG_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->linkchg_task, 4);
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+}
+
+static void rtl8126_schedule_link_work(struct rtl8126_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        set_bit(R8126_FLAG_TASK_LINK_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->link_task, RTL8126_LINK_TIMEOUT);
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+}
+
+#define rtl8126_cancel_schedule_reset_work(a)
+#define rtl8126_cancel_schedule_esd_work(a)
+#define rtl8126_cancel_schedule_linkchg_work(a)
+#define rtl8126_cancel_schedule_link_work(a)
+
+#else
+static void rtl8126_schedule_reset_work(struct rtl8126_private *tp)
+{
+        set_bit(R8126_FLAG_TASK_RESET_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->reset_task, 4);
+}
+
+static void rtl8126_cancel_schedule_reset_work(struct rtl8126_private *tp)
+{
+        struct work_struct *work = &tp->reset_task.work;
+
+        if (!work->func)
+                return;
+
+        cancel_delayed_work_sync(&tp->reset_task);
+}
+
+static void rtl8126_schedule_esd_work(struct rtl8126_private *tp)
+{
+        set_bit(R8126_FLAG_TASK_ESD_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->esd_task, RTL8126_ESD_TIMEOUT);
+}
+
+static void rtl8126_cancel_schedule_esd_work(struct rtl8126_private *tp)
+{
+        struct work_struct *work = &tp->esd_task.work;
+
+        if (!work->func)
+                return;
+
+        cancel_delayed_work_sync(&tp->esd_task);
+}
+
+static void rtl8126_schedule_linkchg_work(struct rtl8126_private *tp)
+{
+        set_bit(R8126_FLAG_TASK_LINKCHG_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->linkchg_task, 4);
+}
+
+static void rtl8126_cancel_schedule_linkchg_work(struct rtl8126_private *tp)
+{
+        struct work_struct *work = &tp->linkchg_task.work;
+
+        if (!work->func)
+                return;
+
+        cancel_delayed_work_sync(&tp->linkchg_task);
+}
+
+static void rtl8126_schedule_link_work(struct rtl8126_private *tp)
+{
+        set_bit(R8126_FLAG_TASK_LINK_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->link_task, RTL8126_LINK_TIMEOUT);
+}
+
+static void rtl8126_cancel_schedule_link_work(struct rtl8126_private *tp)
+{
+        struct work_struct *work = &tp->link_task.work;
+
+        if (!work->func)
+                return;
+
+        cancel_delayed_work_sync(&tp->link_task);
+}
+#endif
+
+static void rtl8126_init_all_schedule_work(struct rtl8126_private *tp)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+        INIT_WORK(&tp->reset_task, rtl8126_reset_task, dev);
+        INIT_WORK(&tp->esd_task, rtl8126_esd_task, dev);
+        INIT_WORK(&tp->linkchg_task, rtl8126_linkchg_task, dev);
+        INIT_WORK(&tp->link_task, rtl8126_link_task, dev);
+#else
+        INIT_DELAYED_WORK(&tp->reset_task, rtl8126_reset_task);
+        INIT_DELAYED_WORK(&tp->esd_task, rtl8126_esd_task);
+        INIT_DELAYED_WORK(&tp->linkchg_task, rtl8126_linkchg_task);
+        INIT_DELAYED_WORK(&tp->link_task, rtl8126_link_task);
+#endif
+}
+
+static void rtl8126_cancel_all_schedule_work(struct rtl8126_private *tp)
+{
+        rtl8126_cancel_schedule_reset_work(tp);
+        rtl8126_cancel_schedule_esd_work(tp);
+        rtl8126_cancel_schedule_linkchg_work(tp);
+        rtl8126_cancel_schedule_link_work(tp);
+}
+
+static void
+rtl8126_wait_for_irq_complete(struct rtl8126_private *tp)
+{
+        if (tp->features & RTL_FEATURE_MSIX) {
+                int i;
+                for (i = 0; i < tp->irq_nvecs; i++)
+                        synchronize_irq(tp->irq_tbl[i].vector);
+        } else {
+                synchronize_irq(tp->dev->irq);
+        }
+}
+
+void
+_rtl8126_wait_for_quiescence(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        /* Wait for any pending NAPI task to complete */
+#ifdef CONFIG_R8126_NAPI
+        rtl8126_disable_napi(tp);
+#endif//CONFIG_R8126_NAPI
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,67)
+        /* Give a racing hard_start_xmit a few cycles to complete. */
+        synchronize_net();
+#endif
+
+        rtl8126_irq_mask_and_ack(tp);
+
+        rtl8126_wait_for_irq_complete(tp);
+}
+
+static void
+rtl8126_wait_for_quiescence(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        //suppress unused variable
+        (void)(tp);
+
+        _rtl8126_wait_for_quiescence(dev);
+
+#ifdef CONFIG_R8126_NAPI
+        rtl8126_enable_napi(tp);
+#endif//CONFIG_R8126_NAPI
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8126_reset_task(void *_data)
+{
+        struct net_device *dev = _data;
+        struct rtl8126_private *tp = netdev_priv(dev);
+#else
+static void rtl8126_reset_task(struct work_struct *work)
+{
+        struct rtl8126_private *tp =
+                container_of(work, struct rtl8126_private, reset_task.work);
+        struct net_device *dev = tp->dev;
+#endif
+        int i;
+
+        rtnl_lock();
+
+        if (!netif_running(dev) ||
+            test_bit(R8126_FLAG_DOWN, tp->task_flags) ||
+            !test_and_clear_bit(R8126_FLAG_TASK_RESET_PENDING, tp->task_flags))
+                goto out_unlock;
+
+        netdev_err(dev, "Device reseting!\n");
+
+        netif_carrier_off(dev);
+        netif_tx_disable(dev);
+        _rtl8126_wait_for_quiescence(dev);
+        rtl8126_hw_reset(dev);
+
+        rtl8126_tx_clear(tp);
+
+        rtl8126_init_ring_indexes(tp);
+
+        rtl8126_tx_desc_init(tp);
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8126_rx_ring *ring;
+                u32 entry;
+
+                ring = &tp->rx_ring[i];
+                for (entry = 0; entry < ring->num_rx_desc; entry++) {
+                        struct RxDesc *desc;
+
+                        desc = rtl8126_get_rxdesc(tp, ring->RxDescArray, entry);
+                        rtl8126_mark_to_asic(tp, desc, tp->rx_buf_sz);
+                }
+        }
+
+#ifdef ENABLE_PTP_SUPPORT
+        rtl8126_ptp_reset(tp);
+#endif
+
+#ifdef CONFIG_R8126_NAPI
+        rtl8126_enable_napi(tp);
+#endif //CONFIG_R8126_NAPI
+
+        if (tp->resume_not_chg_speed) {
+                _rtl8126_check_link_status(dev, R8126_LINK_STATE_UNKNOWN);
+
+                tp->resume_not_chg_speed = 0;
+        } else {
+                rtl8126_enable_hw_linkchg_interrupt(tp);
+
+                rtl8126_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+        }
+
+out_unlock:
+        rtnl_unlock();
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8126_esd_task(void *_data)
+{
+        struct net_device *dev = _data;
+        struct rtl8126_private *tp = netdev_priv(dev);
+#else
+static void rtl8126_esd_task(struct work_struct *work)
+{
+        struct rtl8126_private *tp =
+                container_of(work, struct rtl8126_private, esd_task.work);
+        struct net_device *dev = tp->dev;
+#endif
+        rtnl_lock();
+
+        if (!netif_running(dev) ||
+            test_bit(R8126_FLAG_DOWN, tp->task_flags) ||
+            !test_and_clear_bit(R8126_FLAG_TASK_ESD_CHECK_PENDING, tp->task_flags))
+                goto out_unlock;
+
+        rtl8126_esd_checker(tp);
+
+        rtl8126_schedule_esd_work(tp);
+
+out_unlock:
+        rtnl_unlock();
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8126_linkchg_task(void *_data)
+{
+        struct net_device *dev = _data;
+        //struct rtl8126_private *tp = netdev_priv(dev);
+#else
+static void rtl8126_linkchg_task(struct work_struct *work)
+{
+        struct rtl8126_private *tp =
+                container_of(work, struct rtl8126_private, linkchg_task.work);
+        struct net_device *dev = tp->dev;
+#endif
+        rtnl_lock();
+
+        if (!netif_running(dev) ||
+            test_bit(R8126_FLAG_DOWN, tp->task_flags) ||
+            !test_and_clear_bit(R8126_FLAG_TASK_LINKCHG_CHECK_PENDING, tp->task_flags))
+                goto out_unlock;
+
+        rtl8126_check_link_status(dev);
+
+out_unlock:
+        rtnl_unlock();
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8126_link_task(void *_data)
+{
+        struct net_device *dev = _data;
+        //struct rtl8126_private *tp = netdev_priv(dev);
+#else
+static void rtl8126_link_task(struct work_struct *work)
+{
+        struct rtl8126_private *tp =
+                container_of(work, struct rtl8126_private, link_task.work);
+        struct net_device *dev = tp->dev;
+#endif
+        rtnl_lock();
+
+        if (!netif_running(dev) ||
+            test_bit(R8126_FLAG_DOWN, tp->task_flags) ||
+            !test_and_clear_bit(R8126_FLAG_TASK_LINK_CHECK_PENDING,
+                                tp->task_flags))
+                goto out_unlock;
+
+        if (netif_carrier_ok(dev) != tp->link_ok(dev))
+                rtl8126_schedule_linkchg_work(tp);
+
+        rtl8126_schedule_link_work(tp);
+
+out_unlock:
+        rtnl_unlock();
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+static void
+rtl8126_tx_timeout(struct net_device *dev, unsigned int txqueue)
+#else
+static void
+rtl8126_tx_timeout(struct net_device *dev)
+#endif
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        netdev_err(dev, "Transmit timeout reset Device!\n");
+
+        /* Let's wait a bit while any (async) irq lands on */
+        rtl8126_schedule_reset_work(tp);
+}
+
+static u32
+rtl8126_get_txd_opts1(struct rtl8126_tx_ring *ring,
+                      u32 opts1,
+                      u32 len,
+                      unsigned int entry)
+{
+        u32 status = opts1 | len;
+
+        if (entry == ring->num_tx_desc - 1)
+                status |= RingEnd;
+
+        return status;
+}
+
+static int
+rtl8126_xmit_frags(struct rtl8126_private *tp,
+                   struct rtl8126_tx_ring *ring,
+                   struct sk_buff *skb,
+                   const u32 *opts)
+{
+        struct skb_shared_info *info = skb_shinfo(skb);
+        unsigned int cur_frag, entry;
+        struct TxDesc *txd = NULL;
+        const unsigned char nr_frags = info->nr_frags;
+        unsigned long PktLenCnt = 0;
+        bool LsoPatchEnabled = FALSE;
+
+        entry = ring->cur_tx;
+        for (cur_frag = 0; cur_frag < nr_frags; cur_frag++) {
+                skb_frag_t *frag = info->frags + cur_frag;
+                dma_addr_t mapping;
+                u32 status, len;
+                void *addr;
+
+                entry = (entry + 1) % ring->num_tx_desc;
+
+                txd = ring->TxDescArray + entry;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0)
+                len = frag->size;
+                addr = ((void *) page_address(frag->page)) + frag->page_offset;
+#else
+                len = skb_frag_size(frag);
+                addr = skb_frag_address(frag);
+#endif
+                mapping = dma_map_single(tp_to_dev(tp), addr, len, DMA_TO_DEVICE);
+
+                if (unlikely(dma_mapping_error(tp_to_dev(tp), mapping))) {
+                        if (unlikely(net_ratelimit()))
+                                netif_err(tp, drv, tp->dev,
+                                          "Failed to map TX fragments DMA!\n");
+                        goto err_out;
+                }
+
+                /* anti gcc 2.95.3 bugware (sic) */
+                status = rtl8126_get_txd_opts1(ring, opts[0], len, entry);
+                if (cur_frag == (nr_frags - 1) || LsoPatchEnabled == TRUE)
+                        status |= LastFrag;
+
+                txd->addr = cpu_to_le64(mapping);
+
+                ring->tx_skb[entry].len = len;
+
+                txd->opts2 = cpu_to_le32(opts[1]);
+                wmb();
+                txd->opts1 = cpu_to_le32(status);
+
+                PktLenCnt += len;
+        }
+
+        return cur_frag;
+
+err_out:
+        rtl8126_tx_clear_range(tp, ring, ring->cur_tx + 1, cur_frag);
+        return -EIO;
+}
+
+static inline
+__be16 get_protocol(struct sk_buff *skb)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+        return vlan_get_protocol(skb);
+#else
+        __be16 protocol;
+
+        if (skb->protocol == htons(ETH_P_8021Q))
+                protocol = vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;
+        else
+                protocol = skb->protocol;
+
+        return protocol;
+#endif
+}
+
+static inline
+u8 rtl8126_get_l4_protocol(struct sk_buff *skb)
+{
+        int no = skb_network_offset(skb);
+        struct ipv6hdr *i6h, _i6h;
+        struct iphdr *ih, _ih;
+        u8 ip_protocol = IPPROTO_RAW;
+
+        switch (get_protocol(skb)) {
+        case  __constant_htons(ETH_P_IP):
+                ih = skb_header_pointer(skb, no, sizeof(_ih), &_ih);
+                if (ih)
+                        ip_protocol = ih->protocol;
+                break;
+        case  __constant_htons(ETH_P_IPV6):
+                i6h = skb_header_pointer(skb, no, sizeof(_i6h), &_i6h);
+                if (i6h)
+                        ip_protocol = i6h->nexthdr;
+                break;
+        }
+
+        return ip_protocol;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0)
+static bool rtl8126_skb_pad_with_len(struct sk_buff *skb, unsigned int len)
+{
+        if (skb_padto(skb, len))
+                return false;
+        skb_put(skb, len - skb->len);
+        return true;
+}
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0)
+
+static bool rtl8126_skb_pad(struct sk_buff *skb)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0)
+        return rtl8126_skb_pad_with_len(skb, ETH_ZLEN);
+#else
+        return !eth_skb_pad(skb);
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+/* msdn_giant_send_check()
+ * According to the document of microsoft, the TCP Pseudo Header excludes the
+ * packet length for IPv6 TCP large packets.
+ */
+static int msdn_giant_send_check(struct sk_buff *skb)
+{
+        const struct ipv6hdr *ipv6h;
+        struct tcphdr *th;
+        int ret;
+
+        ret = skb_cow_head(skb, 0);
+        if (ret)
+                return ret;
+
+        ipv6h = ipv6_hdr(skb);
+        th = tcp_hdr(skb);
+
+        th->check = 0;
+        th->check = ~tcp_v6_check(0, &ipv6h->saddr, &ipv6h->daddr, 0);
+
+        return ret;
+}
+#endif
+
+static bool
+rtl8126_tso_csum(struct sk_buff *skb,
+                 struct net_device *dev,
+                 u32 *opts,
+                 unsigned int *bytecount,
+                 unsigned short *gso_segs)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        unsigned long large_send = 0;
+        u32 csum_cmd = 0;
+        u8 sw_calc_csum = false;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        if (dev->features & (NETIF_F_TSO | NETIF_F_TSO6)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+                u32 mss = skb_shinfo(skb)->tso_size;
+#else
+                u32 mss = skb_shinfo(skb)->gso_size;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+
+                /* TCP Segmentation Offload (or TCP Large Send) */
+                if (mss) {
+                        union {
+                                struct iphdr *v4;
+                                struct ipv6hdr *v6;
+                                unsigned char *hdr;
+                        } ip;
+                        union {
+                                struct tcphdr *tcp;
+                                struct udphdr *udp;
+                                unsigned char *hdr;
+                        } l4;
+                        u32 l4_offset, hdr_len;
+
+                        ip.hdr = skb_network_header(skb);
+                        l4.hdr = skb_checksum_start(skb);
+
+                        l4_offset = skb_transport_offset(skb);
+                        assert((l4_offset%2) == 0);
+                        switch (get_protocol(skb)) {
+                        case __constant_htons(ETH_P_IP):
+                                if (l4_offset <= GTTCPHO_MAX) {
+                                        opts[0] |= GiantSendv4;
+                                        opts[0] |= l4_offset << GTTCPHO_SHIFT;
+                                        opts[1] |= min(mss, MSS_MAX) << 18;
+                                        large_send = 1;
+                                }
+                                break;
+                        case __constant_htons(ETH_P_IPV6):
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+                                if (msdn_giant_send_check(skb))
+                                        return false;
+#endif
+                                if (l4_offset <= GTTCPHO_MAX) {
+                                        opts[0] |= GiantSendv6;
+                                        opts[0] |= l4_offset << GTTCPHO_SHIFT;
+                                        opts[1] |= min(mss, MSS_MAX) << 18;
+                                        large_send = 1;
+                                }
+                                break;
+                        default:
+                                if (unlikely(net_ratelimit()))
+                                        dprintk("tso proto=%x!\n", skb->protocol);
+                                break;
+                        }
+
+                        if (large_send == 0)
+                                return false;
+
+
+                        /* compute length of segmentation header */
+                        hdr_len = (l4.tcp->doff * 4) + l4_offset;
+                        /* update gso size and bytecount with header size */
+                        *gso_segs = skb_shinfo(skb)->gso_segs;
+                        *bytecount += (*gso_segs - 1) * hdr_len;
+
+                        return true;
+                }
+        }
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+
+        if (skb->ip_summed == CHECKSUM_PARTIAL) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+                const struct iphdr *ip = skb->nh.iph;
+
+                if (dev->features & NETIF_F_IP_CSUM) {
+                        if (ip->protocol == IPPROTO_TCP)
+                                csum_cmd = tp->tx_ip_csum_cmd | tp->tx_tcp_csum_cmd;
+                        else if (ip->protocol == IPPROTO_UDP)
+                                csum_cmd = tp->tx_ip_csum_cmd | tp->tx_udp_csum_cmd;
+                        else if (ip->protocol == IPPROTO_IP)
+                                csum_cmd = tp->tx_ip_csum_cmd;
+                }
+#else
+                u8 ip_protocol = IPPROTO_RAW;
+
+                switch (get_protocol(skb)) {
+                case  __constant_htons(ETH_P_IP):
+                        if (dev->features & NETIF_F_IP_CSUM) {
+                                ip_protocol = ip_hdr(skb)->protocol;
+                                csum_cmd = tp->tx_ip_csum_cmd;
+                        }
+                        break;
+                case  __constant_htons(ETH_P_IPV6):
+                        if (dev->features & NETIF_F_IPV6_CSUM) {
+                                if (skb_transport_offset(skb) > 0 && skb_transport_offset(skb) <= TCPHO_MAX) {
+                                        ip_protocol = ipv6_hdr(skb)->nexthdr;
+                                        csum_cmd = tp->tx_ipv6_csum_cmd;
+                                        csum_cmd |= skb_transport_offset(skb) << TCPHO_SHIFT;
+                                }
+                        }
+                        break;
+                default:
+                        if (unlikely(net_ratelimit()))
+                                dprintk("checksum_partial proto=%x!\n", skb->protocol);
+                        break;
+                }
+
+                if (ip_protocol == IPPROTO_TCP)
+                        csum_cmd |= tp->tx_tcp_csum_cmd;
+                else if (ip_protocol == IPPROTO_UDP)
+                        csum_cmd |= tp->tx_udp_csum_cmd;
+#endif
+                if (csum_cmd == 0) {
+                        sw_calc_csum = true;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                        WARN_ON(1); /* we need a WARN() */
+#endif
+                }
+        }
+
+        if (skb->len < ETH_ZLEN) {
+                if (tp->UseSwPaddingShortPkt ||
+                    (tp->ShortPacketSwChecksum && csum_cmd != 0)) {
+                        if (!rtl8126_skb_pad(skb))
+                                return false;
+
+                        if (csum_cmd != 0)
+                                sw_calc_csum = true;
+                }
+        }
+
+        if (sw_calc_csum) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,7)
+                skb_checksum_help(&skb, 0);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)
+                skb_checksum_help(skb, 0);
+#else
+                skb_checksum_help(skb);
+#endif
+        } else
+                opts[1] |= csum_cmd;
+
+        return true;
+}
+
+static bool rtl8126_tx_slots_avail(struct rtl8126_private *tp,
+                                   struct rtl8126_tx_ring *ring)
+{
+        unsigned int slots_avail = READ_ONCE(ring->dirty_tx) + ring->num_tx_desc
+                                   - READ_ONCE(ring->cur_tx);
+
+        /* A skbuff with nr_frags needs nr_frags+1 entries in the tx queue */
+        return slots_avail > MAX_SKB_FRAGS;
+}
+
+static inline u32
+rtl8126_fast_mod_mask(const u32 input, const u32 mask)
+{
+        return input > mask ? input & mask : input;
+}
+
+static void rtl8126_doorbell(struct rtl8126_private *tp,
+                             struct rtl8126_tx_ring *ring)
+{
+        if (tp->EnableTxNoClose) {
+                if (tp->HwSuppTxNoCloseVer > 3)
+                        RTL_W32(tp, ring->sw_tail_ptr_reg, ring->cur_tx);
+                else
+                        RTL_W16(tp, ring->sw_tail_ptr_reg, ring->cur_tx);
+        } else
+                RTL_W16(tp, TPPOLL_8125, BIT(ring->index));    /* set polling bit */
+}
+
+static netdev_tx_t
+rtl8126_start_xmit(struct sk_buff *skb,
+                   struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+        unsigned int   bytecount;
+        unsigned short gso_segs;
+        struct ring_info *last;
+        unsigned int last_entry;
+        unsigned int entry;
+        struct TxDesc *txd;
+        dma_addr_t mapping;
+        u32 len;
+        u32 opts[2];
+        netdev_tx_t ret = NETDEV_TX_OK;
+        int frags;
+        u8 EnableTxNoClose = tp->EnableTxNoClose;
+        const u16 queue_mapping = skb_get_queue_mapping(skb);
+        struct rtl8126_tx_ring *ring;
+        bool stop_queue;
+
+        assert(queue_mapping < tp->num_tx_rings);
+
+        ring = &tp->tx_ring[queue_mapping];
+
+        if (unlikely(!rtl8126_tx_slots_avail(tp, ring))) {
+                if (netif_msg_drv(tp)) {
+                        printk(KERN_ERR
+                               "%s: BUG! Tx Ring[%d] full when queue awake!\n",
+                               dev->name,
+                               queue_mapping);
+                }
+                goto err_stop;
+        }
+
+        entry = ring->cur_tx % ring->num_tx_desc;
+        txd = ring->TxDescArray + entry;
+
+        if (!EnableTxNoClose) {
+                if (unlikely(le32_to_cpu(txd->opts1) & DescOwn)) {
+                        if (netif_msg_drv(tp)) {
+                                printk(KERN_ERR
+                                       "%s: BUG! Tx Desc is own by hardware!\n",
+                                       dev->name);
+                        }
+                        goto err_stop;
+                }
+        }
+
+        bytecount = skb->len;
+        gso_segs = 1;
+
+        opts[0] = DescOwn;
+        opts[1] = rtl8126_tx_vlan_tag(tp, skb);
+
+        if (unlikely(!rtl8126_tso_csum(skb, dev, opts, &bytecount, &gso_segs)))
+                goto err_dma_0;
+
+        frags = rtl8126_xmit_frags(tp, ring, skb, opts);
+        if (unlikely(frags < 0))
+                goto err_dma_0;
+        if (frags) {
+                len = skb_headlen(skb);
+                opts[0] |= FirstFrag;
+        } else {
+                len = skb->len;
+                opts[0] |= FirstFrag | LastFrag;
+        }
+
+        opts[0] = rtl8126_get_txd_opts1(ring, opts[0], len, entry);
+        mapping = dma_map_single(tp_to_dev(tp), skb->data, len, DMA_TO_DEVICE);
+        if (unlikely(dma_mapping_error(tp_to_dev(tp), mapping))) {
+                if (unlikely(net_ratelimit()))
+                        netif_err(tp, drv, dev, "Failed to map TX DMA!\n");
+                goto err_dma_1;
+        }
+
+#ifdef ENABLE_PTP_SUPPORT
+        if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {
+                if (!test_and_set_bit_lock(__RTL8126_PTP_TX_IN_PROGRESS, &tp->state)) {
+                        if (tp->hwtstamp_config.tx_type == HWTSTAMP_TX_ON &&
+                            !tp->ptp_tx_skb) {
+                                skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+
+                                tp->ptp_tx_skb = skb_get(skb);
+                                tp->ptp_tx_start = jiffies;
+                                schedule_work(&tp->ptp_tx_work);
+                        } else
+                                tp->tx_hwtstamp_skipped++;
+                }
+        }
+#endif
+        /* set first fragment's length */
+        ring->tx_skb[entry].len = len;
+
+        /* set skb to last fragment */
+        last_entry = (entry + frags) % ring->num_tx_desc;
+        last = &ring->tx_skb[last_entry];
+        last->skb = skb;
+        last->gso_segs = gso_segs;
+        last->bytecount = bytecount;
+
+        txd->addr = cpu_to_le64(mapping);
+        txd->opts2 = cpu_to_le32(opts[1]);
+        wmb();
+        txd->opts1 = cpu_to_le32(opts[0]);
+
+        netdev_tx_sent_queue(txring_txq(ring), bytecount);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+        dev->trans_start = jiffies;
+#else
+        skb_tx_timestamp(skb);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+
+        /* rtl_tx needs to see descriptor changes before updated tp->cur_tx */
+        smp_wmb();
+
+        WRITE_ONCE(ring->cur_tx, ring->cur_tx + frags + 1);
+
+        stop_queue = !rtl8126_tx_slots_avail(tp, ring);
+        if (unlikely(stop_queue)) {
+                /* Avoid wrongly optimistic queue wake-up: rtl_tx thread must
+                 * not miss a ring update when it notices a stopped queue.
+                 */
+                smp_wmb();
+                netif_stop_subqueue(dev, queue_mapping);
+        }
+
+        if (netif_xmit_stopped(txring_txq(ring)) || !netdev_xmit_more())
+                rtl8126_doorbell(tp, ring);
+
+        if (unlikely(stop_queue)) {
+                /* Sync with rtl_tx:
+                 * - publish queue status and cur_tx ring index (write barrier)
+                 * - refresh dirty_tx ring index (read barrier).
+                 * May the current thread have a pessimistic view of the ring
+                 * status and forget to wake up queue, a racing rtl_tx thread
+                 * can't.
+                 */
+                smp_mb();
+                if (rtl8126_tx_slots_avail(tp, ring))
+                        netif_start_subqueue(dev, queue_mapping);
+        }
+out:
+        return ret;
+err_dma_1:
+        rtl8126_tx_clear_range(tp, ring, ring->cur_tx + 1, frags);
+err_dma_0:
+        RTLDEV->stats.tx_dropped++;
+        dev_kfree_skb_any(skb);
+        ret = NETDEV_TX_OK;
+        goto out;
+err_stop:
+        netif_stop_subqueue(dev, queue_mapping);
+        ret = NETDEV_TX_BUSY;
+        RTLDEV->stats.tx_dropped++;
+        goto out;
+}
+
+/* recycle tx no close desc*/
+static int
+rtl8126_tx_interrupt_noclose(struct rtl8126_tx_ring *ring, int budget)
+{
+        unsigned int total_bytes = 0, total_packets = 0;
+        struct rtl8126_private *tp = ring->priv;
+        struct net_device *dev = tp->dev;
+        unsigned int dirty_tx, tx_left;
+        unsigned int tx_desc_closed;
+        unsigned int count = 0;
+
+        dirty_tx = ring->dirty_tx;
+        ring->NextHwDesCloPtr = rtl8126_get_hw_clo_ptr(ring);
+        tx_desc_closed = rtl8126_fast_mod_mask(ring->NextHwDesCloPtr -
+                                               ring->BeginHwDesCloPtr,
+                                               tp->MaxTxDescPtrMask);
+        tx_left = min((READ_ONCE(ring->cur_tx) - dirty_tx), tx_desc_closed);
+        ring->BeginHwDesCloPtr += tx_left;
+
+        while (tx_left > 0) {
+                unsigned int entry = dirty_tx % ring->num_tx_desc;
+                struct ring_info *tx_skb = ring->tx_skb + entry;
+
+                rtl8126_unmap_tx_skb(tp->pci_dev,
+                                     tx_skb,
+                                     ring->TxDescArray + entry);
+
+                if (tx_skb->skb != NULL) {
+                        /* update the statistics for this packet */
+                        total_bytes += tx_skb->bytecount;
+                        total_packets += tx_skb->gso_segs;
+
+                        RTL_NAPI_CONSUME_SKB_ANY(tx_skb->skb, budget);
+                        tx_skb->skb = NULL;
+                }
+                dirty_tx++;
+                tx_left--;
+        }
+
+        if (total_packets) {
+                netdev_tx_completed_queue(txring_txq(ring),
+                                          total_packets, total_bytes);
+
+                RTLDEV->stats.tx_bytes += total_bytes;
+                RTLDEV->stats.tx_packets+= total_packets;
+        }
+
+        if (ring->dirty_tx != dirty_tx) {
+                count = dirty_tx - ring->dirty_tx;
+                WRITE_ONCE(ring->dirty_tx, dirty_tx);
+                smp_wmb();
+                if (__netif_subqueue_stopped(dev, ring->index) &&
+                    rtl8126_tx_slots_avail(tp, ring) && netif_carrier_ok(dev)) {
+                        netif_start_subqueue(dev, ring->index);
+                }
+        }
+
+        return count;
+}
+
+/* recycle tx close desc*/
+static int
+rtl8126_tx_interrupt_close(struct rtl8126_tx_ring *ring, int budget)
+{
+        unsigned int total_bytes = 0, total_packets = 0;
+        struct rtl8126_private *tp = ring->priv;
+        struct net_device *dev = tp->dev;
+        unsigned int dirty_tx, tx_left;
+        unsigned int count = 0;
+
+        dirty_tx = ring->dirty_tx;
+        tx_left = READ_ONCE(ring->cur_tx) - dirty_tx;
+
+        while (tx_left > 0) {
+                unsigned int entry = dirty_tx % ring->num_tx_desc;
+                struct ring_info *tx_skb = ring->tx_skb + entry;
+
+                if (le32_to_cpu(READ_ONCE(ring->TxDescArray[entry].opts1)) & DescOwn)
+                        break;
+
+                rtl8126_unmap_tx_skb(tp->pci_dev,
+                                     tx_skb,
+                                     ring->TxDescArray + entry);
+
+                if (tx_skb->skb != NULL) {
+                        /* update the statistics for this packet */
+                        total_bytes += tx_skb->bytecount;
+                        total_packets += tx_skb->gso_segs;
+
+                        RTL_NAPI_CONSUME_SKB_ANY(tx_skb->skb, budget);
+                        tx_skb->skb = NULL;
+                }
+                dirty_tx++;
+                tx_left--;
+        }
+
+        if (total_packets) {
+                netdev_tx_completed_queue(txring_txq(ring),
+                                          total_packets, total_bytes);
+
+                RTLDEV->stats.tx_bytes += total_bytes;
+                RTLDEV->stats.tx_packets+= total_packets;
+        }
+
+        if (ring->dirty_tx != dirty_tx) {
+                count = dirty_tx - ring->dirty_tx;
+                WRITE_ONCE(ring->dirty_tx, dirty_tx);
+                smp_wmb();
+                if (__netif_subqueue_stopped(dev, ring->index) &&
+                    rtl8126_tx_slots_avail(tp, ring) && netif_carrier_ok(dev)) {
+                        netif_start_subqueue(dev, ring->index);
+                }
+
+                if (READ_ONCE(ring->cur_tx) != dirty_tx)
+                        rtl8126_doorbell(tp, ring);
+        }
+
+        return count;
+}
+
+static int
+rtl8126_tx_interrupt(struct rtl8126_tx_ring *ring, int budget)
+{
+        struct rtl8126_private *tp = ring->priv;
+
+        if (tp->EnableTxNoClose)
+                return rtl8126_tx_interrupt_noclose(ring, budget);
+        else
+                return rtl8126_tx_interrupt_close(ring, budget);
+}
+
+static int
+rtl8126_tx_interrupt_with_vector(struct rtl8126_private *tp,
+                                 const int message_id,
+                                 int budget)
+{
+        int count = 0;
+
+        switch (tp->HwCurrIsrVer) {
+        case 3:
+        case 4:
+                if (message_id < tp->num_tx_rings)
+                        count += rtl8126_tx_interrupt(&tp->tx_ring[message_id], budget);
+                break;
+        case 5:
+                if (message_id == 16)
+                        count += rtl8126_tx_interrupt(&tp->tx_ring[0], budget);
+#ifdef ENABLE_MULTIPLE_TX_QUEUE
+                else if (message_id == 17 && tp->num_tx_rings > 1)
+                        count += rtl8126_tx_interrupt(&tp->tx_ring[1], budget);
+#endif
+                break;
+        default:
+                if (message_id == 16)
+                        count += rtl8126_tx_interrupt(&tp->tx_ring[0], budget);
+#ifdef ENABLE_MULTIPLE_TX_QUEUE
+                else if (message_id == 18 && tp->num_tx_rings > 1)
+                        count += rtl8126_tx_interrupt(&tp->tx_ring[1], budget);
+#endif
+                break;
+        }
+
+        return count;
+}
+
+static inline int
+rtl8126_fragmented_frame(struct rtl8126_private *tp, u32 status)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                return (status & (FirstFrag_V3 | LastFrag_V3)) != (FirstFrag_V3 | LastFrag_V3);
+        case RX_DESC_RING_TYPE_4:
+                return (status & (FirstFrag_V4 | LastFrag_V4)) != (FirstFrag_V4 | LastFrag_V4);
+        default:
+                return (status & (FirstFrag | LastFrag)) != (FirstFrag | LastFrag);
+        }
+}
+
+static inline int
+rtl8126_is_non_eop(struct rtl8126_private *tp, u32 status)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                return !(status & LastFrag_V3);
+        case RX_DESC_RING_TYPE_4:
+                return !(status & LastFrag_V4);
+        default:
+                return !(status & LastFrag);
+        }
+}
+
+static inline int
+rtl8126_rx_desc_type(u32 status)
+{
+        return ((status >> 26) & 0x0F);
+}
+
+static inline void
+rtl8126_rx_v1_csum(struct rtl8126_private *tp,
+                   struct sk_buff *skb,
+                   struct RxDesc *desc)
+{
+        u32 opts1 = le32_to_cpu(desc->opts1);
+
+        if (((opts1 & RxTCPT) && !(opts1 & RxTCPF)) ||
+            ((opts1 & RxUDPT) && !(opts1 & RxUDPF)))
+                skb->ip_summed = CHECKSUM_UNNECESSARY;
+        else
+                skb_checksum_none_assert(skb);
+}
+
+static inline void
+rtl8126_rx_v3_csum(struct rtl8126_private *tp,
+                   struct sk_buff *skb,
+                   struct RxDescV3 *descv3)
+{
+        u32 opts2 = le32_to_cpu(descv3->RxDescNormalDDWord4.opts2);
+
+        /* rx csum offload for RTL8125 */
+        if (((opts2 & RxTCPT_v3) && !(opts2 & RxTCPF_v3)) ||
+            ((opts2 & RxUDPT_v3) && !(opts2 & RxUDPF_v3)))
+                skb->ip_summed = CHECKSUM_UNNECESSARY;
+        else
+                skb_checksum_none_assert(skb);
+}
+
+static inline void
+rtl8126_rx_v4_csum(struct rtl8126_private *tp,
+                   struct sk_buff *skb,
+                   struct RxDescV4 *descv4)
+{
+        u32 opts1 = le32_to_cpu(descv4->RxDescNormalDDWord2.opts1);
+
+        /* rx csum offload for RTL8125 */
+        if (((opts1 & RxTCPT_v4) && !(opts1 & RxTCPF_v4)) ||
+            ((opts1 & RxUDPT_v4) && !(opts1 & RxUDPF_v4)))
+                skb->ip_summed = CHECKSUM_UNNECESSARY;
+        else
+                skb_checksum_none_assert(skb);
+}
+
+static inline void
+rtl8126_rx_csum(struct rtl8126_private *tp,
+                struct sk_buff *skb,
+                struct RxDesc *desc)
+{
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                rtl8126_rx_v3_csum(tp, skb, (struct RxDescV3 *)desc);
+                break;
+        case RX_DESC_RING_TYPE_4:
+                rtl8126_rx_v4_csum(tp, skb, (struct RxDescV4 *)desc);
+                break;
+        default:
+                rtl8126_rx_v1_csum(tp, skb, desc);
+                break;
+        }
+}
+
+/*
+static inline int
+rtl8126_try_rx_copy(struct rtl8126_private *tp,
+                    struct rtl8126_rx_ring *ring,
+                    struct sk_buff **sk_buff,
+                    int pkt_size,
+                    struct RxDesc *desc,
+                    int rx_buf_sz)
+{
+        int ret = -1;
+
+        struct sk_buff *skb;
+
+        skb = RTL_ALLOC_SKB_INTR(&tp->r8126napi[ring->index].napi, pkt_size + R8126_RX_ALIGN);
+        if (skb) {
+                u8 *data;
+
+                data = sk_buff[0]->data;
+                if (!R8126_USE_NAPI_ALLOC_SKB)
+                    skb_reserve(skb, R8126_RX_ALIGN);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
+                prefetch(data - R8126_RX_ALIGN);
+#endif
+                eth_copy_and_sum(skb, data, pkt_size, 0);
+                *sk_buff = skb;
+                rtl8126_mark_to_asic(tp, desc, rx_buf_sz);
+                ret = 0;
+        }
+
+        return ret;
+}
+*/
+
+static inline void
+rtl8126_rx_skb(struct rtl8126_private *tp,
+               struct sk_buff *skb,
+               u32 ring_index)
+{
+#ifdef CONFIG_R8126_NAPI
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+        netif_receive_skb(skb);
+#else
+        napi_gro_receive(&tp->r8126napi[ring_index].napi, skb);
+#endif
+#else
+        netif_rx(skb);
+#endif
+}
+
+static int
+rtl8126_check_rx_desc_error(struct net_device *dev,
+                            struct rtl8126_private *tp,
+                            u32 status)
+{
+        int ret = 0;
+
+        switch (tp->InitRxDescType) {
+        case RX_DESC_RING_TYPE_3:
+                if (unlikely(status & RxRES_V3)) {
+                        if (status & (RxRWT_V3 | RxRUNT_V3))
+                                RTLDEV->stats.rx_length_errors++;
+                        if (status & RxCRC_V3)
+                                RTLDEV->stats.rx_crc_errors++;
+
+                        ret = -1;
+                }
+                break;
+        case RX_DESC_RING_TYPE_4:
+                if (unlikely(status & RxRES_V4)) {
+                        if (status & RxRUNT_V4)
+                                RTLDEV->stats.rx_length_errors++;
+                        if (status & RxCRC_V4)
+                                RTLDEV->stats.rx_crc_errors++;
+
+                        ret = -1;
+                }
+                break;
+        default:
+                if (unlikely(status & RxRES)) {
+                        if (status & (RxRWT | RxRUNT))
+                                RTLDEV->stats.rx_length_errors++;
+                        if (status & RxCRC)
+                                RTLDEV->stats.rx_crc_errors++;
+
+                        ret = -1;
+                }
+                break;
+        }
+
+        return ret;
+}
+
+#ifdef ENABLE_PAGE_REUSE
+
+static inline bool
+rtl8126_reuse_rx_ok(struct page *page)
+{
+        /* avoid re-using remote pages */
+        if (!dev_page_is_reusable(page)) {
+                //printk(KERN_INFO "r8126 page pfmemalloc, can't reuse!\n");
+                return false;
+        }
+        /* if we are only owner of page we can reuse it */
+        if (unlikely(page_ref_count(page) != 1)) {
+                //printk(KERN_INFO "r8126 page refcnt %d, can't reuse!\n", page_ref_count(page));
+                return false;
+        }
+
+        return true;
+}
+
+static void
+rtl8126_reuse_rx_buffer(struct rtl8126_private *tp, struct rtl8126_rx_ring *ring, u32 cur_rx, struct rtl8126_rx_buffer *rxb)
+{
+        struct page *page = rxb->page;
+
+        u32 dirty_rx = ring->dirty_rx;
+        u32 entry = dirty_rx % ring->num_rx_desc;
+        struct rtl8126_rx_buffer *nrxb = &ring->rx_buffer[entry];
+
+        u32 noffset;
+
+        //the page gonna be shared by us and kernel, keep page ref = 2
+        page_ref_inc(page);
+
+        //flip the buffer in page to use next
+        noffset = rxb->page_offset ^ (tp->rx_buf_page_size / 2); //one page, two buffer, ping-pong
+
+        nrxb->dma = rxb->dma;
+        nrxb->page_offset = noffset;
+        nrxb->data = rxb->data;
+
+        if (cur_rx != dirty_rx) {
+                //move the buffer to other slot
+                nrxb->page = page;
+                rxb->page = NULL;
+        }
+}
+
+static void rtl8126_put_rx_buffer(struct rtl8126_private *tp,
+                                  struct rtl8126_rx_ring *ring,
+                                  u32 cur_rx,
+                                  struct rtl8126_rx_buffer *rxb)
+{
+        struct rtl8126_rx_buffer *nrxb;
+        struct page *page = rxb->page;
+        u32 entry;
+
+        entry = ring->dirty_rx % ring->num_rx_desc;
+        nrxb = &ring->rx_buffer[entry];
+        if (likely(rtl8126_reuse_rx_ok(page))) {
+                /* hand second half of page back to the ring */
+                rtl8126_reuse_rx_buffer(tp, ring, cur_rx, rxb);
+        } else {
+                tp->page_reuse_fail_cnt++;
+
+                dma_unmap_page_attrs(&tp->pci_dev->dev, rxb->dma,
+                                     tp->rx_buf_page_size,
+                                     DMA_FROM_DEVICE,
+                                     (DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING));
+                //the page ref is kept 1, uniquely owned by kernel now
+                rxb->page = NULL;
+
+                return;
+        }
+
+        dma_sync_single_range_for_device(tp_to_dev(tp),
+                                         nrxb->dma,
+                                         nrxb->page_offset,
+                                         tp->rx_buf_sz,
+                                         DMA_FROM_DEVICE);
+
+        rtl8126_map_to_asic(tp, ring,
+                            rtl8126_get_rxdesc(tp, ring->RxDescArray, entry),
+                            nrxb->dma + nrxb->page_offset,
+                            tp->rx_buf_sz, entry);
+
+        ring->dirty_rx++;
+}
+
+#endif //ENABLE_PAGE_REUSE
+
+static int
+rtl8126_rx_interrupt(struct net_device *dev,
+                     struct rtl8126_private *tp,
+                     struct rtl8126_rx_ring *ring,
+                     napi_budget budget)
+{
+        unsigned int cur_rx, rx_left;
+        unsigned int delta, count = 0;
+        unsigned int entry;
+        struct RxDesc *desc;
+        struct sk_buff *skb;
+        u32 status;
+        u32 rx_quota;
+        u32 ring_index = ring->index;
+#ifdef ENABLE_PAGE_REUSE
+        struct rtl8126_rx_buffer *rxb;
+#else //ENABLE_PAGE_REUSE
+        u64 rx_buf_phy_addr;
+#endif //ENABLE_PAGE_REUSE
+        unsigned int total_rx_multicast_packets = 0;
+        unsigned int total_rx_bytes = 0, total_rx_packets = 0;
+
+        assert(dev != NULL);
+        assert(tp != NULL);
+
+        if (ring->RxDescArray == NULL)
+                goto rx_out;
+
+        rx_quota = RTL_RX_QUOTA(budget);
+        cur_rx = ring->cur_rx;
+        rx_left = ring->num_rx_desc + ring->dirty_rx - cur_rx;
+        rx_left = rtl8126_rx_quota(rx_left, (u32)rx_quota);
+
+        for (; rx_left > 0; rx_left--, cur_rx++) {
+#ifndef ENABLE_PAGE_REUSE
+                const void *rx_buf;
+#endif //!ENABLE_PAGE_REUSE
+                u32 pkt_size;
+
+                entry = cur_rx % ring->num_rx_desc;
+                desc = rtl8126_get_rxdesc(tp, ring->RxDescArray, entry);
+                status = le32_to_cpu(rtl8126_rx_desc_opts1(tp, desc));
+                if (status & DescOwn) {
+                        RTL_R8(tp, tp->imr_reg[0]);
+                        status = le32_to_cpu(rtl8126_rx_desc_opts1(tp, desc));
+                        if (status & DescOwn)
+                                break;
+                }
+
+                rmb();
+
+                if (unlikely(rtl8126_check_rx_desc_error(dev, tp, status) < 0)) {
+                        if (netif_msg_rx_err(tp)) {
+                                printk(KERN_INFO
+                                       "%s: Rx ERROR. status = %08x\n",
+                                       dev->name, status);
+                        }
+
+                        RTLDEV->stats.rx_errors++;
+
+                        if (!(dev->features & NETIF_F_RXALL))
+                                goto release_descriptor;
+                }
+                pkt_size = status & 0x00003fff;
+                if (likely(!(dev->features & NETIF_F_RXFCS))) {
+#ifdef ENABLE_RX_PACKET_FRAGMENT
+                        if (rtl8126_is_non_eop(tp, status) &&
+                            pkt_size == tp->rx_buf_sz) {
+                                struct RxDesc *desc_next;
+                                unsigned int entry_next;
+                                int pkt_size_next;
+                                u32 status_next;
+
+                                entry_next = (cur_rx + 1) % ring->num_rx_desc;
+                                desc_next = rtl8126_get_rxdesc(tp, ring->RxDescArray, entry_next);
+                                status_next = le32_to_cpu(rtl8126_rx_desc_opts1(tp, desc_next));
+                                if (!(status_next & DescOwn)) {
+                                        pkt_size_next = status_next & 0x00003fff;
+                                        if (pkt_size_next < ETH_FCS_LEN)
+                                                pkt_size -= (ETH_FCS_LEN - pkt_size_next);
+                                }
+                        }
+#endif //ENABLE_RX_PACKET_FRAGMENT
+                        if (!rtl8126_is_non_eop(tp, status)) {
+                                if (pkt_size < ETH_FCS_LEN) {
+#ifdef ENABLE_RX_PACKET_FRAGMENT
+                                        pkt_size = 0;
+#else
+                                        goto drop_packet;
+#endif //ENABLE_RX_PACKET_FRAGMENT
+                                } else
+                                        pkt_size -= ETH_FCS_LEN;
+                        }
+                }
+
+                if (unlikely(pkt_size > tp->rx_buf_sz))
+                        goto drop_packet;
+
+#if !defined(ENABLE_RX_PACKET_FRAGMENT) || !defined(ENABLE_PAGE_REUSE)
+                /*
+                 * The driver does not support incoming fragmented
+                 * frames. They are seen as a symptom of over-mtu
+                 * sized frames.
+                 */
+                if (unlikely(rtl8126_fragmented_frame(tp, status)))
+                        goto drop_packet;
+#endif //!ENABLE_RX_PACKET_FRAGMENT || !ENABLE_PAGE_REUSE
+
+#ifdef ENABLE_PAGE_REUSE
+                rxb = &ring->rx_buffer[entry];
+                skb = rxb->skb;
+                rxb->skb = NULL;
+                if (!skb) {
+                        skb = RTL_BUILD_SKB_INTR(rxb->data + rxb->page_offset - ring->rx_offset, tp->rx_buf_page_size / 2);
+                        if (!skb) {
+                                //netdev_err(tp->dev, "Failed to allocate RX skb!\n");
+                                goto drop_packet;
+                        }
+
+                        skb->dev = dev;
+                        if (!R8126_USE_NAPI_ALLOC_SKB)
+                                skb_reserve(skb, R8126_RX_ALIGN);
+                        skb_put(skb, pkt_size);
+#ifdef ENABLE_RSS_SUPPORT
+                        rtl8126_rx_hash(tp, desc, skb);
+#endif
+                        rtl8126_rx_csum(tp, skb, desc);
+                } else
+                        skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, rxb->page,
+                                        rxb->page_offset, pkt_size, tp->rx_buf_page_size / 2);
+                //recycle desc
+                rtl8126_put_rx_buffer(tp, ring, cur_rx, rxb);
+
+                dma_sync_single_range_for_cpu(tp_to_dev(tp),
+                                              rxb->dma,
+                                              rxb->page_offset,
+                                              tp->rx_buf_sz,
+                                              DMA_FROM_DEVICE);
+#else //ENABLE_PAGE_REUSE
+                skb = RTL_ALLOC_SKB_INTR(&tp->r8126napi[ring->index].napi, pkt_size + R8126_RX_ALIGN);
+                if (!skb) {
+                        //netdev_err(tp->dev, "Failed to allocate RX skb!\n");
+                        goto drop_packet;
+                }
+
+                skb->dev = dev;
+                if (!R8126_USE_NAPI_ALLOC_SKB)
+                        skb_reserve(skb, R8126_RX_ALIGN);
+                skb_put(skb, pkt_size);
+
+                rx_buf_phy_addr = ring->RxDescPhyAddr[entry];
+                dma_sync_single_for_cpu(tp_to_dev(tp),
+                                        rx_buf_phy_addr, tp->rx_buf_sz,
+                                        DMA_FROM_DEVICE);
+                rx_buf = ring->Rx_skbuff[entry]->data;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
+                prefetch(rx_buf - R8126_RX_ALIGN);
+#endif
+                eth_copy_and_sum(skb, rx_buf, pkt_size, 0);
+
+                dma_sync_single_for_device(tp_to_dev(tp), rx_buf_phy_addr,
+                                           tp->rx_buf_sz, DMA_FROM_DEVICE);
+#endif //ENABLE_PAGE_REUSE
+
+#ifdef ENABLE_PTP_SUPPORT
+                if (tp->flags & RTL_FLAG_RX_HWTSTAMP_ENABLED)
+                        rtl8126_rx_ptp_timestamp(tp, skb);
+#endif // ENABLE_PTP_SUPPORT
+
+#ifdef ENABLE_RX_PACKET_FRAGMENT
+                if (rtl8126_is_non_eop(tp, status)) {
+                        unsigned int entry_next;
+                        entry_next = (entry + 1) % ring->num_rx_desc;
+                        rxb = &ring->rx_buffer[entry_next];
+                        rxb->skb = skb;
+                        continue;
+                }
+#endif //ENABLE_RX_PACKET_FRAGMENT
+
+#ifndef ENABLE_PAGE_REUSE
+#ifdef ENABLE_RSS_SUPPORT
+                rtl8126_rx_hash(tp, desc, skb);
+#endif
+                rtl8126_rx_csum(tp, skb, desc);
+#endif /* !ENABLE_PAGE_REUSE */
+
+                skb->protocol = eth_type_trans(skb, dev);
+
+                total_rx_bytes += skb->len;
+
+                if (skb->pkt_type == PACKET_MULTICAST)
+                        total_rx_multicast_packets++;
+
+                if (rtl8126_rx_vlan_skb(tp, desc, skb) < 0)
+                        rtl8126_rx_skb(tp, skb, ring_index);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0)
+                dev->last_rx = jiffies;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0)
+                total_rx_packets++;
+
+#ifdef ENABLE_PAGE_REUSE
+                rxb->skb = NULL;
+                continue;
+#endif
+
+release_descriptor:
+                switch (tp->InitRxDescType) {
+                case RX_DESC_RING_TYPE_3:
+                case RX_DESC_RING_TYPE_4:
+                        rtl8126_set_desc_dma_addr(tp, desc,
+                                                  ring->RxDescPhyAddr[entry]);
+                        wmb();
+                        break;
+                }
+                rtl8126_mark_to_asic(tp, desc, tp->rx_buf_sz);
+                continue;
+drop_packet:
+                RTLDEV->stats.rx_dropped++;
+                RTLDEV->stats.rx_length_errors++;
+                goto release_descriptor;
+        }
+
+        count = cur_rx - ring->cur_rx;
+        ring->cur_rx = cur_rx;
+
+        delta = rtl8126_rx_fill(tp, ring, dev, ring->dirty_rx, ring->cur_rx, 1);
+        if (!delta && count && netif_msg_intr(tp))
+                printk(KERN_INFO "%s: no Rx buffer allocated\n", dev->name);
+        ring->dirty_rx += delta;
+
+        RTLDEV->stats.rx_bytes += total_rx_bytes;
+        RTLDEV->stats.rx_packets += total_rx_packets;
+        RTLDEV->stats.multicast += total_rx_multicast_packets;
+
+        /*
+         * FIXME: until there is periodic timer to try and refill the ring,
+         * a temporary shortage may definitely kill the Rx process.
+         * - disable the asic to try and avoid an overflow and kick it again
+         *   after refill ?
+         * - how do others driver handle this condition (Uh oh...).
+         */
+        if ((ring->dirty_rx + ring->num_rx_desc == ring->cur_rx) && netif_msg_intr(tp))
+                printk(KERN_EMERG "%s: Rx buffers exhausted\n", dev->name);
+
+rx_out:
+        return total_rx_packets;
+}
+
+static bool
+rtl8126_linkchg_interrupt(struct rtl8126_private *tp, u32 status)
+{
+        switch (tp->HwCurrIsrVer) {
+        case 2:
+        case 3:
+                return status & ISRIMR_V2_LINKCHG;
+        case 4:
+                return status & ISRIMR_V4_LINKCHG;
+        case 5:
+                return status & ISRIMR_V5_LINKCHG;
+        default:
+                return status & LinkChg;
+        }
+}
+
+static u32
+rtl8126_get_linkchg_message_id(struct rtl8126_private *tp)
+{
+        switch (tp->HwCurrIsrVer) {
+        case 4:
+                return 29;
+        case 5:
+                return 18;
+        default:
+                return 21;
+        }
+}
+
+/*
+ *The interrupt handler does all of the Rx thread work and cleans up after
+ *the Tx thread.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t rtl8126_interrupt(int irq, void *dev_instance, struct pt_regs *regs)
+#else
+static irqreturn_t rtl8126_interrupt(int irq, void *dev_instance)
+#endif
+{
+        struct r8126_napi *r8126napi = dev_instance;
+        struct rtl8126_private *tp = r8126napi->priv;
+        struct net_device *dev = tp->dev;
+        u32 status;
+        int handled = 0;
+
+        do {
+                status = RTL_R32(tp, tp->isr_reg[0]);
+
+                if (!(tp->features & (RTL_FEATURE_MSI | RTL_FEATURE_MSIX))) {
+                        /* hotplug/major error/no more work/shared irq */
+                        if (!status)
+                                break;
+
+                        if (status == 0xFFFFFFFF)
+                                break;
+
+                        if (!(status & (tp->intr_mask | tp->timer_intr_mask)))
+                                break;
+                }
+
+                handled = 1;
+
+#if defined(RTL_USE_NEW_INTR_API)
+                if (!tp->irq_tbl[0].requested)
+                        break;
+#endif
+                rtl8126_disable_hw_interrupt(tp);
+
+                RTL_W32(tp, tp->isr_reg[0], status&~RxFIFOOver);
+
+                if (rtl8126_linkchg_interrupt(tp, status))
+                        rtl8126_schedule_linkchg_work(tp);
+#ifdef CONFIG_R8126_NAPI
+                if (status & tp->intr_mask || tp->keep_intr_cnt-- > 0) {
+                        if (status & tp->intr_mask)
+                                tp->keep_intr_cnt = RTK_KEEP_INTERRUPT_COUNT;
+
+                        if (likely(RTL_NETIF_RX_SCHEDULE_PREP(dev, &tp->r8126napi[0].napi)))
+                                __RTL_NETIF_RX_SCHEDULE(dev, &tp->r8126napi[0].napi);
+                        else if (netif_msg_intr(tp))
+                                printk(KERN_INFO "%s: interrupt %04x in poll\n",
+                                       dev->name, status);
+                } else {
+                        tp->keep_intr_cnt = RTK_KEEP_INTERRUPT_COUNT;
+                        rtl8126_switch_to_hw_interrupt(tp);
+                }
+#else
+                if (status & tp->intr_mask || tp->keep_intr_cnt-- > 0) {
+                        u32 budget = ~(u32)0;
+                        int i;
+
+                        if (status & tp->intr_mask)
+                                tp->keep_intr_cnt = RTK_KEEP_INTERRUPT_COUNT;
+
+                        for (i = 0; i < tp->num_tx_rings; i++)
+                                rtl8126_tx_interrupt(&tp->tx_ring[i], ~(u32)0);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+                        rtl8126_rx_interrupt(dev, tp, &tp->rx_ring[0], &budget);
+#else
+                        rtl8126_rx_interrupt(dev, tp, &tp->rx_ring[0], budget);
+#endif	//LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+
+                        rtl8126_switch_to_timer_interrupt(tp);
+                } else {
+                        tp->keep_intr_cnt = RTK_KEEP_INTERRUPT_COUNT;
+                        rtl8126_switch_to_hw_interrupt(tp);
+                }
+#endif
+        } while (false);
+
+        return IRQ_RETVAL(handled);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t rtl8126_interrupt_msix(int irq, void *dev_instance, struct pt_regs *regs)
+#else
+static irqreturn_t rtl8126_interrupt_msix(int irq, void *dev_instance)
+#endif
+{
+        struct r8126_napi *r8126napi = dev_instance;
+        struct rtl8126_private *tp = r8126napi->priv;
+        struct net_device *dev = tp->dev;
+        int message_id = r8126napi->index;
+#ifndef CONFIG_R8126_NAPI
+        u32 budget = ~(u32)0;
+#endif
+
+        do {
+#if defined(RTL_USE_NEW_INTR_API)
+                if (!tp->irq_tbl[message_id].requested)
+                        break;
+#endif
+                //link change
+                if (message_id == rtl8126_get_linkchg_message_id(tp)) {
+                        rtl8126_disable_hw_interrupt_v2(tp, message_id);
+                        rtl8126_clear_hw_isr_v2(tp, message_id);
+                        rtl8126_schedule_linkchg_work(tp);
+                        break;
+                }
+
+#ifdef CONFIG_R8126_NAPI
+                if (likely(RTL_NETIF_RX_SCHEDULE_PREP(dev, &r8126napi->napi))) {
+                        rtl8126_disable_hw_interrupt_v2(tp, message_id);
+                        __RTL_NETIF_RX_SCHEDULE(dev, &r8126napi->napi);
+                } else if (netif_msg_intr(tp))
+                        printk(KERN_INFO "%s: interrupt message id %d in poll_msix\n",
+                               dev->name, message_id);
+                rtl8126_clear_hw_isr_v2(tp, message_id);
+#else
+                rtl8126_disable_hw_interrupt_v2(tp, message_id);
+
+                rtl8126_clear_hw_isr_v2(tp, message_id);
+
+                rtl8126_tx_interrupt_with_vector(tp, message_id, ~(u32)0);
+
+                if (message_id < tp->num_rx_rings) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+                        rtl8126_rx_interrupt(dev, tp, &tp->rx_ring[message_id], &budget);
+#else
+                        rtl8126_rx_interrupt(dev, tp, &tp->rx_ring[message_id], budget);
+#endif	//LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+                }
+
+                rtl8126_enable_hw_interrupt_v2(tp, message_id);
+#endif
+
+        } while (false);
+
+        return IRQ_HANDLED;
+}
+
+static void rtl8126_down(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        //rtl8126_delete_esd_timer(dev, &tp->esd_timer);
+
+        //rtl8126_delete_link_timer(dev, &tp->link_timer);
+
+        netif_carrier_off(dev);
+
+        netif_tx_disable(dev);
+
+        _rtl8126_wait_for_quiescence(dev);
+
+        rtl8126_hw_reset(dev);
+
+        rtl8126_tx_clear(tp);
+
+        rtl8126_rx_clear(tp);
+}
+
+static int rtl8126_resource_freed(struct rtl8126_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++)
+                if (tp->tx_ring[i].TxDescArray)
+                        return 0;
+
+        for (i = 0; i < tp->num_rx_rings; i++)
+                if (tp->rx_ring[i].RxDescArray)
+                        return 0;
+
+        return 1;
+}
+
+int rtl8126_close(struct net_device *dev)
+{
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        if (!rtl8126_resource_freed(tp)) {
+                set_bit(R8126_FLAG_DOWN, tp->task_flags);
+
+                rtl8126_down(dev);
+
+                pci_clear_master(tp->pci_dev);
+
+#ifdef ENABLE_PTP_SUPPORT
+                rtl8126_ptp_stop(tp);
+#endif
+                rtl8126_hw_d3_para(dev);
+
+                rtl8126_powerdown_pll(dev, 0);
+
+                rtl8126_free_irq(tp);
+
+                rtl8126_free_alloc_resources(tp);
+        } else {
+                rtl8126_hw_d3_para(dev);
+
+                rtl8126_powerdown_pll(dev, 0);
+        }
+
+        return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,11)
+static void rtl8126_shutdown(struct pci_dev *pdev)
+{
+        struct net_device *dev = pci_get_drvdata(pdev);
+        struct rtl8126_private *tp = netdev_priv(dev);
+
+        rtnl_lock();
+
+        rtl8126_disable_pci_offset_180(tp);
+
+        if (s5_keep_curr_mac == 0 && tp->random_mac == 0)
+                rtl8126_rar_set(tp, tp->org_mac_addr);
+
+        if (s5wol == 0)
+                tp->wol_enabled = WOL_DISABLED;
+
+        rtl8126_close(dev);
+        rtl8126_disable_msi(pdev, tp);
+
+        rtnl_unlock();
+
+        if (system_state == SYSTEM_POWER_OFF) {
+                pci_clear_master(tp->pci_dev);
+                pci_wake_from_d3(pdev, tp->wol_enabled);
+                pci_set_power_state(pdev, PCI_D3hot);
+        }
+}
+#endif
+
+#ifdef CONFIG_PM
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+static int
+rtl8126_suspend(struct pci_dev *pdev, u32 state)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+static int
+rtl8126_suspend(struct device *device)
+#else
+static int
+rtl8126_suspend(struct pci_dev *pdev, pm_message_t state)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+        struct pci_dev *pdev = to_pci_dev(device);
+        struct net_device *dev = pci_get_drvdata(pdev);
+#else
+        struct net_device *dev = pci_get_drvdata(pdev);
+#endif
+        struct rtl8126_private *tp = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+        u32 pci_pm_state = pci_choose_state(pdev, state);
+#endif
+        rtnl_lock();
+
+        if (!netif_running(dev))
+                goto out;
+
+        set_bit(R8126_FLAG_DOWN, tp->task_flags);
+
+        netif_carrier_off(dev);
+
+        netif_tx_disable(dev);
+
+        netif_device_detach(dev);
+
+#ifdef ENABLE_PTP_SUPPORT
+        rtl8126_ptp_suspend(tp);
+#endif
+        rtl8126_hw_reset(dev);
+
+        pci_clear_master(pdev);
+
+        rtl8126_hw_d3_para(dev);
+
+        rtl8126_powerdown_pll(dev, 1);
+
+out:
+        rtnl_unlock();
+
+        pci_disable_device(pdev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+        pci_save_state(pdev, &pci_pm_state);
+#else
+        pci_save_state(pdev);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+        pci_enable_wake(pdev, pci_choose_state(pdev, state), tp->wol_enabled);
+#endif
+
+        pci_prepare_to_sleep(pdev);
+
+        return 0;
+}
+
+static int
+rtl8126_hw_d3_not_power_off(struct net_device *dev)
+{
+        return rtl8126_check_hw_phy_mcu_code_ver(dev);
+}
+
+static int rtl8126_wait_phy_nway_complete_sleep(struct rtl8126_private *tp)
+{
+        int i, val;
+
+        for (i = 0; i < 30; i++) {
+                val = rtl8126_mdio_read(tp, MII_BMSR) & BMSR_ANEGCOMPLETE;
+                if (val)
+                        return 0;
+
+                mdelay(100);
+        }
+
+        return -1;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+static int
+rtl8126_resume(struct pci_dev *pdev)
+#else
+static int
+rtl8126_resume(struct device *device)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+        struct pci_dev *pdev = to_pci_dev(device);
+        struct net_device *dev = pci_get_drvdata(pdev);
+#else
+        struct net_device *dev = pci_get_drvdata(pdev);
+#endif
+        struct rtl8126_private *tp = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+        u32 pci_pm_state = PCI_D0;
+#endif
+        unsigned long flags;
+        u32 err;
+
+        rtnl_lock();
+
+        err = pci_enable_device(pdev);
+        if (err) {
+                dev_err(&pdev->dev, "Cannot enable PCI device from suspend\n");
+                goto out_unlock;
+        }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+        pci_restore_state(pdev, &pci_pm_state);
+#else
+        pci_restore_state(pdev);
+#endif
+        pci_enable_wake(pdev, PCI_D0, 0);
+
+        /* restore last modified mac address */
+        rtl8126_rar_set(tp, dev->dev_addr);
+
+        r8126_spin_lock(&tp->phy_lock, flags);
+
+        tp->resume_not_chg_speed = 0;
+        if (tp->check_keep_link_speed &&
+            //tp->link_ok(dev) &&
+            rtl8126_hw_d3_not_power_off(dev) &&
+            rtl8126_wait_phy_nway_complete_sleep(tp) == 0)
+                tp->resume_not_chg_speed = 1;
+
+        r8126_spin_unlock(&tp->phy_lock, flags);
+
+        if (!netif_running(dev))
+                goto out_unlock;
+
+        pci_set_master(pdev);
+
+        rtl8126_exit_oob(dev);
+
+        rtl8126_up(dev);
+
+        clear_bit(R8126_FLAG_DOWN, tp->task_flags);
+
+        rtl8126_schedule_reset_work(tp);
+
+        rtl8126_schedule_esd_work(tp);
+
+#ifdef ENABLE_FIBER_SUPPORT
+        if (HW_FIBER_MODE_ENABLED(tp))
+                rtl8126_schedule_link_work(tp);
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        //mod_timer(&tp->esd_timer, jiffies + RTL8126_ESD_TIMEOUT);
+        //mod_timer(&tp->link_timer, jiffies + RTL8126_LINK_TIMEOUT);
+out_unlock:
+        netif_device_attach(dev);
+
+        rtnl_unlock();
+
+        return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+
+static struct dev_pm_ops rtl8126_pm_ops = {
+        .suspend = rtl8126_suspend,
+        .resume = rtl8126_resume,
+        .freeze = rtl8126_suspend,
+        .thaw = rtl8126_resume,
+        .poweroff = rtl8126_suspend,
+        .restore = rtl8126_resume,
+};
+
+#define RTL8126_PM_OPS	(&rtl8126_pm_ops)
+
+#endif
+
+#else /* !CONFIG_PM */
+
+#define RTL8126_PM_OPS	NULL
+
+#endif /* CONFIG_PM */
+
+static struct pci_driver rtl8126_pci_driver = {
+        .name       = MODULENAME,
+        .id_table   = rtl8126_pci_tbl,
+        .probe      = rtl8126_init_one,
+        .remove     = __devexit_p(rtl8126_remove_one),
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,11)
+        .shutdown   = rtl8126_shutdown,
+#endif
+#ifdef CONFIG_PM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+        .suspend    = rtl8126_suspend,
+        .resume     = rtl8126_resume,
+#else
+        .driver.pm	= RTL8126_PM_OPS,
+#endif
+#endif
+};
+
+static int __init
+rtl8126_init_module(void)
+{
+        int ret = 0;
+#ifdef ENABLE_R8126_PROCFS
+        rtl8126_proc_module_init();
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+
+        ret = pci_register_driver(&rtl8126_pci_driver);
+#else
+        ret = pci_module_init(&rtl8126_pci_driver);
+#endif
+
+        return ret;
+}
+
+static void __exit
+rtl8126_cleanup_module(void)
+{
+        pci_unregister_driver(&rtl8126_pci_driver);
+
+#ifdef ENABLE_R8126_PROCFS
+        if (rtl8126_proc) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+                remove_proc_subtree(MODULENAME, init_net.proc_net);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+                remove_proc_entry(MODULENAME, init_net.proc_net);
+#else
+                remove_proc_entry(MODULENAME, proc_net);
+#endif  //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#endif  //LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+                rtl8126_proc = NULL;
+        }
+#endif
+}
+
+module_init(rtl8126_init_module);
+module_exit(rtl8126_cleanup_module);
Index: drivers/net/ethernet/r8126-10.016.00/rtltool.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8126-10.016.00/rtltool.c b/drivers/net/ethernet/r8126-10.016.00/rtltool.c
new file mode 100755
--- /dev/null	(date 1763109333415)
+++ b/drivers/net/ethernet/r8126-10.016.00/rtltool.c	(date 1763109333415)
@@ -0,0 +1,293 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8126 is the Linux device driver released for Realtek 5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/in.h>
+#include <linux/ethtool.h>
+#include <asm/uaccess.h>
+#include "r8126.h"
+#include "rtl_eeprom.h"
+#include "rtltool.h"
+
+int rtl8126_tool_ioctl(struct rtl8126_private *tp, struct ifreq *ifr)
+{
+        struct rtltool_cmd my_cmd;
+        unsigned long flags;
+        int ret;
+
+        if (copy_from_user(&my_cmd, ifr->ifr_data, sizeof(my_cmd)))
+                return -EFAULT;
+
+        ret = 0;
+        switch (my_cmd.cmd) {
+        case RTLTOOL_READ_MAC:
+                if ((my_cmd.offset + my_cmd.len) > pci_resource_len(tp->pci_dev, 2)) {
+                        ret = -EINVAL;
+                        break;
+                }
+
+                if (my_cmd.len==1)
+                        my_cmd.data = readb(tp->mmio_addr+my_cmd.offset);
+                else if (my_cmd.len==2)
+                        my_cmd.data = readw(tp->mmio_addr+(my_cmd.offset&~1));
+                else if (my_cmd.len==4)
+                        my_cmd.data = readl(tp->mmio_addr+(my_cmd.offset&~3));
+                else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+                break;
+
+        case RTLTOOL_WRITE_MAC:
+                if ((my_cmd.offset + my_cmd.len) > pci_resource_len(tp->pci_dev, 2)) {
+                        ret = -EINVAL;
+                        break;
+                }
+
+                if (my_cmd.len==1)
+                        writeb(my_cmd.data, tp->mmio_addr+my_cmd.offset);
+                else if (my_cmd.len==2)
+                        writew(my_cmd.data, tp->mmio_addr+(my_cmd.offset&~1));
+                else if (my_cmd.len==4)
+                        writel(my_cmd.data, tp->mmio_addr+(my_cmd.offset&~3));
+                else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_READ_PHY:
+                r8126_spin_lock(&tp->phy_lock, flags);
+                my_cmd.data = rtl8126_mdio_prot_read(tp, my_cmd.offset);
+                r8126_spin_unlock(&tp->phy_lock, flags);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_WRITE_PHY:
+                r8126_spin_lock(&tp->phy_lock, flags);
+                rtl8126_mdio_prot_write(tp, my_cmd.offset, my_cmd.data);
+                r8126_spin_unlock(&tp->phy_lock, flags);
+                break;
+
+        case RTLTOOL_READ_EPHY:
+                my_cmd.data = rtl8126_ephy_read(tp, my_cmd.offset);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_WRITE_EPHY:
+                rtl8126_ephy_write(tp, my_cmd.offset, my_cmd.data);
+                break;
+
+        case RTLTOOL_READ_ERI:
+                my_cmd.data = 0;
+                if (my_cmd.len==1 || my_cmd.len==2 || my_cmd.len==4) {
+                        my_cmd.data = rtl8126_eri_read(tp, my_cmd.offset, my_cmd.len, ERIAR_ExGMAC);
+                } else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_WRITE_ERI:
+                if (my_cmd.len==1 || my_cmd.len==2 || my_cmd.len==4) {
+                        rtl8126_eri_write(tp, my_cmd.offset, my_cmd.len, my_cmd.data, ERIAR_ExGMAC);
+                } else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+                break;
+
+        case RTLTOOL_READ_PCI:
+                my_cmd.data = 0;
+                if (my_cmd.len==1)
+                        pci_read_config_byte(tp->pci_dev, my_cmd.offset,
+                                             (u8 *)&my_cmd.data);
+                else if (my_cmd.len==2)
+                        pci_read_config_word(tp->pci_dev, my_cmd.offset,
+                                             (u16 *)&my_cmd.data);
+                else if (my_cmd.len==4)
+                        pci_read_config_dword(tp->pci_dev, my_cmd.offset,
+                                              &my_cmd.data);
+                else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+                break;
+
+        case RTLTOOL_WRITE_PCI:
+                if (my_cmd.len==1)
+                        pci_write_config_byte(tp->pci_dev, my_cmd.offset,
+                                              my_cmd.data);
+                else if (my_cmd.len==2)
+                        pci_write_config_word(tp->pci_dev, my_cmd.offset,
+                                              my_cmd.data);
+                else if (my_cmd.len==4)
+                        pci_write_config_dword(tp->pci_dev, my_cmd.offset,
+                                               my_cmd.data);
+                else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_READ_EEPROM:
+                my_cmd.data = rtl8126_eeprom_read_sc(tp, my_cmd.offset);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_WRITE_EEPROM:
+                rtl8126_eeprom_write_sc(tp, my_cmd.offset, my_cmd.data);
+                break;
+
+        case RTL_ENABLE_PCI_DIAG:
+                r8126_spin_lock(&tp->phy_lock, flags);
+                tp->rtk_enable_diag = 1;
+                r8126_spin_unlock(&tp->phy_lock, flags);
+
+                dprintk("enable rtk diag\n");
+                break;
+
+        case RTL_DISABLE_PCI_DIAG:
+                r8126_spin_lock(&tp->phy_lock, flags);
+                tp->rtk_enable_diag = 0;
+                r8126_spin_unlock(&tp->phy_lock, flags);
+
+                dprintk("disable rtk diag\n");
+                break;
+
+        case RTL_READ_MAC_OCP:
+                if (my_cmd.offset % 2)
+                        return -EOPNOTSUPP;
+
+                my_cmd.data = rtl8126_mac_ocp_read(tp, my_cmd.offset);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+                break;
+
+        case RTL_WRITE_MAC_OCP:
+                if ((my_cmd.offset % 2) || (my_cmd.len != 2))
+                        return -EOPNOTSUPP;
+
+                rtl8126_mac_ocp_write(tp, my_cmd.offset, (u16)my_cmd.data);
+                break;
+
+        case RTL_DIRECT_READ_PHY_OCP:
+                r8126_spin_lock(&tp->phy_lock, flags);
+                my_cmd.data = rtl8126_mdio_prot_direct_read_phy_ocp(tp, my_cmd.offset);
+                r8126_spin_unlock(&tp->phy_lock, flags);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTL_DIRECT_WRITE_PHY_OCP:
+                r8126_spin_lock(&tp->phy_lock, flags);
+                rtl8126_mdio_prot_direct_write_phy_ocp(tp, my_cmd.offset, my_cmd.data);
+                r8126_spin_unlock(&tp->phy_lock, flags);
+                break;
+
+#ifdef ENABLE_FIBER_SUPPORT
+        case RTL_READ_FIBER_PHY:
+                if (!HW_FIBER_STATUS_CONNECTED(tp)) {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                r8126_spin_lock(&tp->phy_lock, flags);
+                my_cmd.data = rtl8126_fiber_mdio_read(tp, my_cmd.offset);
+                r8126_spin_unlock(&tp->phy_lock, flags);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTL_WRITE_FIBER_PHY:
+                if (!HW_FIBER_STATUS_CONNECTED(tp)) {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                r8126_spin_lock(&tp->phy_lock, flags);
+                rtl8126_fiber_mdio_write(tp, my_cmd.offset, my_cmd.data);
+                r8126_spin_unlock(&tp->phy_lock, flags);
+                break;
+#endif /* ENABLE_FIBER_SUPPORT */
+
+        default:
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        return ret;
+}
Index: drivers/net/ethernet/r8125-9.016.01/Makefile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/Makefile b/drivers/net/ethernet/r8125-9.016.01/Makefile
new file mode 100755
--- /dev/null	(date 1763113990524)
+++ b/drivers/net/ethernet/r8125-9.016.01/Makefile	(date 1763113990524)
@@ -0,0 +1,139 @@
+# SPDX-License-Identifier: GPL-2.0-only
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+
+################################################################################
+#  This product is covered by one or more of the following patents:
+#  US6,570,884, US6,115,776, and US6,327,625.
+################################################################################
+
+CONFIG_SOC_LAN = y
+ENABLE_FIBER_SUPPORT = n
+ENABLE_REALWOW_SUPPORT = n
+ENABLE_DASH_SUPPORT = n
+CONFIG_DOWN_SPEED_100 = n
+CONFIG_ASPM = n
+ENABLE_S5WOL = y
+ENABLE_S5_KEEP_CURR_MAC = n
+ENABLE_EEE = y
+ENABLE_S0_MAGIC_PACKET = n
+ENABLE_TX_NO_CLOSE = y
+ENABLE_MULTIPLE_TX_QUEUE = n
+ENABLE_PTP_SUPPORT = n
+ENABLE_PTP_MASTER_MODE = n
+ENABLE_RSS_SUPPORT = y
+ENABLE_LIB_SUPPORT = n
+ENABLE_USE_FIRMWARE_FILE = n
+DISABLE_WOL_SUPPORT = n
+DISABLE_MULTI_MSIX_VECTOR = n
+ENABLE_DOUBLE_VLAN = n
+ENABLE_PAGE_REUSE = n
+ENABLE_RX_PACKET_FRAGMENT = n
+ENABLE_GIGA_LITE = n
+
+obj-$(CONFIG_R8125) += r8125.o
+r8125-objs := r8125_n.o rtl_eeprom.o rtltool.o
+ifeq ($(CONFIG_SOC_LAN), y)
+	EXTRA_CFLAGS += -DCONFIG_SOC_LAN
+endif
+ifeq ($(ENABLE_FIBER_SUPPORT), y)
+	r8125-objs += r8125_fiber.o
+	EXTRA_CFLAGS += -DENABLE_FIBER_SUPPORT
+endif
+ifeq ($(ENABLE_REALWOW_SUPPORT), y)
+	r8125-objs += r8125_realwow.o
+	EXTRA_CFLAGS += -DENABLE_REALWOW_SUPPORT
+endif
+ifeq ($(ENABLE_DASH_SUPPORT), y)
+	r8125-objs += r8125_dash.o
+	EXTRA_CFLAGS += -DENABLE_DASH_SUPPORT
+endif
+EXTRA_CFLAGS += -DCONFIG_R8125_NAPI
+EXTRA_CFLAGS += -DCONFIG_R8125_VLAN
+ifeq ($(CONFIG_DOWN_SPEED_100), y)
+	EXTRA_CFLAGS += -DCONFIG_DOWN_SPEED_100
+endif
+ifeq ($(CONFIG_ASPM), y)
+	EXTRA_CFLAGS += -DCONFIG_ASPM
+endif
+ifeq ($(ENABLE_S5WOL), y)
+	EXTRA_CFLAGS += -DENABLE_S5WOL
+endif
+ifeq ($(ENABLE_S5_KEEP_CURR_MAC), y)
+	EXTRA_CFLAGS += -DENABLE_S5_KEEP_CURR_MAC
+endif
+ifeq ($(ENABLE_EEE), y)
+	EXTRA_CFLAGS += -DENABLE_EEE
+endif
+ifeq ($(ENABLE_S0_MAGIC_PACKET), y)
+	EXTRA_CFLAGS += -DENABLE_S0_MAGIC_PACKET
+endif
+ifeq ($(ENABLE_TX_NO_CLOSE), y)
+	EXTRA_CFLAGS += -DENABLE_TX_NO_CLOSE
+endif
+ifeq ($(ENABLE_MULTIPLE_TX_QUEUE), y)
+	EXTRA_CFLAGS += -DENABLE_MULTIPLE_TX_QUEUE
+endif
+ifeq ($(ENABLE_PTP_SUPPORT), y)
+	r8125-objs += r8125_ptp.o
+	EXTRA_CFLAGS += -DENABLE_PTP_SUPPORT
+endif
+ifeq ($(ENABLE_PTP_MASTER_MODE), y)
+	EXTRA_CFLAGS += -DENABLE_PTP_MASTER_MODE
+endif
+ifeq ($(ENABLE_RSS_SUPPORT), y)
+	r8125-objs += r8125_rss.o
+	EXTRA_CFLAGS += -DENABLE_RSS_SUPPORT
+endif
+ifeq ($(ENABLE_LIB_SUPPORT), y)
+	r8125-objs += r8125_lib.o
+	EXTRA_CFLAGS += -DENABLE_LIB_SUPPORT
+endif
+ifeq ($(ENABLE_USE_FIRMWARE_FILE), y)
+	r8125-objs += r8125_firmware.o
+	EXTRA_CFLAGS += -DENABLE_USE_FIRMWARE_FILE
+endif
+ifeq ($(DISABLE_WOL_SUPPORT), y)
+	EXTRA_CFLAGS += -DDISABLE_WOL_SUPPORT
+endif
+ifeq ($(DISABLE_MULTI_MSIX_VECTOR), y)
+	EXTRA_CFLAGS += -DDISABLE_MULTI_MSIX_VECTOR
+endif
+ifeq ($(ENABLE_DOUBLE_VLAN), y)
+	EXTRA_CFLAGS += -DENABLE_DOUBLE_VLAN
+endif
+ifeq ($(ENABLE_PAGE_REUSE), y)
+	EXTRA_CFLAGS += -DENABLE_PAGE_REUSE
+endif
+ifeq ($(ENABLE_RX_PACKET_FRAGMENT), y)
+	EXTRA_CFLAGS += -DENABLE_RX_PACKET_FRAGMENT
+endif
+ifeq ($(ENABLE_GIGA_LITE), y)
+	EXTRA_CFLAGS += -DENABLE_GIGA_LITE
+endif
+
+# Backward compatibility
+ccflags-y  += $(EXTRA_CFLAGS)
Index: drivers/net/ethernet/r8125-9.016.01/r8125_dash.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/r8125_dash.c b/drivers/net/ethernet/r8125-9.016.01/r8125_dash.c
new file mode 100755
--- /dev/null	(date 1763113879452)
+++ b/drivers/net/ethernet/r8125-9.016.01/r8125_dash.c	(date 1763113879452)
@@ -0,0 +1,573 @@
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/if_vlan.h>
+#include <linux/crc32.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/init.h>
+#include <linux/rtnetlink.h>
+#include <linux/completion.h>
+
+#include <asm/uaccess.h>
+
+#include "r8125.h"
+#include "r8125_dash.h"
+#include "rtl_eeprom.h"
+
+static void r8125_dash_set_ipc2_reg_bit(struct rtl8125_private *tp, unsigned long reg, u32 mask)
+{
+        RTL_DASH_IPC2_W32(tp, reg, RTL_DASH_IPC2_R32(tp, reg) | mask);
+}
+
+/*
+static void r8125_dash_clear_ipc2_reg_bit(struct rtl8125_private *tp, unsigned long reg, u32 mask)
+{
+        RTL_DASH_IPC2_W32(tp, reg, RTL_DASH_IPC2_R32(tp, reg) & ~mask);
+}
+*/
+
+static void r8125_write_ipc2_tx_ack(struct rtl8125_private *tp)
+{
+        if (!tp->DASH)
+                return;
+
+        if (!HW_DASH_SUPPORT_IPC2(tp))
+                return;
+
+        r8125_dash_set_ipc2_reg_bit(tp, IPC2_TX_SET_REG, IPC2_TX_ACK_BIT);
+}
+
+static void r8125_write_ipc2_tx_polling(struct rtl8125_private *tp)
+{
+        if (!tp->DASH)
+                return;
+
+        if (!HW_DASH_SUPPORT_IPC2(tp))
+                return;
+
+        r8125_dash_set_ipc2_reg_bit(tp, IPC2_TX_SET_REG, IPC2_TX_SEND_BIT);
+}
+
+static unsigned long
+r8125_get_ipc2_rx_buffer(struct rtl8125_private *tp)
+{
+        if (HW_DASH_SUPPORT_IPC2(tp))
+                return IPC2_RX_BUFFER;
+        else
+                return 0;
+}
+
+static u8 rtl8125_copy_from_ipc2(struct rtl8125_private *tp, u8 *dest, u32 len)
+{
+        unsigned long const data_reg = r8125_get_ipc2_rx_buffer(tp);
+        u32 offset = 0;
+        u32 *pDword;
+        u8 *pByte;
+
+        if (FALSE == HW_DASH_SUPPORT_IPC2(tp))
+                goto exit;
+
+        if (!dest)
+                goto exit;
+
+        if (len == 0)
+                goto exit;
+
+        pDword = (u32*)dest;
+        while (len > 3 && offset < (IPC2_BUFFER_LENGTH - 4)) {
+                *pDword++ = RTL_DASH_IPC2_R32(tp, data_reg + offset);
+
+                len -= 4;
+                offset += 4;
+        }
+
+        pByte = (u8*)pDword;
+        while (len > 0 && offset < (IPC2_BUFFER_LENGTH - 1)) {
+                *pByte++ = RTL_DASH_IPC2_R8(tp, data_reg + offset);
+
+                len -= 1;
+                offset += 1;
+        }
+
+exit:
+        return (len == 0) ? TRUE : FALSE;
+}
+
+static void RecvFromDashFwComplete(struct rtl8125_private *tp)
+{
+        if (!tp->DASH)
+                return;
+
+        if (!HW_DASH_SUPPORT_IPC2(tp))
+                return;
+
+        if (tp->DashReqRegValue == DASH_OOB_HDR_TYPE_REQ) { //rok
+                RX_DASH_BUFFER_TYPE_2 rxDashBufferType2 = {0};
+                u32 dataLen;
+
+                if (!tp->OobReq)
+                        goto exit;
+
+                /* copy header for check data length */
+                if (!rtl8125_copy_from_ipc2(tp,
+                                            (u8*)&rxDashBufferType2,
+                                            sizeof(rxDashBufferType2)))
+                        goto exit;
+
+                dataLen = (u16)rxDashBufferType2.oobhdr.len;
+
+                tp->AfterRecvFromFwBufLen = dataLen + sizeof(OSOOBHdr);
+                if (tp->AfterRecvFromFwBufLen > tp->SizeOfRecvFromFwBuffer) {
+                        tp->AfterRecvFromFwBufLen = tp->SizeOfRecvFromFwBuffer;
+                        tp->RecvFromFwBufErrCnt++;
+                }
+
+                /* copy data */
+                rtl8125_copy_from_ipc2(tp,
+                                       tp->AfterRecvFromFwBuf,
+                                       tp->AfterRecvFromFwBufLen);
+
+                r8125_write_ipc2_tx_ack(tp);
+
+                tp->OobReqComplete = TRUE;
+
+                tp->RecvFromDashFwCnt++;
+        } else if (tp->DashReqRegValue == DASH_OOB_HDR_TYPE_ACK) { //rx ack
+                if (!tp->OobAck)
+                        goto exit;
+
+                tp->OobAckComplete = TRUE;
+
+                tp->RecvFromDashFwCnt++;
+        }
+
+exit:
+        return;
+}
+
+static unsigned long r8125_get_ipc2_tx_buffer(struct rtl8125_private *tp)
+{
+        if (HW_DASH_SUPPORT_IPC2(tp))
+                return IPC2_TX_BUFFER;
+        else
+                return 0;
+}
+
+static u32 rtl8125_copy_to_ipc2(struct rtl8125_private *tp, u8 *src, u32 len)
+{
+        unsigned long const data_reg = r8125_get_ipc2_tx_buffer(tp);
+        u32 offset = 0;
+        u32 *pDword;
+        u8 *pByte;
+
+        if (FALSE == HW_DASH_SUPPORT_IPC2(tp))
+                goto exit;
+
+        if (!src)
+                goto exit;
+
+        if (len == 0)
+                goto exit;
+
+        pDword = (u32*)src;
+        while (len > 3 && offset < (IPC2_BUFFER_LENGTH - 4)) {
+                RTL_DASH_IPC2_W32(tp, data_reg + offset, *pDword++);
+
+                len -= 4;
+                offset += 4;
+        }
+
+        pByte = (u8*)pDword;
+        while (len > 0 && offset < (IPC2_BUFFER_LENGTH - 1)) {
+                RTL_DASH_IPC2_W8(tp, data_reg + offset, *pByte++);
+
+                len -= 1;
+                offset += 1;
+        }
+
+exit:
+        return offset;
+}
+
+static int SendToDashFw(struct rtl8125_private *tp, u8 *src, u16 len)
+{
+        POSOOBHdr pOobHdr;
+        int rc = -1;
+
+        if (!tp->DASH)
+                goto exit;
+
+        if (FALSE == HW_DASH_SUPPORT_IPC2(tp))
+                goto exit;
+
+        if (TRUE == tp->SendingToFw)
+                goto exit;
+
+        if (!src)
+                goto exit;
+
+        if (len > tp->SizeOfSendToFwBuffer)
+                goto exit;
+
+        if (len < sizeof(OSOOBHdr))
+                goto exit;
+
+        pOobHdr = (POSOOBHdr)src;
+        if (pOobHdr->hostReqV == DASH_OOB_HDR_TYPE_REQ) {
+                r8125_write_ipc2_tx_ack(tp);
+                rc = 0;
+                goto exit;
+        }
+
+        tp->SendingToFw = TRUE;
+
+        rtl8125_copy_to_ipc2(tp, src, len);
+
+        r8125_write_ipc2_tx_polling(tp);
+
+        tp->SendingToFw = FALSE;
+
+        rc = 0;
+
+exit:
+        if (!rc)
+                tp->AfterSendToFwBufLen = len;
+        else
+                tp->AfterSendToFwBufLen = 0;
+
+        return rc;
+}
+
+static u32 rtl8125_get_ipc2_isr(struct rtl8125_private *tp)
+{
+        u32 isr = 0;
+
+        if (FALSE == HW_DASH_SUPPORT_IPC2(tp))
+                goto exit;
+
+        isr = RTL_DASH_IPC2_R32(tp, IPC2_RX_STATUS_REG);
+
+        if (isr == ULONG_MAX)
+                isr = 0;
+
+exit:
+        return isr;
+}
+
+static void rtl8125_set_ipc2_isr(struct rtl8125_private *tp, u32 val)
+{
+        if (FALSE == HW_DASH_SUPPORT_IPC2(tp))
+                return;
+
+        RTL_DASH_IPC2_W32(tp, IPC2_RX_CLEAR_REG, val);
+}
+
+void rtl8125_clear_ipc2_isr(struct rtl8125_private *tp)
+{
+        rtl8125_set_ipc2_isr(tp, rtl8125_get_ipc2_isr(tp));
+}
+
+void rtl8125_set_ipc2_soc_imr_bit(struct rtl8125_private *tp, u16 mask)
+{
+        if (FALSE == HW_DASH_SUPPORT_IPC2(tp))
+                return;
+
+        RTL_W16(tp, RISC_IMR_8125BP, RTL_R16(tp, RISC_IMR_8125BP) | mask);
+}
+
+void rtl8125_clear_ipc2_soc_imr_bit(struct rtl8125_private *tp, u16 mask)
+{
+        if (FALSE == HW_DASH_SUPPORT_IPC2(tp))
+                return;
+
+        RTL_W16(tp, RISC_IMR_8125BP, RTL_R16(tp, RISC_IMR_8125BP) & ~mask);
+}
+
+bool rtl8125_check_dash_interrupt(struct rtl8125_private *tp)
+{
+        bool rc = false;
+        u32 isr;
+
+        if(!tp->DASH)
+                goto exit;
+
+        if (FALSE == HW_DASH_SUPPORT_IPC2(tp))
+                goto exit;
+
+        isr = rtl8125_get_ipc2_isr(tp);
+
+        if (isr & (IPC2_RX_ROK_BIT | IPC2_RX_ACK_BIT)) {
+                set_bit(R8125_RCV_REQ_DASH_OK, tp->dash_req_flags);
+                if (isr & IPC2_RX_ROK_BIT)
+                        tp->DashReqRegValue = DASH_OOB_HDR_TYPE_REQ;
+                else
+                        tp->DashReqRegValue = DASH_OOB_HDR_TYPE_ACK;
+        }
+
+        rtl8125_set_ipc2_isr(tp, isr);
+
+exit:
+        return rc;
+}
+
+void rtl8125_handle_dash_interrupt(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if(!tp->DASH)
+                return;
+
+        if (test_and_clear_bit(R8125_RCV_REQ_DASH_OK, tp->dash_req_flags))
+                RecvFromDashFwComplete(tp);
+}
+
+static int DashIoctlGetRcvFromFwData(struct net_device *dev, struct rtl_dash_ioctl_struct *prtl_dash_usrdata)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 ulInfoLen;
+        void *InformationBuffer;
+        u32 InformationBufferLength;
+        void *pInfo;
+        u8 *pByte;
+        u16 *pWord;
+        u8 *tmpBuf;
+        int ret = -EFAULT;
+
+        if (!tp->DASH)
+                goto exit;
+
+        if (!tp->rtk_enable_diag)
+                goto exit;
+
+        if (tp->AfterRecvFromFwBufLen == 0)
+                goto exit;
+
+        InformationBufferLength = prtl_dash_usrdata->len;
+        InformationBuffer = prtl_dash_usrdata->data_buffer;
+
+        ulInfoLen = tp->AfterRecvFromFwBufLen + 2 + 2;
+        if (InformationBufferLength < ulInfoLen) {
+                ret = -EFAULT;
+                goto exit;
+        }
+
+        if (!(tmpBuf = kmalloc(ulInfoLen, GFP_ATOMIC))) {
+                ret = -ENOMEM;
+                goto exit;
+        }
+
+        pInfo = (void*) tp->AfterRecvFromFwBuf;
+        pWord = (u16*) tmpBuf;
+        *pWord++ = tp->AfterRecvFromFwBufLen;
+        pByte = (u8*)pWord;
+        memcpy(pByte, pInfo, tp->AfterRecvFromFwBufLen);
+        pWord = (u16*)(pByte + tp->AfterRecvFromFwBufLen);
+        *pWord= tp->DashReqRegValue;
+        tp->AfterRecvFromFwBufLen = 0;
+        if (copy_to_user(InformationBuffer, tmpBuf, ulInfoLen)) {
+                kfree(tmpBuf);
+                ret = -EFAULT;
+                goto exit;
+        }
+        kfree(tmpBuf);
+        ret = 0;
+
+exit:
+        return ret;
+}
+
+static int DashIoctlCheckSendBufferToFwComplete(struct net_device *dev, struct rtl_dash_ioctl_struct *prtl_dash_usrdata)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 ulInfoLen;
+        void *InformationBuffer;
+        u32 InformationBufferLength;
+        u16 *pWord;
+        u8 *tmpBuf;
+        int ret = -EFAULT;
+
+        if (!tp->DASH)
+                goto exit;
+
+        if (!tp->rtk_enable_diag)
+                goto exit;
+
+        InformationBufferLength = prtl_dash_usrdata->len;
+        InformationBuffer = prtl_dash_usrdata->data_buffer;
+
+        if (tp->SendingToFw == FALSE)
+                ulInfoLen = tp->AfterSendToFwBufLen + sizeof(u16);
+        else
+                ulInfoLen = sizeof(u16);
+
+        if (InformationBufferLength < ulInfoLen) {
+                ret = -EFAULT;
+                goto exit;
+        }
+
+        if (!(tmpBuf = kmalloc(ulInfoLen, GFP_ATOMIC))) {
+                ret = -ENOMEM;
+                goto exit;
+        }
+
+        pWord = (u16*) tmpBuf;
+        if (tp->SendingToFw == FALSE) {
+                *pWord++ = tp->AfterSendToFwBufLen;
+                memcpy(pWord, tp->AfterSendToFwBuf, tp->AfterSendToFwBufLen);
+                tp->AfterSendToFwBufLen = 0;
+        } else {
+                *pWord = 0xffff;
+        }
+
+        if (copy_to_user(InformationBuffer, tmpBuf, ulInfoLen))
+                ret = -EFAULT;
+        else
+                ret = 0;
+
+        kfree(tmpBuf);
+
+exit:
+        return ret;
+}
+
+static int DashIoctlCheckSendBufferToFw(struct net_device *dev, struct rtl_dash_ioctl_struct *prtl_dash_usrdata)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 ulInfoLen;
+        void *InformationBuffer;
+        u32 InformationBufferLength;
+        u16 *pWord;
+        u16 SetDataSize;
+        int ret = -EFAULT;
+
+        if (!tp->DASH)
+                goto exit;
+
+        if (!tp->rtk_enable_diag)
+                goto exit;
+
+        InformationBufferLength = prtl_dash_usrdata->len;
+        if (!(InformationBuffer = kmalloc(InformationBufferLength, GFP_KERNEL))) {
+                ret = -ENOMEM;
+                goto exit;
+        }
+
+        if (copy_from_user(InformationBuffer, prtl_dash_usrdata->data_buffer,
+                           InformationBufferLength)) {
+                ret = -EFAULT;
+                goto free_mem;
+        }
+
+        ulInfoLen = sizeof(u16) + sizeof(u16);
+
+        if (InformationBufferLength < ulInfoLen)
+                goto free_mem;
+
+        pWord = (u16*) InformationBuffer;
+        SetDataSize = *pWord++;
+
+        if (InformationBufferLength < (SetDataSize + sizeof(u16) + sizeof(u16))) {
+                ret = -EFAULT;
+                goto free_mem;
+        }
+
+        ret = SendToDashFw(tp, (u8*)pWord, SetDataSize);
+
+free_mem:
+        kfree(InformationBuffer);
+
+exit:
+        return ret;
+}
+
+int rtl8125_dash_ioctl(struct net_device *dev, struct ifreq *ifr)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        void *user_data = ifr->ifr_data;
+        struct rtl_dash_ioctl_struct rtl_dash_usrdata;
+
+        int ret=0;
+
+        if (FALSE == HW_DASH_SUPPORT_DASH(tp))
+                return -EOPNOTSUPP;
+
+        if (!tp->DASH)
+                return -EINVAL;
+
+        if (copy_from_user(&rtl_dash_usrdata, user_data,
+                           sizeof(struct rtl_dash_ioctl_struct)))
+                return -EFAULT;
+
+        switch (rtl_dash_usrdata.cmd) {
+        case RTL_DASH_SEND_BUFFER_DATA_TO_DASH_FW:
+                ret = DashIoctlCheckSendBufferToFw(dev, &rtl_dash_usrdata);
+                break;
+        case RTL_DASH_CHECK_SEND_BUFFER_TO_DASH_FW_COMPLETE:
+                ret = DashIoctlCheckSendBufferToFwComplete(dev,
+                                &rtl_dash_usrdata);
+                break;
+        case RTL_DASH_GET_RCV_FROM_FW_BUFFER_DATA:
+                ret = DashIoctlGetRcvFromFwData(dev, &rtl_dash_usrdata);
+                break;
+        case RTL_DASH_OOB_REQ:
+                tp->OobReq = TRUE;
+                tp->OobReqComplete = FALSE;
+                break;
+        case RTL_DASH_OOB_ACK:
+                tp->OobAck = TRUE;
+                tp->OobAckComplete = FALSE;
+                break;
+        case RTL_DASH_DETACH_OOB_REQ:
+                tp->OobReq = FALSE;
+                tp->OobReqComplete = FALSE;
+                break;
+        case RTL_DASH_DETACH_OOB_ACK:
+                tp->OobAck = FALSE;
+                tp->OobAckComplete = FALSE;
+                break;
+        default:
+                return -EOPNOTSUPP;
+        }
+
+        return ret;
+}
Index: drivers/net/ethernet/r8125-9.016.01/r8125_firmware.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/drivers/net/ethernet/r8125-9.016.01/r8125_firmware.h b/drivers/net/ethernet/r8125-9.016.01/r8125_firmware.h
new file mode 100755
--- /dev/null	(date 1763113879453)
+++ b/drivers/net/ethernet/r8125-9.016.01/r8125_firmware.h	(date 1763113879453)
@@ -0,0 +1,68 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5 Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2025 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_rtl8125_FIRMWARE_H
+#define _LINUX_rtl8125_FIRMWARE_H
+
+#include <linux/device.h>
+#include <linux/firmware.h>
+
+struct rtl8125_private;
+typedef void (*rtl8125_fw_write_t)(struct rtl8125_private *tp, u16 reg, u16 val);
+typedef u32 (*rtl8125_fw_read_t)(struct rtl8125_private *tp, u16 reg);
+
+#define RTL8125_VER_SIZE		32
+
+struct rtl8125_fw {
+        rtl8125_fw_write_t phy_write;
+        rtl8125_fw_read_t phy_read;
+        rtl8125_fw_write_t mac_mcu_write;
+        rtl8125_fw_read_t mac_mcu_read;
+        const struct firmware *fw;
+        const char *fw_name;
+        struct device *dev;
+
+        char version[RTL8125_VER_SIZE];
+
+        struct rtl8125_fw_phy_action {
+                __le32 *code;
+                size_t size;
+        } phy_action;
+};
+
+int rtl8125_fw_request_firmware(struct rtl8125_fw *rtl_fw);
+void rtl8125_fw_release_firmware(struct rtl8125_fw *rtl_fw);
+void rtl8125_fw_write_firmware(struct rtl8125_private *tp, struct rtl8125_fw *rtl_fw);
+
+#endif /* _LINUX_rtl8125_FIRMWARE_H */
